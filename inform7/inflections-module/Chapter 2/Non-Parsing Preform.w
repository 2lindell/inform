[Preform::Nonparsing::] Non-Parsing Preform.

Other uses for Preform grammar, including the generation of adaptive
text, and word inflection.

@h Introduction.
Looked at more generally, Preform isn't just a parser syntax: it's a general-purpose way to specify
textual patterns, so we may as well take advantage of it for miscellaneous
other needs. There are altogether five non-parsing uses for Preform; in
order of complexity,

(a) Specifying text being generated by Inform;

(b) Specifying replacements of one set of words by another;

(c) Specifying miscellaneous entries for the lexicon in the index;

(d) Saying how to build a trie which will detect patterns in a single word and
then modify it;

(e) Saying how to conjugate a verb, that is, how to modify the wording of a
verb ("take", say) into all of its different forms (I take, he takes, it was
taken, I am taking, and so on). This we'll leave for later.

Speed is not of the essence in any of these problems.

@h (a) Specifying generated text.
Our main operation here is a "merge". This extracts the text from a production,
substituting the ingredient text in place of any |...| it finds. (Other
wildcards and nonterminals are ignored.) For example, merging the production

	|fried ... tomatoes|

with "orange" results in "fried orange tomatoes".

=
word_assemblage Preform::Nonparsing::merge(nonterminal *nt, int pnum, word_assemblage ingredient) {
	production_list *pl;
	for (pl = nt->first_production_list; pl; pl = pl->next_production_list) {
		int N = 0;
		production *pr;
		for (pr = pl->first_production; pr; pr = pr->next_production) {
			if (N == pnum) {
				word_assemblage wa = WordAssemblages::lit_0();
				ptoken *pt;
				for (pt = pr->first_ptoken; pt; pt = pt->next_ptoken) {
					if (pt->ptoken_category == FIXED_WORD_PTC) {
						wa = WordAssemblages::join(wa, WordAssemblages::lit_1(pt->ve_pt));
					} else if (pt->ptoken_category == MULTIPLE_WILDCARD_PTC) {
						wa = WordAssemblages::join(wa, ingredient);
					}
				}
				return wa;
			}
			N++;
		}
	}
	return WordAssemblages::lit_0(); /* give up, in other words */
}

@ Thus we can simply extract the wording by performing a merge with the empty
ingredient text:

=
word_assemblage Preform::Nonparsing::wording(nonterminal *nt, int pnum) {
	return Preform::Nonparsing::merge(nt, pnum, WordAssemblages::lit_0());
}

@ And here we take just one word:

=
vocabulary_entry *Preform::Nonparsing::word(nonterminal *nt, int pnum) {
	word_assemblage wa = Preform::Nonparsing::merge(nt, pnum, WordAssemblages::lit_0());
	vocabulary_entry **words;
	int num_words;
	WordAssemblages::as_array(&wa, &words, &num_words);
	if (num_words == 1) return words[0];
	return NULL;
}

@h (b) Specifying replacements.
The following looks for a word in one nonterminal and replaces it with the
corresponding word in another. If the word isn't found, it's left unchanged.

=
vocabulary_entry *Preform::Nonparsing::replace_word(vocabulary_entry *ve,
	nonterminal *nt_from, nonterminal *nt_to) {
	production_list *pl_from, *pl_to;
	for (pl_from = nt_from->first_production_list,
		pl_to = nt_to->first_production_list;
		((pl_from) && (pl_to));
		pl_from = pl_from->next_production_list,
		pl_to = pl_to->next_production_list) {
		production *pr_from, *pr_to;
		for (pr_from = pl_from->first_production,
			pr_to = pl_to->first_production;
			((pr_from) && (pr_to));
			pr_from = pr_from->next_production,
			pr_to = pr_to->next_production) {
			ptoken *pt_from, *pt_to;
			for (pt_from = pr_from->first_ptoken,
				pt_to = pr_to->first_ptoken;
				((pt_from) && (pt_to));
				pt_from = pt_from->next_ptoken,
				pt_to = pt_to->next_ptoken) {
				if ((pt_from->ptoken_category == FIXED_WORD_PTC) &&
					(pt_to->ptoken_category == FIXED_WORD_PTC)) {
					if (ve == pt_from->ve_pt) return pt_to->ve_pt;
				}
			}
		}
	}
	return ve; /* no change, in other words */
}

@h (c) Lexicon entry.
This is only a convenience for putting particles into the Lexicon:

=
#ifdef CORE_MODULE
void Preform::Nonparsing::enter_lexicon(nonterminal *nt_from, int pos, char *category, char *gloss) {
	production_list *pl;
	for (pl = nt_from->first_production_list; pl; pl = pl->next_production_list) {
		production *pr;
		for (pr = pl->first_production; pr; pr = pr->next_production) {
			ptoken *pt;
			for (pt = pr->first_ptoken; pt; pt = pt->next_ptoken) {
				ptoken *alt;
				for (alt = pt; alt; alt = alt->alternative_ptoken) {
					vocabulary_entry *ve = alt->ve_pt;
					if (ve) {
						Index::Lexicon::new_entry_with_details(EMPTY_WORDING, pos,
							WordAssemblages::lit_1(ve), category, gloss);
					}
				}
			}
		}
	}
}
#endif

@h (d) Making tries.
Properly speaking, we make "avinues". Note that we expect to make a different
avinue for each natural language; this matters so that we can pluralise words
correctly in both English and French in the same run of Inform, for example.
But we are going to need to use these avinues frequently, so we cache them once
created.

=
match_avinue *Preform::Nonparsing::define_trie(nonterminal *nt, int end, PREFORM_LANGUAGE_TYPE *nl) {
	if (nl == NULL) nl = English_language;
	match_avinue *ave = NULL;
	production_list *pl;
	for (pl = nt->first_production_list; pl; pl = pl->next_production_list) {
		if (pl->definition_language == nl) {
			if (pl->as_avinue) return pl->as_avinue;
			@<Construct a new avinue from this nonterminal@>;
			pl->as_avinue = ave;
		}
	}
	return ave;
}

@ The grammar for this nonterminal is either a "list grammar", meaning that it
lists other nonterminals which each define avinues, and we have to string those
together into one long avinue; or else it contains the actual content of a
single avinue.

@<Construct a new avinue from this nonterminal@> =
	int list_grammar = NOT_APPLICABLE; /* i.e., we don't know yet */
	production *pr;
	for (pr = pl->first_production; pr; pr = pr->next_production) {
		ptoken *first = pr->first_ptoken;
		if (first == NULL) continue;
		ptoken *second = first->next_ptoken;
		if ((second) && (second->next_ptoken)) {
			Preform::log_production(pr, FALSE);
			Conjugation::trie_definition_error(nt, pr, "trie line with more than 2 words");
		}
		@<Consider the one- or two-token production in this nonterminal@>;
	}

@ Each production contains one or two tokens. There are four possibilities for
the production:

	|(1)   ... <some-nonterminal>|
	|(2)   <some-nonterminal> ...|
	|(3)   <some-nonterminal>|
	|(4)   pattern-word instructions-word|

Cases (1), (2) and (3) are allowed only in list grammars; case (4) is allowed
only in content grammars. The |...| indicates whether the trie in the named
nonterminal will act on the start or end of a word -- this is needed only to
override the normal convention.

@<Consider the one- or two-token production in this nonterminal@> =
	int this_end = end;
	ptoken *entry = NULL;
	if ((first->ptoken_category == MULTIPLE_WILDCARD_PTC) &&
		(second) && (second->ptoken_category == NONTERMINAL_PTC)) {
		entry = second; this_end = TRIE_END;
	}
	if ((first->ptoken_category == NONTERMINAL_PTC) &&
		(second) && (second->ptoken_category == MULTIPLE_WILDCARD_PTC)) {
		entry = first; this_end = TRIE_START;
	}
	if ((first->ptoken_category == NONTERMINAL_PTC) && (second == NULL)) {
		entry = first;
	}

	if (entry) {
		if (list_grammar == FALSE) @<Throw problem for a mixed trie nonterminal@>;
		@<Recurse to make an avinue from the nonterminal named here, and add it to our result@>;
		list_grammar = TRUE;
	} else {
		if (list_grammar == TRUE) @<Throw problem for a mixed trie nonterminal@>;
		if (second == NULL)
			Conjugation::trie_definition_error(nt, pr,
				"there should be two words here, a pattern and an instruction");
		@<Add this pattern and instruction to the trie, creating it if we haven't already started one@>;
		list_grammar = FALSE;
	}

@<Throw problem for a mixed trie nonterminal@> =
	Conjugation::trie_definition_error(nt, pr,
		"this should either be a list of other nonterminals, or a list of patterns "
		"and instructions, but not a mixture");

@<Recurse to make an avinue from the nonterminal named here, and add it to our result@> =
	match_avinue *next_mt =
		Tries::duplicate_avinue(Preform::Nonparsing::define_trie(entry->nt_pt, this_end, nl));
	if (ave == NULL) ave = next_mt;
	else {
		match_avinue *m = ave;
		while (m->next) m = m->next;
		m->next = next_mt;
	}

@<Add this pattern and instruction to the trie, creating it if we haven't already started one@> =
	if (ave == NULL) ave = Tries::new_avinue(end);
	TEMPORARY_TEXT(from);
	WRITE_TO(from, "%V", first->ve_pt);
	Tries::add_to_avinue(ave, from, Vocabulary::get_exemplar(second->ve_pt, FALSE));
	DISCARD_TEXT(from);

@ The following may be useful for debugging:

=
void Preform::Nonparsing::log_avinues(void) {
	nonterminal *nt;
	LOOP_OVER(nt, nonterminal) {
		production_list *pl;
		for (pl = nt->first_production_list; pl; pl = pl->next_production_list) {
			if (pl->as_avinue) {
				LOG("\n\n%V ($J)\n%a",
					nt->nonterminal_id, pl->definition_language, pl->as_avinue);
			}
		}
	}
}
