B/utilt: Utilities Template.

@Purpose: Miscellaneous utility routines for some fundamental I6 needs.

@-------------------------------------------------------------------------------

@p Saying Phrases.

@c
[ SayPhraseName closure;
	if (closure == 0) print "nothing";
	else print (string) closure-->2;
];

@p Kinds.

@c
[ KindAtomic kind;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return kind;
	return kind-->0;
];

[ KindBaseArity kind;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return 0;
	return kind-->1;
];

[ KindBaseTerm kind n;
	if ((kind >= 0) && (kind < BASE_KIND_HWM)) return UNKNOWN_TY;
	return kind-->(2+n);
];

@p GenerateRandomNumber.
The following uses the virtual machine's RNG (via the I6 built-in function
|random|) to produce a uniformly random integer in the range $n$ to $m$
inclusive, where $n$ and $m$ are allowed to be either way around; so that
a random number between 17 and 4 is the same thing as a random number
between 4 and 17, and there is therefore no pair of $n$ and $m$ corresponding
to an empty range of values.

@c
[ GenerateRandomNumber n m s;
	if (n==m) return n;
	if (n>m) { s = n; n = m; m = s; }
	n--;
	return random(m-n) + n;
];
Constant R_DecimalNumber = GenerateRandomNumber;
Constant R_PrintTimeOfDay = GenerateRandomNumber;

@p PrintSpaces.
Which prints a row of $n$ spaces, for $n\geq 0$.

@c
[ PrintSpaces n;
    while (n > 0) {
        print " ";
        n = n - 1;
    }
];

@p SwapWorkflags.
Recall that we have two general-purpose temporary attributes for each object:
|workflag| and |workflag2|. The following swaps their values over for every
object at once.

@c
[ SwapWorkflags obj lst;
	objectloop (obj ofclass Object) {
		lst = false;
		if (obj has workflag2) lst = true;
		give obj ~workflag2;
		if (obj has workflag) give obj workflag2;
		give obj ~workflag;
		if (lst) give obj workflag;
	}
];

@p TestUseOption.
This routine, compiled by NI, returns |true| if the supplied argument is the
number of a use option in force for the current run of NI, and |false|
otherwise.

@p ZRegion.
I7 contains many relics from I6, but here's a relic from I5: a routine which
used to determine the metaclass of a value, before that concept was given a
name. In I6 code, it can be implemented simply using |metaclass|, as the
following shows. (The name is from "region of the Z-machine".)

@c
[ ZRegion addr;
    switch (metaclass(addr)) {
		nothing: return 0;
		Object, Class: return 1;
		Routine: return 2;
		String: return 3;
    }
];

@p Memcpy.
This is equivalent to C's memcpy function, in good ways and bad.

@c
[ Memcpy to_addr from_addr size  n;
#Ifdef TARGET_ZCODE;
	for (n = size/WORDSIZE: (n--) > 0: ) to_addr-->n = from_addr-->n;
	for (n = size: ((n--) % WORDSIZE ~= 0): ) to_addr->n = from_addr->n;
#Ifnot; ! TARGET_GLULX
    @mcopy size from_addr to_addr;
#Endif; ! TARGET_
];

@p Arrcpy.
This is not quite so efficient, but not terrible.

@c
[ Arrcpy to_array to_entry_size from_array from_entry_size no_entries  n val;
	if (to_entry_size == from_entry_size)
		Memcpy(to_array, from_array, to_entry_size*no_entries);
	else if ((to_entry_size == 2) && (from_entry_size == 4)) {
		for (n = 0: n<no_entries: n++) {
			val = from_array-->n;
			to_array->0 = (val/256)%256; to_array->1 = val%256;
			to_array = to_array + 2;
		}
	} else "*** Arrcpy doesn't support this ***";
];

@p Verbs as Values.

@c
[ PrintVerbAsValue vb;
	if (vb == 0) print "(no verb)";
	else { print "verb "; vb(1); }
];

[ VerbIsMeaningful vb;
	if ((vb) && (BlkValueCompare(vb(CV_MEANING), MEANINGLESS_RR) ~= 0)) rtrue;
	rfalse;
];

[ VerbIsModal vb;
	if ((vb) && (vb(CV_MODAL))) rtrue;
	rfalse;
];

