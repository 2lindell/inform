Basic Inform Extras.

Additions to the Basic Inform template which are needed only if the Standard
Rules are not to be used.

@h Justification.
Q. Why isn't all of this done with conditional compilation in the Basic Inform
template files? A. That wouldn't work, since template files are assimilated
before it is known how they will be used.

@h Miscellany.

=
[ DefaultTopic; return 0; ];
[ PrintSnippet x; ];
[ LIST_WRITER_INTERNAL_RM x;
	print " and ";
];
[ RunTimeProblemShowWM n x y z; ];
[ OwnerOf o; return nothing; ];
[ MoveObject from to; ];
[ WriteListOfMarkedObjects in_style
	obj c;
	objectloop (obj ofclass Object && obj has workflag2) {
		c++;
	}
	objectloop (obj ofclass Object && obj has workflag2) {
		PrintShortName(obj);
		c--;
		if (c > 0) print ", ";
	}
];
[ PrintShortName obj;
	print (object) obj;
];
[ Main;
	#ifdef TARGET_ZCODE; max_z_object = #largest_object - 255; #endif;
	VM_Initialise();
	print "^";
	INITIALISE_MEMORY_R();
	SEED_RANDOM_NUMBER_GENERATOR_R();
	Submain();
];

Constant FBNA_PROP_NUMBER = MAX_POSITIVE_NUMBER;

[ INITIALISE_MEMORY_R;
	#ifdef TARGET_GLULX; VM_PreInitialise(); #Endif;
	#Ifdef LanguageInitialise; LanguageInitialise(); #Endif;

	CreatePropertyOffsets();
	HeapInitialise(); ! Create a completely unused memory allocation heap
	StackFramingInitialise(); ! Create an empty stack
	CreateDynamicRelations(); ! Create relation structures on the heap

	rfalse;
];

[ DrawStatusLine width posb;
];

@h Veneer.

=
#Ifdef TARGET_ZCODE;
[ VM_Initialise i;
	standard_interpreter = HDR_TERPSTANDARD-->0;
	top_object = #largest_object-255;

	if (TEMPLATE_CONFIGURATION_BITMAP & FIX_RNG_TCBIT) {
		@random 10000 -> i;
		i = -i-2000;
		print "[Random number generator seed is ", i, "]^";
		@random i -> i;
	}
];

[ OC__Cl obj cla j a n objflag;

	@jl obj 1 ?NotObj;
	@jg obj max_z_object ?NotObj;
	@inc objflag;
	.NotObj;

	@je cla Object Class ?ObjOrClass;
	@je cla Routine String ?RoutOrStr;

	@jin cla 1 ?~Mistake;

	@jz objflag ?rfalse;
	@get_prop_addr obj 2 -> a;
	@jz a ?rfalse;
	@get_prop_len a -> n;

	@div n 2 -> n;
	.Loop;
	@loadw a j -> sp;
	@je sp cla ?rtrue;
	@inc j;
	@jl j n ?Loop;
	@rfalse;

	.ObjOrClass;
	@jz objflag ?rfalse;
	@je cla Object ?JustObj;

	! So now cla is Class
	@jg obj String ?~rtrue;
	@jin obj Class ?rtrue;
	@rfalse;

	.JustObj;
	! So now cla is Object
	@jg obj String ?~rfalse;
	@jin obj Class ?rfalse;
	@rtrue;

	.RoutOrStr;
	@jz objflag ?~rfalse;
	@call_2s Z__Region obj -> sp;
	@inc sp;
	@je sp cla ?rtrue;
	@rfalse;

	.Mistake;
	RT__Err("apply 'ofclass' for", cla, -1);
	rfalse;
];
#Endif;

