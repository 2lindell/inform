Glk Template.

Glk is a fully-featured input-output model, designed by Andrew Plotkin for use
with the Glulx virtual machine, but not used only for that. All 32-bit Inform
programs use Glk.

@h Stubs.
These are I6 library-style entry point routines, not used by I7, but retained
in case I7 extensions want to do interesting things with Glulx.

=
#Stub HandleGlkEvent    3;
#Stub InitGlkWindow     1;

Constant GLK_NULL 0;

@h Glk object recovery.
|GGRecoverObjects| handles recovering the Glk objects after restarting or restoring.

=
Global current_glk_object_rock = 0;
Global current_glk_object_reference = 0;

[ GGRecoverObjects ref;
	! Reset all Glk references as if none existed
	FollowRulebook(RESET_GLK_REFERENCES_RB);

	! Iterate through each of the windows, streams, file refs and sound channels
	while (ref = glk_window_iterate(ref, gg_arguments)) {
		current_glk_object_rock = gg_arguments-->0;
		current_glk_object_reference = ref;
		FollowRulebook(IDENTIFY_WINDOWS_RB);
	}
	while (ref = glk_stream_iterate(ref, gg_arguments)) {
		current_glk_object_rock = gg_arguments-->0;
		current_glk_object_reference = ref;
		FollowRulebook(IDENTIFY_STREAMS_RB);
	}
	while (ref = glk_fileref_iterate(ref, gg_arguments)) {
		current_glk_object_rock = gg_arguments-->0;
		current_glk_object_reference = ref;
		FollowRulebook(IDENTIFY_FILEREFS_RB);
	}
	if (glk_gestalt(gestalt_Sound, 0)) {
		while (ref = glk_schannel_iterate(ref, gg_arguments)) {
			current_glk_object_rock = gg_arguments-->0;
			current_glk_object_reference = ref;
			FollowRulebook(IDENTIFY_SCHANNELS_RB);
		}
	}

	! Tell the game to tie up any loose ends
	FollowRulebook(GLK_OBJECT_UPDATING_RB);
	rfalse;
];

@ The built in object recovery rules.

=
[ RESET_GLK_REFERENCES_R;
	gg_mainwin = 0;
	gg_statuswin = 0;
	gg_quotewin = 0;
	gg_scriptfref = 0;
	gg_scriptstr = 0;
	gg_savestr = 0;
	statuswin_cursize = 0;
	gg_foregroundchan = 0;
	gg_backgroundchan = 0;
	gg_commandstr = 0;
	gg_command_reading = false;
	rfalse;
];

[ IDENTIFY_WINDOWS_R;
	switch (current_glk_object_rock) {
		GG_MAINWIN_ROCK:
			gg_mainwin = current_glk_object_reference;
		GG_STATUSWIN_ROCK:
			gg_statuswin = current_glk_object_reference;
		GG_QUOTEWIN_ROCK:
			gg_quotewin = current_glk_object_reference;
	}
	rfalse;
];

[ IDENTIFY_STREAMS_R;
	switch (current_glk_object_rock) {
		GG_SAVESTR_ROCK:
			gg_savestr = current_glk_object_reference;
		GG_SCRIPTSTR_ROCK:
			gg_scriptstr = current_glk_object_reference;
		GG_COMMANDWSTR_ROCK:
			gg_commandstr = current_glk_object_reference;
			gg_command_reading = false;
		GG_COMMANDRSTR_ROCK:
			gg_commandstr = current_glk_object_reference;
			gg_command_reading = true;
	}
	rfalse;
];

[ IDENTIFY_FILEREFS_R;
	switch (current_glk_object_rock) {
		GG_SCRIPTFREF_ROCK:
			gg_scriptfref = current_glk_object_reference;
	}
	rfalse;
];

[ IDENTIFY_SCHANNELS_R;
	switch (current_glk_object_rock) {
		GG_FOREGROUNDCHAN_ROCK:
			gg_foregroundchan = current_glk_object_reference;
		GG_BACKGROUNDCHAN_ROCK:
			gg_backgroundchan = current_glk_object_reference;
	}
	rfalse;
];

[ STOP_SCHANNELS_R;
	if (glk_gestalt(gestalt_Sound, 0)) {
		if (gg_foregroundchan ~= 0) {
			glk_schannel_stop(gg_foregroundchan);
		}
		if (gg_backgroundchan ~= 0) {
			glk_schannel_stop(gg_backgroundchan);
		}
	}
	rfalse;
];

@h Debugging verb.
This powers the GLKLIST command, when there's a command parser to read it.

=
[ GlkDebuggingList id val;
	id = glk_window_iterate(0, gg_arguments);
	while (id) {
		print "Window ", id, " (", gg_arguments-->0, "): ";
		val = glk_window_get_type(id);
		switch (val) {
			1: print "pair";
			2: print "blank";
			3: print "textbuffer";
			4: print "textgrid";
			5: print "graphics";
			default: print "unknown";
		}
		val = glk_window_get_parent(id);
		if (val) print ", parent is window ", val;
		else     print ", no parent (root)";
		val = glk_window_get_stream(id);
		print ", stream ", val;
		val = glk_window_get_echo_stream(id);
		if (val) print ", echo stream ", val;
		print "^";
		id = glk_window_iterate(id, gg_arguments);
	}
	id = glk_stream_iterate(0, gg_arguments);
	while (id) {
		print "Stream ", id, " (", gg_arguments-->0, ")^";
		id = glk_stream_iterate(id, gg_arguments);
	}
	id = glk_fileref_iterate(0, gg_arguments);
	while (id) {
		print "Fileref ", id, " (", gg_arguments-->0, ")^";
		id = glk_fileref_iterate(id, gg_arguments);
	}
	if (glk_gestalt(gestalt_Sound, 0)) {
		id = glk_schannel_iterate(0, gg_arguments);
		while (id) {
			print "Soundchannel ", id, " (", gg_arguments-->0, ")^";
			id = glk_schannel_iterate(id, gg_arguments);
		}
	}
];
