Glk Template.

Glk is a fully-featured input-output model, designed by Andrew Plotkin for use
with the Glulx virtual machine, but not used only for that. All 32-bit Inform
programs use Glk.

@h Stubs.
These are I6 library-style entry point routines, not used by I7, but retained
in case I7 extensions want to do interesting things with Glulx.

=
#Stub HandleGlkEvent    3;
#Stub IdentifyGlkObject 4;
#Stub InitGlkWindow     1;

Constant GLK_NULL 0;

@ |GGRecoverObjects| handles recovering the Glk objects after restarting or restoring.

=
[ GGRecoverObjects id;
	! If GGRecoverObjects() has been called, all these stored IDs are
	! invalid, so we start by clearing them all out.
	! (In fact, after a restoreundo, some of them may still be good.
	! For simplicity, though, we assume the general case.)
	gg_mainwin = 0;
	gg_statuswin = 0;
	gg_quotewin = 0;
	gg_scriptfref = 0;
	gg_scriptstr = 0;
	gg_savestr = 0;
	statuswin_cursize = 0;
	gg_foregroundchan = 0;
	gg_backgroundchan = 0;
	gg_commandstr = 0;
	gg_command_reading = false;
	! Also tell the game to clear its object references.
	IdentifyGlkObject(0);

	id = glk_stream_iterate(0, gg_arguments);
	while (id) {
		switch (gg_arguments-->0) {
			GG_SAVESTR_ROCK: gg_savestr = id;
			GG_SCRIPTSTR_ROCK: gg_scriptstr = id;
			GG_COMMANDWSTR_ROCK: gg_commandstr = id;
									gg_command_reading = false;
			GG_COMMANDRSTR_ROCK: gg_commandstr = id;
									gg_command_reading = true;
			default: IdentifyGlkObject(1, 1, id, gg_arguments-->0);
		}
		id = glk_stream_iterate(id, gg_arguments);
	}

	id = glk_window_iterate(0, gg_arguments);
	while (id) {
		switch (gg_arguments-->0) {
			GG_MAINWIN_ROCK: gg_mainwin = id;
			GG_STATUSWIN_ROCK: gg_statuswin = id;
			GG_QUOTEWIN_ROCK: gg_quotewin = id;
			default: IdentifyGlkObject(1, 0, id, gg_arguments-->0);
		}
		id = glk_window_iterate(id, gg_arguments);
	}

	id = glk_fileref_iterate(0, gg_arguments);
	while (id) {
		switch (gg_arguments-->0) {
			GG_SCRIPTFREF_ROCK: gg_scriptfref = id;
			default: IdentifyGlkObject(1, 2, id, gg_arguments-->0);
		}
		id = glk_fileref_iterate(id, gg_arguments);
	}

	if (glk_gestalt(gestalt_Sound, 0)) {
		id = glk_schannel_iterate(0, gg_arguments);
		while (id) {
			switch (gg_arguments-->0) {
				GG_FOREGROUNDCHAN_ROCK: gg_foregroundchan = id;
				GG_BACKGROUNDCHAN_ROCK: gg_backgroundchan = id;
				default: IdentifyGlkObject(1, 3, id, gg_arguments-->0);
			}
			id = glk_schannel_iterate(id, gg_arguments);
		}
		if (gg_foregroundchan ~= 0) { glk_schannel_stop(gg_foregroundchan); }
		if (gg_backgroundchan ~= 0) { glk_schannel_stop(gg_backgroundchan); }
	}

	! Tell the game to tie up any loose ends.
	IdentifyGlkObject(2);
	rfalse;
];

@h Debugging verb.
This powers the GLKLIST command, when there's a command parser to read it.

=
[ GlkDebuggingList id val;
	id = glk_window_iterate(0, gg_arguments);
	while (id) {
		print "Window ", id, " (", gg_arguments-->0, "): ";
		val = glk_window_get_type(id);
		switch (val) {
			1: print "pair";
			2: print "blank";
			3: print "textbuffer";
			4: print "textgrid";
			5: print "graphics";
			default: print "unknown";
		}
		val = glk_window_get_parent(id);
		if (val) print ", parent is window ", val;
		else     print ", no parent (root)";
		val = glk_window_get_stream(id);
		print ", stream ", val;
		val = glk_window_get_echo_stream(id);
		if (val) print ", echo stream ", val;
		print "^";
		id = glk_window_iterate(id, gg_arguments);
	}
	id = glk_stream_iterate(0, gg_arguments);
	while (id) {
		print "Stream ", id, " (", gg_arguments-->0, ")^";
		id = glk_stream_iterate(id, gg_arguments);
	}
	id = glk_fileref_iterate(0, gg_arguments);
	while (id) {
		print "Fileref ", id, " (", gg_arguments-->0, ")^";
		id = glk_fileref_iterate(id, gg_arguments);
	}
	if (glk_gestalt(gestalt_Sound, 0)) {
		id = glk_schannel_iterate(0, gg_arguments);
		while (id) {
			print "Soundchannel ", id, " (", gg_arguments-->0, ")^";
			id = glk_schannel_iterate(id, gg_arguments);
		}
	}
];