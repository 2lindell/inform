[I6T::] I6 Template Interpreter.

Inform 6 template language, or I6T for short, is a notation for expressing
low-level code in Inter.

@h Three readers.
In the pre-2015 design of Inform, the I6T interpreter was a formidably complex
function. There was a special |Main.i6t| file which contained, essentially,
the entire top-level logic of the compiler, calling hundreds of different
functions (a design pattern recommended by Eric Raymond's "The Art of Unix
Programming", but not in fact helpful in practice). There were numerous
features for having template files open each other, and switch output on and
off: these were needed when Inform was reading raw I6T versions of the
low-level library code on every compilation, but in the age of Inter, this
no longer happens. (See the assimilator in the code-generator for what is
done instead.) Finally, I6T was complex because it had subsumed three quite
different functions.

Those three usages live on, but are now called by three different names,
even though they share an underlying implementation (which has a general
air of being over-engineered, thanks to its once-mightier state).

(a) We can read a |*.kindt| file which defines the properties of built-in
kinds of value, such as "number".

(b) We can read a |*.indext| file which acts as a contents page for the
Index generated by a project.

(c) Or we can read from a C (wide) string of I6T code and expand that into
a text stream. Expansion doesn't change much, but it does handle the |(+|
and |+)| Inform 7 escapes (see below).

@e KINDT_MODE from 1
@e INDEXT_MODE
@e I6TCODE_MODE

=
void I6T::interpret_kindt(text_stream *segment_name) {
	I6T::interpreter_shared(KINDT_MODE, NULL, NULL, segment_name, -1, NULL);
}

void I6T::interpret_indext(filename *indext_file) {
	if (do_not_generate_index == FALSE)
		I6T::interpreter_shared(INDEXT_MODE, NULL, NULL, NULL, -1, indext_file);
}

void I6T::interpret_i6t(OUTPUT_STREAM, wchar_t *sf, int N_escape) {
	I6T::interpreter_shared(I6TCODE_MODE, OUT, sf, NULL, N_escape, NULL);
}

@h Implementation.
So, then, here is the shared interpreter for these functions. Broadly
speaking, it's a filter from input to output, where the input is either to
be a file or a wide C-string, and the output (if any) is a text stream.
In kind or indexing mode, there is in fact no output, and the interpreter
is run only to call other functions.

=
void I6T::interpreter_shared(int int_mode, OUTPUT_STREAM, wchar_t *sf, text_stream *segment_name,
	int N_escape, filename *index_template) {
	FILE *Input_File = NULL;
	int col = 1, cr, sfp = 0;
	TEMPORARY_TEXT(heading_name);

	int skip_part = FALSE, comment = FALSE;
	if ((int_mode == I6TCODE_MODE) && (Str::len(segment_name) > 0)) comment = TRUE;

	@<Open a file for input, if necessary@>;

	TEMPORARY_TEXT(command);
	TEMPORARY_TEXT(argument);
	do {
		Str::clear(command);
		Str::clear(argument);
		@<Read next character from I6T stream@>;
		NewCharacter: if (cr == EOF) break;
		if ((cr == '@') && (col == 1)) {
			int inweb_syntax = -1;
			@<Read the rest of line as an at-heading@>;
			@<Act on the at-heading, going in or out of comment mode as appropriate@>;
			continue;
		}
		if (comment == FALSE) {
			if (int_mode == KINDT_MODE) {
				if ((cr == 10) || (cr == 13)) continue; /* skip blank lines here */
				@<Read rest of line as argument@>;
				if ((Str::get_first_char(argument) == '!') ||
					(Str::get_first_char(argument) == 0)) continue; /* skip blanks and comments */
				Kinds::Interpreter::despatch_kind_command(argument);
				continue;
			}
			if (cr == '{') {
				@<Read next character from I6T stream@>;
				if (cr == '-') {
					@<Read up to the next close brace as an I6T command and argument@>;
					if (Str::get_first_char(command) == '!') continue;
					@<Act on I6T command and argument@>;
					continue;
				} else if ((cr == 'N') && (N_escape >= 0)) {
					@<Read next character from I6T stream@>;
					if (cr == '}') {
						WRITE("%d", N_escape);
						continue;
					}
					if (OUT) WRITE("{N");
					goto NewCharacter;
				} else { /* otherwise the open brace was a literal */
					if (OUT) PUT_TO(OUT, '{');
					goto NewCharacter;
				}
			}
			if (cr == '(') {
				@<Read next character from I6T stream@>;
				if (cr == '+') {
					@<Read up to the next plus close-bracket as an I7 expression@>;
					continue;
				} else { /* otherwise the open bracket was a literal */
					if (OUT) PUT_TO(OUT, '(');
					goto NewCharacter;
				}
			}
			if (OUT) PUT_TO(OUT, cr);
		}
	} while (cr != EOF);
	DISCARD_TEXT(command);
	DISCARD_TEXT(argument);
	if (Input_File) { if (DL) STREAM_FLUSH(DL); fclose(Input_File); }

	DISCARD_TEXT(heading_name);
}

@ "If necessary" because our input may be supplied as a wide string, not a
file.

@<Open a file for input, if necessary@> =
	if (Str::len(segment_name) > 0) {
		@<Open the I6 template file@>;
	} else if (index_template) {
		Input_File = Filenames::fopen(index_template, "r");
		if (Input_File == NULL) {
			Problems::Issue::unlocated_problem(_p_(BelievedImpossible), /* or anyway not usefully testable */
				"I couldn't open the template file for the index.");
		}
	}

@ We look for the |.i6t| files first in the materials folder, then in the
installed area and lastly (but almost always) in the built-in resources.
Within those, we look inside |Inter/kinds| for |*.kindt| files,
and |Inter/miscellaneous| for |*.i6t| files (though at present Inform makes
no use of this ability).

@<Open the I6 template file@> =
	Input_File = NULL;
	for (int area=0; area<NO_FS_AREAS; area++)
		if (Input_File == NULL) {
			pathname *P = pathname_of_inter_resources[area];
			if (int_mode == KINDT_MODE) P = Pathnames::subfolder(P, I"kinds");
			else P = Pathnames::subfolder(P, I"miscellaneous");
			Input_File = Filenames::fopen(
				Filenames::in_folder(P, segment_name), "r");
		}
	if (Input_File == NULL) {
		WRITE_TO(STDERR, "inform: Unable to open segment <%S>\n", segment_name);
		Problems::Issue::unlocated_problem(_p_(BelievedImpossible), /* or anyway not usefully testable */
			"I couldn't open a requested I6T segment: see the console "
			"output for details.");
	}

@ I6 template files are encoded as ISO Latin-1, not as Unicode UTF-8, so
ordinary |fgetc| is used, and no BOM marker is parsed. Lines are assumed
to be terminated with either |0x0a| or |0x0d|. (Since blank lines are
harmless, we take no trouble over |0a0d| or |0d0a| combinations.) The
built-in template files, almost always the only ones used, are line
terminated |0x0a| in Unix fashion.

@<Read next character from I6T stream@> =
	if (Input_File) cr = fgetc(Input_File);
	else if (sf) {
		cr = sf[sfp]; if (cr == 0) cr = EOF; else sfp++;
	} else cr = EOF;
	col++; if ((cr == 10) || (cr == 13)) col = 0;

@ Anything following an at-character in the first column is looked at to see if
it's a heading, that is, an Inweb syntax:

@d INWEB_PARAGRAPH_SYNTAX 1
@d INWEB_CODE_SYNTAX 2
@d INWEB_DASH_SYNTAX 3
@d INWEB_PURPOSE_SYNTAX 4

@<Read the rest of line as an at-heading@> =
	TEMPORARY_TEXT(I6T_buffer);
	int i = 0, committed = FALSE, unacceptable_character = FALSE;
	while (i<MAX_I6T_LINE_LENGTH) {
		@<Read next character from I6T stream@>;
		if ((committed == FALSE) && ((cr == 10) || (cr == 13) || (cr == ' '))) {
			if (Str::eq_wide_string(I6T_buffer, L"p")) inweb_syntax = INWEB_PARAGRAPH_SYNTAX;
			else if (Str::eq_wide_string(I6T_buffer, L"c")) inweb_syntax = INWEB_CODE_SYNTAX;
			else if (Str::get_first_char(I6T_buffer) == '-') inweb_syntax = INWEB_DASH_SYNTAX;
			else if (Str::begins_with_wide_string(I6T_buffer, L"Purpose:")) inweb_syntax = INWEB_PURPOSE_SYNTAX;
			committed = TRUE;
			if (inweb_syntax == -1) {
				if (unacceptable_character == FALSE) {
					if (OUT) {
						PUT_TO(OUT, '@');
						WRITE_TO(OUT, "%S", I6T_buffer);
						PUT_TO(OUT, cr);
					}
					break;
				} else {
					LOG("heading begins: <%S>\n", I6T_buffer);
					Problems::quote_stream(1, I6T_buffer);
					Problems::Issue::unlocated_problem(_p_(PM_BadTemplateAtSign),
						"An unknown '@...' marker has been found at column 0 in "
						"raw Inform 6 template material: specifically, '@%1'. ('@' "
						"has a special meaning in this first column, and this "
						"might clash with its use to introduce an assembly-language "
						"opcode in Inform 6: if that's a problem, you can avoid it "
						"simply by putting one or more spaces or tabs in front of "
						"the opcode(s) to keep them clear of the left margin.)");
				}
			}
		}
		if (!(((cr >= 'A') && (cr <= 'Z')) || ((cr >= 'a') && (cr <= 'z'))
			|| ((cr >= '0') && (cr <= '9'))
			|| (cr == '-') || (cr == '>') || (cr == ':') || (cr == '_')))
			unacceptable_character = TRUE;
		if ((cr == 10) || (cr == 13)) break;
		PUT_TO(I6T_buffer, cr);
	}
	Str::copy(command, I6T_buffer);
	DISCARD_TEXT(I6T_buffer);

@ As can be seen, only a small minority of Inweb syntaxes are allowed:
in particular, no |@d| or angle-bracketed macros. This interpreter is not
a full-fledged tangler.

@<Act on the at-heading, going in or out of comment mode as appropriate@> =
	switch (inweb_syntax) {
		case INWEB_PARAGRAPH_SYNTAX: {
			Str::copy_tail(heading_name, command, 2);
			int c;
			while (((c = Str::get_last_char(heading_name)) != 0) &&
				((c == ' ') || (c == '\t') || (c == '.')))
				Str::delete_last_character(heading_name);
			if (Str::len(heading_name) == 0)
				I6T::error("Empty heading name in I6 template file");
			comment = TRUE; skip_part = FALSE;
			break;
		}
		case INWEB_CODE_SYNTAX:
			if (skip_part == FALSE) comment = FALSE;
			break;
		case INWEB_DASH_SYNTAX: break;
		case INWEB_PURPOSE_SYNTAX: break;
	}

@ We get here when reading a kinds template file. Note that initial and
trailing white space on the line is deleted: this makes it easier to lay
out I6T template files tidily.

@<Read rest of line as argument@> =
	Str::clear(argument);
	if (Characters::is_space_or_tab(cr) == FALSE) PUT_TO(argument, cr);
	int at_start = TRUE;
	while (TRUE) {
		@<Read next character from I6T stream@>;
		if ((cr == 10) || (cr == 13)) break;
		if ((at_start) && (Characters::is_space_or_tab(cr))) continue;
		PUT_TO(argument, cr); at_start = FALSE;
	}
	while (Characters::is_space_or_tab(Str::get_last_char(argument)))
		Str::delete_last_character(argument);

@ And here we read a normal command. The command name must not include |}|
or |:|. If there is no |:| then the argument is left unset (so that it will
be the empty string: see above). The argument must not include |}|.

@<Read up to the next close brace as an I6T command and argument@> =
	Str::clear(command);
	Str::clear(argument);
	int com_mode = TRUE;
	while (TRUE) {
		@<Read next character from I6T stream@>;
		if ((cr == '}') || (cr == EOF)) break;
		if ((cr == ':') && (com_mode)) { com_mode = FALSE; continue; }
		if (com_mode) PUT_TO(command, cr);
		else PUT_TO(argument, cr);
	}

@ I7 expressions can be included in I6T code exactly as in inline invocation
definitions: thus

	|Constant FROG_CLASS = (+ pond-dwelling amphibian +);|

will expand "pond-dwelling amphibian" into the I6 translation of the kind
of object with this name. Because of this syntax, one has to watch out for
I6 code like so:

	|if (++counter_of_some_kind > 0) ...|

which can trigger an unwanted |(+|.

@<Read up to the next plus close-bracket as an I7 expression@> =
	TEMPORARY_TEXT(i7_exp);
	while (TRUE) {
		@<Read next character from I6T stream@>;
		if (cr == EOF) break;
		if ((cr == ')') && (Str::get_last_char(i7_exp) == '+')) {
			Str::delete_last_character(i7_exp); break; }
		PUT_TO(i7_exp, cr);
	}
	I6T::compile_I7_from_I6(NULL, OUT, i7_exp);
	DISCARD_TEXT(i7_exp);

@h Acting on I6T commands.
At one time there were very many commands avalable here, but no longer.

=
@<Act on I6T command and argument@> =
	if (int_mode == INDEXT_MODE) @<Act on an I6T indexing command@>;

	LOG("command: <%S> argument: <%S>\n", command, argument);
	Problems::quote_stream(1, command);
	Problems::Issue::unlocated_problem(_p_(PM_TemplateError),
		"In an explicit Inform 6 code insertion, I recognise a few special "
		"notations in the form '{-command}'. This time, though, the unknown notation "
		"{-%1} has been used, and this is an error. (It seems very unlikely indeed "
		"that this could be legal Inform 6 which I'm misreading, but if so, try "
		"adjusting the spacing to make this problem message go away.)");

@h Indexing commands.
Commands in a |.indext| file are skipped when Inform has been called with a 
ommand-line switch to disable the index. (As is done by |intest|, to save
time.) |{-index:name}| opens the index file called |name|.

@<Act on an I6T indexing command@> =
	if (Str::eq_wide_string(command, L"index-complete")) { Index::complete(); continue; }

	if (Str::eq_wide_string(command, L"index-page")) {
		match_results mr = Regexp::create_mr();
		if (Regexp::match(&mr, argument, L"(%c+?)=(%c+?)=(%c+)")) {
			text_stream *col = mr.exp[0];
			text_stream *titling = mr.exp[1];
			text_stream *explanation = mr.exp[2];
			match_results mr2 = Regexp::create_mr();
			text_stream *leafname = titling;
			if (Regexp::match(&mr2, titling, L"(%C+?) (%c+)")) leafname = mr2.exp[0];
			Index::new_page(col, titling, explanation, leafname);
			Regexp::dispose_of(&mr2);
		} else internal_error("bad index-page format");
		Regexp::dispose_of(&mr);
		continue;
	}

	if (Str::eq_wide_string(command, L"index-element")) {
		match_results mr = Regexp::create_mr();
		if (Regexp::match(&mr, argument, L"(%C+) (%c+?)=(%c+)"))
			Index::new_segment(mr.exp[0], mr.exp[1], mr.exp[2]);
		else internal_error("bad index-element format");
		Regexp::dispose_of(&mr);
		continue;
	}

	if (Str::eq_wide_string(command, L"index")) {
		match_results mr = Regexp::create_mr();
		if (Regexp::match(&mr, argument, L"(%c+?)=(%c+)")) {
			text_stream *titling = mr.exp[0];
			text_stream *explanation = mr.exp[1];
			match_results mr2 = Regexp::create_mr();
			TEMPORARY_TEXT(leafname);
			Str::copy(leafname, titling);
			if (Regexp::match(&mr2, leafname, L"(%C+?) (%c+)")) Str::copy(leafname, mr2.exp[0]);
			WRITE_TO(leafname, ".html");
			Index::open_file(leafname, titling, -1, explanation);
			Regexp::dispose_of(&mr2);
			DISCARD_TEXT(leafname);
		} else {
			internal_error("bad index format");
		}
		Regexp::dispose_of(&mr);
		continue;
	}

@h Template errors.
Errors here used to be basically failed assertions, but inevitably people
reported this as a bug (0001596). It was never intended that I6T coding
be part of the outside-facing language, but for a handful of people
using template-hacking there are a handful of cases that can't be avoided, so...

=
void I6T::error(char *message) {
	Problems::quote_text(1, message);
	Problems::Issue::handmade_problem(_p_(...));
	Problems::issue_problem_segment(
		"I ran into a mistake in a template file command: %1. The I6 "
		"template files (or .i6t files) are a very low-level part of Inform, "
		"and errors like this will only occur if the standard installation "
		"has been amended or damaged. One possibility is that you're using "
		"an extension which does some 'template hacking', as it's called, "
		"but made a mistake doing so.");
	Problems::issue_problem_end();
}

@h I7 expression evaluation.
This is not quite like regular expression evaluation, because we want
"room" and "lighted" to be evaluated as the I6 translation of the
relevant class or property, rather than as code to test the predicate
"X is a room" or "X is lighted", and similarly for bare names
of defined adjectives. So:

=
void I6T::compile_I7_from_I6(value_holster *VH, text_stream *OUT, text_stream *p) {
	if ((VH) && (VH->vhmode_wanted == INTER_VOID_VHMODE)) {
		Produce::evaluation(Emit::tree());
		Produce::down(Emit::tree());
	}

	I6T::compile_I7_from_I6_inner(VH, OUT, p);

	if ((VH) && (VH->vhmode_wanted == INTER_VOID_VHMODE)) {
		Produce::up(Emit::tree());
	}
}

void I6T::compile_I7_from_I6_inner(value_holster *VH, text_stream *OUT, text_stream *p) {
	wording LW = Feeds::feed_stream(p);

	if (<property-name>(LW)) {
		if (VH)
			Produce::val_iname(Emit::tree(), K_value, Properties::iname(<<rp>>));
		else
			WRITE_TO(OUT, "%n", Properties::iname(<<rp>>));
		return;
	}

	if (<k-kind>(LW)) {
		kind *K = <<rp>>;
		if (Kinds::Compare::lt(K, K_object)) {
			if (VH)
				Produce::val_iname(Emit::tree(), K_value, Kinds::RunTime::I6_classname(K));
			else
				WRITE_TO(OUT, "%n", Kinds::RunTime::I6_classname(K));
			return;
		}
	}

	instance *I = Instances::parse_object(LW);
	if (I) {
		if (VH)
			Produce::val_iname(Emit::tree(), K_value, Instances::iname(<<rp>>));
		else
			WRITE_TO(OUT, "%~I", I);
		return;
	}

	adjectival_phrase *aph = Adjectives::parse(LW);
	if (aph) {
		if (Adjectives::Meanings::write_adjective_test_routine(VH, aph)) return;
		Problems::Issue::unlocated_problem(_p_(BelievedImpossible),
			"You tried to use '(+' and '+)' to expand to the Inform 6 routine "
			"address of an adjective, but it was an adjective with no meaning.");
		return;
	}

	#ifdef IF_MODULE
	int initial_problem_count = problem_count;
	#endif
	parse_node *spec = NULL;
	if (<s-value>(LW)) spec = <<rp>>;
	else spec = Specifications::new_UNKNOWN(LW);
	#ifndef IF_MODULE
	Produce::val(Emit::tree(), K_number, LITERAL_IVAL, 0);
	#endif
	#ifdef IF_MODULE
	if (initial_problem_count < problem_count) return;
	Dash::check_value(spec, NULL);
	if (initial_problem_count < problem_count) return;
	BEGIN_COMPILATION_MODE;
	COMPILATION_MODE_EXIT(DEREFERENCE_POINTERS_CMODE);
	if (VH)
		Specifications::Compiler::emit_as_val(K_value, spec);
	else {
		nonlocal_variable *nlv = NonlocalVariables::parse(LW);
		if (nlv) {
			PUT(URL_SYMBOL_CHAR);
			Inter::SymbolsTables::symbol_to_url_name(OUT, InterNames::to_symbol(NonlocalVariables::iname(nlv)));
			PUT(URL_SYMBOL_CHAR);
		} else {
			value_holster VH2 = Holsters::new(INTER_DATA_VHMODE);
			Specifications::Compiler::compile_inner(&VH2, spec);
			inter_t v1 = 0, v2 = 0;
			Holsters::unholster_pair(&VH2, &v1, &v2);
			if (v1 == ALIAS_IVAL) {
				PUT(URL_SYMBOL_CHAR);
				inter_symbols_table *T = Inter::Packages::scope(Emit::current_enclosure()->actual_package);
				inter_symbol *S = Inter::SymbolsTables::symbol_from_id(T, v2);
				Inter::SymbolsTables::symbol_to_url_name(OUT, S);
				PUT(URL_SYMBOL_CHAR);
			} else {
				CodeGen::FC::val_from(OUT, Packaging::at(Emit::tree()), v1, v2);
			}
		}
	}
	END_COMPILATION_MODE;
	#endif
}

