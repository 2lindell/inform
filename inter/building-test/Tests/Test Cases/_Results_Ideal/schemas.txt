Test: parse schema from:
	{-say:val:K} 

0001   * (expr)
    INLINE      -say:val:K
=========
Test: parse schema from:
	print (number) say__n=({something}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LanguageNumber
0001       * (operation) !store
0001           * (expr)
            IDENTIFIER  say__n
0001           * (subexpression)
0001               * (expr)
                INLINE      something
=========
Test: parse schema from:
	STextSubstitution(); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  STextSubstitution
=========
Test: parse schema from:
	print (PrintTimeOfDayEnglish) {something}; 

0001   * (call)
0001       * (expr)
        IDENTIFIER  PrintTimeOfDayEnglish
0001       * (expr)
        INLINE      something
=========
Test: parse schema from:
	print (a) {something}; 

0001   * (call)
0001       * (expr)
        IDENTIFIER  IndefArt
0001       * (expr)
        INLINE      something
=========
Test: parse schema from:
	print (a) {something}; 

0001   * (call)
0001       * (expr)
        IDENTIFIER  IndefArt
0001       * (expr)
        INLINE      something
=========
Test: parse schema from:
	CIndefArt({something}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  CIndefArt
0001       * (expr)
        INLINE      something
=========
Test: parse schema from:
	CIndefArt({something}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  CIndefArt
0001       * (expr)
        INLINE      something
=========
Test: parse schema from:
	print (the) {something}; 

0001   * (call)
0001       * (expr)
        IDENTIFIER  DefArt
0001       * (expr)
        INLINE      something
=========
Test: parse schema from:
	print (The) {something}; 

0001   * (call)
0001       * (expr)
        IDENTIFIER  CDefArt
0001       * (expr)
        INLINE      something
=========
Test: parse schema from:
	@nop; {-segment-count}: 

0001   * (assembly)
0001       * (expr)
        OPCODE      @nop
0001   * (statement) !case
0001       * (expr)
        INLINE      -segment-count
0001       * (code) <
=========
Test: parse schema from:
	{-close-brace} 

0001   * (code) >
=========
Test: parse schema from:
	{-close-brace} 

0001   * (code) >
=========
Test: parse schema from:
	{-close-brace} 

0001   * (code) >
=========
Test: parse schema from:
	{-close-brace} 

0001   * (code) >
=========
Test: parse schema from:
	{-close-brace} 

0001   * (code) >
=========
Test: parse schema from:
	{-close-brace} 

0001   * (code) >
=========
Test: parse schema from:
	{-close-brace} 

0001   * (code) >
=========
Test: parse schema from:
	{-close-brace} 

0001   * (code) >
=========
Test: parse schema from:
	{-close-brace} 

0001   * (code) >
=========
Test: parse schema from:
	{-close-brace} 

0001   * (code) >
=========
Test: parse schema from:
	new_line; 

0001   * (statement) !print
0001       * (expr)
        DQUOTED     

=========
Test: parse schema from:
	DivideParagraphPoint(); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  DivideParagraphPoint
=========
Test: parse schema from:
	CommandClarificationBreak(); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  CommandClarificationBreak
=========
Test: parse schema from:
	DivideParagraphPoint(); new_line; 

0001   * (call)
0001       * (expr)
        IDENTIFIER  DivideParagraphPoint
0001   * (statement) !print
0001       * (expr)
        DQUOTED     

=========
Test: parse schema from:
	RunParagraphOn(); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RunParagraphOn
=========
Test: parse schema from:
	SpecialLookSpacingBreak(); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  SpecialLookSpacingBreak
=========
Test: parse schema from:
	(say__p) 

0001   * (subexpression)
0001       * (expr)
        IDENTIFIER  say__p
=========
Test: parse schema from:
	print "["; 

0001   * (statement) !print
0001       * (expr)
        DQUOTED     [
=========
Test: parse schema from:
	print "]"; 

0001   * (statement) !print
0001       * (expr)
        DQUOTED     ]
=========
Test: parse schema from:
	print "'"; 

0001   * (statement) !print
0001       * (expr)
        DQUOTED     '
=========
Test: parse schema from:
	print "~"; 

0001   * (statement) !print
0001       * (expr)
        DQUOTED     "
=========
Test: parse schema from:
	style bold; 

0001   * (statement) !style
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	style underline; 

0001   * (statement) !style
0001       * (expr)
        NUMBER      2
=========
Test: parse schema from:
	style roman; 

0001   * (statement) !style
0001       * (expr)
        NUMBER      0
=========
Test: parse schema from:
	font off; 

0001   * (statement) !font
0001       * (expr)
        NUMBER      0
=========
Test: parse schema from:
	font on; 

0001   * (statement) !font
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	DisplayBoxedQuotation({-box-quotation-text:Q}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  DisplayBoxedQuotation
0001       * (expr)
        INLINE      -box-quotation-text:Q
=========
Test: parse schema from:
	Banner(); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  Banner
=========
Test: parse schema from:
	ShowExtensionVersions(); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  ShowExtensionVersions
=========
Test: parse schema from:
	ShowFullExtensionVersions(); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  ShowFullExtensionVersions
=========
Test: parse schema from:
	SL_Location(true); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  SL_Location
0001       * (expr)
        NUMBER      true
=========
Test: parse schema from:
	WriteListFrom(child({O}), {phrase options}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  WriteListFrom
0001       * (call)
0001           * (expr)
            IDENTIFIER  child
0001           * (expr)
            INLINE      O
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	c_style = c_style &~ (RECURSE_BIT+FULLINV_BIT+PARTINV_BIT); 

0001   * (operation) !store
0001       * (expr)
        IDENTIFIER  c_style
0001       * (operation) !bitwiseand
0001           * (expr)
            IDENTIFIER  c_style
0001           * (operation) !bitwisenot
0001               * (subexpression)
0001                   * (operation) !plus
0001                       * (operation) !plus
0001                           * (expr)
                            IDENTIFIER  RECURSE_BIT
0001                           * (expr)
                            IDENTIFIER  FULLINV_BIT
0001                       * (expr)
                        IDENTIFIER  PARTINV_BIT
=========
Test: parse schema from:
	LIST_OF_TY_Say({-by-reference:L}, 1); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_Say
0001       * (expr)
        INLINE      -by-reference:L
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	LIST_OF_TY_Say({-by-reference:L}, 2); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_Say
0001       * (expr)
        INLINE      -by-reference:L
0001       * (expr)
        NUMBER      2
=========
Test: parse schema from:
	LIST_OF_TY_Say({-by-reference:L}, 3); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_Say
0001       * (expr)
        INLINE      -by-reference:L
0001       * (expr)
        NUMBER      3
=========
Test: parse schema from:
	list_filter_routine = {D}; 

0001   * (operation) !store
0001       * (expr)
        IDENTIFIER  list_filter_routine
0001       * (expr)
        INLINE      D
=========
Test: parse schema from:
	list_filter_routine = 0; 

0001   * (operation) !store
0001       * (expr)
        IDENTIFIER  list_filter_routine
0001       * (expr)
        NUMBER      0
=========
Test: parse schema from:
	{cn} 

0001   * (expr)
    INLINE      cn
=========
Test: parse schema from:
	({-arithmetic-operation:X:Y}) 

0001   * (subexpression)
0001       * (expr)
        INLINE      -arithmetic-operation:X:Y
=========
Test: parse schema from:
	({-arithmetic-operation:X:Y}) 

0001   * (subexpression)
0001       * (expr)
        INLINE      -arithmetic-operation:X:Y
=========
Test: parse schema from:
	({-arithmetic-operation:X:Y}) 

0001   * (subexpression)
0001       * (expr)
        INLINE      -arithmetic-operation:X:Y
=========
Test: parse schema from:
	({-arithmetic-operation:X:Y}) 

0001   * (subexpression)
0001       * (expr)
        INLINE      -arithmetic-operation:X:Y
=========
Test: parse schema from:
	({-arithmetic-operation:X:Y}) 

0001   * (subexpression)
0001       * (expr)
        INLINE      -arithmetic-operation:X:Y
=========
Test: parse schema from:
	({-arithmetic-operation:X:Y}) 

0001   * (subexpression)
0001       * (expr)
        INLINE      -arithmetic-operation:X:Y
=========
Test: parse schema from:
	({-arithmetic-operation:X:Y}) 

0001   * (subexpression)
0001       * (expr)
        INLINE      -arithmetic-operation:X:Y
=========
Test: parse schema from:
	({-arithmetic-operation:X:Y}) 

0001   * (subexpression)
0001       * (expr)
        INLINE      -arithmetic-operation:X:Y
=========
Test: parse schema from:
	({-arithmetic-operation:X:Y}) 

0001   * (subexpression)
0001       * (expr)
        INLINE      -arithmetic-operation:X:Y
=========
Test: parse schema from:
	({-arithmetic-operation:X:Y}) 

0001   * (subexpression)
0001       * (expr)
        INLINE      -arithmetic-operation:X:Y
=========
Test: parse schema from:
	({-arithmetic-operation:X:Y}) 

0001   * (subexpression)
0001       * (expr)
        INLINE      -arithmetic-operation:X:Y
=========
Test: parse schema from:
	({-arithmetic-operation:X}) 

0001   * (subexpression)
0001       * (expr)
        INLINE      -arithmetic-operation:X
=========
Test: parse schema from:
	({-arithmetic-operation:X}) 

0001   * (subexpression)
0001       * (expr)
        INLINE      -arithmetic-operation:X
=========
Test: parse schema from:
	{-primitive-definition:total-of} 

0001   * (expr)
    INLINE      -primitive-definition:total-of
=========
Test: parse schema from:
	Float({R}, {N}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  Float
0001       * (expr)
        INLINE      R
0001       * (expr)
        INLINE      N
=========
Test: parse schema from:
	FloatDec({R}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  FloatDec
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	FloatDec({R}, {N}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  FloatDec
0001       * (expr)
        INLINE      R
0001       * (expr)
        INLINE      N
=========
Test: parse schema from:
	FloatExp({R}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  FloatExp
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	FloatExp({R}, {N}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  FloatExp
0001       * (expr)
        INLINE      R
0001       * (expr)
        INLINE      N
=========
Test: parse schema from:
	REAL_NUMBER_TY_Reciprocal({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Reciprocal
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	REAL_NUMBER_TY_Abs({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Abs
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	REAL_NUMBER_TY_Root({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Root
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	REAL_NUMBER_TY_Ceiling({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Ceiling
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	REAL_NUMBER_TY_Floor({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Floor
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	REAL_NUMBER_TY_to_NUMBER_TY({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_to_NUMBER_TY
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	REAL_NUMBER_TY_Log({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Log
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	REAL_NUMBER_TY_BLog({R}, {N}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_BLog
0001       * (expr)
        INLINE      R
0001       * (expr)
        INLINE      N
=========
Test: parse schema from:
	REAL_NUMBER_TY_Exp({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Exp
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	REAL_NUMBER_TY_Pow({R}, {P}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Pow
0001       * (expr)
        INLINE      R
0001       * (expr)
        INLINE      P
=========
Test: parse schema from:
	REAL_NUMBER_TY_Times({R}, $+0.0174532925) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Times
0001       * (expr)
        INLINE      R
0001       * (expr)
        REAL_NUMBER $+0.0174532925
=========
Test: parse schema from:
	REAL_NUMBER_TY_Sin({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Sin
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	REAL_NUMBER_TY_Cos({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Cos
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	REAL_NUMBER_TY_Tan({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Tan
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	REAL_NUMBER_TY_Arcsin({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Arcsin
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	REAL_NUMBER_TY_Arccos({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Arccos
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	REAL_NUMBER_TY_Arctan({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Arctan
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	REAL_NUMBER_TY_Sinh({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Sinh
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	REAL_NUMBER_TY_Cosh({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Cosh
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	REAL_NUMBER_TY_Tanh({R}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  REAL_NUMBER_TY_Tanh
0001       * (expr)
        INLINE      R
=========
Test: parse schema from:
	{-primitive-definition:number-of} 

0001   * (expr)
    INLINE      -primitive-definition:number-of
=========
Test: parse schema from:
	{-next-routine:K}({X}) 

0001   * (call)
0001       * (expr)
        INLINE      -next-routine:K
0001       * (expr)
        INLINE      X
=========
Test: parse schema from:
	{-previous-routine:K}({X}) 

0001   * (call)
0001       * (expr)
        INLINE      -previous-routine:K
0001       * (expr)
        INLINE      X
=========
Test: parse schema from:
	({C}) 

0001   * (subexpression)
0001       * (expr)
        INLINE      C
=========
Test: parse schema from:
	{-primitive-definition:random-of} 

0001   * (expr)
    INLINE      -primitive-definition:random-of
=========
Test: parse schema from:
	{-ranger-routine:K}({first value}, {second value}) 

0001   * (call)
0001       * (expr)
        INLINE      -ranger-routine:K
0001       * (expr)
        INLINE      first value
0001       * (expr)
        INLINE      second value
=========
Test: parse schema from:
	{-ranger-routine:K}({first value}, {second value}) 

0001   * (call)
0001       * (expr)
        INLINE      -ranger-routine:K
0001       * (expr)
        INLINE      first value
0001       * (expr)
        INLINE      second value
=========
Test: parse schema from:
	{-ranger-routine:K}({first value}, {second value}) 

0001   * (call)
0001       * (expr)
        INLINE      -ranger-routine:K
0001       * (expr)
        INLINE      first value
0001       * (expr)
        INLINE      second value
=========
Test: parse schema from:
	{-ranger-routine:K}({first value}, {second value}) 

0001   * (call)
0001       * (expr)
        INLINE      -ranger-routine:K
0001       * (expr)
        INLINE      first value
0001       * (expr)
        INLINE      second value
=========
Test: parse schema from:
	(GenerateRandomNumber(1, {M}) <= {N}) 

0001   * (subexpression)
0001       * (operation) !le
0001           * (call)
0001               * (expr)
                IDENTIFIER  GenerateRandomNumber
0001               * (expr)
                NUMBER      1
0001               * (expr)
                INLINE      M
0001           * (expr)
            INLINE      N
=========
Test: parse schema from:
	VM_Seed_RNG({N}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  VM_Seed_RNG
0001       * (expr)
        INLINE      N
=========
Test: parse schema from:
	{-my:ct_0} = {T}; {-my:ct_1} = {N}; 

0001   * (operation) !store
0001       * (expr)
        INLINE      -my:ct_0
0001       * (expr)
        INLINE      T
0001   * (operation) !store
0001       * (expr)
        INLINE      -my:ct_1
0001       * (expr)
        INLINE      N
=========
Test: parse schema from:
	{-my:ct_0} = {T}; {-my:ct_1} = TableRowCorr(ct_0, {TC}, {w}); 

0001   * (operation) !store
0001       * (expr)
        INLINE      -my:ct_0
0001       * (expr)
        INLINE      T
0001   * (operation) !store
0001       * (expr)
        INLINE      -my:ct_1
0001       * (call)
0001           * (expr)
            IDENTIFIER  TableRowCorr
0001           * (expr)
            IDENTIFIER  ct_0
0001           * (expr)
            INLINE      TC
0001           * (expr)
            INLINE      w
=========
Test: parse schema from:
	{-my:ct_0} = {T}; {-my:ct_1} = TableBlankRow(ct_0); 

0001   * (operation) !store
0001       * (expr)
        INLINE      -my:ct_0
0001       * (expr)
        INLINE      T
0001   * (operation) !store
0001       * (expr)
        INLINE      -my:ct_1
0001       * (call)
0001           * (expr)
            IDENTIFIER  TableBlankRow
0001           * (expr)
            IDENTIFIER  ct_0
=========
Test: parse schema from:
	{-my:ct_0} = {T}; {-my:ct_1} = TableRandomRow(ct_0); 

0001   * (operation) !store
0001       * (expr)
        INLINE      -my:ct_0
0001       * (expr)
        INLINE      T
0001   * (operation) !store
0001       * (expr)
        INLINE      -my:ct_1
0001       * (call)
0001           * (expr)
            IDENTIFIER  TableRandomRow
0001           * (expr)
            IDENTIFIER  ct_0
=========
Test: parse schema from:
	TableRows({T}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TableRows
0001       * (expr)
        INLINE      T
=========
Test: parse schema from:
	TableBlankRows({T}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TableBlankRows
0001       * (expr)
        INLINE      T
=========
Test: parse schema from:
	TableFilledRows({T}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TableFilledRows
0001       * (expr)
        INLINE      T
=========
Test: parse schema from:
	({-reference-exists:TR}) 

0001   * (subexpression)
0001       * (expr)
        INLINE      -reference-exists:TR
=========
Test: parse schema from:
	({-reference-exists:TR} == false) 

0001   * (subexpression)
0001       * (operation) !eq
0001           * (expr)
            INLINE      -reference-exists:TR
0001           * (expr)
            NUMBER      false
=========
Test: parse schema from:
	{-by-reference-blank-out:tr}; 

0001   * (expr) ;
    INLINE      -by-reference-blank-out:tr
=========
Test: parse schema from:
	TableBlankOutRow({-my:ct_0}, {-my:ct_1}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TableBlankOutRow
0001       * (expr)
        INLINE      -my:ct_0
0001       * (expr)
        INLINE      -my:ct_1
=========
Test: parse schema from:
	TableBlankOutColumn({T}, {TC}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TableBlankOutColumn
0001       * (expr)
        INLINE      T
0001       * (expr)
        INLINE      TC
=========
Test: parse schema from:
	TableBlankOutAll({T}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TableBlankOutAll
0001       * (expr)
        INLINE      T
=========
Test: parse schema from:
	TableDebug({T}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TableDebug
0001       * (expr)
        INLINE      T
=========
Test: parse schema from:
	TableRowDebug({-my:ct_0}, {-my:ct_1}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TableRowDebug
0001       * (expr)
        INLINE      -my:ct_0
0001       * (expr)
        INLINE      -my:ct_1
=========
Test: parse schema from:
	TableRowDebug({T}, {N}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TableRowDebug
0001       * (expr)
        INLINE      T
0001       * (expr)
        INLINE      N
=========
Test: parse schema from:
	TableColumnDebug({T}, {TC}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TableColumnDebug
0001       * (expr)
        INLINE      T
0001       * (expr)
        INLINE      TC
=========
Test: parse schema from:
	TableShuffle({T}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TableShuffle
0001       * (expr)
        INLINE      T
=========
Test: parse schema from:
	TableSort({T}, {TC}, 1); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TableSort
0001       * (expr)
        INLINE      T
0001       * (expr)
        INLINE      TC
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	TableSort({T}, {TC}, -1); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TableSort
0001       * (expr)
        INLINE      T
0001       * (expr)
        INLINE      TC
0001       * (operation) !unaryminus
0001           * (expr)
            NUMBER      1
=========
Test: parse schema from:
	TEXT_TY_BlobAccess({-by-reference:T}, CHR_BLOB) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_BlobAccess
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        IDENTIFIER  CHR_BLOB
=========
Test: parse schema from:
	TEXT_TY_BlobAccess({-by-reference:T}, WORD_BLOB) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_BlobAccess
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        IDENTIFIER  WORD_BLOB
=========
Test: parse schema from:
	TEXT_TY_BlobAccess({-by-reference:T}, PWORD_BLOB) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_BlobAccess
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        IDENTIFIER  PWORD_BLOB
=========
Test: parse schema from:
	TEXT_TY_BlobAccess({-by-reference:T}, UWORD_BLOB) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_BlobAccess
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        IDENTIFIER  UWORD_BLOB
=========
Test: parse schema from:
	TEXT_TY_BlobAccess({-by-reference:T}, LINE_BLOB) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_BlobAccess
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        IDENTIFIER  LINE_BLOB
=========
Test: parse schema from:
	TEXT_TY_BlobAccess({-by-reference:T}, PARA_BLOB) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_BlobAccess
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        IDENTIFIER  PARA_BLOB
=========
Test: parse schema from:
	TEXT_TY_GetBlob({-new:text}, {-by-reference:T}, {N}, CHR_BLOB) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_GetBlob
0001       * (expr)
        INLINE      -new:text
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        INLINE      N
0001       * (expr)
        IDENTIFIER  CHR_BLOB
=========
Test: parse schema from:
	TEXT_TY_GetBlob({-new:text}, {-by-reference:T}, {N}, WORD_BLOB) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_GetBlob
0001       * (expr)
        INLINE      -new:text
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        INLINE      N
0001       * (expr)
        IDENTIFIER  WORD_BLOB
=========
Test: parse schema from:
	TEXT_TY_GetBlob({-new:text}, {-by-reference:T}, {N}, PWORD_BLOB) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_GetBlob
0001       * (expr)
        INLINE      -new:text
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        INLINE      N
0001       * (expr)
        IDENTIFIER  PWORD_BLOB
=========
Test: parse schema from:
	TEXT_TY_GetBlob({-new:text}, {-by-reference:T}, {N}, UWORD_BLOB) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_GetBlob
0001       * (expr)
        INLINE      -new:text
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        INLINE      N
0001       * (expr)
        IDENTIFIER  UWORD_BLOB
=========
Test: parse schema from:
	TEXT_TY_GetBlob({-new:text}, {-by-reference:T}, {N}, LINE_BLOB) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_GetBlob
0001       * (expr)
        INLINE      -new:text
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        INLINE      N
0001       * (expr)
        IDENTIFIER  LINE_BLOB
=========
Test: parse schema from:
	TEXT_TY_GetBlob({-new:text}, {-by-reference:T}, {N}, PARA_BLOB) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_GetBlob
0001       * (expr)
        INLINE      -new:text
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        INLINE      N
0001       * (expr)
        IDENTIFIER  PARA_BLOB
=========
Test: parse schema from:
	TEXT_TY_SubstitutedForm({-new:text}, {-by-reference:T}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_SubstitutedForm
0001       * (expr)
        INLINE      -new:text
0001       * (expr)
        INLINE      -by-reference:T
=========
Test: parse schema from:
	TEXT_TY_Replace_RE(CHR_BLOB,{-by-reference:T},{-by-reference:find},0,{phrase options},1) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_Replace_RE
0001       * (expr)
        IDENTIFIER  CHR_BLOB
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        INLINE      -by-reference:find
0001       * (expr)
        NUMBER      0
0001       * (expr)
        INLINE      phrase options
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	TEXT_TY_Replace_RE(CHR_BLOB,{-by-reference:T},{-by-reference:find},0,{phrase options}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_Replace_RE
0001       * (expr)
        IDENTIFIER  CHR_BLOB
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        INLINE      -by-reference:find
0001       * (expr)
        NUMBER      0
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	TEXT_TY_Replace_RE(CHR_BLOB,{-by-reference:T},{-by-reference:find},1,{phrase options}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_Replace_RE
0001       * (expr)
        IDENTIFIER  CHR_BLOB
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        INLINE      -by-reference:find
0001       * (expr)
        NUMBER      1
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	TEXT_TY_Replace_RE(REGEXP_BLOB,{-by-reference:T},{-by-reference:find},0,{phrase options},1) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_Replace_RE
0001       * (expr)
        IDENTIFIER  REGEXP_BLOB
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        INLINE      -by-reference:find
0001       * (expr)
        NUMBER      0
0001       * (expr)
        INLINE      phrase options
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	TEXT_TY_Replace_RE(REGEXP_BLOB,{-by-reference:T},{-by-reference:find},0,{phrase options}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_Replace_RE
0001       * (expr)
        IDENTIFIER  REGEXP_BLOB
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        INLINE      -by-reference:find
0001       * (expr)
        NUMBER      0
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	TEXT_TY_RE_GetMatchVar(0) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_RE_GetMatchVar
0001       * (expr)
        NUMBER      0
=========
Test: parse schema from:
	TEXT_TY_RE_GetMatchVar({N}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_RE_GetMatchVar
0001       * (expr)
        INLINE      N
=========
Test: parse schema from:
	TEXT_TY_Replace_RE(REGEXP_BLOB,{-by-reference:T},{-by-reference:find},1,{phrase options}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_Replace_RE
0001       * (expr)
        IDENTIFIER  REGEXP_BLOB
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        INLINE      -by-reference:find
0001       * (expr)
        NUMBER      1
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	TEXT_TY_ReplaceText(WORD_BLOB, {-lvalue-by-reference:T}, {-by-reference:find}, {-by-reference:replace}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_ReplaceText
0001       * (expr)
        IDENTIFIER  WORD_BLOB
0001       * (expr)
        INLINE      -lvalue-by-reference:T
0001       * (expr)
        INLINE      -by-reference:find
0001       * (expr)
        INLINE      -by-reference:replace
=========
Test: parse schema from:
	TEXT_TY_ReplaceText(PWORD_BLOB, {-lvalue-by-reference:T}, {-by-reference:find}, {-by-reference:replace}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_ReplaceText
0001       * (expr)
        IDENTIFIER  PWORD_BLOB
0001       * (expr)
        INLINE      -lvalue-by-reference:T
0001       * (expr)
        INLINE      -by-reference:find
0001       * (expr)
        INLINE      -by-reference:replace
=========
Test: parse schema from:
	TEXT_TY_ReplaceBlob(CHR_BLOB, {-lvalue-by-reference:T}, {N}, {-by-reference:replace}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_ReplaceBlob
0001       * (expr)
        IDENTIFIER  CHR_BLOB
0001       * (expr)
        INLINE      -lvalue-by-reference:T
0001       * (expr)
        INLINE      N
0001       * (expr)
        INLINE      -by-reference:replace
=========
Test: parse schema from:
	TEXT_TY_ReplaceBlob(WORD_BLOB, {-lvalue-by-reference:T}, {N}, {-by-reference:replace}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_ReplaceBlob
0001       * (expr)
        IDENTIFIER  WORD_BLOB
0001       * (expr)
        INLINE      -lvalue-by-reference:T
0001       * (expr)
        INLINE      N
0001       * (expr)
        INLINE      -by-reference:replace
=========
Test: parse schema from:
	TEXT_TY_ReplaceBlob(PWORD_BLOB, {-lvalue-by-reference:T}, {N}, {-by-reference:replace}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_ReplaceBlob
0001       * (expr)
        IDENTIFIER  PWORD_BLOB
0001       * (expr)
        INLINE      -lvalue-by-reference:T
0001       * (expr)
        INLINE      N
0001       * (expr)
        INLINE      -by-reference:replace
=========
Test: parse schema from:
	TEXT_TY_ReplaceBlob(UWORD_BLOB, {-lvalue-by-reference:T}, {N}, {-by-reference:replace}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_ReplaceBlob
0001       * (expr)
        IDENTIFIER  UWORD_BLOB
0001       * (expr)
        INLINE      -lvalue-by-reference:T
0001       * (expr)
        INLINE      N
0001       * (expr)
        INLINE      -by-reference:replace
=========
Test: parse schema from:
	TEXT_TY_ReplaceBlob(LINE_BLOB, {-lvalue-by-reference:T}, {N}, {-by-reference:replace}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_ReplaceBlob
0001       * (expr)
        IDENTIFIER  LINE_BLOB
0001       * (expr)
        INLINE      -lvalue-by-reference:T
0001       * (expr)
        INLINE      N
0001       * (expr)
        INLINE      -by-reference:replace
=========
Test: parse schema from:
	TEXT_TY_ReplaceBlob(PARA_BLOB, {-lvalue-by-reference:T}, {N}, {-by-reference:replace}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_ReplaceBlob
0001       * (expr)
        IDENTIFIER  PARA_BLOB
0001       * (expr)
        INLINE      -lvalue-by-reference:T
0001       * (expr)
        INLINE      N
0001       * (expr)
        INLINE      -by-reference:replace
=========
Test: parse schema from:
	TEXT_TY_CharactersToCase({-new:text}, {-by-reference:T}, 0) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_CharactersToCase
0001       * (expr)
        INLINE      -new:text
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        NUMBER      0
=========
Test: parse schema from:
	TEXT_TY_CharactersToCase({-new:text}, {-by-reference:T}, 1) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_CharactersToCase
0001       * (expr)
        INLINE      -new:text
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	TEXT_TY_CharactersToCase({-new:text}, {-by-reference:T}, 2) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_CharactersToCase
0001       * (expr)
        INLINE      -new:text
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        NUMBER      2
=========
Test: parse schema from:
	TEXT_TY_CharactersToCase({-new:text}, {-by-reference:T}, 3) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_CharactersToCase
0001       * (expr)
        INLINE      -new:text
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        NUMBER      3
=========
Test: parse schema from:
	TEXT_TY_CharactersOfCase({-by-reference:T}, 0) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_CharactersOfCase
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        NUMBER      0
=========
Test: parse schema from:
	TEXT_TY_CharactersOfCase({-by-reference:T}, 1) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TEXT_TY_CharactersOfCase
0001       * (expr)
        INLINE      -by-reference:T
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	{V}(1); 

0001   * (call)
0001       * (expr)
        INLINE      V
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	{V}(2); 

0001   * (call)
0001       * (expr)
        INLINE      V
0001       * (expr)
        NUMBER      2
=========
Test: parse schema from:
	{V}(3); 

0001   * (call)
0001       * (expr)
        INLINE      V
0001       * (expr)
        NUMBER      3
=========
Test: parse schema from:
	{V}(CV_POS, PNToVP(), story_tense); 

0001   * (call)
0001       * (expr)
        INLINE      V
0001       * (expr)
        IDENTIFIER  CV_POS
0001       * (call)
0001           * (expr)
            IDENTIFIER  PNToVP
0001       * (expr)
        IDENTIFIER  story_tense
=========
Test: parse schema from:
	{V}(CV_POS, PNToVP(), {T}); 

0001   * (call)
0001       * (expr)
        INLINE      V
0001       * (expr)
        IDENTIFIER  CV_POS
0001       * (call)
0001           * (expr)
            IDENTIFIER  PNToVP
0001       * (expr)
        INLINE      T
=========
Test: parse schema from:
	{V}(CV_POS, {P}, story_tense); 

0001   * (call)
0001       * (expr)
        INLINE      V
0001       * (expr)
        IDENTIFIER  CV_POS
0001       * (expr)
        INLINE      P
0001       * (expr)
        IDENTIFIER  story_tense
=========
Test: parse schema from:
	{V}(CV_POS, {P}, {T}); 

0001   * (call)
0001       * (expr)
        INLINE      V
0001       * (expr)
        IDENTIFIER  CV_POS
0001       * (expr)
        INLINE      P
0001       * (expr)
        INLINE      T
=========
Test: parse schema from:
	{V}(CV_NEG, PNToVP(), story_tense); 

0001   * (call)
0001       * (expr)
        INLINE      V
0001       * (expr)
        IDENTIFIER  CV_NEG
0001       * (call)
0001           * (expr)
            IDENTIFIER  PNToVP
0001       * (expr)
        IDENTIFIER  story_tense
=========
Test: parse schema from:
	{V}(CV_NEG, PNToVP(), {T}); 

0001   * (call)
0001       * (expr)
        INLINE      V
0001       * (expr)
        IDENTIFIER  CV_NEG
0001       * (call)
0001           * (expr)
            IDENTIFIER  PNToVP
0001       * (expr)
        INLINE      T
=========
Test: parse schema from:
	{V}(CV_NEG, {P}, story_tense); 

0001   * (call)
0001       * (expr)
        INLINE      V
0001       * (expr)
        IDENTIFIER  CV_NEG
0001       * (expr)
        INLINE      P
0001       * (expr)
        IDENTIFIER  story_tense
=========
Test: parse schema from:
	{V}(CV_NEG, {P}, {T}); 

0001   * (call)
0001       * (expr)
        INLINE      V
0001       * (expr)
        IDENTIFIER  CV_NEG
0001       * (expr)
        INLINE      P
0001       * (expr)
        INLINE      T
=========
Test: parse schema from:
	{V}(CV_MEANING) 

0001   * (call)
0001       * (expr)
        INLINE      V
0001       * (expr)
        IDENTIFIER  CV_MEANING
=========
Test: parse schema from:
	LIST_OF_TY_InsertItem({-lvalue-by-reference:L}, {new entry}, 0, 0, {phrase options}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_InsertItem
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        INLINE      new entry
0001       * (expr)
        NUMBER      0
0001       * (expr)
        NUMBER      0
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	LIST_OF_TY_InsertItem({-lvalue-by-reference:L}, {new entry}, 1, {E}, {phrase options}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_InsertItem
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        INLINE      new entry
0001       * (expr)
        NUMBER      1
0001       * (expr)
        INLINE      E
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	LIST_OF_TY_AppendList({-lvalue-by-reference:L}, {-by-reference:LX}, 0, 0, {phrase options}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_AppendList
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        INLINE      -by-reference:LX
0001       * (expr)
        NUMBER      0
0001       * (expr)
        NUMBER      0
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	LIST_OF_TY_AppendList({-lvalue-by-reference:L}, {-by-reference:LX}, 1, {E}, 0); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_AppendList
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        INLINE      -by-reference:LX
0001       * (expr)
        NUMBER      1
0001       * (expr)
        INLINE      E
0001       * (expr)
        NUMBER      0
=========
Test: parse schema from:
	LIST_OF_TY_RemoveValue({-lvalue-by-reference:L}, {existing entry}, {phrase options}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_RemoveValue
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        INLINE      existing entry
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	LIST_OF_TY_Remove_List({-lvalue-by-reference:L}, {-by-reference:N}, {phrase options}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_Remove_List
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        INLINE      -by-reference:N
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	LIST_OF_TY_RemoveItemRange({-lvalue-by-reference:L}, {N}, {N}, {phrase options}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_RemoveItemRange
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        INLINE      N
0001       * (expr)
        INLINE      N
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	LIST_OF_TY_RemoveItemRange({-lvalue-by-reference:L}, {N}, {N2}, {phrase options}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_RemoveItemRange
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        INLINE      N
0001       * (expr)
        INLINE      N2
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	(LIST_OF_TY_FindItem({-by-reference:L}, {N})) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  LIST_OF_TY_FindItem
0001           * (expr)
            INLINE      -by-reference:L
0001           * (expr)
            INLINE      N
=========
Test: parse schema from:
	(LIST_OF_TY_FindItem({-by-reference:L}, {N}) == false) 

0001   * (subexpression)
0001       * (operation) !eq
0001           * (call)
0001               * (expr)
                IDENTIFIER  LIST_OF_TY_FindItem
0001               * (expr)
                INLINE      -by-reference:L
0001               * (expr)
                INLINE      N
0001           * (expr)
            NUMBER      false
=========
Test: parse schema from:
	{-new-list-of:list of K} 

0001   * (expr)
    INLINE      -new-list-of:list of K
=========
Test: parse schema from:
	LIST_OF_TY_Mol({-new:list of objects}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_Mol
0001       * (expr)
        INLINE      -new:list of objects
=========
Test: parse schema from:
	LIST_OF_TY_Set_Mol({-by-reference:L}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_Set_Mol
0001       * (expr)
        INLINE      -by-reference:L
=========
Test: parse schema from:
	LIST_OF_TY_GetLength({-by-reference:L}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_GetLength
0001       * (expr)
        INLINE      -by-reference:L
=========
Test: parse schema from:
	LIST_OF_TY_SetLength({-lvalue-by-reference:L}, {N}, -1, 1); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_SetLength
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        INLINE      N
0001       * (operation) !unaryminus
0001           * (expr)
            NUMBER      1
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	LIST_OF_TY_SetLength({-lvalue-by-reference:L}, {N}, -1, 1); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_SetLength
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        INLINE      N
0001       * (operation) !unaryminus
0001           * (expr)
            NUMBER      1
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	LIST_OF_TY_SetLength({-lvalue-by-reference:L}, {N}, -1, -1); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_SetLength
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        INLINE      N
0001       * (operation) !unaryminus
0001           * (expr)
            NUMBER      1
0001       * (operation) !unaryminus
0001           * (expr)
            NUMBER      1
=========
Test: parse schema from:
	LIST_OF_TY_SetLength({-lvalue-by-reference:L}, {N}, 1); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_SetLength
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        INLINE      N
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	LIST_OF_TY_SetLength({-lvalue-by-reference:L}, {N}, 0); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_SetLength
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        INLINE      N
0001       * (expr)
        NUMBER      0
=========
Test: parse schema from:
	LIST_OF_TY_Reverse({-lvalue-by-reference:L}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_Reverse
0001       * (expr)
        INLINE      -lvalue-by-reference:L
=========
Test: parse schema from:
	LIST_OF_TY_Rotate({-lvalue-by-reference:L}, 0); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_Rotate
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        NUMBER      0
=========
Test: parse schema from:
	LIST_OF_TY_Rotate({-lvalue-by-reference:L}, 1); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_Rotate
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	LIST_OF_TY_Sort({-lvalue-by-reference:L}, 1); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_Sort
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	LIST_OF_TY_Sort({-lvalue-by-reference:L}, -1); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_Sort
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (operation) !unaryminus
0001           * (expr)
            NUMBER      1
=========
Test: parse schema from:
	LIST_OF_TY_Sort({-lvalue-by-reference:L}, 2); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_Sort
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        NUMBER      2
=========
Test: parse schema from:
	LIST_OF_TY_Sort({-lvalue-by-reference:L}, 1, {P}, {-property-holds-block-value:P}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_Sort
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (expr)
        NUMBER      1
0001       * (expr)
        INLINE      P
0001       * (expr)
        INLINE      -property-holds-block-value:P
=========
Test: parse schema from:
	LIST_OF_TY_Sort({-lvalue-by-reference:L}, -1, {P}, {-property-holds-block-value:P}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LIST_OF_TY_Sort
0001       * (expr)
        INLINE      -lvalue-by-reference:L
0001       * (operation) !unaryminus
0001           * (expr)
            NUMBER      1
0001       * (expr)
        INLINE      P
0001       * (expr)
        INLINE      -property-holds-block-value:P
=========
Test: parse schema from:
	{-show-me:R}; RelationTest({-by-reference:R}, RELS_SHOW); 

0001   * (expr) ;
    INLINE      -show-me:R
0001   * (call)
0001       * (expr)
        IDENTIFIER  RelationTest
0001       * (expr)
        INLINE      -by-reference:R
0001       * (expr)
        IDENTIFIER  RELS_SHOW
=========
Test: parse schema from:
	RelationRouteTo({-by-reference:R},{O1},{O2},false) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RelationRouteTo
0001       * (expr)
        INLINE      -by-reference:R
0001       * (expr)
        INLINE      O1
0001       * (expr)
        INLINE      O2
0001       * (expr)
        NUMBER      false
=========
Test: parse schema from:
	RelationRouteTo({-by-reference:R},{O1},{O2},true) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RelationRouteTo
0001       * (expr)
        INLINE      -by-reference:R
0001       * (expr)
        INLINE      O1
0001       * (expr)
        INLINE      O2
0001       * (expr)
        NUMBER      true
=========
Test: parse schema from:
	RelationTest({-by-reference:R}, RELS_LIST, {-new:list of K}, RLIST_ALL_X) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RelationTest
0001       * (expr)
        INLINE      -by-reference:R
0001       * (expr)
        IDENTIFIER  RELS_LIST
0001       * (expr)
        INLINE      -new:list of K
0001       * (expr)
        IDENTIFIER  RLIST_ALL_X
=========
Test: parse schema from:
	RelationTest({-by-reference:R}, RELS_LIST, {-new:list of L}, RLIST_ALL_Y) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RelationTest
0001       * (expr)
        INLINE      -by-reference:R
0001       * (expr)
        IDENTIFIER  RELS_LIST
0001       * (expr)
        INLINE      -new:list of L
0001       * (expr)
        IDENTIFIER  RLIST_ALL_Y
=========
Test: parse schema from:
	RelationTest({-by-reference:R}, RELS_LIST, {-new:list of L}, RLIST_ALL_Y) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RelationTest
0001       * (expr)
        INLINE      -by-reference:R
0001       * (expr)
        IDENTIFIER  RELS_LIST
0001       * (expr)
        INLINE      -new:list of L
0001       * (expr)
        IDENTIFIER  RLIST_ALL_Y
=========
Test: parse schema from:
	RelationTest({-by-reference:R}, RELS_LOOKUP_ALL_X, {Y}, {-new:list of K}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RelationTest
0001       * (expr)
        INLINE      -by-reference:R
0001       * (expr)
        IDENTIFIER  RELS_LOOKUP_ALL_X
0001       * (expr)
        INLINE      Y
0001       * (expr)
        INLINE      -new:list of K
=========
Test: parse schema from:
	RelationTest({-by-reference:R}, RELS_LOOKUP_ALL_Y, {X}, {-new:list of L}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RelationTest
0001       * (expr)
        INLINE      -by-reference:R
0001       * (expr)
        IDENTIFIER  RELS_LOOKUP_ALL_Y
0001       * (expr)
        INLINE      X
0001       * (expr)
        INLINE      -new:list of L
=========
Test: parse schema from:
	RelationTest({-by-reference:R}, RELS_LOOKUP_ALL_Y, {X}, {-new:list of L}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RelationTest
0001       * (expr)
        INLINE      -by-reference:R
0001       * (expr)
        IDENTIFIER  RELS_LOOKUP_ALL_Y
0001       * (expr)
        INLINE      X
0001       * (expr)
        INLINE      -new:list of L
=========
Test: parse schema from:
	RelationTest({-by-reference:R}, RELS_LOOKUP_ANY, {Y}, RLANY_CAN_GET_X) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RelationTest
0001       * (expr)
        INLINE      -by-reference:R
0001       * (expr)
        IDENTIFIER  RELS_LOOKUP_ANY
0001       * (expr)
        INLINE      Y
0001       * (expr)
        IDENTIFIER  RLANY_CAN_GET_X
=========
Test: parse schema from:
	RelationTest({-by-reference:R}, RELS_LOOKUP_ANY, {X}, RLANY_CAN_GET_Y) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RelationTest
0001       * (expr)
        INLINE      -by-reference:R
0001       * (expr)
        IDENTIFIER  RELS_LOOKUP_ANY
0001       * (expr)
        INLINE      X
0001       * (expr)
        IDENTIFIER  RLANY_CAN_GET_Y
=========
Test: parse schema from:
	RelationTest({-by-reference:R}, RELS_LOOKUP_ANY, {Y}, RLANY_GET_X) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RelationTest
0001       * (expr)
        INLINE      -by-reference:R
0001       * (expr)
        IDENTIFIER  RELS_LOOKUP_ANY
0001       * (expr)
        INLINE      Y
0001       * (expr)
        IDENTIFIER  RLANY_GET_X
=========
Test: parse schema from:
	RelationTest({-by-reference:R}, RELS_LOOKUP_ANY, {X}, RLANY_GET_Y) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RelationTest
0001       * (expr)
        INLINE      -by-reference:R
0001       * (expr)
        IDENTIFIER  RELS_LOOKUP_ANY
0001       * (expr)
        INLINE      X
0001       * (expr)
        IDENTIFIER  RLANY_GET_Y
=========
Test: parse schema from:
	RelationTest({-by-reference:R}, RELS_LOOKUP_ANY, {X}, RLANY_GET_Y) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RelationTest
0001       * (expr)
        INLINE      -by-reference:R
0001       * (expr)
        IDENTIFIER  RELS_LOOKUP_ANY
0001       * (expr)
        INLINE      X
0001       * (expr)
        IDENTIFIER  RLANY_GET_Y
=========
Test: parse schema from:
	{-primitive-definition:description-application} 

0001   * (expr)
    INLINE      -primitive-definition:description-application
=========
Test: parse schema from:
	{-primitive-definition:function-application} 

0001   * (expr)
    INLINE      -primitive-definition:function-application
=========
Test: parse schema from:
	{-primitive-definition:function-application} 

0001   * (expr)
    INLINE      -primitive-definition:function-application
=========
Test: parse schema from:
	{-primitive-definition:function-application} 

0001   * (expr)
    INLINE      -primitive-definition:function-application
=========
Test: parse schema from:
	{-primitive-definition:function-application} 

0001   * (expr)
    INLINE      -primitive-definition:function-application
=========
Test: parse schema from:
	{-primitive-definition:function-application}; 

0001   * (expr) ;
    INLINE      -primitive-definition:function-application
=========
Test: parse schema from:
	{-primitive-definition:function-application}; 

0001   * (expr) ;
    INLINE      -primitive-definition:function-application
=========
Test: parse schema from:
	{-primitive-definition:function-application}; 

0001   * (expr) ;
    INLINE      -primitive-definition:function-application
=========
Test: parse schema from:
	{-primitive-definition:function-application}; 

0001   * (expr) ;
    INLINE      -primitive-definition:function-application
=========
Test: parse schema from:
	{-show-me:V} 

0001   * (expr)
    INLINE      -show-me:V
=========
Test: parse schema from:
	{-new:K} 

0001   * (expr)
    INLINE      -new:K
=========
Test: parse schema from:
	FileIO_GetTable({filename}, {T}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  FileIO_GetTable
0001       * (expr)
        INLINE      filename
0001       * (expr)
        INLINE      T
=========
Test: parse schema from:
	FileIO_PutTable({filename}, {T}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  FileIO_PutTable
0001       * (expr)
        INLINE      filename
0001       * (expr)
        INLINE      T
=========
Test: parse schema from:
	(FileIO_Exists({filename}, false)) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  FileIO_Exists
0001           * (expr)
            INLINE      filename
0001           * (expr)
            NUMBER      false
=========
Test: parse schema from:
	(FileIO_Ready({filename}, false)) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  FileIO_Ready
0001           * (expr)
            INLINE      filename
0001           * (expr)
            NUMBER      false
=========
Test: parse schema from:
	FileIO_MarkReady({filename}, true); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  FileIO_MarkReady
0001       * (expr)
        INLINE      filename
0001       * (expr)
        NUMBER      true
=========
Test: parse schema from:
	FileIO_MarkReady({filename}, false); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  FileIO_MarkReady
0001       * (expr)
        INLINE      filename
0001       * (expr)
        NUMBER      false
=========
Test: parse schema from:
	FileIO_PutContents({FN}, {T}, false); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  FileIO_PutContents
0001       * (expr)
        INLINE      FN
0001       * (expr)
        INLINE      T
0001       * (expr)
        NUMBER      false
=========
Test: parse schema from:
	FileIO_PutContents({FN}, {T}, true); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  FileIO_PutContents
0001       * (expr)
        INLINE      FN
0001       * (expr)
        INLINE      T
0001       * (expr)
        NUMBER      true
=========
Test: parse schema from:
	FileIO_PrintContents({FN}); say__p = 1; 

0001   * (call)
0001       * (expr)
        IDENTIFIER  FileIO_PrintContents
0001       * (expr)
        INLINE      FN
0001   * (operation) !store
0001       * (expr)
        IDENTIFIER  say__p
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	DisplayFigure(ResourceIDsOfFigures-->{F}, {phrase options}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  DisplayFigure
0001       * (operation) !lookup
0001           * (expr)
            IDENTIFIER  ResourceIDsOfFigures
0001           * (expr)
            INLINE      F
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	ResourceIDsOfFigures-->{F} 

0001   * (operation) !lookup
0001       * (expr)
        IDENTIFIER  ResourceIDsOfFigures
0001       * (expr)
        INLINE      F
=========
Test: parse schema from:
	PlaySound(ResourceIDsOfSounds-->{SFX}, {phrase options}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  PlaySound
0001       * (operation) !lookup
0001           * (expr)
            IDENTIFIER  ResourceIDsOfSounds
0001           * (expr)
            INLINE      SFX
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	ResourceIDsOfSounds-->{SFX} 

0001   * (operation) !lookup
0001       * (expr)
        IDENTIFIER  ResourceIDsOfSounds
0001       * (expr)
        INLINE      SFX
=========
Test: parse schema from:
	{c}  

0001   * (expr)
    INLINE      c
=========
Test: parse schema from:
	(~~{c})  

0001   * (subexpression)
0001       * (operation) !not
0001           * (expr)
            INLINE      c
=========
Test: parse schema from:
	end

schemawhile {c}  

0002   * (expr)
    IDENTIFIER  end
    IDENTIFIER  schemawhile
    INLINE      c
=========
Test: parse schema from:
	for ({loopvar}={v}: {loopvar}<={w}: {loopvar}++)  

0001   * (statement) !for
0001       * (eval)
0001           * (operation) !store
0001               * (expr)
                INLINE      loopvar
0001               * (expr)
                INLINE      v
0001       * (eval)
0001           * (operation) !le
0001               * (expr)
                INLINE      loopvar
0001               * (expr)
                INLINE      w
0001       * (eval)
0001           * (operation) !postincrement
0001               * (expr)
                INLINE      loopvar
0001       * (code) <
=========
Test: parse schema from:
	for ({loopvar}={v}: {loopvar}<={w}: {loopvar}++)  

0001   * (statement) !for
0001       * (eval)
0001           * (operation) !store
0001               * (expr)
                INLINE      loopvar
0001               * (expr)
                INLINE      v
0001       * (eval)
0001           * (operation) !le
0001               * (expr)
                INLINE      loopvar
0001               * (expr)
                INLINE      w
0001       * (eval)
0001           * (operation) !postincrement
0001               * (expr)
                INLINE      loopvar
0001       * (code) <
=========
Test: parse schema from:
	{-primitive-definition:repeat-through} 

0001   * (expr)
    INLINE      -primitive-definition:repeat-through
=========
Test: parse schema from:
	{-primitive-definition:repeat-through-list} 

0001   * (expr)
    INLINE      -primitive-definition:repeat-through-list
=========
Test: parse schema from:
	{-primitive-definition:break} 

0001   * (expr)
    INLINE      -primitive-definition:break
=========
Test: parse schema from:
	continue; 

0001   * (statement) !continue
=========
Test: parse schema from:
	rtrue; 

0001   * (statement) !return
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	rtrue; 

0001   * (statement) !return
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	rfalse; 

0001   * (statement) !return
0001       * (expr)
        NUMBER      0
=========
Test: parse schema from:
	rfalse; 

0001   * (statement) !return
0001       * (expr)
        NUMBER      0
=========
Test: parse schema from:
	return {-return-value:something}; 

0001   * (statement) !return
0001       * (expr)
        INLINE      -return-value:something
=========
Test: parse schema from:
	; 

<nodeless scheme
=========
Test: parse schema from:
	rtrue; 

0001   * (statement) !return
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	{-try-action:S} 

0001   * (expr)
    INLINE      -try-action:S
=========
Test: parse schema from:
	{-try-action-silently:S} 

0001   * (expr)
    INLINE      -try-action-silently:S
=========
Test: parse schema from:
	{-try-action-silently:S} 

0001   * (expr)
    INLINE      -try-action-silently:S
=========
Test: parse schema from:
	(keep_silent == false) 

0001   * (subexpression)
0001       * (operation) !eq
0001           * (expr)
            IDENTIFIER  keep_silent
0001           * (expr)
            NUMBER      false
=========
Test: parse schema from:
	(NeedToTouchNoun()) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  NeedToTouchNoun
=========
Test: parse schema from:
	(NeedToTouchSecondNoun()) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  NeedToTouchSecondNoun
=========
Test: parse schema from:
	(NeedToCarryNoun()) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  NeedToCarryNoun
=========
Test: parse schema from:
	(NeedToCarrySecondNoun()) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  NeedToCarrySecondNoun
=========
Test: parse schema from:
	(NeedLightForAction()) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  NeedLightForAction
=========
Test: parse schema from:
	rtrue; 

0001   * (statement) !return
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	rfalse; 

0001   * (statement) !return
0001       * (expr)
        NUMBER      0
=========
Test: parse schema from:
	STORED_ACTION_TY_Current({-new:action}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  STORED_ACTION_TY_Current
0001       * (expr)
        INLINE      -new:action
=========
Test: parse schema from:
	{A} 

0001   * (expr)
    INLINE      A
=========
Test: parse schema from:
	(STORED_ACTION_TY_Involves({-by-reference:act}, {X})) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  STORED_ACTION_TY_Involves
0001           * (expr)
            INLINE      -by-reference:act
0001           * (expr)
            INLINE      X
=========
Test: parse schema from:
	(STORED_ACTION_TY_Part({-by-reference:act}, STORA_ACTION_F)) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  STORED_ACTION_TY_Part
0001           * (expr)
            INLINE      -by-reference:act
0001           * (expr)
            IDENTIFIER  STORA_ACTION_F
=========
Test: parse schema from:
	(STORED_ACTION_TY_Part({-by-reference:act}, STORA_NOUN_F)) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  STORED_ACTION_TY_Part
0001           * (expr)
            INLINE      -by-reference:act
0001           * (expr)
            IDENTIFIER  STORA_NOUN_F
=========
Test: parse schema from:
	(STORED_ACTION_TY_Part({-by-reference:act}, STORA_SECOND_F)) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  STORED_ACTION_TY_Part
0001           * (expr)
            INLINE      -by-reference:act
0001           * (expr)
            IDENTIFIER  STORA_SECOND_F
=========
Test: parse schema from:
	(STORED_ACTION_TY_Part({-by-reference:act}, STORA_ACTOR_F)) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  STORED_ACTION_TY_Part
0001           * (expr)
            INLINE      -by-reference:act
0001           * (expr)
            IDENTIFIER  STORA_ACTOR_F
=========
Test: parse schema from:
	CarryOutActivity({A}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  CarryOutActivity
0001       * (expr)
        INLINE      A
=========
Test: parse schema from:
	CarryOutActivity({A}, {val}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  CarryOutActivity
0001       * (expr)
        INLINE      A
0001       * (expr)
        INLINE      val
=========
Test: parse schema from:
	rfalse; 

0001   * (statement) !return
0001       * (expr)
        NUMBER      0
=========
Test: parse schema from:
	BeginActivity({A}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  BeginActivity
0001       * (expr)
        INLINE      A
=========
Test: parse schema from:
	BeginActivity({A}, {val}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  BeginActivity
0001       * (expr)
        INLINE      A
0001       * (expr)
        INLINE      val
=========
Test: parse schema from:
	(~~(ForActivity({A}))) 

0001   * (subexpression)
0001       * (operation) !not
0001           * (subexpression)
0001               * (call)
0001                   * (expr)
                    IDENTIFIER  ForActivity
0001                   * (expr)
                    INLINE      A
=========
Test: parse schema from:
	(~~(ForActivity({A}, {val}))) 

0001   * (subexpression)
0001       * (operation) !not
0001           * (subexpression)
0001               * (call)
0001                   * (expr)
                    IDENTIFIER  ForActivity
0001                   * (expr)
                    INLINE      A
0001                   * (expr)
                    INLINE      val
=========
Test: parse schema from:
	EndActivity({A}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  EndActivity
0001       * (expr)
        INLINE      A
=========
Test: parse schema from:
	EndActivity({A}, {val}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  EndActivity
0001       * (expr)
        INLINE      A
0001       * (expr)
        INLINE      val
=========
Test: parse schema from:
	AbandonActivity({A}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  AbandonActivity
0001       * (expr)
        INLINE      A
=========
Test: parse schema from:
	AbandonActivity({A}, {val}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  AbandonActivity
0001       * (expr)
        INLINE      A
0001       * (expr)
        INLINE      val
=========
Test: parse schema from:
	FollowRulebook({RL}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  FollowRulebook
0001       * (expr)
        INLINE      RL
=========
Test: parse schema from:
	FollowRulebook({RL}, {V}, true); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  FollowRulebook
0001       * (expr)
        INLINE      RL
0001       * (expr)
        INLINE      V
0001       * (expr)
        NUMBER      true
=========
Test: parse schema from:
	FollowRulebook({RL}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  FollowRulebook
0001       * (expr)
        INLINE      RL
=========
Test: parse schema from:
	ResultOfRule({RL}, 0, true, {-strong-kind:K}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  ResultOfRule
0001       * (expr)
        INLINE      RL
0001       * (expr)
        NUMBER      0
0001       * (expr)
        NUMBER      true
0001       * (expr)
        INLINE      -strong-kind:K
=========
Test: parse schema from:
	ResultOfRule({RL}, {V}, true, {-strong-kind:L}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  ResultOfRule
0001       * (expr)
        INLINE      RL
0001       * (expr)
        INLINE      V
0001       * (expr)
        NUMBER      true
0001       * (expr)
        INLINE      -strong-kind:L
=========
Test: parse schema from:
	ResultOfRule({RL}, 0, true, {-strong-kind:K}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  ResultOfRule
0001       * (expr)
        INLINE      RL
0001       * (expr)
        NUMBER      0
0001       * (expr)
        NUMBER      true
0001       * (expr)
        INLINE      -strong-kind:K
=========
Test: parse schema from:
	if (FollowRulebook({RL})) rtrue; 

0001   * (statement) !if
0001       * (subexpression)
0001           * (call)
0001               * (expr)
                IDENTIFIER  FollowRulebook
0001               * (expr)
                INLINE      RL
0001       * (code)
0001           * (statement) !return
0001               * (expr)
                NUMBER      1
=========
Test: parse schema from:
	if (FollowRulebook({RL}, {V}, true)) rtrue; 

0001   * (statement) !if
0001       * (subexpression)
0001           * (call)
0001               * (expr)
                IDENTIFIER  FollowRulebook
0001               * (expr)
                INLINE      RL
0001               * (expr)
                INLINE      V
0001               * (expr)
                NUMBER      true
0001       * (code)
0001           * (statement) !return
0001               * (expr)
                NUMBER      1
=========
Test: parse schema from:
	if (FollowRulebook({RL})) rtrue; 

0001   * (statement) !if
0001       * (subexpression)
0001           * (call)
0001               * (expr)
                IDENTIFIER  FollowRulebook
0001               * (expr)
                INLINE      RL
0001       * (code)
0001           * (statement) !return
0001               * (expr)
                NUMBER      1
=========
Test: parse schema from:
	rfalse; 

0001   * (statement) !return
0001       * (expr)
        NUMBER      0
=========
Test: parse schema from:
	RulebookSucceeds(); rtrue; 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RulebookSucceeds
0001   * (statement) !return
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	RulebookFails(); rtrue; 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RulebookFails
0001   * (statement) !return
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	RulebookSucceeds({-weak-kind:rule-return-kind},{-return-value-from-rule:val}); rtrue; 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RulebookSucceeds
0001       * (expr)
        INLINE      -weak-kind:rule-return-kind
0001       * (expr)
        INLINE      -return-value-from-rule:val
0001   * (statement) !return
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	(RulebookSucceeded()) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  RulebookSucceeded
=========
Test: parse schema from:
	(RulebookFailed()) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  RulebookFailed
=========
Test: parse schema from:
	(ResultOfRule()) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  ResultOfRule
=========
Test: parse schema from:
	deadflag=3; story_complete=false; 

0001   * (operation) !store
0001       * (expr)
        IDENTIFIER  deadflag
0001       * (expr)
        NUMBER      3
0001   * (operation) !store
0001       * (expr)
        IDENTIFIER  story_complete
0001       * (expr)
        NUMBER      false
=========
Test: parse schema from:
	deadflag=3; story_complete=true; 

0001   * (operation) !store
0001       * (expr)
        IDENTIFIER  deadflag
0001       * (expr)
        NUMBER      3
0001   * (operation) !store
0001       * (expr)
        IDENTIFIER  story_complete
0001       * (expr)
        NUMBER      true
=========
Test: parse schema from:
	deadflag={-by-reference:finale}; story_complete=false; 

0001   * (operation) !store
0001       * (expr)
        IDENTIFIER  deadflag
0001       * (expr)
        INLINE      -by-reference:finale
0001   * (operation) !store
0001       * (expr)
        IDENTIFIER  story_complete
0001       * (expr)
        NUMBER      false
=========
Test: parse schema from:
	deadflag={-by-reference:finale}; story_complete=true; 

0001   * (operation) !store
0001       * (expr)
        IDENTIFIER  deadflag
0001       * (expr)
        INLINE      -by-reference:finale
0001   * (operation) !store
0001       * (expr)
        IDENTIFIER  story_complete
0001       * (expr)
        NUMBER      true
=========
Test: parse schema from:
	(deadflag~=0) 

0001   * (subexpression)
0001       * (operation) !ne
0001           * (expr)
            IDENTIFIER  deadflag
0001           * (expr)
            NUMBER      0
=========
Test: parse schema from:
	(story_complete) 

0001   * (subexpression)
0001       * (expr)
        IDENTIFIER  story_complete
=========
Test: parse schema from:
	(deadflag==0) 

0001   * (subexpression)
0001       * (operation) !eq
0001           * (expr)
            IDENTIFIER  deadflag
0001           * (expr)
            NUMBER      0
=========
Test: parse schema from:
	(story_complete==false) 

0001   * (subexpression)
0001       * (operation) !eq
0001           * (expr)
            IDENTIFIER  story_complete
0001           * (expr)
            NUMBER      false
=========
Test: parse schema from:
	resurrect_please = true; 

0001   * (operation) !store
0001       * (expr)
        IDENTIFIER  resurrect_please
0001       * (expr)
        NUMBER      true
=========
Test: parse schema from:
	({t}%ONE_HOUR) 

0001   * (subexpression)
0001       * (operation) !modulo
0001           * (expr)
            INLINE      t
0001           * (expr)
            IDENTIFIER  ONE_HOUR
=========
Test: parse schema from:
	({t}/ONE_HOUR) 

0001   * (subexpression)
0001       * (operation) !divide
0001           * (expr)
            INLINE      t
0001           * (expr)
            IDENTIFIER  ONE_HOUR
=========
Test: parse schema from:
	((({t}+20*ONE_HOUR)%(TWENTY_FOUR_HOURS))<(({t2}+20*ONE_HOUR)%(TWENTY_FOUR_HOURS))) 

0001   * (subexpression)
0001       * (operation) !lt
0001           * (subexpression)
0001               * (operation) !modulo
0001                   * (subexpression)
0001                       * (operation) !plus
0001                           * (expr)
                            INLINE      t
0001                           * (operation) !times
0001                               * (expr)
                                NUMBER      20
0001                               * (expr)
                                IDENTIFIER  ONE_HOUR
0001                   * (subexpression)
0001                       * (expr)
                        IDENTIFIER  TWENTY_FOUR_HOURS
0001           * (subexpression)
0001               * (operation) !modulo
0001                   * (subexpression)
0001                       * (operation) !plus
0001                           * (expr)
                            INLINE      t2
0001                           * (operation) !times
0001                               * (expr)
                                NUMBER      20
0001                               * (expr)
                                IDENTIFIER  ONE_HOUR
0001                   * (subexpression)
0001                       * (expr)
                        IDENTIFIER  TWENTY_FOUR_HOURS
=========
Test: parse schema from:
	((({t}+20*ONE_HOUR)%(TWENTY_FOUR_HOURS))>(({t2}+20*ONE_HOUR)%(TWENTY_FOUR_HOURS))) 

0001   * (subexpression)
0001       * (operation) !gt
0001           * (subexpression)
0001               * (operation) !modulo
0001                   * (subexpression)
0001                       * (operation) !plus
0001                           * (expr)
                            INLINE      t
0001                           * (operation) !times
0001                               * (expr)
                                NUMBER      20
0001                               * (expr)
                                IDENTIFIER  ONE_HOUR
0001                   * (subexpression)
0001                       * (expr)
                        IDENTIFIER  TWENTY_FOUR_HOURS
0001           * (subexpression)
0001               * (operation) !modulo
0001                   * (subexpression)
0001                       * (operation) !plus
0001                           * (expr)
                            INLINE      t2
0001                           * (operation) !times
0001                               * (expr)
                                NUMBER      20
0001                               * (expr)
                                IDENTIFIER  ONE_HOUR
0001                   * (subexpression)
0001                       * (expr)
                        IDENTIFIER  TWENTY_FOUR_HOURS
=========
Test: parse schema from:
	(({t2}-{t}+TWENTY_FOUR_HOURS)%(TWENTY_FOUR_HOURS)) 

0001   * (subexpression)
0001       * (operation) !modulo
0001           * (subexpression)
0001               * (operation) !plus
0001                   * (operation) !minus
0001                       * (expr)
                        INLINE      t2
0001                       * (expr)
                        INLINE      t
0001                   * (expr)
                    IDENTIFIER  TWENTY_FOUR_HOURS
0001           * (subexpression)
0001               * (expr)
                IDENTIFIER  TWENTY_FOUR_HOURS
=========
Test: parse schema from:
	(({t2}+{t}+TWENTY_FOUR_HOURS)%(TWENTY_FOUR_HOURS)) 

0001   * (subexpression)
0001       * (operation) !modulo
0001           * (subexpression)
0001               * (operation) !plus
0001                   * (operation) !plus
0001                       * (expr)
                        INLINE      t2
0001                       * (expr)
                        INLINE      t
0001                   * (expr)
                    IDENTIFIER  TWENTY_FOUR_HOURS
0001           * (subexpression)
0001               * (expr)
                IDENTIFIER  TWENTY_FOUR_HOURS
=========
Test: parse schema from:
	(({n})%(TWENTY_FOUR_HOURS)) 

0001   * (subexpression)
0001       * (operation) !modulo
0001           * (subexpression)
0001               * (expr)
                INLINE      n
0001           * (subexpression)
0001               * (expr)
                IDENTIFIER  TWENTY_FOUR_HOURS
=========
Test: parse schema from:
	(({n}*ONE_HOUR)%(TWENTY_FOUR_HOURS)) 

0001   * (subexpression)
0001       * (operation) !modulo
0001           * (subexpression)
0001               * (operation) !times
0001                   * (expr)
                    INLINE      n
0001                   * (expr)
                    IDENTIFIER  ONE_HOUR
0001           * (subexpression)
0001               * (expr)
                IDENTIFIER  TWENTY_FOUR_HOURS
=========
Test: parse schema from:
	SetTimedEvent({-mark-event-used:R}, {t}+1, 0); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  SetTimedEvent
0001       * (expr)
        INLINE      -mark-event-used:R
0001       * (operation) !plus
0001           * (expr)
            INLINE      t
0001           * (expr)
            NUMBER      1
0001       * (expr)
        NUMBER      0
=========
Test: parse schema from:
	SetTimedEvent({-mark-event-used:R}, {t}, 1); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  SetTimedEvent
0001       * (expr)
        INLINE      -mark-event-used:R
0001       * (expr)
        INLINE      t
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	SetTimedEvent({-mark-event-used:R}, (the_time+{t})%(TWENTY_FOUR_HOURS), 1); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  SetTimedEvent
0001       * (expr)
        INLINE      -mark-event-used:R
0001       * (operation) !modulo
0001           * (subexpression)
0001               * (operation) !plus
0001                   * (expr)
                    IDENTIFIER  the_time
0001                   * (expr)
                    INLINE      t
0001           * (subexpression)
0001               * (expr)
                IDENTIFIER  TWENTY_FOUR_HOURS
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	(scene_endings-->({sc}-1)) 

0001   * (subexpression)
0001       * (operation) !lookup
0001           * (expr)
            IDENTIFIER  scene_endings
0001           * (subexpression)
0001               * (operation) !minus
0001                   * (expr)
                    INLINE      sc
0001                   * (expr)
                    NUMBER      1
=========
Test: parse schema from:
	(scene_endings-->({sc}-1) == 0) 

0001   * (subexpression)
0001       * (operation) !eq
0001           * (operation) !lookup
0001               * (expr)
                IDENTIFIER  scene_endings
0001               * (subexpression)
0001                   * (operation) !minus
0001                       * (expr)
                        INLINE      sc
0001                       * (expr)
                        NUMBER      1
0001           * (expr)
            NUMBER      0
=========
Test: parse schema from:
	(scene_endings-->({sc}-1) > 1) 

0001   * (subexpression)
0001       * (operation) !gt
0001           * (operation) !lookup
0001               * (expr)
                IDENTIFIER  scene_endings
0001               * (subexpression)
0001                   * (operation) !minus
0001                       * (expr)
                        INLINE      sc
0001                       * (expr)
                        NUMBER      1
0001           * (expr)
            NUMBER      1
=========
Test: parse schema from:
	(scene_endings-->({sc}-1) <= 1) 

0001   * (subexpression)
0001       * (operation) !le
0001           * (operation) !lookup
0001               * (expr)
                IDENTIFIER  scene_endings
0001               * (subexpression)
0001                   * (operation) !minus
0001                       * (expr)
                        INLINE      sc
0001                       * (expr)
                        NUMBER      1
0001           * (expr)
            NUMBER      1
=========
Test: parse schema from:
	(SceneUtility({sc}, 1)) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  SceneUtility
0001           * (expr)
            INLINE      sc
0001           * (expr)
            NUMBER      1
=========
Test: parse schema from:
	(SceneUtility({sc}, 2)) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  SceneUtility
0001           * (expr)
            INLINE      sc
0001           * (expr)
            NUMBER      2
=========
Test: parse schema from:
	(SceneUtility({sc}, 3)) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  SceneUtility
0001           * (expr)
            INLINE      sc
0001           * (expr)
            NUMBER      3
=========
Test: parse schema from:
	(SceneUtility({sc}, 4)) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  SceneUtility
0001           * (expr)
            INLINE      sc
0001           * (expr)
            NUMBER      4
=========
Test: parse schema from:
	(location==thedark) 

0001   * (subexpression)
0001       * (operation) !eq
0001           * (expr)
            IDENTIFIER  location
0001           * (expr)
            IDENTIFIER  thedark
=========
Test: parse schema from:
	MoveObject({something}, {something else}, {phrase options}, false); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  MoveObject
0001       * (expr)
        INLINE      something
0001       * (expr)
        INLINE      something else
0001       * (expr)
        INLINE      phrase options
0001       * (expr)
        NUMBER      false
=========
Test: parse schema from:
	RemoveFromPlay({something}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RemoveFromPlay
0001       * (expr)
        INLINE      something
=========
Test: parse schema from:
	MoveBackdrop({O}, {D}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  MoveBackdrop
0001       * (expr)
        INLINE      O
0001       * (expr)
        INLINE      D
=========
Test: parse schema from:
	MoveFloatingObjects(); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  MoveFloatingObjects
=========
Test: parse schema from:
	LocationOf({O}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LocationOf
0001       * (expr)
        INLINE      O
=========
Test: parse schema from:
	MapConnection({R1},{D}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  MapConnection
0001       * (expr)
        INLINE      R1
0001       * (expr)
        INLINE      D
=========
Test: parse schema from:
	DoorFrom({R1},{D}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  DoorFrom
0001       * (expr)
        INLINE      R1
0001       * (expr)
        INLINE      D
=========
Test: parse schema from:
	OtherSideOfDoor({D},{R1}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  OtherSideOfDoor
0001       * (expr)
        INLINE      D
0001       * (expr)
        INLINE      R1
=========
Test: parse schema from:
	DirectionDoorLeadsIn({D},{R1}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  DirectionDoorLeadsIn
0001       * (expr)
        INLINE      D
0001       * (expr)
        INLINE      R1
=========
Test: parse schema from:
	RoomOrDoorFrom({R1},{D}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RoomOrDoorFrom
0001       * (expr)
        INLINE      R1
0001       * (expr)
        INLINE      D
=========
Test: parse schema from:
	AssertMapConnection({R1},{D},{R2}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  AssertMapConnection
0001       * (expr)
        INLINE      R1
0001       * (expr)
        INLINE      D
0001       * (expr)
        INLINE      R2
=========
Test: parse schema from:
	AssertMapConnection({R1},{D},nothing); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  AssertMapConnection
0001       * (expr)
        INLINE      R1
0001       * (expr)
        INLINE      D
0001       * (expr)
        NUMBER      nothing
=========
Test: parse schema from:
	FrontSideOfDoor({D}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  FrontSideOfDoor
0001       * (expr)
        INLINE      D
=========
Test: parse schema from:
	BackSideOfDoor({D}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  BackSideOfDoor
0001       * (expr)
        INLINE      D
=========
Test: parse schema from:
	MapRouteTo({R1},{R2},0,{phrase options}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  MapRouteTo
0001       * (expr)
        INLINE      R1
0001       * (expr)
        INLINE      R2
0001       * (expr)
        NUMBER      0
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	MapRouteTo({R1},{R2},0,{phrase options},true) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  MapRouteTo
0001       * (expr)
        INLINE      R1
0001       * (expr)
        INLINE      R2
0001       * (expr)
        NUMBER      0
0001       * (expr)
        INLINE      phrase options
0001       * (expr)
        NUMBER      true
=========
Test: parse schema from:
	MapRouteTo({R1},{R2},{RS},{phrase options}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  MapRouteTo
0001       * (expr)
        INLINE      R1
0001       * (expr)
        INLINE      R2
0001       * (expr)
        INLINE      RS
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	MapRouteTo({R1},{R2},{RS},{phrase options},true) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  MapRouteTo
0001       * (expr)
        INLINE      R1
0001       * (expr)
        INLINE      R2
0001       * (expr)
        INLINE      RS
0001       * (expr)
        INLINE      phrase options
0001       * (expr)
        NUMBER      true
=========
Test: parse schema from:
	(HolderOf({something})) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  HolderOf
0001           * (expr)
            INLINE      something
=========
Test: parse schema from:
	(sibling({something})) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  sibling
0001           * (expr)
            INLINE      something
=========
Test: parse schema from:
	(child({something})) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  child
0001           * (expr)
            INLINE      something
=========
Test: parse schema from:
	YesOrNo() 

0001   * (call)
0001       * (expr)
        IDENTIFIER  YesOrNo
=========
Test: parse schema from:
	(SnippetMatches({S}, {T})) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  SnippetMatches
0001           * (expr)
            INLINE      S
0001           * (expr)
            INLINE      T
=========
Test: parse schema from:
	(SnippetMatches({S}, {T}) == false) 

0001   * (subexpression)
0001       * (operation) !eq
0001           * (call)
0001               * (expr)
                IDENTIFIER  SnippetMatches
0001               * (expr)
                INLINE      S
0001               * (expr)
                INLINE      T
0001           * (expr)
            NUMBER      false
=========
Test: parse schema from:
	(matched_text=SnippetIncludes({T},{S})) 

0001   * (subexpression)
0001       * (operation) !store
0001           * (expr)
            IDENTIFIER  matched_text
0001           * (call)
0001               * (expr)
                IDENTIFIER  SnippetIncludes
0001               * (expr)
                INLINE      T
0001               * (expr)
                INLINE      S
=========
Test: parse schema from:
	(SnippetIncludes({T},{S})==0) 

0001   * (subexpression)
0001       * (operation) !eq
0001           * (call)
0001               * (expr)
                IDENTIFIER  SnippetIncludes
0001               * (expr)
                INLINE      T
0001               * (expr)
                INLINE      S
0001           * (expr)
            NUMBER      0
=========
Test: parse schema from:
	SetPlayersCommand({-by-reference:T}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  SetPlayersCommand
0001       * (expr)
        INLINE      -by-reference:T
=========
Test: parse schema from:
	SpliceSnippet({S}, {-by-reference:T}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  SpliceSnippet
0001       * (expr)
        INLINE      S
0001       * (expr)
        INLINE      -by-reference:T
=========
Test: parse schema from:
	SpliceSnippet({S}, 0); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  SpliceSnippet
0001       * (expr)
        INLINE      S
0001       * (expr)
        NUMBER      0
=========
Test: parse schema from:
	RulebookFails(); rtrue; 

0001   * (call)
0001       * (expr)
        IDENTIFIER  RulebookFails
0001   * (statement) !return
0001       * (expr)
        NUMBER      1
=========
Test: parse schema from:
	PlaceInScope({O}, {phrase options}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  PlaceInScope
0001       * (expr)
        INLINE      O
0001       * (expr)
        INLINE      phrase options
=========
Test: parse schema from:
	ScopeWithin({O}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  ScopeWithin
0001       * (expr)
        INLINE      O
=========
Test: parse schema from:
	PronounNotice({O}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  PronounNotice
0001       * (expr)
        INLINE      O
=========
Test: parse schema from:
	NotifyTheScore(); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  NotifyTheScore
=========
Test: parse schema from:
	print (address) pronoun_word; 

0001   * (statement) !printdword
0001       * (expr)
        IDENTIFIER  pronoun_word
=========
Test: parse schema from:
	PrintCommand(); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  PrintCommand
=========
Test: parse schema from:
	print (address) pronoun_word; 

0001   * (statement) !printdword
0001       * (expr)
        IDENTIFIER  pronoun_word
=========
Test: parse schema from:
	PrintCommand(); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  PrintCommand
=========
Test: parse schema from:
	CoreOf({X}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  CoreOf
0001       * (expr)
        INLINE      X
=========
Test: parse schema from:
	(CommonAncestor({O}, {P})) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  CommonAncestor
0001           * (expr)
            INLINE      O
0001           * (expr)
            INLINE      P
=========
Test: parse schema from:
	(CoreOfParentOfCoreOf({O})) 

0001   * (subexpression)
0001       * (call)
0001           * (expr)
            IDENTIFIER  CoreOfParentOfCoreOf
0001           * (expr)
            INLINE      O
=========
Test: parse schema from:
	VisibilityParent({O}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  VisibilityParent
0001       * (expr)
        INLINE      O
=========
Test: parse schema from:
	FindVisibilityLevels(); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  FindVisibilityLevels
=========
Test: parse schema from:
	TouchabilityCeiling({O}) 

0001   * (call)
0001       * (expr)
        IDENTIFIER  TouchabilityCeiling
0001       * (expr)
        INLINE      O
=========
Test: parse schema from:
	visibility_levels 

0001   * (expr)
    IDENTIFIER  visibility_levels
=========
Test: parse schema from:
	visibility_ceiling 

0001   * (expr)
    IDENTIFIER  visibility_ceiling
=========
Test: parse schema from:
	LookAfterGoing(); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  LookAfterGoing
=========
Test: parse schema from:
	PrintOrRun(location, description); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  PrintOrRun
0001       * (expr)
        IDENTIFIER  location
0001       * (expr)
        IDENTIFIER  description
=========
Test: parse schema from:
	say__comp 

0001   * (expr)
    IDENTIFIER  say__comp
=========
Test: parse schema from:
	(multiflag==1) 

0001   * (subexpression)
0001       * (operation) !eq
0001           * (expr)
            IDENTIFIER  multiflag
0001           * (expr)
            NUMBER      1
=========
Test: parse schema from:
	(lookmode == 1) 

0001   * (subexpression)
0001       * (operation) !eq
0001           * (expr)
            IDENTIFIER  lookmode
0001           * (expr)
            NUMBER      1
=========
Test: parse schema from:
	(lookmode == 2) 

0001   * (subexpression)
0001       * (operation) !eq
0001           * (expr)
            IDENTIFIER  lookmode
0001           * (expr)
            NUMBER      2
=========
Test: parse schema from:
	(lookmode == 3) 

0001   * (subexpression)
0001       * (operation) !eq
0001           * (expr)
            IDENTIFIER  lookmode
0001           * (expr)
            NUMBER      3
=========
Test: parse schema from:
	return GVS_Convert({AN},{O},0); 

0001   * (statement) !return
0001       * (call)
0001           * (expr)
            IDENTIFIER  GVS_Convert
0001           * (expr)
            INLINE      AN
0001           * (expr)
            INLINE      O
0001           * (expr)
            NUMBER      0
=========
Test: parse schema from:
	return ConvertToRequest({X}, {AN}, {Y}, {Z}); 

0001   * (statement) !return
0001       * (call)
0001           * (expr)
            IDENTIFIER  ConvertToRequest
0001           * (expr)
            INLINE      X
0001           * (expr)
            INLINE      AN
0001           * (expr)
            INLINE      Y
0001           * (expr)
            INLINE      Z
=========
Test: parse schema from:
	return ConvertToGoingWithPush(); 

0001   * (statement) !return
0001       * (call)
0001           * (expr)
            IDENTIFIER  ConvertToGoingWithPush
=========
Test: parse schema from:
	move {something} to {something else}; 

0001   * (statement) !move
0001       * (expr)
        INLINE      something
0001       * (expr)
        INLINE      something else
=========
Test: parse schema from:
	MoveDuringGoing({something}, {something else}); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  MoveDuringGoing
0001       * (expr)
        INLINE      something
0001       * (expr)
        INLINE      something else
=========
Test: parse schema from:
	SilentlyConsiderLight(); 

0001   * (call)
0001       * (expr)
        IDENTIFIER  SilentlyConsiderLight
=========
Test: parse schema from:
	{-primitive-definition:verbose-checking} 

0001   * (expr)
    INLINE      -primitive-definition:verbose-checking
=========
Test: parse schema from:
	{-primitive-definition:verbose-checking} 

0001   * (expr)
    INLINE      -primitive-definition:verbose-checking
=========
Test: parse schema from:
	@log_shift xorshift_seed -3 -> temp;
	@log_shift xorshift_seed (-3) -> temp;

0001   * (assembly)
0001       * (expr)
        OPCODE      @log_shift
0001       * (expr)
        IDENTIFIER  xorshift_seed
0001       * (expr)
        NUMBER      -3
0001       * (expr)
        ASM_ARROW   ->
0001       * (expr)
        IDENTIFIER  temp
0002   * (assembly)
0002       * (expr)
        OPCODE      @log_shift
0002       * (expr)
        IDENTIFIER  xorshift_seed
0002       * (expr)
        NUMBER      -3
0002       * (expr)
        ASM_ARROW   ->
0001       * (expr)
        IDENTIFIER  temp
=========
Test: parse schema from:
	print "";

0001   * (statement) !print
0001       * (expr)
        DQUOTED     
=========
Test: parse schema from:
	print '^';
	print 'helen^s//';
	print (char) '@ss', " might be an @ss, who knows.^";
	print (address) 'x@ss', " might be an x@ss, who knows.^";
	print (char) '@{0041}', " might be an A, who knows.^";
	print (address) 'x@{0041}', " might be an xA, who knows.^";

0001   * (statement) !printnumber
0001       * (expr)
        SQUOTED     ^
0002   * (statement) !printnumber
0002       * (expr)
        SQUOTED     helen's//
0003   * (statement) !printchar
0003       * (expr)
        SQUOTED     ß
0003   * (statement) !print
0003       * (expr)
        DQUOTED      might be an ß, who knows.

0004   * (statement) !printdword
0004       * (expr)
        SQUOTED     xß
0004   * (statement) !print
0004       * (expr)
        DQUOTED      might be an xß, who knows.

0005   * (statement) !printchar
0005       * (expr)
        SQUOTED     A
0005   * (statement) !print
0005       * (expr)
        DQUOTED      might be an A, who knows.

0006   * (statement) !printdword
0006       * (expr)
        SQUOTED     xA
0006   * (statement) !print
0006       * (expr)
        DQUOTED      might be an xA, who knows.

=========
Test: parse schema from:
	print "Les @oeuvres d'@AEsop en fran@,cais, mon @'el@`eve!";
	print "Na@:ive readers of the New Yorker re@:elected Mr Clinton.";
	print "Gau@ss first proved the Fundamental Theorem of Algebra.";
	print "@'a@'e@'i@'o@'u@'y@'A@'E@'I@'O@'U@'Y@`a@`e@`i@`o@`u@`A@`E@`I@`O@`U@^a@^e@^i@^o@^u@^A@^E@^I@^O@^U@:a@:e@:i@:o@:u@:y@:A@:E@:I@:O@:U@:Y";
	print "@~a@~n@~o@~A@~N@~O@,c@,C@\o@\O@ae@AE@et@Et@th@Th@LL@!!@??@<<@>>@ss@oa@oA@oe@OE";
	print "So @{a9} is a copyright sign, and @{424} is a capital Cyrillic ef, and @{25B2} is a triangle";
	print "Backslash: @@92 At sign: @@64 Caret: @@94 Tilde: @@126";
	print "a-diarhesis: @@155.";
	print "o-diarhesis: @@156.";
	print "u-diarhesis: @@157.";
	print "A-diarhesis: @@158.";
	print "O-diarhesis: @@159.";
	print "U-diarhesis: @@160.";
	print "sharp s: @@161.";
	print "close double-angle quotation mark: @@162.";
	print "open double-angle quotation mark: @@163.";
	print "e-diarhesis: @@164.";
	print "i-diarhesis: @@165.";
	print "y-diarhesis: @@166.";
	print "E-diarhesis: @@167.";
	print "I-diarhesis: @@168.";
	print "a-acute: @@169.";
	print "e-acute: @@170.";
	print "i-acute: @@171.";
	print "o-acute: @@172.";
	print "u-acute: @@173.";
	print "y-acute: @@174.";
	print "A-acute: @@175.";
	print "E-acute: @@176.";
	print "I-acute: @@177.";
	print "O-acute: @@178.";
	print "U-acute: @@179.";
	print "Y-acute: @@180.";
	print "a-grave: @@181.";
	print "e-grave: @@182.";
	print "i-grave: @@183.";
	print "o-grave: @@184.";
	print "u-grave: @@185.";
	print "A-grave: @@186.";
	print "E-grave: @@187.";
	print "I-grave: @@188.";
	print "O-grave: @@189.";
	print "U-grave: @@190.";
	print "a-circumflex: @@191.";
	print "e-circumflex: @@192.";
	print "i-circumflex: @@193.";
	print "o-circumflex: @@194.";
	print "u-circumflex: @@195.";
	print "A-circumflex: @@196.";
	print "E-circumflex: @@197.";
	print "I-circumflex: @@198.";
	print "O-circumflex: @@199.";
	print "U-circumflex: @@200.";
	print "a-ring: @@201.";
	print "A-ring: @@202.";
	print "o-stroke: @@203.";
	print "O-stroke: @@204.";
	print "a-tilde: @@205.";
	print "n-tilde: @@206.";
	print "o-tilde: @@207.";
	print "A-tilde: @@208.";
	print "N-tilde: @@209.";
	print "O-tilde: @@210.";
	print "ae: @@211.";
	print "AE: @@212.";
	print "c-cedilla: @@213.";
	print "C-cedilla: @@214.";
	print "thorn: @@215.";
	print "eth: @@216.";
	print "Thorn: @@217.";
	print "Eth: @@218.";
	print "pound sterling sign: @@219.";
	print "oe: @@220.";
	print "OE: @@221.";
	print "inverted !: @@222.";
	print "inverted ?: @@223.";
	print "[unicode 169] is a copyright sign. [unicode 1060] is a capital Cyrillic ef, and [unicode 9650] is a triangle.";

0001   * (statement) !print
0001       * (expr)
        DQUOTED     Les œuvres d'Æsop en français, mon élève!
0002   * (statement) !print
0002       * (expr)
        DQUOTED     Naïve readers of the New Yorker reëlected Mr Clinton.
0003   * (statement) !print
0003       * (expr)
        DQUOTED     Gauß first proved the Fundamental Theorem of Algebra.
0004   * (statement) !print
0004       * (expr)
        DQUOTED     áéíóúýÁÉÍÓÚÝàèìòùÀÈÌÒÙâêîôûÂÊÎÔÛäëïöüÿÄËÏÖÜŸ
0005   * (statement) !print
0005       * (expr)
        DQUOTED     ãñõÃÑÕçÇøØæÆðÐþÎ£¡¿«»ßåÅœŒ
0006   * (statement) !print
0006       * (expr)
        DQUOTED     So © is a copyright sign, and Ф is a capital Cyrillic ef, and ▲ is a triangle
0007   * (statement) !print
0007       * (expr)
        DQUOTED     Backslash: \ At sign: @ Caret: ^ Tilde: ~
0008   * (statement) !print
0008       * (expr)
        DQUOTED     a-diarhesis: ä.
0009   * (statement) !print
0009       * (expr)
        DQUOTED     o-diarhesis: ö.
0010   * (statement) !print
0010       * (expr)
        DQUOTED     u-diarhesis: ü.
0011   * (statement) !print
0011       * (expr)
        DQUOTED     A-diarhesis: Ä.
0012   * (statement) !print
0012       * (expr)
        DQUOTED     O-diarhesis: Ö.
0013   * (statement) !print
0013       * (expr)
        DQUOTED     U-diarhesis: Ü.
0014   * (statement) !print
0014       * (expr)
        DQUOTED     sharp s: ß.
0015   * (statement) !print
0015       * (expr)
        DQUOTED     close double-angle quotation mark: ».
0016   * (statement) !print
0016       * (expr)
        DQUOTED     open double-angle quotation mark: «.
0017   * (statement) !print
0017       * (expr)
        DQUOTED     e-diarhesis: ë.
0018   * (statement) !print
0018       * (expr)
        DQUOTED     i-diarhesis: ï.
0019   * (statement) !print
0019       * (expr)
        DQUOTED     y-diarhesis: ÿ.
0020   * (statement) !print
0020       * (expr)
        DQUOTED     E-diarhesis: Ë.
0021   * (statement) !print
0021       * (expr)
        DQUOTED     I-diarhesis: Ï.
0022   * (statement) !print
0022       * (expr)
        DQUOTED     a-acute: á.
0023   * (statement) !print
0023       * (expr)
        DQUOTED     e-acute: é.
0024   * (statement) !print
0024       * (expr)
        DQUOTED     i-acute: í.
0025   * (statement) !print
0025       * (expr)
        DQUOTED     o-acute: ó.
0026   * (statement) !print
0026       * (expr)
        DQUOTED     u-acute: ú.
0027   * (statement) !print
0027       * (expr)
        DQUOTED     y-acute: ý.
0028   * (statement) !print
0028       * (expr)
        DQUOTED     A-acute: Á.
0029   * (statement) !print
0029       * (expr)
        DQUOTED     E-acute: É.
0030   * (statement) !print
0030       * (expr)
        DQUOTED     I-acute: Í.
0031   * (statement) !print
0031       * (expr)
        DQUOTED     O-acute: Ó.
0032   * (statement) !print
0032       * (expr)
        DQUOTED     U-acute: Ú.
0033   * (statement) !print
0033       * (expr)
        DQUOTED     Y-acute: Ý.
0034   * (statement) !print
0034       * (expr)
        DQUOTED     a-grave: à.
0035   * (statement) !print
0035       * (expr)
        DQUOTED     e-grave: è.
0036   * (statement) !print
0036       * (expr)
        DQUOTED     i-grave: ì.
0037   * (statement) !print
0037       * (expr)
        DQUOTED     o-grave: ò.
0038   * (statement) !print
0038       * (expr)
        DQUOTED     u-grave: ù.
0039   * (statement) !print
0039       * (expr)
        DQUOTED     A-grave: À.
0040   * (statement) !print
0040       * (expr)
        DQUOTED     E-grave: È.
0041   * (statement) !print
0041       * (expr)
        DQUOTED     I-grave: Ì.
0042   * (statement) !print
0042       * (expr)
        DQUOTED     O-grave: Ò.
0043   * (statement) !print
0043       * (expr)
        DQUOTED     U-grave: Ù.
0044   * (statement) !print
0044       * (expr)
        DQUOTED     a-circumflex: â.
0045   * (statement) !print
0045       * (expr)
        DQUOTED     e-circumflex: ê.
0046   * (statement) !print
0046       * (expr)
        DQUOTED     i-circumflex: î.
0047   * (statement) !print
0047       * (expr)
        DQUOTED     o-circumflex: ô.
0048   * (statement) !print
0048       * (expr)
        DQUOTED     u-circumflex: û.
0049   * (statement) !print
0049       * (expr)
        DQUOTED     A-circumflex: Â.
0050   * (statement) !print
0050       * (expr)
        DQUOTED     E-circumflex: Ê.
0051   * (statement) !print
0051       * (expr)
        DQUOTED     I-circumflex: Î.
0052   * (statement) !print
0052       * (expr)
        DQUOTED     O-circumflex: Ô.
0053   * (statement) !print
0053       * (expr)
        DQUOTED     U-circumflex: Û.
0054   * (statement) !print
0054       * (expr)
        DQUOTED     a-ring: æ.
0055   * (statement) !print
0055       * (expr)
        DQUOTED     A-ring: Æ.
0056   * (statement) !print
0056       * (expr)
        DQUOTED     o-stroke: ø.
0057   * (statement) !print
0057       * (expr)
        DQUOTED     O-stroke: Ø.
0058   * (statement) !print
0058       * (expr)
        DQUOTED     a-tilde: ã.
0059   * (statement) !print
0059       * (expr)
        DQUOTED     n-tilde: ñ.
0060   * (statement) !print
0060       * (expr)
        DQUOTED     o-tilde: õ.
0061   * (statement) !print
0061       * (expr)
        DQUOTED     A-tilde: Ã.
0062   * (statement) !print
0062       * (expr)
        DQUOTED     N-tilde: Ñ.
0063   * (statement) !print
0063       * (expr)
        DQUOTED     O-tilde: Õ.
0064   * (statement) !print
0064       * (expr)
        DQUOTED     ae: æ.
0065   * (statement) !print
0065       * (expr)
        DQUOTED     AE: Æ.
0066   * (statement) !print
0066       * (expr)
        DQUOTED     c-cedilla: ç.
0067   * (statement) !print
0067       * (expr)
        DQUOTED     C-cedilla: Ç.
0068   * (statement) !print
0068       * (expr)
        DQUOTED     thorn: þ.
0069   * (statement) !print
0069       * (expr)
        DQUOTED     eth: ð.
0070   * (statement) !print
0070       * (expr)
        DQUOTED     Thorn: Þ.
0071   * (statement) !print
0071       * (expr)
        DQUOTED     Eth: Ð.
0072   * (statement) !print
0072       * (expr)
        DQUOTED     pound sterling sign: £.
0073   * (statement) !print
0073       * (expr)
        DQUOTED     oe: œ.
0074   * (statement) !print
0074       * (expr)
        DQUOTED     OE: Œ.
0075   * (statement) !print
0075       * (expr)
        DQUOTED     inverted !: ¡.
0076   * (statement) !print
0076       * (expr)
        DQUOTED     inverted ?: ¿.
0077   * (statement) !print
0077       * (expr)
        DQUOTED     © is a copyright sign. Ф is a capital Cyrillic ef, and ▲ is a triangle.
=========
Test: parse schema from:
	print BasicInformKit`stuff();
	DialogueKit`temp = 1;

0001   * (statement) !printnumber
0001       * (call)
0002           * (expr)
            IDENTIFIER  BasicInformKit`stuff
0002   * (operation) !store
0002       * (expr)
        IDENTIFIER  DialogueKit`temp
0003       * (expr)
        NUMBER      1
=========
