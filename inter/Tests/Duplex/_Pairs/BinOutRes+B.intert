# This is a miscellany of tests.

packagetype _plain
packagetype _code

primitive !return val -> void
primitive !modulo val val -> val
primitive !plus val val -> val

pragma target_I6 "$MAX_STATIC_DATA=180000"

package main _plain
	typename K_number = int32
	typename K_truth_state = int2
	defaultvalue K_number = 47
	variable (K_number) V_banana = 100
	constant (K_number) C_death = -5
	constant (K_number) C_taxes = 14
	variable (K_number) V_anxiety = C_death
	constant (K_number) C_x = 0x7f2a __hex
	constant (K_number) cornelius = dw"frogs"
	constant (K_number) gaius = dw"toads"
	splat "Sing a song of \"six splats\"...\nand don't wait up"
	typename K_colour = enum
	instance I_green K_colour = 1
	instance I_red K_colour = 17
	variable (K_colour) V_shade = I_red
	typename K_list_of_number = list of K_number
	constant (K_list_of_number) C_primes = { 2, 3, 5, 7, 11, 13, 17, 19 }
	constant (K_list_of_number) C_concealed = C_primes
	variable (K_list_of_number) V_watch_list = C_concealed
	typename K_text = text
	constant (K_text) C_complaint = "This is already quite a long test case."
	constant (K_number) C_raw = glob"SOME_I6_DRIVEL"
	typename K_odour = enum
	instance I_citrus K_odour = 5
	instance I_leather K_odour = 10
	property (K_number) P_strength __property_name="strength"
	permission P_strength K_odour
	propertyvalue P_strength I_citrus = 20
	propertyvalue P_strength I_leather = 7
	property (K_number) P_lingeringness
	permission P_lingeringness K_odour
	propertyvalue P_lingeringness I_citrus = 1
	propertyvalue P_lingeringness I_leather = 3
	propertyvalue P_lingeringness K_odour = 2
	typename K_table = table
	typename K_column_of_number = column of K_number
	typename K_column_of_colour = column of K_colour
	constant (K_column_of_number) C_egtable_col1 = { 1, 4, 9, 16 }
	constant (K_column_of_colour) C_egtable_col2 = { I_green, !undef, I_red }
	constant (K_table) C_egtable = { C_egtable_col1, C_egtable_col2 }
	typename K_object = enum
	instance I_board K_object = 1
	typename K_piece <=  K_object
	instance I_bishop K_piece = 2
	instance I_rook K_piece = 3
	typename K_list_of_objects = list of K_object
	constant (K_list_of_objects) C_majors = { I_bishop, I_rook }
	permission P_lingeringness I_bishop
	typename K_func = function K_colour K_number -> K_odour
	typename K_rule = rule void -> void
	typename K_rulebook = rulebook of K_rule
	typename K_stuff = struct K_number K_colour K_odour
	constant (K_stuff) S_stuff = struct{ 5, I_red, I_citrus }
	package R_after1_B _code
	package R_after2_B _code
	constant (K_rule) R_after1 = function R_after1_B
	constant (K_rule) R_after2 = function R_after2_B
	constant (K_rulebook) RB_after = { R_after1, R_after2 }
	typename K_colour____colour = function K_colour -> K_colour
	package R_101_B _code
		local (/main/K_colour) x __argument
		code
			inv /main/R_102
				val (/main/K_number) dw"marbles"
			inv !return
				inv !modulo
					inv !plus
						cast /main/K_number <- /main/K_colour
							val (/main/K_colour) x
						val (/main/K_number) 1
					val (/main/K_truth_state) glob"a b"
	constant (K_colour____colour) R_101 = function R_101_B
	package R_102_B _code
		local (/main/K_colour) x __argument
		code
			inv !return
				val (/main/K_colour) /main/I_red
	constant (K_colour____colour) R_102 = function R_102_B
	constant (K_number) amount = sum{ 2, C_taxes }

