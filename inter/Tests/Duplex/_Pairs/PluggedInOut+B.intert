# This is a miscellany of tests.

packagetype _plain
packagetype _code
packagetype _linkage

version 7

primitive !return val -> void
primitive !modulo val val -> val
primitive !plus val val -> val

pragma target_I6 "$MAX_STATIC_DATA=180000"

package main _plain
	kind K_number int32
	kind K_truth_state int2
	defaultvalue K_number = 47
	variable V_banana K_number = 100
	constant C_death K_number = -5
	constant C_taxes K_number = 14
	variable V_anxiety K_number = C_death
	constant C_x K_number = 0x7f2a __hex
	link early "alpha" "beta" "gamma" "delta"
	link before "alpha" "" "" ""
	link instead "" "beta" "" ""
	link after "" "" "gamma" ""
	constant cornelius K_number = dw'frogs'
	constant gaius K_number = dw'toads'
	splat &"Sing a song of \"six splats\"...\nand don't wait up"
	kind K_colour enum
	instance I_green K_colour = 1
	instance I_red K_colour = 17
	variable V_shade K_colour = I_red
	kind K_list_of_number list of K_number
	constant C_primes K_list_of_number = { 2, 3, 5, 7, 11, 13, 17, 19 }
	constant C_concealed K_list_of_number = C_primes
	variable V_watch_list K_list_of_number = C_concealed
	kind K_text text
	constant C_complaint K_text = "This is already quite a long test case."
	constant C_raw K_number = &"SOME_I6_DRIVEL"
	kind K_odour enum
	instance I_citrus K_odour = 5
	instance I_leather K_odour = 10
	property P_strength K_number __property_name="strength"
	permission P_strength K_odour
	propertyvalue P_strength I_citrus = 20
	propertyvalue P_strength I_leather = 7
	property P_lingeringness K_number
	permission P_lingeringness K_odour
	propertyvalue P_lingeringness I_citrus = 1
	propertyvalue P_lingeringness I_leather = 3
	propertyvalue P_lingeringness K_odour = 2
	kind K_table table
	kind K_column_of_number column of K_number
	kind K_column_of_colour column of K_colour
	constant C_egtable_col1 K_column_of_number = { 1, 4, 9, 16 }
	constant C_egtable_col2 K_column_of_colour = { I_green, undef, I_red }
	constant C_egtable K_table = { C_egtable_col1, C_egtable_col2 }
	kind K_object enum
	instance I_board K_object = 1
	kind K_piece <= K_object
	instance I_bishop K_piece = 2
	instance I_rook K_piece = 3
	kind K_list_of_objects list of K_object
	constant C_majors K_list_of_objects = { I_bishop, I_rook }
	permission P_lingeringness I_bishop
	kind K_func function K_colour K_number -> K_odour
	kind K_rule rule void -> void
	kind K_rulebook rulebook of K_rule
	kind K_stuff struct K_number K_colour K_odour
	constant S_stuff K_stuff = { 5, I_red, I_citrus }
	package R_after1_B _code
	package R_after2_B _code
	constant R_after1 K_rule = R_after1_B
	constant R_after2 K_rule = R_after2_B
	constant RB_after K_rulebook = { R_after1, R_after2 }
	kind K_colour____colour function K_colour -> K_colour
	package R_101_B _code
		local x /main/K_colour __argument
		code
			inv /main/R_102
				val /main/K_colour /main/I_green
			inv !return
				inv !modulo
					inv !plus
						cast /main/K_number <- /main/K_colour
							val /main/K_colour x
						val /main/K_number 1
					val /main/K_truth_state &"a b"
	constant R_101 K_colour____colour = R_101_B
	package R_102_B _code
		local x /main/K_colour __argument
		code
			inv !return
				val /main/K_colour /main/I_red
	constant R_102 K_colour____colour = R_102_B
	constant amount K_number = sum{ 2, C_taxes }
	package connectors _linkage
		socket C_majors ~~> /main/C_majors
		plug plug_00001 ~~> "secret"
