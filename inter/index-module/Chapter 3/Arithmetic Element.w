[ArithmeticElement::] Arithmetic Element.

To write the Arithmetic element (Ar) in the index.

@ These were really indexed for us in metadata generated by the main compiler;
so we do little more than tabulate that data here.

=
void ArithmeticElement::render(OUTPUT_STREAM, localisation_dictionary *LD) {
	inter_tree *I = InterpretIndex::get_tree();
	tree_inventory *inv = Synoptic::inv(I);
	TreeLists::sort(inv->kind_nodes, Synoptic::module_order);
	TreeLists::sort(inv->multiplication_rule_nodes, Synoptic::module_order);
	HTML_TAG("hr");
	@<Index the rubric about quasinumerical kinds@>;
	@<Index the table of quasinumerical kinds@>;
	@<Index the table of multiplication rules@>;
}

@<Index the rubric about quasinumerical kinds@> =
	HTML_OPEN("p");
	HTML_TAG_WITH("a", "calculator");
	HTML::begin_plain_html_table(OUT);
	HTML::first_html_column(OUT, 0);
	HTML_TAG_WITH("img", "border=0 src=inform:/doc_images/calc2.png");
	WRITE("&nbsp;");
	WRITE("Kinds of value marked with the calculator symbol are numerical - "
		"these are values we can add, multiply and so on. The range of these "
		"numbers depends on the Format setting for the project (Glulx format "
		"supports much higher numbers than Z-code).");
	HTML::end_html_row(OUT);
	HTML::end_html_table(OUT);
	HTML_CLOSE("p");

@<Index the table of quasinumerical kinds@> =
	HTML_OPEN("p");
	HTML::begin_plain_html_table(OUT);

	HTML::first_html_column(OUT, 0);
	WRITE("<b>kind of value</b>");
	HTML::next_html_column(OUT, 0);
	WRITE("<b>minimum</b>");
	HTML::next_html_column(OUT, 0);
	WRITE("<b>maximum</b>");
	HTML::next_html_column(OUT, 0);
	WRITE("<b>dimensions</b>");
	HTML::end_html_row(OUT);

	for (int i=0; i<TreeLists::len(inv->kind_nodes); i++) {
		inter_package *pack = Inter::Package::defined_by_frame(inv->kind_nodes->list[i].node);
		if (Str::len(Metadata::read_optional_textual(pack, I"^min_value")) > 0) {
			HTML::first_html_column(OUT, 0);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^printed_name"));
			HTML::next_html_column(OUT, 0);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^min_value"));
			HTML::next_html_column(OUT, 0);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^max_value"));
			HTML::next_html_column(OUT, 0);
			text_stream *dims = Metadata::read_optional_textual(pack, I"^dimensions");
			if (Str::len(dims) > 0) WRITE("%S", dims); else WRITE("<i>dimensionless</i>");
			HTML::end_html_row(OUT);
		}
	}
	HTML::end_html_table(OUT);
	HTML_CLOSE("p");

@ This is simply a table of all the multiplications declared in the source
text, sorted into kind order of left and then right operand.

@<Index the table of multiplication rules@> =
	if (TreeLists::len(inv->multiplication_rule_nodes) > 0) {
		HTML_OPEN("p");
		WRITE("This is how multiplication changes kinds:");
		HTML_CLOSE("p");
		HTML_OPEN("p");
		HTML::begin_plain_html_table(OUT);
		for (int i=0; i<TreeLists::len(inv->multiplication_rule_nodes); i++) {
			inter_package *pack = Inter::Package::defined_by_frame(inv->multiplication_rule_nodes->list[i].node);
			HTML::first_html_column(OUT, 0);
			int at = (int) Metadata::read_optional_numeric(pack, I"^at");
			if (at > 0) IndexUtilities::link(OUT, at);
			HTML::next_html_column(OUT, 0);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^left_operand"));
			HTML::begin_colour(OUT, I"808080");
			WRITE(" x ");
			HTML::end_colour(OUT);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^right_operand"));
			HTML::begin_colour(OUT, I"808080");
			WRITE(" = ");
			HTML::end_colour(OUT);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^result"));
			WRITE("&nbsp;&nbsp;&nbsp;&nbsp;");
			HTML::next_html_column(OUT, 0);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^left_operand_benchmark"));
			HTML::begin_colour(OUT, I"808080");
			WRITE(" x ");
			HTML::end_colour(OUT);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^right_operand_benchmark"));
			HTML::begin_colour(OUT, I"808080");
			WRITE(" = ");
			HTML::end_colour(OUT);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^result_benchmark"));
			HTML::end_html_row(OUT);
		}
		HTML::end_html_table(OUT);
		HTML_CLOSE("p");
	}
