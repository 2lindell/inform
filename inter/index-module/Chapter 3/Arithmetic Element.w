[ArithmeticElement::] Arithmetic Element.

To write the Arithmetic element (Ar) in the index.

@ These were really indexed for us in metadata generated by the main compiler;
so we do little more than tabulate that data here.

=
void ArithmeticElement::render(OUTPUT_STREAM, index_session *session) {
	localisation_dictionary *LD = Indexing::get_localisation(session);
	tree_inventory *inv = Indexing::get_inventory(session);
	InterNodeList::array_sort(inv->kind_nodes, MakeSynopticModuleStage::module_order);
	InterNodeList::array_sort(inv->multiplication_rule_nodes, MakeSynopticModuleStage::module_order);
	HTML_TAG("hr");
	@<Index the rubric about quasinumerical kinds@>;
	@<Index the table of quasinumerical kinds@>;
	@<Index the table of multiplication rules@>;
}

@<Index the rubric about quasinumerical kinds@> =
	HTML_OPEN("p");
	HTML_TAG_WITH("a", "calculator");
	HTML::begin_plain_html_table(OUT);
	HTML::first_html_column(OUT, 0);
	HTML_TAG_WITH("img", "border=0 src=inform:/doc_images/calc2.png");
	WRITE("&nbsp;");
	Localisation::roman(OUT, LD, I"Index.Elements.Ar.Calculator");
	HTML::end_html_row(OUT);
	HTML::end_html_table(OUT);
	HTML_CLOSE("p");

@<Index the table of quasinumerical kinds@> =
	HTML_OPEN("p");
	HTML::begin_plain_html_table(OUT);

	HTML::first_html_column(OUT, 0);
	ArithmeticElement::column(OUT, I"KindColumn", LD);
	HTML::next_html_column(OUT, 0);
	ArithmeticElement::column(OUT, I"MinimumColumn", LD);
	HTML::next_html_column(OUT, 0);
	ArithmeticElement::column(OUT, I"MaximumColumn", LD);
	HTML::next_html_column(OUT, 0);
	ArithmeticElement::column(OUT, I"DimensionsdColumn", LD);
	HTML::end_html_row(OUT);

	inter_package *pack;
	LOOP_OVER_INVENTORY_PACKAGES(pack, i, inv->kind_nodes)
		if (Str::len(Metadata::read_optional_textual(pack, I"^min_value")) > 0) {
			HTML::first_html_column(OUT, 0);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^printed_name"));
			HTML::next_html_column(OUT, 0);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^min_value"));
			HTML::next_html_column(OUT, 0);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^max_value"));
			HTML::next_html_column(OUT, 0);
			@<Dimensions column@>;
			HTML::end_html_row(OUT);
		}
	HTML::end_html_table(OUT);
	HTML_CLOSE("p");

@<Dimensions column@> =
	text_stream *dims = Metadata::read_optional_textual(pack, I"^dimensions");
	if (Str::len(dims) > 0) {
		WRITE("%S", dims);
	} else {
		Localisation::italic(OUT, LD, I"Index.Elements.Ar.Dimensionless");
	}

@ This is simply a table of all the multiplications declared in the source
text, sorted into kind order of left and then right operand.

@<Index the table of multiplication rules@> =
	if (InterNodeList::array_len(inv->multiplication_rule_nodes) > 0) {
		HTML_OPEN("p");
		WRITE("This is how multiplication changes kinds:");
		HTML_CLOSE("p");
		HTML_OPEN("p");
		HTML::begin_plain_html_table(OUT);
		inter_package *pack;
		LOOP_OVER_INVENTORY_PACKAGES(pack, i, inv->multiplication_rule_nodes) {
			HTML::first_html_column(OUT, 0);
			IndexUtilities::link_package(OUT, pack);
			HTML::next_html_column(OUT, 0);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^left_operand"));
			HTML::begin_colour(OUT, I"808080");
			WRITE(" x ");
			HTML::end_colour(OUT);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^right_operand"));
			HTML::begin_colour(OUT, I"808080");
			WRITE(" = ");
			HTML::end_colour(OUT);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^result"));
			WRITE("&nbsp;&nbsp;&nbsp;&nbsp;");
			HTML::next_html_column(OUT, 0);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^left_operand_benchmark"));
			HTML::begin_colour(OUT, I"808080");
			WRITE(" x ");
			HTML::end_colour(OUT);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^right_operand_benchmark"));
			HTML::begin_colour(OUT, I"808080");
			WRITE(" = ");
			HTML::end_colour(OUT);
			WRITE("%S", Metadata::read_optional_textual(pack, I"^result_benchmark"));
			HTML::end_html_row(OUT);
		}
		HTML::end_html_table(OUT);
		HTML_CLOSE("p");
	}

@ =
void ArithmeticElement::column(OUTPUT_STREAM, text_stream *key, localisation_dictionary *LD) {
	TEMPORARY_TEXT(full)
	WRITE_TO(full, "Index.Elements.Ar.%S", key);
	Localisation::bold(OUT, LD, full);
	WRITE(" ");
	DISCARD_TEXT(full)
}
