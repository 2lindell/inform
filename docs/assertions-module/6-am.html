<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Adjective Meanings</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
MathJax = {
	tex: {
		inlineMath: '$', '$'], ['\\(', '\\)'
	},
	svg: {
		fontCache: 'global'
	}
};
</script>
<script type="text/javascript" id="MathJax-script" async
	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Preform-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../compiler.html">compiler tools</a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul><h2>Compiler Webs</h2><ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul><h2>Inbuild Modules</h2><ul>
<li><a href="../supervisor-module/index.html">supervisor</a></li>
</ul><h2>Inform7 Modules</h2><ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="index.html"><span class="selectedlink">assertions</span></a></li>
<li><a href="../values-module/index.html">values</a></li>
<li><a href="../knowledge-module/index.html">knowledge</a></li>
<li><a href="../imperative-module/index.html">imperative</a></li>
<li><a href="../runtime-module/index.html">runtime</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul><h2>Inter Modules</h2><ul>
<li><a href="../bytecode-module/index.html">bytecode</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul><h2>Services</h2><ul>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../calculus-module/index.html">calculus</a></li>
<li><a href="../html-module/index.html">html</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Adjective Meanings' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../compiler.html">Inform7</a></li><li><a href="index.html">assertions</a></li><li><a href="index.html#6">Chapter 6: Predicates</a></li><li><b>Adjective Meanings</b></li></ul></div>
<p class="purpose">One individual meaning which an adjective can have.</p>

<ul class="toc"><li><a href="6-am.html#SP5">&#167;5. Symbols</a></li><li><a href="6-am.html#SP8">&#167;8. Individual meanings</a></li><li><a href="6-am.html#SP10">&#167;10. The domain of validity</a></li><li><a href="6-am.html#SP13">&#167;13. Specifying the domain of a new AM</a></li><li><a href="6-am.html#SP17">&#167;17. Comparing domains of validity</a></li><li><a href="6-am.html#SP18">&#167;18. Testing and asserting in play</a></li><li><a href="6-am.html#SP24">&#167;24. Kinds of adjectives</a></li><li><a href="6-am.html#SP30">&#167;30. Parsing for adaptive text</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1.  </b>Each individual sense of an adjective has its own <span class="extract"><span class="extract-syntax">adjective_meaning</span></span>
structure, which we define next. It consists of some logistical data to keep
its place in the linked lists (see above), some data to specify its domain
(see below), some indexing data which is not very important, and then the
crucial part: its "detailed meaning".
</p>

<p class="commentary">The general model is that adjective meanings come in different "kinds",
for which specific code is scattered across Inform. In each case, the
<span class="extract"><span class="extract-syntax">detailed_meaning</span></span> points to an appropriate data structure, and specialised
routines are called to create and use the adjective.
</p>

<p class="commentary">We can also specify that the meaning implied by this pointer is to be
understood reversely: that the adjective is the negation of the one specified.
This enables "non-empty" for texts (say) to be defined identically with
"empty" for texts, but with the <span class="extract"><span class="extract-syntax">meaning_parity</span></span> flag set to <span class="extract"><span class="extract-syntax">FALSE</span></span>
rather than <span class="extract"><span class="extract-syntax">TRUE</span></span>.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">method_set</span><span class="plain-syntax"> *</span><span class="identifier-syntax">methods</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">parsing_priority</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax">;</span>

<span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::new_family</span><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">N</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">f</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">f</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">parsing_priority</span><span class="plain-syntax"> = </span><span class="identifier-syntax">N</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">f</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">methods</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Methods::new_set</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">f</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>The structure adjective_meaning_family is private to this section.</li></ul>
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">family</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">adjective_index_text</span><span class="plain-syntax">; </span><span class="comment-syntax"> text to use in the Phrasebook index</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">defined_at</span><span class="plain-syntax">; </span><span class="comment-syntax"> from what sentence this came (if it did)</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">owning_adjective</span><span class="plain-syntax">; </span><span class="comment-syntax"> of which this is a definition</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">next_meaning</span><span class="plain-syntax">; </span><span class="comment-syntax"> next in order of definition</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">next_sorted</span><span class="plain-syntax">; </span><span class="comment-syntax"> next in logically sorted order</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">domain_text</span><span class="plain-syntax">; </span><span class="comment-syntax"> domain to which defn applies</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">domain_infs</span><span class="plain-syntax">; </span><span class="comment-syntax"> what domain the defn applies to</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">setting_domain</span><span class="plain-syntax">; </span><span class="comment-syntax"> are we currently working this out?</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">domain_kind</span><span class="plain-syntax">; </span><span class="comment-syntax"> what kind of values</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">problems_thrown</span><span class="plain-syntax">; </span><span class="comment-syntax"> complaining about the domain of this adjective</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">meaning_parity</span><span class="plain-syntax">; </span><span class="comment-syntax"> meaning understood positively?</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am_negated_from</span><span class="plain-syntax">; </span><span class="comment-syntax"> if explicitly constructed as such</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">general_pointer</span><span class="plain-syntax"> </span><span class="identifier-syntax">detailed_meaning</span><span class="plain-syntax">; </span><span class="comment-syntax"> to the relevant structure</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">task_via_support_routine</span><span class="plain-syntax">[</span><span class="constant-syntax">NO_ADJECTIVE_TASKS</span><span class="plain-syntax"> + </span><span class="constant-syntax">1</span><span class="plain-syntax">];</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> </span><span class="identifier-syntax">i6s_to_transfer_to_SR</span><span class="plain-syntax">[</span><span class="constant-syntax">NO_ADJECTIVE_TASKS</span><span class="plain-syntax"> + </span><span class="constant-syntax">1</span><span class="plain-syntax">]; </span><span class="comment-syntax"> where </span><span class="extract"><span class="extract-syntax">TRUE</span></span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> </span><span class="identifier-syntax">i6s_for_runtime_task</span><span class="plain-syntax">[</span><span class="constant-syntax">NO_ADJECTIVE_TASKS</span><span class="plain-syntax"> + </span><span class="constant-syntax">1</span><span class="plain-syntax">]; </span><span class="comment-syntax"> where </span><span class="extract"><span class="extract-syntax">TRUE</span></span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">am_ready_flag</span><span class="plain-syntax">; </span><span class="comment-syntax"> optional flag to mark whether schemas prepared yet</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">defined_already</span><span class="plain-syntax">; </span><span class="comment-syntax"> temporary workspace used when compiling support routines</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>The structure adjective_meaning is accessed in 6/tap, 6/tcp, 6/aa and here.</li></ul>
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3.  </b>What are adjectives for? Since an adjective is a unary predicate, it can be
thought of as an assignment from its domain set to the set of two possibilities:
true, false. Thus one sense of "open" maps doors to true if they are currently
open, false if they are closed.
</p>

<p class="commentary">There are altogether five things we might want to do with an adjective:
</p>

<ul class="items"><li>(1) Test whether it is true at any given point during play.
</li><li>(2) Assert that it is true at the start of play.
</li><li>(3) Assert that it is false at the start of play.
</li><li>(4) Assert that it is now to be true from this point on during play.
</li><li>(5) Assert that it is now to be false from this point on during play.
</li></ul>
<p class="commentary">We do not need to test whether it is false, since we need only test whether
it is true and negate the result.
</p>

<p class="commentary">Adjectives for which all five of these operations can be carried out are
the exception rather than the rule. "Open" is an example:
</p>

<blockquote>
    <p>[1] if the marble door is open, ...</p>
</blockquote>

<blockquote>
    <p>[2] The marble door is open.</p>
</blockquote>

<blockquote>
    <p>[3] The marble door is not open.</p>
</blockquote>

<blockquote>
    <p>[4] now the marble door is open;</p>
</blockquote>

<blockquote>
    <p>[5] now the marble door is not open;</p>
</blockquote>

<p class="commentary">Every adjective in practice supports (1), testing for truth, but this is
not required by the code below. Many adjectives &mdash; properly speaking, many
senses of an adjective &mdash; only support testing: "empty" in the sense of
texts, for instance.
</p>

<p class="commentary">Of the five possibilities, (1), (4) and (5) happen at run-time. These are
called "tasks" and are identified by the following constants. While in
theory an adjective's handling code can compile anything it likes to carry
out these tasks, in practice most are defined by providing an I6 schema,
which is why the <span class="extract"><span class="extract-syntax">adjective_meaning</span></span> structure contains these &mdash; see below.
</p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="constant-syntax">NO_ADJECTIVE_TASKS</span><span class="plain-syntax"> </span><span class="constant-syntax">3</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">TEST_ADJECTIVE_TASK</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax"> </span><span class="comment-syntax"> test if currently true</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain-syntax"> </span><span class="constant-syntax">2</span><span class="plain-syntax"> </span><span class="comment-syntax"> assert now true</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain-syntax"> </span><span class="constant-syntax">3</span><span class="plain-syntax"> </span><span class="comment-syntax"> assert now false</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4.  </b>For indexing (only) we need to run through the definitions of a given
adjectival phrase in sorted order, so:
</p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">LOOP_OVER_SORTED_MEANINGS</span><span class="plain-syntax">(</span><span class="identifier-syntax">aph</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax"> = </span><a href="6-aa.html#SP7" class="function-link"><span class="function-syntax">AdjectiveAmbiguity::get_sorted_definition_list</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">aph</span><span class="plain-syntax">); </span><span class="identifier-syntax">am</span><span class="plain-syntax">; </span><span class="identifier-syntax">am</span><span class="plain-syntax">=</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_sorted</span><span class="plain-syntax">)</span>
</pre>
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5. Symbols. </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">adjective_compilation_data</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">inter_name</span><span class="plain-syntax"> *</span><span class="identifier-syntax">aph_iname</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">package_request</span><span class="plain-syntax"> *</span><span class="identifier-syntax">aph_package</span><span class="plain-syntax">;</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">adjective_compilation_data</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>The structure adjective_compilation_data is private to this section.</li></ul>
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6.  </b></p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="constant-syntax">ADJECTIVE_COMPILATION_LINGUISTICS_CALLBACK</span><span class="plain-syntax"> </span><a href="6-am.html#SP6" class="function-link"><span class="function-syntax">AdjectiveMeanings::initialise</span></a>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::initialise</span><span class="plain-syntax">(</span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">adj</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_compilation</span><span class="plain-syntax">.</span><span class="element-syntax">aph_package</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Hierarchy::package</span><span class="plain-syntax">(</span><span class="identifier-syntax">CompilationUnits::current</span><span class="plain-syntax">(), </span><span class="identifier-syntax">ADJECTIVES_HAP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_compilation</span><span class="plain-syntax">.</span><span class="element-syntax">aph_iname</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Hierarchy::make_iname_in</span><span class="plain-syntax">(</span><span class="identifier-syntax">ADJECTIVE_HL</span><span class="plain-syntax">, </span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_compilation</span><span class="plain-syntax">.</span><span class="element-syntax">aph_package</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">adjective_iname_holder</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">aph_held</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">task_code</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">weak_ID_of_domain</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">inter_name</span><span class="plain-syntax"> *</span><span class="identifier-syntax">iname_held</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">adjective_iname_holder</span><span class="plain-syntax">;</span>

<span class="identifier-syntax">inter_name</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::iname</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">AdjectiveMeanings::iname</span></span>:<br/><a href="6-am.html#SP20">&#167;20</a>, <a href="6-am.html#SP23_1">&#167;23.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">aph</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">task</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">weak_id</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_iname_holder</span><span class="plain-syntax"> *</span><span class="identifier-syntax">aih</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">aih</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_iname_holder</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">aih</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">aph_held</span><span class="plain-syntax"> == </span><span class="identifier-syntax">aph</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">aih</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_code</span><span class="plain-syntax"> == </span><span class="identifier-syntax">task</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">aih</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">weak_ID_of_domain</span><span class="plain-syntax"> == </span><span class="identifier-syntax">weak_id</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">aih</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">iname_held</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">aih</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_iname_holder</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">aih</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">aph_held</span><span class="plain-syntax"> = </span><span class="identifier-syntax">aph</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">aih</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_code</span><span class="plain-syntax"> = </span><span class="identifier-syntax">task</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">aih</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">weak_ID_of_domain</span><span class="plain-syntax"> = </span><span class="identifier-syntax">weak_id</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">package_request</span><span class="plain-syntax"> *</span><span class="identifier-syntax">PR</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Hierarchy::package_within</span><span class="plain-syntax">(</span><span class="identifier-syntax">ADJECTIVE_TASKS_HAP</span><span class="plain-syntax">, </span><span class="identifier-syntax">aph</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_compilation</span><span class="plain-syntax">.</span><span class="element-syntax">aph_package</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">aih</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">iname_held</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Hierarchy::make_iname_in</span><span class="plain-syntax">(</span><span class="identifier-syntax">TASK_FN_HL</span><span class="plain-syntax">, </span><span class="identifier-syntax">PR</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">aih</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">iname_held</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>The structure adjective_iname_holder is private to this section.</li></ul>
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7.  </b>Once declared, an AM stays with the same APH for the whole of Inform's run,
and it can only be declared once. So every AM belongs to one and only one
APH, which we can read off as follows:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::get_aph_from_am</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">owning_adjective</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8. Individual meanings. </b>So you want to define a new meaning for an adjective? Here's the procedure:
</p>

<ul class="items"><li>(1) Call <span class="extract"><span class="extract-syntax">AdjectiveMeanings::new</span></span> to create it. The <span class="extract"><span class="extract-syntax">form</span></span> should
be one of the <span class="extract"><span class="extract-syntax">*_KADJ</span></span> constants, and the <span class="extract"><span class="extract-syntax">details</span></span> should contain a pointer to
the data structure it uses. The word range is used for indexing only.
</li><li>(2) Call <span class="extract"><span class="extract-syntax">AdjectiveAmbiguity::add_meaning_to_adjective</span></span> to associate it with a given
adjective name, and thus have it added to the possible meanings list of the
appropriate APH.
</li><li>(3) Give it a domain of definition (see below).
</li><li>(4) Optionally, give it explicit I6 schemas for testing and asserting (see
below) &mdash; this makes coding what the adjective compiles to much easier.
</li></ul>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::new</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">family</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">general_pointer</span><span class="plain-syntax"> </span><span class="identifier-syntax">details</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax"> = </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">adjective_index_text</span><span class="plain-syntax"> = </span><span class="identifier-syntax">W</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">owning_adjective</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_meaning</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_sorted</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_text</span><span class="plain-syntax"> = </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_kind</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">setting_domain</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family</span><span class="plain-syntax"> = </span><span class="identifier-syntax">family</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">detailed_meaning</span><span class="plain-syntax"> = </span><span class="identifier-syntax">details</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_already</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">problems_thrown</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">meaning_parity</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">am_ready_flag</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">=1; </span><span class="identifier-syntax">i</span><span class="plain-syntax">&lt;=</span><span class="constant-syntax">NO_ADJECTIVE_TASKS</span><span class="plain-syntax">; </span><span class="identifier-syntax">i</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_via_support_routine</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">] = </span><span class="identifier-syntax">NOT_APPLICABLE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Calculus::Schemas::modify</span><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">i6s_for_runtime_task</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">]), </span><span class="string-syntax">""</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Calculus::Schemas::modify</span><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">i6s_to_transfer_to_SR</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">]), </span><span class="string-syntax">""</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">am_negated_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">am</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9.  </b>Negating an AM.
If you want to define an adjective as the logical negation of an existing one,
take any AM which has been through stages (1) to (4) and then apply
<span class="extract"><span class="extract-syntax">AdjectiveMeanings::negate</span></span> to create a new AM. Then use
<span class="extract"><span class="extract-syntax">AdjectiveAmbiguity::add_meaning_to_adjective</span></span> to associate this with a (presumably
different) name, but there's no need to specify its I6 schemas or its domain &mdash;
those are inherited.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::negate</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">neg</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax"> = </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">adjective_index_text</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">adjective_index_text</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">owning_adjective</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_meaning</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next_sorted</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_text</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_text</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax">; </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_kind</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_kind</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">detailed_meaning</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">detailed_meaning</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_already</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">problems_thrown</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">am_ready_flag</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">meaning_parity</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">meaning_parity</span><span class="plain-syntax">)?</span><span class="identifier-syntax">FALSE:TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">=1; </span><span class="identifier-syntax">i</span><span class="plain-syntax">&lt;=</span><span class="constant-syntax">NO_ADJECTIVE_TASKS</span><span class="plain-syntax">; </span><span class="identifier-syntax">i</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">j</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">i</span><span class="plain-syntax"> == </span><span class="constant-syntax">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain-syntax">) </span><span class="identifier-syntax">j</span><span class="plain-syntax"> = </span><span class="constant-syntax">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">i</span><span class="plain-syntax"> == </span><span class="constant-syntax">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain-syntax">) </span><span class="identifier-syntax">j</span><span class="plain-syntax"> = </span><span class="constant-syntax">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_via_support_routine</span><span class="plain-syntax">[</span><span class="identifier-syntax">j</span><span class="plain-syntax">] = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_via_support_routine</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">];</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">i6s_for_runtime_task</span><span class="plain-syntax">[</span><span class="identifier-syntax">j</span><span class="plain-syntax">] = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">i6s_for_runtime_task</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">];</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Calculus::Schemas::modify</span><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">i6s_to_transfer_to_SR</span><span class="plain-syntax">[</span><span class="identifier-syntax">j</span><span class="plain-syntax">]), </span><span class="string-syntax">""</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">am_negated_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">neg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::get_form</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10. The domain of validity. </b>Every AM has a clearly defined range of values or objects to which it applies.
For example, "odd" for numbers has <span class="extract"><span class="extract-syntax">domain_infs</span></span> equal to "number",
while the sense of "odd" created by
</p>

<blockquote>
    <p>Mrs Elspeth Spong can be odd, eccentric or mildly dotty.</p>
</blockquote>

<p class="commentary">would have <span class="extract"><span class="extract-syntax">domain_infs</span></span> equal to Mrs Spong herself.
</p>

<p class="commentary firstcommentary"><a id="SP11" class="paragraph-anchor"></a><b>&#167;11.  </b>In comparing and testing domains, we use two different levels of matching:
weak and strong.
</p>

<p class="commentary">Strong checking makes an exact match, but weak checking blurs the definitions
so that two domains are counted as equal if they are close enough that run-time
type checking can be used to tell them apart.
</p>

<p class="commentary">In general, any two base kinds are different even in weak checking &mdash; "scene"
and "number", for instance. On the other hand, "list of scenes" weakly
matches "list of numbers", and "container" weakly matches "animal".
As this last example shows, two domains can be completely disjoint and still
make a weak match.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::domain_weak_match</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">AdjectiveMeanings::domain_weak_match</span></span>:<br/>Adjective Ambiguity - <a href="6-aa.html#SP8">&#167;8</a>, <a href="6-aa.html#SP9">&#167;9</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K1</span><span class="plain-syntax">, </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K2</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">RTKinds::weak_id</span><span class="plain-syntax">(</span><span class="identifier-syntax">K1</span><span class="plain-syntax">) == </span><span class="identifier-syntax">RTKinds::weak_id</span><span class="plain-syntax">(</span><span class="identifier-syntax">K2</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP12" class="paragraph-anchor"></a><b>&#167;12.  </b>Whereas the following makes a strict check of whether a given subject is
within the domain of an adjective meaning.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::domain_subj_compare</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">AdjectiveMeanings::domain_subj_compare</span></span>:<br/>Adjective Ambiguity - <a href="6-aa.html#SP8">&#167;8</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax"> = </span><span class="identifier-syntax">InstanceSubjects::to_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">infs</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">I</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax"> == </span><span class="identifier-syntax">KindSubjects::from_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_object</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">while</span><span class="plain-syntax"> (</span><span class="identifier-syntax">infs</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax"> == </span><span class="identifier-syntax">infs</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">infs</span><span class="plain-syntax"> = </span><span class="identifier-syntax">InferenceSubjects::narrowest_broader_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">infs</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP13" class="paragraph-anchor"></a><b>&#167;13. Specifying the domain of a new AM. </b>In principle the domain should be set as soon as the AM is created, but in
practice some AMs &mdash; those coming from properties &mdash; might need to be
created very early in Inform's run, at a time when objects and kinds of
object do not exist. For those cases, an alternative is to give a word range &mdash;
"a number", say, or "a container" &mdash; and if necessary this is left
until later on in the run to parse. (For "a number", it wouldn't be
necessary; for "a container", it would.)
</p>

<p class="commentary">The inclusion of <span class="extract"><span class="extract-syntax">domain_kind</span></span> may seem redundant here; surely the INFS is
sufficient? But it isn't, because "list of numbers" &mdash; say &mdash; has the
same INFS as "list of texts" or a list of anything else, so that if we
recorded the domain only as an INFS then we couldn't define adjectives
over specific constructed kinds.
</p>

<p class="commentary">To set the domain, call exactly one of the following three routines:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::set_domain_text</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_kind</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_text</span><span class="plain-syntax"> = </span><span class="identifier-syntax">W</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><a href="6-am.html#SP16" class="function-link"><span class="function-syntax">AdjectiveMeanings::set_definition_domain</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::set_domain_from_instance</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">I</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax"> = </span><span class="identifier-syntax">KindSubjects::from_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_object</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_kind</span><span class="plain-syntax"> = </span><span class="identifier-syntax">K_object</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_kind</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Kinds::weaken</span><span class="plain-syntax">(</span><span class="identifier-syntax">Instances::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="identifier-syntax">K_object</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_text</span><span class="plain-syntax"> = </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP14" class="paragraph-anchor"></a><b>&#167;14.  </b>Note that we round up the kind to "object" if it's more specialised than that
&mdash; say, if it's "door" &mdash; because run-time rather than compile-time
disambiguation is used when applying adjectives to objects.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::set_domain_from_kind</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">K</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">Kinds::Behaviour::is_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">))) </span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">K_object</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax"> = </span><span class="identifier-syntax">KindSubjects::from_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_kind</span><span class="plain-syntax"> = </span><span class="identifier-syntax">K</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_text</span><span class="plain-syntax"> = </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP15" class="paragraph-anchor"></a><b>&#167;15.  </b>And we can read the main domain thus:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::get_domain</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">AdjectiveMeanings::get_domain</span></span>:<br/><a href="6-am.html#SP19">&#167;19</a>, <a href="6-am.html#SP20">&#167;20</a>, <a href="6-am.html#SP23_1">&#167;23.1</a><br/>The Adjectival Predicates - <a href="6-tap.html#SP2">&#167;2</a><br/>Adjective Ambiguity - <a href="6-aa.html#SP4">&#167;4</a>, <a href="6-aa.html#SP8">&#167;8</a>, <a href="6-aa.html#SP9">&#167;9</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_kind</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::get_domain_forcing</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><a href="6-am.html#SP16" class="function-link"><span class="function-syntax">AdjectiveMeanings::set_definition_domain</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_kind</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP16" class="paragraph-anchor"></a><b>&#167;16.  </b>In the case where the domain is declared as a word range, the following
routine eventually converts it to the correct form. In effect, this is a
lazy evaluation trick &mdash; the routine is called just before the domain is
actually needed.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::set_definition_domain</span><button class="popup" onclick="togglePopup('usagePopup5')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup5">Usage of <span class="code-font"><span class="function-syntax">AdjectiveMeanings::set_definition_domain</span></span>:<br/><a href="6-am.html#SP13">&#167;13</a>, <a href="6-am.html#SP15">&#167;15</a><br/>Adjective Ambiguity - <a href="6-aa.html#SP4">&#167;4</a>, <a href="6-aa.html#SP7">&#167;7</a>, <a href="6-aa.html#SP9">&#167;9</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">early</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::empty</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_text</span><span class="plain-syntax">)) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"undeclared domain kind for AM"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">supplied</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;s-type-expression&gt;(am-&gt;</span><span class="element-syntax">domain_text</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">supplied</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">supplied</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="6-am.html#SP16_1" class="named-paragraph-link"><span class="named-paragraph">Reject domain of adjective</span><span class="named-paragraph-number">16.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="6-am.html#SP16_4" class="named-paragraph-link"><span class="named-paragraph">Reject domain of adjective unless a kind of value or description of objects</span><span class="named-paragraph-number">16.4</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Specifications::is_condition</span><span class="plain-syntax">(</span><span class="identifier-syntax">supplied</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Specifications::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">supplied</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Specifications::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">supplied</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">K_object</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="6-am.html#SP16_5" class="named-paragraph-link"><span class="named-paragraph">Reject domain of adjective if it is a set of objects which may vary in play</span><span class="named-paragraph-number">16.5</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Rvalues::is_rvalue</span><span class="plain-syntax">(</span><span class="identifier-syntax">supplied</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Rvalues::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">supplied</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">K</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="6-am.html#SP16_1" class="named-paragraph-link"><span class="named-paragraph">Reject domain of adjective</span><span class="named-paragraph-number">16.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::is_kind_of_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">)) </span><span class="named-paragraph-container code-font"><a href="6-am.html#SP16_2" class="named-paragraph-link"><span class="named-paragraph">Reject domain as vague</span><span class="named-paragraph-number">16.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">K_understanding</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Kinds::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_understanding</span><span class="plain-syntax">))) </span><span class="named-paragraph-container code-font"><a href="6-am.html#SP16_3" class="named-paragraph-link"><span class="named-paragraph">Reject domain as topic</span><span class="named-paragraph-number">16.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="6-am.html#SP16_6" class="named-paragraph-link"><span class="named-paragraph">Set the domain INFS as needed</span><span class="named-paragraph-number">16.6</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP16_1" class="paragraph-anchor"></a><b>&#167;16.1.  </b>Note that we throw only one problem message per AM, as otherwise duplication
can't be avoided.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Reject domain of adjective</span><span class="named-paragraph-number">16.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">early</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">problems_thrown</span><span class="plain-syntax">++ &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::adjective_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_AdjDomainUnknown</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">adjective_index_text</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_text</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"this isn't a thing, a kind of thing or a kind of value"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"and indeed doesn't have any meaning I can make sense of."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="6-am.html#SP16">&#167;16</a> (twice).</li></ul>
<p class="commentary firstcommentary"><a id="SP16_2" class="paragraph-anchor"></a><b>&#167;16.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Reject domain as vague</span><span class="named-paragraph-number">16.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">early</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">problems_thrown</span><span class="plain-syntax">++ &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::adjective_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_AdjDomainVague</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">adjective_index_text</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_text</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"this isn't allowed as the domain of a definition"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"since it potentially describes many different kinds, not just one."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="6-am.html#SP16">&#167;16</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP16_3" class="paragraph-anchor"></a><b>&#167;16.3.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Reject domain as topic</span><span class="named-paragraph-number">16.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">early</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">problems_thrown</span><span class="plain-syntax">++ &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::adjective_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_AdjDomainTopic</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">adjective_index_text</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_text</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"this isn't allowed as the domain of a definition"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"because 'topic' doesn't behave the way other kinds of value do when "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"it comes to making comparisons."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="6-am.html#SP16">&#167;16</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP16_4" class="paragraph-anchor"></a><b>&#167;16.4.  </b>Similarly:
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Reject domain of adjective unless a kind of value or description of objects</span><span class="named-paragraph-number">16.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">supplied</span><span class="plain-syntax">, </span><span class="identifier-syntax">CONSTANT_NT</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Specifications::is_description_like</span><span class="plain-syntax">(</span><span class="identifier-syntax">supplied</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Rvalues::to_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">supplied</span><span class="plain-syntax">) == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">early</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">problems_thrown</span><span class="plain-syntax">++ &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::adjective_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_AdjDomainSurreal</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">adjective_index_text</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_text</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"this isn't allowed as the domain of a definition"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"since adjectives like this can be applied only to specific things, "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"kinds of things or kinds of values: so 'Definition: a door is ajar "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"if...' is fine, because a door is a kind of thing, and 'Definition: "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"a number is prime if ...' is fine too, but 'Definition: 5 is prime "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"if ...' is not allowed."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="6-am.html#SP16">&#167;16</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP16_5" class="paragraph-anchor"></a><b>&#167;16.5.  </b>And a final possible objection:
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Reject domain of adjective if it is a set of objects which may vary in play</span><span class="named-paragraph-number">16.5</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Descriptions::is_qualified</span><span class="plain-syntax">(</span><span class="identifier-syntax">supplied</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">problems_thrown</span><span class="plain-syntax">++ &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::adjective_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_AdjDomainSlippery</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">adjective_index_text</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_text</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"this is slippery"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"because it can change during play. Definitions can only be "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"made in cases where it's clear for any given value or object "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"what definition will apply. For instance, 'Definition: a "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"door is shiny if ...' is fine, but 'Definition: an open "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"door is shiny if ...' is not allowed - Inform wouldn't know "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"whether or not to apply it to the Big Blue Door (say), since "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"it would only apply some of the time."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="6-am.html#SP16">&#167;16</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP16_6" class="paragraph-anchor"></a><b>&#167;16.6.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Set the domain INFS as needed</span><span class="named-paragraph-number">16.6</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Rvalues::to_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">supplied</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">I</span><span class="plain-syntax">) </span><span class="identifier-syntax">supplied</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Rvalues::from_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::is_subkind_of_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">supplied</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Specifications::from_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax"> = </span><span class="identifier-syntax">InferenceSubjects::from_specification</span><span class="plain-syntax">(</span><span class="identifier-syntax">supplied</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_kind</span><span class="plain-syntax"> = </span><span class="identifier-syntax">K</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="6-am.html#SP16">&#167;16</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP17" class="paragraph-anchor"></a><b>&#167;17. Comparing domains of validity. </b>In order to sort AMs into logical precedence order, we rely on the
following routine, which like <span class="extract"><span class="extract-syntax">strcmp</span></span> returns a positive number to favour
the first term, a negative to favour the second, and zero if they are
equally good. Note that zero is only in fact returned when the two AMs
compared are one and the same &mdash; we want to ensure that there is one
and only one possible sorted state for any given list of AMs.
</p>

<p class="commentary">Suppose the adjectives \(A_1\) and \(A_2\) have domain sets \(D_1\) and \(D_2\). Then:
</p>

<ul class="items"><li>(i) If \(D_1\subseteq D_2\) and \(D_1\neq D_2\), then \(A_1\) precedes \(A_2\).
</li><li>(ii) If \(D_2\subseteq D_1\) and \(D_2\neq D_1\), then \(A_2\) precedes \(A_1\).
</li><li>(iii) If \(D_1 = D_2\) or if \(D_1\cap D_2 = \emptyset\) then we have to be
pragmatic: see below.
</li></ul>
<p class="commentary">Those are the only possibilities; the range of possible domains is set up
so that there can never be an interesting Venn diagram of overlaps
between them.
</p>

<p class="commentary">Unlike our weak domain tests above, this is a strict test.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::compare</span><button class="popup" onclick="togglePopup('usagePopup6')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup6">Usage of <span class="code-font"><span class="function-syntax">AdjectiveMeanings::compare</span></span>:<br/>Adjective Ambiguity - <a href="6-aa.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am1</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am2</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am1</span><span class="plain-syntax"> == </span><span class="identifier-syntax">am2</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">am2</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">am2</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> -1;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">InferenceSubjects::is_strictly_within</span><span class="plain-syntax">(</span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax">, </span><span class="identifier-syntax">am2</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">InferenceSubjects::is_strictly_within</span><span class="plain-syntax">(</span><span class="identifier-syntax">am2</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax">, </span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> -1;</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">KindSubjects::to_nonobject_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">KindSubjects::to_nonobject_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">am2</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">K1</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">K2</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">c1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Kinds::compatible</span><span class="plain-syntax">(</span><span class="identifier-syntax">K1</span><span class="plain-syntax">, </span><span class="identifier-syntax">K2</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">c2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Kinds::compatible</span><span class="plain-syntax">(</span><span class="identifier-syntax">K2</span><span class="plain-syntax">, </span><span class="identifier-syntax">K1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">c1</span><span class="plain-syntax"> == </span><span class="identifier-syntax">ALWAYS_MATCH</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">c2</span><span class="plain-syntax"> != </span><span class="identifier-syntax">ALWAYS_MATCH</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">c1</span><span class="plain-syntax"> != </span><span class="identifier-syntax">ALWAYS_MATCH</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">c2</span><span class="plain-syntax"> == </span><span class="identifier-syntax">ALWAYS_MATCH</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> -1;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax"> == </span><span class="identifier-syntax">am2</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">domain_infs</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="6-am.html#SP17_1" class="named-paragraph-link"><span class="named-paragraph">Worry about definitions of the same adjective on the same domain</span><span class="named-paragraph-number">17.1</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">am2</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">allocation_id</span><span class="plain-syntax"> - </span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">allocation_id</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP17_1" class="paragraph-anchor"></a><b>&#167;17.1.  </b>In general, it's an error to define the same adjective on the same domain
twice, except for a redefinition in the source text of a definition in an
extension. (We exclude enumerative adjectives because they are defined
internally by a method which involves occasional duplication but where
the duplicates are all mutually consistent; these do not arise from the
author's source text.)
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Worry about definitions of the same adjective on the same domain</span><span class="named-paragraph-number">17.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax">))) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">am2</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax">))) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">InstanceAdjectives::is_enumerative</span><span class="plain-syntax">(</span><span class="identifier-syntax">am1</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">InstanceAdjectives::is_enumerative</span><span class="plain-syntax">(</span><span class="identifier-syntax">am2</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inform_extension</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ef1</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Extensions::corresponding_to</span><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Lexer::file_of_origin</span><span class="plain-syntax">(</span><span class="identifier-syntax">Wordings::first_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax">))));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inform_extension</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ef2</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Extensions::corresponding_to</span><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Lexer::file_of_origin</span><span class="plain-syntax">(</span><span class="identifier-syntax">Wordings::first_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">am2</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax">))));</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">ef1</span><span class="plain-syntax"> == </span><span class="identifier-syntax">ef2</span><span class="plain-syntax">) || ((</span><span class="identifier-syntax">ef1</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">ef2</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Problems::quote_wording_as_source</span><span class="plain-syntax">(1, </span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">adjective_index_text</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Problems::quote_wording_as_source</span><span class="plain-syntax">(2, </span><span class="identifier-syntax">am2</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">adjective_index_text</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">StandardProblems::handmade_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_AdjDomainDuplicated</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Problems::issue_problem_segment</span><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="string-syntax">"The definitions %1 and %2 both try to cover the same situation: "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"the same adjective applied to the exact same range. %P"</span>
<span class="plain-syntax">                </span><span class="string-syntax">"It's okay to override a definition in an extension with another "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"one in the main source text, but it's not okay to define the same "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"adjective twice over the same domain in the same file."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Problems::issue_problem_end</span><span class="plain-syntax">();</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">ef1</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">ef2</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> -1;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="6-am.html#SP17">&#167;17</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP18" class="paragraph-anchor"></a><b>&#167;18. Testing and asserting in play. </b>Now for testing, making true and making false in play. We won't be there when
the story file is played, of course, so what we have to do is to compile code
to perform the test or force the state.
</p>

<p class="commentary">In fact what we do is to supply an I6 schema, which for this purpose is
simply the text of I6 code in which the escape <span class="extract"><span class="extract-syntax">*1</span></span> represents the value
to which the adjective is applied. In the example of "open" for containers,
we might choose:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    if the sack is open, ...  --&gt;   (Adj_53_t1_v61(*1))</span>
<span class="plain-syntax">    now the sack is open; ...  --&gt;   Adj_53_t2_v61(*1)</span>
<span class="plain-syntax">    now the sack is not open; ...  --&gt;   Adj_53_t3_v61(*1)</span>
</pre>
<p class="commentary">These schemas call an I6 routine called a "support routine". The names
here are schematic: "open" on this run was APH number 53, the run-time
tasks to perform were task 1, task 2 and task 3, and the sense of the
adjective was the one applying to domain 61 &mdash; which in this example run
was the weak ID of "object". In other words, these are routines to "test
open in the sense of objects", "now open in the sense of objects", and
"now not open in the sense of objects".
</p>

<p class="commentary">If we make a choice like that, then we say that the task is provided
"via a support routine". We need not do so: for instance,
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    if the Entire Game is happening, ...  --&gt;  (scene_status-&gt;(*1 - 1)==1)</span>
</pre>
<p class="commentary">is an example where the sense of "happening" for scenes can be tested
directly using a schema, without calling a support routine. And clearly
support routines only put off the problem, because we will also have to
compile the routine itself. So why use them? The answer is that in
complicated situations where run-time type checking is needed, they
avoid duplication of code, and can make repeated use of the <span class="extract"><span class="extract-syntax">*1</span></span> value
without repeating any side-effects produced by the calculation of this
value. They also make the code simpler for human eyes to read.
</p>

<p class="commentary firstcommentary"><a id="SP19" class="paragraph-anchor"></a><b>&#167;19.  </b>When an AM has been declared, the provider can choose to set an I6
schema for it, for any of the tasks, immediately; or can wait and do it
later; or can choose not to do it, and instead provide code which
generates a suitable schema on the fly. If at whatever stage the
provider does set an I6 schema for a task, it should call the following.
</p>

<p class="commentary">Note that any AM working on objects always has to go via a support
routine &mdash; this is because, thanks to weak domain-checking, there may
be run-time type-checking code to apply. In other cases, the provider
can choose to go via a support routine or not.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::set_i6_schema</span><button class="popup" onclick="togglePopup('usagePopup7')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup7">Usage of <span class="code-font"><span class="function-syntax">AdjectiveMeanings::set_i6_schema</span></span>:<br/><a href="6-am.html#SP21">&#167;21</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">via_support</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><a href="6-am.html#SP15" class="function-link"><span class="function-syntax">AdjectiveMeanings::get_domain</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">K</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">K_object</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::is_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">)) </span><span class="identifier-syntax">via_support</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_via_support_routine</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">] = </span><span class="identifier-syntax">via_support</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> &amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">i6s_for_runtime_task</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">]);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP20" class="paragraph-anchor"></a><b>&#167;20.  </b>The following is needed when making sense of the I6-to-I7 escape sequence
<span class="extract"><span class="extract-syntax">(+ adj +)</span></span>, where <span class="extract"><span class="extract-syntax">adj</span></span> is the name of an adjective. Since I6 is typeless,
there's no good way to choose which sense of the adjective is meant, so we
don't know which routine to expand out. The convention is: a meaning for
objects, if there is one; otherwise the first-declared meaning.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::write_adjective_test_routine</span><span class="plain-syntax">(</span><span class="identifier-syntax">value_holster</span><span class="plain-syntax"> *</span><span class="identifier-syntax">VH</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">aph</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sch</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">weak_id</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RTKinds::weak_id</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_object</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">sch</span><span class="plain-syntax"> = </span><a href="6-aa.html#SP9" class="function-link"><span class="function-syntax">AdjectiveAmbiguity::schema_for_task</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">aph</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="constant-syntax">TEST_ADJECTIVE_TASK</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">sch</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax"> = </span><a href="6-aa.html#SP6" class="function-link"><span class="function-syntax">AdjectiveAmbiguity::first_meaning</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">aph</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am_kind</span><span class="plain-syntax"> = </span><a href="6-am.html#SP15" class="function-link"><span class="function-syntax">AdjectiveMeanings::get_domain</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am_kind</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">weak_id</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RTKinds::weak_id</span><span class="plain-syntax">(</span><span class="identifier-syntax">am_kind</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Produce::val_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><a href="6-am.html#SP6" class="function-link"><span class="function-syntax">AdjectiveMeanings::iname</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">aph</span><span class="plain-syntax">, </span><span class="constant-syntax">TEST_ADJECTIVE_TASK</span><span class="plain-syntax">, </span><span class="identifier-syntax">weak_id</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP21" class="paragraph-anchor"></a><b>&#167;21.  </b>The following instructs an AM to use a support routine to handle a given
task.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::pass_task_to_support_routine</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><a href="6-am.html#SP19" class="function-link"><span class="function-syntax">AdjectiveMeanings::set_i6_schema</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP22" class="paragraph-anchor"></a><b>&#167;22.  </b>Some kinds of adjective find it useful to do some preparation work just
before first compilation, but only once. For those, the ready flag is available:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::get_ready_flag</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">am_ready_flag</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::set_ready_flag</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">am_ready_flag</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP23" class="paragraph-anchor"></a><b>&#167;23.  </b>Note that the <span class="extract"><span class="extract-syntax">task_via_support_routine</span></span> values are not flags: they can be
<span class="extract"><span class="extract-syntax">TRUE</span></span> (allowed, done via support routine), <span class="extract"><span class="extract-syntax">FALSE</span></span> (allowed, done directly)
or <span class="extract"><span class="extract-syntax">NOT_APPLICABLE</span></span> (the task certainly can't be done). If none of the
applicable meanings for the adjective are able to perform the task at
run-time, we return <span class="extract"><span class="extract-syntax">NULL</span></span> as our schema, and the code-generator will use
that to issue a suitable problem message.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::schema_for_task</span><button class="popup" onclick="togglePopup('usagePopup8')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup8">Usage of <span class="code-font"><span class="function-syntax">AdjectiveMeanings::schema_for_task</span></span>:<br/>Adjective Ambiguity - <a href="6-aa.html#SP9">&#167;9</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><a href="6-am.html#SP26" class="function-link"><span class="function-syntax">AdjectiveMeanings::compiling_soon</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">T</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_via_support_routine</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">]) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE:</span><span class="plain-syntax"> </span><span class="reserved-syntax">return</span><span class="plain-syntax"> &amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">i6s_for_runtime_task</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">]);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Calculus::Schemas::empty</span><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">i6s_to_transfer_to_SR</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">])))</span>
<span class="plain-syntax">                </span><span class="named-paragraph-container code-font"><a href="6-am.html#SP23_1" class="named-paragraph-link"><span class="named-paragraph">Construct a schema for this adjective, using the standard routine naming</span><span class="named-paragraph-number">23.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> &amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">i6s_to_transfer_to_SR</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">]);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP23_1" class="paragraph-anchor"></a><b>&#167;23.1.  </b>Where the following is complicated by the need to respect negations; it may
be that the original adjective has a support routine defined, but that the
negation does not, and so must use those of the original.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Construct a schema for this adjective, using the standard routine naming</span><span class="named-paragraph-number">23.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">task</span><span class="plain-syntax"> = </span><span class="identifier-syntax">T</span><span class="plain-syntax">; </span><span class="reserved-syntax">char</span><span class="plain-syntax"> *</span><span class="identifier-syntax">negation_operator</span><span class="plain-syntax"> = </span><span class="string-syntax">""</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">use_adj</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">owning_adjective</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">am_negated_from</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">use_adj</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">am_negated_from</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">owning_adjective</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="identifier-syntax">T</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">TEST_ADJECTIVE_TASK:</span><span class="plain-syntax"> </span><span class="identifier-syntax">negation_operator</span><span class="plain-syntax"> = </span><span class="string-syntax">"~~"</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">NOW_ADJECTIVE_TRUE_TASK:</span><span class="plain-syntax"> </span><span class="identifier-syntax">task</span><span class="plain-syntax"> = </span><span class="constant-syntax">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">NOW_ADJECTIVE_FALSE_TASK:</span><span class="plain-syntax"> </span><span class="identifier-syntax">task</span><span class="plain-syntax"> = </span><span class="constant-syntax">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inter_name</span><span class="plain-syntax"> *</span><span class="identifier-syntax">iname</span><span class="plain-syntax"> = </span><a href="6-am.html#SP6" class="function-link"><span class="function-syntax">AdjectiveMeanings::iname</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">use_adj</span><span class="plain-syntax">, </span><span class="identifier-syntax">task</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">RTKinds::weak_id</span><span class="plain-syntax">(</span><a href="6-am.html#SP15" class="function-link"><span class="function-syntax">AdjectiveMeanings::get_domain</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">)));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Calculus::Schemas::modify</span><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">i6s_to_transfer_to_SR</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">]), </span><span class="string-syntax">"*=-(%s%n(*1))"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">negation_operator</span><span class="plain-syntax">, </span><span class="identifier-syntax">iname</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="6-am.html#SP23">&#167;23</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP24" class="paragraph-anchor"></a><b>&#167;24. Kinds of adjectives. </b>This is where <span class="extract"><span class="extract-syntax">inweb</span></span>'s use of C rather than <span class="extract"><span class="extract-syntax">C++</span></span> or Python as a base
language becomes a little embarrassing: we really want to have seven or
eight subclasses of an "adjective" class, and provide a group of methods.
Instead we simulate this with the following clumsy code. (More elegant
code using pointers to functions would trip up <span class="extract"><span class="extract-syntax">inweb</span></span>'s structure-element
usage checking.)
</p>

<p class="commentary">To define a new kind of adjective, first allocate it a new <span class="extract"><span class="extract-syntax">*_KADJ</span></span>
constant (see above). Then declare functions to handle the following
methods.
</p>

<p class="commentary firstcommentary"><a id="SP25" class="paragraph-anchor"></a><b>&#167;25.  </b>1. <span class="extract"><span class="extract-syntax">*_KADJ_parse</span></span>. This enables the kind of adjective to claim a definition
which the user has explicitly written, like so:
</p>

<blockquote>
    <p>Definition: A ... (called ...) is ... if ...</p>
</blockquote>

<p class="commentary">In place of the ellipses are the adjective name, domain name, condition
text and (optionally) also the calling name. The routine should return a
pointer to the AM it creates, if it does want to claim the definition;
and <span class="extract"><span class="extract-syntax">NULL</span></span> if it doesn't want it. <span class="extract"><span class="extract-syntax">sense</span></span> is either \(1\), meaning that
"if" was used (the condition has positive sense); or \(-1\), meaning
that it was "unless" (a negative sense); or \(0\), meaning that instead
of a condition, a rule was supplied. (Most kinds of adjective will only
claim if the sense is \(1\); some never claim at all.)
</p>

<pre class="definitions code-font"><span class="definition-keyword">enum</span> <span class="constant-syntax">PARSE_ADJM_MTID</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">INT_METHOD_TYPE</span><span class="plain-syntax">(</span><span class="constant-syntax">PARSE_ADJM_MTID</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">f</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> **</span><span class="identifier-syntax">result</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">q</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">sense</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">AW</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">DNW</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">CONW</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">CALLW</span><span class="plain-syntax">)</span>

<span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::parse</span><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">q</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">sense</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">AW</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">DNW</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">CONW</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">CALLW</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">priority</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">; </span><span class="identifier-syntax">priority</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">10</span><span class="plain-syntax">; </span><span class="identifier-syntax">priority</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">f</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">f</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">f</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">parsing_priority</span><span class="plain-syntax"> == </span><span class="identifier-syntax">priority</span><span class="plain-syntax">)</span>
<span class="plain-syntax">                </span><span class="named-paragraph-container code-font"><a href="6-am.html#SP25_1" class="named-paragraph-link"><span class="named-paragraph">Try the f family</span><span class="named-paragraph-number">25.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP25_1" class="paragraph-anchor"></a><b>&#167;25.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Try the f family</span><span class="named-paragraph-number">25.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">rv</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">INT_METHOD_CALL</span><span class="plain-syntax">(</span><span class="identifier-syntax">rv</span><span class="plain-syntax">, </span><span class="identifier-syntax">f</span><span class="plain-syntax">, </span><span class="constant-syntax">PARSE_ADJM_MTID</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">q</span><span class="plain-syntax">, </span><span class="identifier-syntax">sense</span><span class="plain-syntax">, </span><span class="identifier-syntax">AW</span><span class="plain-syntax">, </span><span class="identifier-syntax">DNW</span><span class="plain-syntax">, </span><span class="identifier-syntax">CONW</span><span class="plain-syntax">, </span><span class="identifier-syntax">CALLW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">rv</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">am</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="6-am.html#SP25">&#167;25</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP26" class="paragraph-anchor"></a><b>&#167;26.  </b>2. <span class="extract"><span class="extract-syntax">*_KADJ_compiling_soon</span></span>. This warns the adjective that it will shortly be
needed in compilation, that is, that code will soon be compiled which uses it.
This advance warning is an opportunity to compile a schema for the adjective
at the last minute, but there is no obligation. There is also no return value.
</p>

<pre class="definitions code-font"><span class="definition-keyword">enum</span> <span class="constant-syntax">COMPILING_SOON_ADJM_MTID</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">VOID_METHOD_TYPE</span><span class="plain-syntax">(</span><span class="constant-syntax">COMPILING_SOON_ADJM_MTID</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">f</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">)</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::compiling_soon</span><button class="popup" onclick="togglePopup('usagePopup9')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup9">Usage of <span class="code-font"><span class="function-syntax">AdjectiveMeanings::compiling_soon</span></span>:<br/><a href="6-am.html#SP23">&#167;23</a>, <a href="6-am.html#SP27">&#167;27</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">VOID_METHOD_CALL</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family</span><span class="plain-syntax">, </span><span class="constant-syntax">COMPILING_SOON_ADJM_MTID</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">T</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP27" class="paragraph-anchor"></a><b>&#167;27.  </b>3. <span class="extract"><span class="extract-syntax">*_KADJ_compile</span></span>. We should now either compile code which, in the
given stack frame and writing code to the given file handle, carries out the
given task for the adjective, and return <span class="extract"><span class="extract-syntax">TRUE</span></span>; or return <span class="extract"><span class="extract-syntax">FALSE</span></span> to
tell Inform that the task is impossible.
</p>

<p class="commentary">Note that if an adjective has defined a schema to handle the task, then its
<span class="extract"><span class="extract-syntax">*_KADJ_compile</span></span> is not needed and not consulted.
</p>

<pre class="definitions code-font"><span class="definition-keyword">enum</span> <span class="constant-syntax">COMPILE_ADJM_MTID</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::emit_meaning</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="identifier-syntax">ph_stack_frame</span><span class="plain-syntax"> *</span><span class="identifier-syntax">phsf</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="6-am.html#SP27" class="function-link"><span class="function-syntax">AdjectiveMeanings::compile_inner</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">phsf</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::compilation_possible</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="6-am.html#SP27" class="function-link"><span class="function-syntax">AdjectiveMeanings::compile_inner</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>

<span class="identifier-syntax">INT_METHOD_TYPE</span><span class="plain-syntax">(</span><span class="constant-syntax">COMPILE_ADJM_MTID</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">f</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">emit_flag</span><span class="plain-syntax">, </span><span class="identifier-syntax">ph_stack_frame</span><span class="plain-syntax"> *</span><span class="identifier-syntax">phsf</span><span class="plain-syntax">)</span>

<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::compile_inner</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">emit_flag</span><span class="plain-syntax">, </span><span class="identifier-syntax">ph_stack_frame</span><span class="plain-syntax"> *</span><span class="identifier-syntax">phsf</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><a href="6-am.html#SP26" class="function-link"><span class="function-syntax">AdjectiveMeanings::compiling_soon</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">T</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="6-am.html#SP27_1" class="named-paragraph-link"><span class="named-paragraph">Use the I6 schema instead to compile the task, if one exists</span><span class="named-paragraph-number">27.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">rv</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">INT_METHOD_CALL</span><span class="plain-syntax">(</span><span class="identifier-syntax">rv</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family</span><span class="plain-syntax">, </span><span class="constant-syntax">COMPILE_ADJM_MTID</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="identifier-syntax">emit_flag</span><span class="plain-syntax">, </span><span class="identifier-syntax">phsf</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">rv</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP27_1" class="paragraph-anchor"></a><b>&#167;27.1.  </b>We expand the I6 schema, placing the "it" variable &mdash; a nameless call
parameter which is always local variable number 0 for this stack frame &mdash;
into <span class="extract"><span class="extract-syntax">*1</span></span>.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Use the I6 schema instead to compile the task, if one exists</span><span class="named-paragraph-number">27.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Calculus::Schemas::empty</span><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">i6s_for_runtime_task</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">])) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">emit_flag</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">it_var</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Lvalues::new_LOCAL_VARIABLE</span><span class="plain-syntax">(</span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">LocalVariables::it_variable</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">it_term</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Terms::new_constant</span><span class="plain-syntax">(</span><span class="identifier-syntax">it_var</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">EmitSchemas::emit_expand_from_terms</span><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">i6s_for_runtime_task</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">]), &amp;</span><span class="identifier-syntax">it_term</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="6-am.html#SP27">&#167;27</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP28" class="paragraph-anchor"></a><b>&#167;28.  </b>4. <span class="extract"><span class="extract-syntax">*_KADJ_assert</span></span>. We should now either take action to ensure that
the adjective will hold (or not hold, according to <span class="extract"><span class="extract-syntax">parity</span></span>) for the given
object or value; or return <span class="extract"><span class="extract-syntax">FALSE</span></span> to tell Inform that this cannot be
asserted, which will trigger a problem message.
</p>

<pre class="definitions code-font"><span class="definition-keyword">enum</span> <span class="constant-syntax">ASSERT_ADJM_MTID</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">INT_METHOD_TYPE</span><span class="plain-syntax">(</span><span class="constant-syntax">ASSERT_ADJM_MTID</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">f</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs_to_assert_on</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">val_to_assert_on</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">parity</span><span class="plain-syntax">)</span>

<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::assert_single</span><button class="popup" onclick="togglePopup('usagePopup10')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup10">Usage of <span class="code-font"><span class="function-syntax">AdjectiveMeanings::assert_single</span></span>:<br/>Adjective Ambiguity - <a href="6-aa.html#SP8">&#167;8</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs_to_assert_on</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">val_to_assert_on</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">parity</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">meaning_parity</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">am</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">am_negated_from</span><span class="plain-syntax">; </span><span class="identifier-syntax">parity</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">parity</span><span class="plain-syntax">)?</span><span class="identifier-syntax">FALSE:TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">rv</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">INT_METHOD_CALL</span><span class="plain-syntax">(</span><span class="identifier-syntax">rv</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family</span><span class="plain-syntax">, </span><span class="constant-syntax">ASSERT_ADJM_MTID</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">infs_to_assert_on</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">val_to_assert_on</span><span class="plain-syntax">, </span><span class="identifier-syntax">parity</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">rv</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP29" class="paragraph-anchor"></a><b>&#167;29.  </b>5. <span class="extract"><span class="extract-syntax">*_KADJ_index</span></span>. This should print a description of the adjective to the
index, for use in the Phrasebook lexicon. Note that it is only needed where
the AM has been constructed positively, that is, it is not needed if the
AM was made as a negation of something else.
</p>

<p class="commentary">Note also that if the AM was defined with any indexing text then that will
be printed if the routine does nothing better.
</p>

<pre class="definitions code-font"><span class="definition-keyword">enum</span> <span class="constant-syntax">INDEX_ADJM_MTID</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">INT_METHOD_TYPE</span><span class="plain-syntax">(</span><span class="constant-syntax">INDEX_ADJM_MTID</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">f</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">)</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::print_to_index</span><span class="plain-syntax">(</span><span class="identifier-syntax">OUTPUT_STREAM</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="6-am.html#SP29_1" class="named-paragraph-link"><span class="named-paragraph">Index the domain of validity of the AM</span><span class="named-paragraph-number">29.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">am_negated_from</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Adjectives::get_nominative_singular</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">am_negated_from</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">owning_adjective</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">" opposite of &lt;/i&gt;%+W&lt;i&gt;"</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">rv</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">INT_METHOD_CALL</span><span class="plain-syntax">(</span><span class="identifier-syntax">rv</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family</span><span class="plain-syntax">, </span><span class="constant-syntax">INDEX_ADJM_MTID</span><span class="plain-syntax">, </span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">rv</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">adjective_index_text</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"%+W"</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">adjective_index_text</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">adjective_index_text</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Index::link</span><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">Wordings::first_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">adjective_index_text</span><span class="plain-syntax">));</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP29_1" class="paragraph-anchor"></a><b>&#167;29.1.  </b>This is supposed to imitate dictionaries, distinguishing meanings by
concisely showing their usage. Thus "empty" would have indexed entries
prefaced "(of a rulebook)", "(of an activity)", and so on.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Index the domain of validity of the AM</span><span class="named-paragraph-number">29.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"(of &lt;/i&gt;%+W&lt;i&gt;) "</span><span class="plain-syntax">, </span><span class="identifier-syntax">InferenceSubjects::get_name_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain_infs</span><span class="plain-syntax">));</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="6-am.html#SP29">&#167;29</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP30" class="paragraph-anchor"></a><b>&#167;30. Parsing for adaptive text. </b></p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;adaptive-adjective&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">Projects::get_language_of_play</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">Task::project</span><span class="Preform-plain-syntax">()) == </span><span class="Preform-identifier-syntax">DefaultLanguage::get</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">NULL</span><span class="Preform-plain-syntax">)) </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">FALSE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">adjective</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">aph</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">LOOP_OVER</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">aph</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">adjective</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">wording</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">AW</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Clusters::get_form_general</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">aph</span><span class="Preform-plain-syntax">-&gt;</span><span class="Preform-identifier-syntax">adjective_names</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">Projects::get_language_of_play</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">Task::project</span><span class="Preform-plain-syntax">()), </span><span class="Preform-constant-syntax">1</span><span class="Preform-plain-syntax">, -1);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">Wordings::match</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">AW</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">)) {</span>
<span class="Preform-plain-syntax">            ==&gt; { </span><span class="Preform-identifier-syntax">FALSE</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">aph</span><span class="Preform-plain-syntax">};</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">        }</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="6-aa.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-am.html">1</a></li><li class="progresschapter"><a href="2-bv.html">2</a></li><li class="progresschapter"><a href="3-dlr.html">3</a></li><li class="progresschapter"><a href="4-nr.html">4</a></li><li class="progresschapter"><a href="5-tc.html">5</a></li><li class="progresscurrentchapter">6</li><li class="progresssection"><a href="6-kpr.html">kpr</a></li><li class="progresssection"><a href="6-tap.html">tap</a></li><li class="progresssection"><a href="6-tcp.html">tcp</a></li><li class="progresssection"><a href="6-terr.html">terr</a></li><li class="progresssection"><a href="6-qr.html">qr</a></li><li class="progresssection"><a href="6-tur.html">tur</a></li><li class="progresssection"><a href="6-er.html">er</a></li><li class="progresssection"><a href="6-lr.html">lr</a></li><li class="progresssection"><a href="6-aa.html">aa</a></li><li class="progresscurrent">am</li><li class="progresssection"><a href="6-cu.html">cu</a></li><li class="progressnext"><a href="6-cu.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

