<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Adjective Meanings</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
MathJax = {
	tex: {
		inlineMath: '$', '$'], ['\\(', '\\)'
	},
	svg: {
		fontCache: 'global'
	}
};
</script>
<script type="text/javascript" id="MathJax-script" async
	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Preform-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../compiler.html">compiler tools</a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul><h2>Compiler Webs</h2><ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul><h2>Inbuild Modules</h2><ul>
<li><a href="../supervisor-module/index.html">supervisor</a></li>
</ul><h2>Inform7 Modules</h2><ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="index.html"><span class="selectedlink">assertions</span></a></li>
<li><a href="../values-module/index.html">values</a></li>
<li><a href="../knowledge-module/index.html">knowledge</a></li>
<li><a href="../imperative-module/index.html">imperative</a></li>
<li><a href="../runtime-module/index.html">runtime</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul><h2>Inter Modules</h2><ul>
<li><a href="../bytecode-module/index.html">bytecode</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul><h2>Services</h2><ul>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../calculus-module/index.html">calculus</a></li>
<li><a href="../html-module/index.html">html</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Adjective Meanings' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../compiler.html">Inform7</a></li><li><a href="index.html">assertions</a></li><li><a href="index.html#6">Chapter 6: Predicates</a></li><li><b>Adjective Meanings</b></li></ul></div>
<p class="purpose">One individual meaning which an adjective can have.</p>

<ul class="toc"><li><a href="6-am.html#SP1">&#167;1. Meanings</a></li><li><a href="6-am.html#SP5">&#167;5. Tasks and their schemas</a></li><li><a href="6-am.html#SP7">&#167;7. Testing and asserting in play</a></li><li><a href="6-am.html#SP12">&#167;12. Kinds of adjectives</a></li><li><a href="6-am.html#SP18">&#167;18. Parsing for adaptive text</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. Meanings. </b>For example, "odd" in the sense of numbers is a single meaning. Each meaning
is an instance of:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">owning_adjective</span><span class="plain-syntax">; </span><span class="comment-syntax"> of which this is a meaning</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">adjective_domain_data</span><span class="plain-syntax"> </span><span class="identifier-syntax">domain</span><span class="plain-syntax">; </span><span class="comment-syntax"> to what can this meaning be applied?</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">family</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">general_pointer</span><span class="plain-syntax"> </span><span class="identifier-syntax">family_specific_data</span><span class="plain-syntax">; </span><span class="comment-syntax"> to the relevant structure</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">negated_from</span><span class="plain-syntax">; </span><span class="comment-syntax"> if explicitly constructed as such</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">indexing_text</span><span class="plain-syntax">; </span><span class="comment-syntax"> text to use in the Phrasebook index</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">defined_at</span><span class="plain-syntax">; </span><span class="comment-syntax"> from what sentence this came (if it did)</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">schemas_prepared</span><span class="plain-syntax">; </span><span class="comment-syntax"> optional flag to mark whether schemas prepared yet</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">adjective_task_data</span><span class="plain-syntax"> </span><span class="identifier-syntax">task_data</span><span class="plain-syntax">[</span><span class="constant-syntax">NO_ADJECTIVE_TASKS</span><span class="plain-syntax"> + </span><span class="constant-syntax">1</span><span class="plain-syntax">];</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">support_function_compiled</span><span class="plain-syntax">; </span><span class="comment-syntax"> temporary workspace used when compiling support routines</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>The structure adjective_meaning is accessed in 3/nrr, 6/tap, 6/tcp, 6/aa, 6/amd and here.</li></ul>
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2.  </b>This can be created in two ways: straightforwardly &mdash;
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::new</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">family</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">general_pointer</span><span class="plain-syntax"> </span><span class="identifier-syntax">details</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax"> = </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">indexing_text</span><span class="plain-syntax"> = </span><span class="identifier-syntax">W</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">owning_adjective</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain</span><span class="plain-syntax"> = </span><a href="6-amd.html#SP2" class="function-link"><span class="function-syntax">AdjectiveMeaningDomains::new_from_text</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family</span><span class="plain-syntax"> = </span><span class="identifier-syntax">family</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family_specific_data</span><span class="plain-syntax"> = </span><span class="identifier-syntax">details</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">support_function_compiled</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">schemas_prepared</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">=1; </span><span class="identifier-syntax">i</span><span class="plain-syntax">&lt;=</span><span class="constant-syntax">NO_ADJECTIVE_TASKS</span><span class="plain-syntax">; </span><span class="identifier-syntax">i</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">].</span><span class="element-syntax">task_via_support_routine</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NOT_APPLICABLE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Calculus::Schemas::modify</span><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">].</span><span class="element-syntax">i6s_for_runtime_task</span><span class="plain-syntax">), </span><span class="string-syntax">""</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Calculus::Schemas::modify</span><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">].</span><span class="element-syntax">i6s_to_transfer_to_SR</span><span class="plain-syntax">), </span><span class="string-syntax">""</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">negated_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">am</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3.  </b>Or as the logical negation of an existing meaning (thus, "odd" for numbers
might be created as the negation of "even" for numbers):
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::negate</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">negated_from</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"cannot negate an already negated AM"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">neg</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax"> = </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">indexing_text</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">indexing_text</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">owning_adjective</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family_specific_data</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family_specific_data</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">support_function_compiled</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">schemas_prepared</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">=1; </span><span class="identifier-syntax">i</span><span class="plain-syntax">&lt;=</span><span class="constant-syntax">NO_ADJECTIVE_TASKS</span><span class="plain-syntax">; </span><span class="identifier-syntax">i</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">j</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">i</span><span class="plain-syntax"> == </span><span class="constant-syntax">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain-syntax">) </span><span class="identifier-syntax">j</span><span class="plain-syntax"> = </span><span class="constant-syntax">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">i</span><span class="plain-syntax"> == </span><span class="constant-syntax">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain-syntax">) </span><span class="identifier-syntax">j</span><span class="plain-syntax"> = </span><span class="constant-syntax">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">j</span><span class="plain-syntax">].</span><span class="element-syntax">task_via_support_routine</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">].</span><span class="element-syntax">task_via_support_routine</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">j</span><span class="plain-syntax">].</span><span class="element-syntax">i6s_for_runtime_task</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">].</span><span class="element-syntax">i6s_for_runtime_task</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Calculus::Schemas::modify</span><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">j</span><span class="plain-syntax">].</span><span class="element-syntax">i6s_to_transfer_to_SR</span><span class="plain-syntax">), </span><span class="string-syntax">""</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">neg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">negated_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">neg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4.  </b>There are currently seven families of adjective meanings, each represented
by an instance of the following:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">method_set</span><span class="plain-syntax"> *</span><span class="identifier-syntax">methods</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">parsing_priority</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax">;</span>

<span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::new_family</span><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">N</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">f</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">f</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">parsing_priority</span><span class="plain-syntax"> = </span><span class="identifier-syntax">N</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">f</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">methods</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Methods::new_set</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">f</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>The structure adjective_meaning_family is private to this section.</li></ul>
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5. Tasks and their schemas. </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">adjective_task_data</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">task_via_support_routine</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> </span><span class="identifier-syntax">i6s_to_transfer_to_SR</span><span class="plain-syntax">; </span><span class="comment-syntax"> where </span><span class="extract"><span class="extract-syntax">TRUE</span></span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> </span><span class="identifier-syntax">i6s_for_runtime_task</span><span class="plain-syntax">; </span><span class="comment-syntax"> where </span><span class="extract"><span class="extract-syntax">TRUE</span></span>
<span class="plain-syntax">} </span><span class="reserved-syntax">adjective_task_data</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>The structure adjective_task_data is private to this section.</li></ul>
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6.  </b>What are adjectives for? Since an adjective is a unary predicate, it can be
thought of as an assignment from its domain set to the set of two possibilities:
true, false. Thus one sense of "open" maps doors to true if they are currently
open, false if they are closed.
</p>

<p class="commentary">There are altogether five things we might want to do with an adjective:
</p>

<ul class="items"><li>(1) Test whether it is true at any given point during play.
</li><li>(2) Assert that it is true at the start of play.
</li><li>(3) Assert that it is false at the start of play.
</li><li>(4) Assert that it is now to be true from this point on during play.
</li><li>(5) Assert that it is now to be false from this point on during play.
</li></ul>
<p class="commentary">We do not need to test whether it is false, since we need only test whether
it is true and negate the result.
</p>

<p class="commentary">Adjectives for which all five of these operations can be carried out are
the exception rather than the rule. "Open" is an example:
</p>

<blockquote>
    <p>[1] if the marble door is open, ...</p>
</blockquote>

<blockquote>
    <p>[2] The marble door is open.</p>
</blockquote>

<blockquote>
    <p>[3] The marble door is not open.</p>
</blockquote>

<blockquote>
    <p>[4] now the marble door is open;</p>
</blockquote>

<blockquote>
    <p>[5] now the marble door is not open;</p>
</blockquote>

<p class="commentary">Every adjective in practice supports (1), testing for truth, but this is
not required by the code below. Many adjectives &mdash; properly speaking, many
senses of an adjective &mdash; only support testing: "empty" in the sense of
texts, for instance.
</p>

<p class="commentary">Of the five possibilities, (1), (4) and (5) happen at run-time. These are
called "tasks" and are identified by the following constants. While in
theory an adjective's handling code can compile anything it likes to carry
out these tasks, in practice most are defined by providing an I6 schema,
which is why the <span class="extract"><span class="extract-syntax">adjective_meaning</span></span> structure contains these &mdash; see below.
</p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="constant-syntax">NO_ADJECTIVE_TASKS</span><span class="plain-syntax"> </span><span class="constant-syntax">3</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">TEST_ADJECTIVE_TASK</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax"> </span><span class="comment-syntax"> test if currently true</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain-syntax"> </span><span class="constant-syntax">2</span><span class="plain-syntax"> </span><span class="comment-syntax"> assert now true</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain-syntax"> </span><span class="constant-syntax">3</span><span class="plain-syntax"> </span><span class="comment-syntax"> assert now false</span>
</pre>
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7. Testing and asserting in play. </b>Now for testing, making true and making false in play. We won't be there when
the story file is played, of course, so what we have to do is to compile code
to perform the test or force the state.
</p>

<p class="commentary">In fact what we do is to supply an I6 schema, which for this purpose is
simply the text of I6 code in which the escape <span class="extract"><span class="extract-syntax">*1</span></span> represents the value
to which the adjective is applied. In the example of "open" for containers,
we might choose:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    if the sack is open, ...  --&gt;   (Adj_53_t1_v61(*1))</span>
<span class="plain-syntax">    now the sack is open; ...  --&gt;   Adj_53_t2_v61(*1)</span>
<span class="plain-syntax">    now the sack is not open; ...  --&gt;   Adj_53_t3_v61(*1)</span>
</pre>
<p class="commentary">These schemas call an I6 routine called a "support routine". The names
here are schematic: "open" on this run was APH number 53, the run-time
tasks to perform were task 1, task 2 and task 3, and the sense of the
adjective was the one applying to domain 61 &mdash; which in this example run
was the weak ID of "object". In other words, these are routines to "test
open in the sense of objects", "now open in the sense of objects", and
"now not open in the sense of objects".
</p>

<p class="commentary">If we make a choice like that, then we say that the task is provided
"via a support routine". We need not do so: for instance,
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    if the Entire Game is happening, ...  --&gt;  (scene_status-&gt;(*1 - 1)==1)</span>
</pre>
<p class="commentary">is an example where the sense of "happening" for scenes can be tested
directly using a schema, without calling a support routine. And clearly
support routines only put off the problem, because we will also have to
compile the routine itself. So why use them? The answer is that in
complicated situations where run-time type checking is needed, they
avoid duplication of code, and can make repeated use of the <span class="extract"><span class="extract-syntax">*1</span></span> value
without repeating any side-effects produced by the calculation of this
value. They also make the code simpler for human eyes to read.
</p>

<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8.  </b>When an AM has been declared, the provider can choose to set an I6
schema for it, for any of the tasks, immediately; or can wait and do it
later; or can choose not to do it, and instead provide code which
generates a suitable schema on the fly. If at whatever stage the
provider does set an I6 schema for a task, it should call the following.
</p>

<p class="commentary">Note that any AM working on objects always has to go via a support
routine &mdash; this is because, thanks to weak domain-checking, there may
be run-time type-checking code to apply. In other cases, the provider
can choose to go via a support routine or not.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::set_i6_schema</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">AdjectiveMeanings::set_i6_schema</span></span>:<br/><a href="6-am.html#SP10">&#167;10</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">via_support</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><a href="6-amd.html#SP7" class="function-link"><span class="function-syntax">AdjectiveMeaningDomains::get_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">K</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">K_object</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::is_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">)) </span><span class="identifier-syntax">via_support</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">].</span><span class="element-syntax">task_via_support_routine</span><span class="plain-syntax"> = </span><span class="identifier-syntax">via_support</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> &amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">].</span><span class="element-syntax">i6s_for_runtime_task</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9.  </b>The following is needed when making sense of the I6-to-I7 escape sequence
<span class="extract"><span class="extract-syntax">(+ adj +)</span></span>, where <span class="extract"><span class="extract-syntax">adj</span></span> is the name of an adjective. Since I6 is typeless,
there's no good way to choose which sense of the adjective is meant, so we
don't know which routine to expand out. The convention is: a meaning for
objects, if there is one; otherwise the first-declared meaning.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::write_adjective_test_routine</span><span class="plain-syntax">(</span><span class="identifier-syntax">value_holster</span><span class="plain-syntax"> *</span><span class="identifier-syntax">VH</span><span class="plain-syntax">, </span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">adj</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sch</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">weak_id</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RTKinds::weak_id</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_object</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">sch</span><span class="plain-syntax"> = </span><a href="6-aa.html#SP9" class="function-link"><span class="function-syntax">AdjectiveAmbiguity::schema_for_task</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">adj</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="constant-syntax">TEST_ADJECTIVE_TASK</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">sch</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax"> = </span><a href="6-aa.html#SP6" class="function-link"><span class="function-syntax">AdjectiveAmbiguity::first_meaning</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">adj</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am_kind</span><span class="plain-syntax"> = </span><a href="6-amd.html#SP7" class="function-link"><span class="function-syntax">AdjectiveMeaningDomains::get_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am_kind</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">weak_id</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RTKinds::weak_id</span><span class="plain-syntax">(</span><span class="identifier-syntax">am_kind</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Produce::val_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">RTAdjectives::iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">adj</span><span class="plain-syntax">, </span><span class="constant-syntax">TEST_ADJECTIVE_TASK</span><span class="plain-syntax">, </span><span class="identifier-syntax">weak_id</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10.  </b>The following instructs an AM to use a support routine to handle a given
task.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::pass_task_to_support_routine</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><a href="6-am.html#SP8" class="function-link"><span class="function-syntax">AdjectiveMeanings::set_i6_schema</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP11" class="paragraph-anchor"></a><b>&#167;11.  </b>Note that the <span class="extract"><span class="extract-syntax">task_via_support_routine</span></span> values are not flags: they can be
<span class="extract"><span class="extract-syntax">TRUE</span></span> (allowed, done via support routine), <span class="extract"><span class="extract-syntax">FALSE</span></span> (allowed, done directly)
or <span class="extract"><span class="extract-syntax">NOT_APPLICABLE</span></span> (the task certainly can't be done). If none of the
applicable meanings for the adjective are able to perform the task at
run-time, we return <span class="extract"><span class="extract-syntax">NULL</span></span> as our schema, and the code-generator will use
that to issue a suitable problem message.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::schema_for_task</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">AdjectiveMeanings::schema_for_task</span></span>:<br/>Adjective Ambiguity - <a href="6-aa.html#SP9">&#167;9</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><a href="6-am.html#SP14" class="function-link"><span class="function-syntax">AdjectiveMeanings::prepare_schemas</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">T</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">].</span><span class="element-syntax">task_via_support_routine</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE:</span><span class="plain-syntax"> </span><span class="reserved-syntax">return</span><span class="plain-syntax"> &amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">].</span><span class="element-syntax">i6s_for_runtime_task</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Calculus::Schemas::empty</span><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">].</span><span class="element-syntax">i6s_to_transfer_to_SR</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">                </span><span class="named-paragraph-container code-font"><a href="6-am.html#SP11_1" class="named-paragraph-link"><span class="named-paragraph">Construct a schema for this adjective, using the standard routine naming</span><span class="named-paragraph-number">11.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> &amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">].</span><span class="element-syntax">i6s_to_transfer_to_SR</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP11_1" class="paragraph-anchor"></a><b>&#167;11.1.  </b>Where the following is complicated by the need to respect negations; it may
be that the original adjective has a support routine defined, but that the
negation does not, and so must use those of the original.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Construct a schema for this adjective, using the standard routine naming</span><span class="named-paragraph-number">11.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">task</span><span class="plain-syntax"> = </span><span class="identifier-syntax">T</span><span class="plain-syntax">; </span><span class="reserved-syntax">char</span><span class="plain-syntax"> *</span><span class="identifier-syntax">negation_operator</span><span class="plain-syntax"> = </span><span class="string-syntax">""</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">use_adj</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">owning_adjective</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">negated_from</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">use_adj</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">negated_from</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">owning_adjective</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="identifier-syntax">T</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">TEST_ADJECTIVE_TASK:</span><span class="plain-syntax"> </span><span class="identifier-syntax">negation_operator</span><span class="plain-syntax"> = </span><span class="string-syntax">"~~"</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">NOW_ADJECTIVE_TRUE_TASK:</span><span class="plain-syntax"> </span><span class="identifier-syntax">task</span><span class="plain-syntax"> = </span><span class="constant-syntax">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">NOW_ADJECTIVE_FALSE_TASK:</span><span class="plain-syntax"> </span><span class="identifier-syntax">task</span><span class="plain-syntax"> = </span><span class="constant-syntax">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inter_name</span><span class="plain-syntax"> *</span><span class="identifier-syntax">iname</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RTAdjectives::iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">use_adj</span><span class="plain-syntax">, </span><span class="identifier-syntax">task</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">RTKinds::weak_id</span><span class="plain-syntax">(</span><a href="6-amd.html#SP7" class="function-link"><span class="function-syntax">AdjectiveMeaningDomains::get_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">)));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Calculus::Schemas::modify</span><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">].</span><span class="element-syntax">i6s_to_transfer_to_SR</span><span class="plain-syntax">), </span><span class="string-syntax">"*=-(%s%n(*1))"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">negation_operator</span><span class="plain-syntax">, </span><span class="identifier-syntax">iname</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="6-am.html#SP11">&#167;11</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP12" class="paragraph-anchor"></a><b>&#167;12. Kinds of adjectives. </b>This is where <span class="extract"><span class="extract-syntax">inweb</span></span>'s use of C rather than <span class="extract"><span class="extract-syntax">C++</span></span> or Python as a base
language becomes a little embarrassing: we really want to have seven or
eight subclasses of an "adjective" class, and provide a group of methods.
Instead we simulate this with the following clumsy code. (More elegant
code using pointers to functions would trip up <span class="extract"><span class="extract-syntax">inweb</span></span>'s structure-element
usage checking.)
</p>

<p class="commentary">To define a new kind of adjective, first allocate it a new <span class="extract"><span class="extract-syntax">*_KADJ</span></span>
constant (see above). Then declare functions to handle the following
methods.
</p>

<p class="commentary firstcommentary"><a id="SP13" class="paragraph-anchor"></a><b>&#167;13.  </b>1. <span class="extract"><span class="extract-syntax">*_KADJ_parse</span></span>. This enables the kind of adjective to claim a definition
which the user has explicitly written, like so:
</p>

<blockquote>
    <p>Definition: A ... (called ...) is ... if ...</p>
</blockquote>

<p class="commentary">In place of the ellipses are the adjective name, domain name, condition
text and (optionally) also the calling name. The routine should return a
pointer to the AM it creates, if it does want to claim the definition;
and <span class="extract"><span class="extract-syntax">NULL</span></span> if it doesn't want it. <span class="extract"><span class="extract-syntax">sense</span></span> is either \(1\), meaning that
"if" was used (the condition has positive sense); or \(-1\), meaning
that it was "unless" (a negative sense); or \(0\), meaning that instead
of a condition, a rule was supplied. (Most kinds of adjective will only
claim if the sense is \(1\); some never claim at all.)
</p>

<pre class="definitions code-font"><span class="definition-keyword">enum</span> <span class="constant-syntax">PARSE_ADJM_MTID</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">INT_METHOD_TYPE</span><span class="plain-syntax">(</span><span class="constant-syntax">PARSE_ADJM_MTID</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">f</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> **</span><span class="identifier-syntax">result</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">q</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">sense</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">AW</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">DNW</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">CONW</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">CALLW</span><span class="plain-syntax">)</span>

<span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveMeanings::parse</span><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">q</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">sense</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">AW</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">DNW</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">CONW</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">CALLW</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">priority</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">; </span><span class="identifier-syntax">priority</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">10</span><span class="plain-syntax">; </span><span class="identifier-syntax">priority</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">f</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">f</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">f</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">parsing_priority</span><span class="plain-syntax"> == </span><span class="identifier-syntax">priority</span><span class="plain-syntax">)</span>
<span class="plain-syntax">                </span><span class="named-paragraph-container code-font"><a href="6-am.html#SP13_1" class="named-paragraph-link"><span class="named-paragraph">Try the f family</span><span class="named-paragraph-number">13.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP13_1" class="paragraph-anchor"></a><b>&#167;13.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Try the f family</span><span class="named-paragraph-number">13.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">rv</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">INT_METHOD_CALL</span><span class="plain-syntax">(</span><span class="identifier-syntax">rv</span><span class="plain-syntax">, </span><span class="identifier-syntax">f</span><span class="plain-syntax">, </span><span class="constant-syntax">PARSE_ADJM_MTID</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">q</span><span class="plain-syntax">, </span><span class="identifier-syntax">sense</span><span class="plain-syntax">, </span><span class="identifier-syntax">AW</span><span class="plain-syntax">, </span><span class="identifier-syntax">DNW</span><span class="plain-syntax">, </span><span class="identifier-syntax">CONW</span><span class="plain-syntax">, </span><span class="identifier-syntax">CALLW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">rv</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">am</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="6-am.html#SP13">&#167;13</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP14" class="paragraph-anchor"></a><b>&#167;14.  </b>2. <span class="extract"><span class="extract-syntax">*_KADJ_compiling_soon</span></span>. This warns the adjective that it will shortly be
needed in compilation, that is, that code will soon be compiled which uses it.
This advance warning is an opportunity to compile a schema for the adjective
at the last minute, but there is no obligation. There is also no return value.
</p>

<pre class="definitions code-font"><span class="definition-keyword">enum</span> <span class="constant-syntax">PREPARE_SCHEMAS_ADJM_MTID</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">VOID_METHOD_TYPE</span><span class="plain-syntax">(</span><span class="constant-syntax">PREPARE_SCHEMAS_ADJM_MTID</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">f</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">)</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::prepare_schemas</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">AdjectiveMeanings::prepare_schemas</span></span>:<br/><a href="6-am.html#SP11">&#167;11</a>, <a href="6-am.html#SP15">&#167;15</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">VOID_METHOD_CALL</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family</span><span class="plain-syntax">, </span><span class="constant-syntax">PREPARE_SCHEMAS_ADJM_MTID</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">T</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">schemas_prepared</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP15" class="paragraph-anchor"></a><b>&#167;15.  </b>3. <span class="extract"><span class="extract-syntax">*_KADJ_compile</span></span>. We should now either compile code which, in the
given stack frame and writing code to the given file handle, carries out the
given task for the adjective, and return <span class="extract"><span class="extract-syntax">TRUE</span></span>; or return <span class="extract"><span class="extract-syntax">FALSE</span></span> to
tell Inform that the task is impossible.
</p>

<p class="commentary">Note that if an adjective has defined a schema to handle the task, then its
<span class="extract"><span class="extract-syntax">*_KADJ_compile</span></span> is not needed and not consulted.
</p>

<pre class="definitions code-font"><span class="definition-keyword">enum</span> <span class="constant-syntax">COMPILE_ADJM_MTID</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::emit_meaning</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="identifier-syntax">ph_stack_frame</span><span class="plain-syntax"> *</span><span class="identifier-syntax">phsf</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">rv</span><span class="plain-syntax"> = </span><a href="6-am.html#SP15" class="function-link"><span class="function-syntax">AdjectiveMeanings::compile_inner</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">phsf</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">support_function_compiled</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">rv</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::compilation_possible</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="6-am.html#SP15" class="function-link"><span class="function-syntax">AdjectiveMeanings::compile_inner</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>

<span class="identifier-syntax">INT_METHOD_TYPE</span><span class="plain-syntax">(</span><span class="constant-syntax">COMPILE_ADJM_MTID</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">f</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">emit_flag</span><span class="plain-syntax">, </span><span class="identifier-syntax">ph_stack_frame</span><span class="plain-syntax"> *</span><span class="identifier-syntax">phsf</span><span class="plain-syntax">)</span>

<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::compile_inner</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">emit_flag</span><span class="plain-syntax">, </span><span class="identifier-syntax">ph_stack_frame</span><span class="plain-syntax"> *</span><span class="identifier-syntax">phsf</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><a href="6-am.html#SP14" class="function-link"><span class="function-syntax">AdjectiveMeanings::prepare_schemas</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">T</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="6-am.html#SP15_1" class="named-paragraph-link"><span class="named-paragraph">Use the I6 schema instead to compile the task, if one exists</span><span class="named-paragraph-number">15.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">rv</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">INT_METHOD_CALL</span><span class="plain-syntax">(</span><span class="identifier-syntax">rv</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family</span><span class="plain-syntax">, </span><span class="constant-syntax">COMPILE_ADJM_MTID</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="identifier-syntax">emit_flag</span><span class="plain-syntax">, </span><span class="identifier-syntax">phsf</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">rv</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP15_1" class="paragraph-anchor"></a><b>&#167;15.1.  </b>We expand the I6 schema, placing the "it" variable &mdash; a nameless call
parameter which is always local variable number 0 for this stack frame &mdash;
into <span class="extract"><span class="extract-syntax">*1</span></span>.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Use the I6 schema instead to compile the task, if one exists</span><span class="named-paragraph-number">15.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Calculus::Schemas::empty</span><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">].</span><span class="element-syntax">i6s_for_runtime_task</span><span class="plain-syntax">)) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">emit_flag</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">it_var</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Lvalues::new_LOCAL_VARIABLE</span><span class="plain-syntax">(</span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">LocalVariables::it_variable</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">it_term</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Terms::new_constant</span><span class="plain-syntax">(</span><span class="identifier-syntax">it_var</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">EmitSchemas::emit_expand_from_terms</span><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">task_data</span><span class="plain-syntax">[</span><span class="identifier-syntax">T</span><span class="plain-syntax">].</span><span class="element-syntax">i6s_for_runtime_task</span><span class="plain-syntax">), &amp;</span><span class="identifier-syntax">it_term</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="6-am.html#SP15">&#167;15</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP16" class="paragraph-anchor"></a><b>&#167;16.  </b>4. <span class="extract"><span class="extract-syntax">*_KADJ_assert</span></span>. We should now either take action to ensure that
the adjective will hold (or not hold, according to <span class="extract"><span class="extract-syntax">parity</span></span>) for the given
object or value; or return <span class="extract"><span class="extract-syntax">FALSE</span></span> to tell Inform that this cannot be
asserted, which will trigger a problem message.
</p>

<pre class="definitions code-font"><span class="definition-keyword">enum</span> <span class="constant-syntax">ASSERT_ADJM_MTID</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">INT_METHOD_TYPE</span><span class="plain-syntax">(</span><span class="constant-syntax">ASSERT_ADJM_MTID</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">f</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs_to_assert_on</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">val_to_assert_on</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">parity</span><span class="plain-syntax">)</span>

<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::assert_single</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">AdjectiveMeanings::assert_single</span></span>:<br/>Adjective Ambiguity - <a href="6-aa.html#SP8">&#167;8</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs_to_assert_on</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">val_to_assert_on</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">parity</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">negated_from</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">am</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">negated_from</span><span class="plain-syntax">; </span><span class="identifier-syntax">parity</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">parity</span><span class="plain-syntax">)?</span><span class="identifier-syntax">FALSE:TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">rv</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">INT_METHOD_CALL</span><span class="plain-syntax">(</span><span class="identifier-syntax">rv</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family</span><span class="plain-syntax">, </span><span class="constant-syntax">ASSERT_ADJM_MTID</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">infs_to_assert_on</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">val_to_assert_on</span><span class="plain-syntax">, </span><span class="identifier-syntax">parity</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">rv</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP17" class="paragraph-anchor"></a><b>&#167;17.  </b>5. <span class="extract"><span class="extract-syntax">*_KADJ_index</span></span>. This should print a description of the adjective to the
index, for use in the Phrasebook lexicon. Note that it is only needed where
the AM has been constructed positively, that is, it is not needed if the
AM was made as a negation of something else.
</p>

<p class="commentary">Note also that if the AM was defined with any indexing text then that will
be printed if the routine does nothing better.
</p>

<pre class="definitions code-font"><span class="definition-keyword">enum</span> <span class="constant-syntax">INDEX_ADJM_MTID</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">INT_METHOD_TYPE</span><span class="plain-syntax">(</span><span class="constant-syntax">INDEX_ADJM_MTID</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">f</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">)</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveMeanings::print_to_index</span><span class="plain-syntax">(</span><span class="identifier-syntax">OUTPUT_STREAM</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="6-am.html#SP17_1" class="named-paragraph-link"><span class="named-paragraph">Index the domain of validity of the AM</span><span class="named-paragraph-number">17.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">negated_from</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Adjectives::get_nominative_singular</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">negated_from</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">owning_adjective</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">" opposite of &lt;/i&gt;%+W&lt;i&gt;"</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">rv</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">INT_METHOD_CALL</span><span class="plain-syntax">(</span><span class="identifier-syntax">rv</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family</span><span class="plain-syntax">, </span><span class="constant-syntax">INDEX_ADJM_MTID</span><span class="plain-syntax">, </span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">rv</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">indexing_text</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"%+W"</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">indexing_text</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">indexing_text</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Index::link</span><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">Wordings::first_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">indexing_text</span><span class="plain-syntax">));</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP17_1" class="paragraph-anchor"></a><b>&#167;17.1.  </b>This is supposed to imitate dictionaries, distinguishing meanings by
concisely showing their usage. Thus "empty" would have indexed entries
prefaced "(of a rulebook)", "(of an activity)", and so on.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Index the domain of validity of the AM</span><span class="named-paragraph-number">17.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain</span><span class="plain-syntax">.</span><span class="element-syntax">domain_infs</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"(of &lt;/i&gt;%+W&lt;i&gt;) "</span><span class="plain-syntax">, </span><span class="identifier-syntax">InferenceSubjects::get_name_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain</span><span class="plain-syntax">.</span><span class="element-syntax">domain_infs</span><span class="plain-syntax">));</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="6-am.html#SP17">&#167;17</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP18" class="paragraph-anchor"></a><b>&#167;18. Parsing for adaptive text. </b></p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;adaptive-adjective&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">Projects::get_language_of_play</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">Task::project</span><span class="Preform-plain-syntax">()) == </span><span class="Preform-identifier-syntax">DefaultLanguage::get</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">NULL</span><span class="Preform-plain-syntax">)) </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">FALSE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">adjective</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">adj</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">LOOP_OVER</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">adj</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">adjective</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">wording</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">AW</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Clusters::get_form_general</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">adj</span><span class="Preform-plain-syntax">-&gt;</span><span class="Preform-identifier-syntax">adjective_names</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">Projects::get_language_of_play</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">Task::project</span><span class="Preform-plain-syntax">()), </span><span class="Preform-constant-syntax">1</span><span class="Preform-plain-syntax">, -1);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">Wordings::match</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">AW</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">)) {</span>
<span class="Preform-plain-syntax">            ==&gt; { </span><span class="Preform-identifier-syntax">FALSE</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">adj</span><span class="Preform-plain-syntax">};</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">        }</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="6-aa.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-am.html">1</a></li><li class="progresschapter"><a href="2-bv.html">2</a></li><li class="progresschapter"><a href="3-dlr.html">3</a></li><li class="progresschapter"><a href="4-nr.html">4</a></li><li class="progresschapter"><a href="5-tc.html">5</a></li><li class="progresscurrentchapter">6</li><li class="progresssection"><a href="6-kpr.html">kpr</a></li><li class="progresssection"><a href="6-tap.html">tap</a></li><li class="progresssection"><a href="6-tcp.html">tcp</a></li><li class="progresssection"><a href="6-terr.html">terr</a></li><li class="progresssection"><a href="6-qr.html">qr</a></li><li class="progresssection"><a href="6-tur.html">tur</a></li><li class="progresssection"><a href="6-er.html">er</a></li><li class="progresssection"><a href="6-lr.html">lr</a></li><li class="progresssection"><a href="6-aa.html">aa</a></li><li class="progresscurrent">am</li><li class="progresssection"><a href="6-amd.html">amd</a></li><li class="progresssection"><a href="6-cu.html">cu</a></li><li class="progressnext"><a href="6-amd.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

