<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>S/rt</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of 'S/st' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">standard_rules Template Library</a></li><li><b>StoredAction Template</b></li></ul><p class="purpose">Code to support the stored action kind of value.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Block Format</a></li><li><a href="#SP2">&#167;2. KOV Support</a></li><li><a href="#SP3">&#167;3. Creation</a></li><li><a href="#SP4">&#167;4. Setting Up</a></li><li><a href="#SP5">&#167;5. Destruction</a></li><li><a href="#SP6">&#167;6. Copying</a></li><li><a href="#SP7">&#167;7. Comparison</a></li><li><a href="#SP8">&#167;8. Hashing</a></li><li><a href="#SP9">&#167;9. Printing</a></li><li><a href="#SP10">&#167;10. Involvement</a></li><li><a href="#SP11">&#167;11. Nouns</a></li><li><a href="#SP12">&#167;12. Pattern Matching</a></li><li><a href="#SP13">&#167;13. Current Action</a></li><li><a href="#SP14">&#167;14. Trying</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Block Format. </b>The short block of a stored action is simply a pointer to a long block. The
long block always has a length of 6 words.
</p>

<p class="inwebparagraph">An action which involves a topic &mdash; such as the one produced by the command
LOOK UP JIM MCDIVITT IN ENCYCLOPAEDIA &mdash; cannot be tried without the text
of that topic (JIM MCDIVITT) being available. That's no problem if the action
is tried in the same turn in which it is generated, because the text will
still be in the command buffer. But once we store actions up for future
use it becomes an issue. So when we store an action involving a topic,
we record the actual text typed at the time when it is stored, and this
goes into array entry 5 of the block. Because that in turn is text,
and therefore a block value on the heap in its own right, we have to be a
little more careful about destroying and copying stored actions than we
otherwise would be.
</p>

<p class="inwebparagraph">Note that entries 1 and 2 are values whose kind depends on the action in
entry 0: but they are never block values, because actions are not allowed
to apply to block values. This simplifies matters considerably.
</p>


<pre class="display">
    <span class="plain">Constant STORA_ACTION_F = 0;</span>
    <span class="plain">Constant STORA_NOUN_F = 1;</span>
    <span class="plain">Constant STORA_SECOND_F = 2;</span>
    <span class="plain">Constant STORA_ACTOR_F = 3;</span>
    <span class="plain">Constant STORA_REQUEST_F = 4;</span>
    <span class="plain">Constant STORA_COMMAND_TEXT_F = 5;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. KOV Support. </b>See the "BlockValues.i6t" segment for the specification of the following
routines.
</p>


<pre class="display">
    <span class="plain">[ STORED_ACTION_TY_Support task arg1 arg2 arg3;</span>
        <span class="plain">switch(task) {</span>
            <span class="plain">CREATE_KOVS:      return STORED_ACTION_TY_Create(arg2);</span>
            <span class="plain">DESTROY_KOVS:     STORED_ACTION_TY_Destroy(arg1);</span>
            <span class="plain">MAKEMUTABLE_KOVS: return 1;</span>
            <span class="plain">COPYQUICK_KOVS:   rtrue;</span>
            <span class="plain">COPYSB_KOVS:	  BlkValueCopySB1(arg1, arg2);</span>
            <span class="plain">KINDDATA_KOVS:    return 0;</span>
            <span class="plain">EXTENT_KOVS:      return 6;</span>
            <span class="plain">COPY_KOVS:        STORED_ACTION_TY_Copy(arg1, arg2);</span>
            <span class="plain">COMPARE_KOVS:     return STORED_ACTION_TY_Compare(arg1, arg2);</span>
            <span class="plain">HASH_KOVS:        return STORED_ACTION_TY_Hash(arg1);</span>
            <span class="plain">DEBUG_KOVS:       print " = ", (STORED_ACTION_TY_Say) arg1;</span>
        <span class="plain">}</span>
        <span class="plain">! We choose not to respond to: CAST_KOVS, COPYKIND_KOVS, READ_FILE_KOVS, WRITE_FILE_KOVS</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Creation. </b>A stored action block has fixed size, so this is a single-block KOV: its
data consists of six words, laid out as shown in the following routine.
Note that it initialises to the default value for this KOV, an action
in which the player waits.
</p>


<pre class="display">
    <span class="plain">[ STORED_ACTION_TY_Create sb stora;</span>
        <span class="plain">stora = FlexAllocate(6*WORDSIZE, STORED_ACTION_TY, BLK_FLAG_WORD);</span>
        <span class="plain">BlkValueWrite(stora, STORA_ACTION_F, ##Wait, true); ! action</span>
        <span class="plain">BlkValueWrite(stora, STORA_NOUN_F, 0, true); ! noun</span>
        <span class="plain">BlkValueWrite(stora, STORA_SECOND_F, 0, true); ! second</span>
        <span class="plain">BlkValueWrite(stora, STORA_ACTOR_F, player, true); ! actor</span>
        <span class="plain">BlkValueWrite(stora, STORA_REQUEST_F, false, true); ! whether a request</span>
        <span class="plain">BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0, true); ! text of command if necessary, 0 if not</span>
        <span class="plain">return BlkValueCreateSB1(sb, stora);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Setting Up. </b>In practice it's convenient for NI to have a routine which creates a stored
action with a given slate of action variables, rather than have to set them
all one at a time, so the following is provided as a shorthand form.
</p>


<pre class="display">
    <span class="plain">[ STORED_ACTION_TY_New a n s ac req  stora;</span>
        <span class="plain">if (stora == 0) stora = BlkValueCreate(STORED_ACTION_TY);</span>
        <span class="plain">BlkValueWrite(stora, STORA_ACTION_F, a);</span>
        <span class="plain">BlkValueWrite(stora, STORA_NOUN_F, n);</span>
        <span class="plain">BlkValueWrite(stora, STORA_SECOND_F, s);</span>
        <span class="plain">BlkValueWrite(stora, STORA_ACTOR_F, ac);</span>
        <span class="plain">BlkValueWrite(stora, STORA_REQUEST_F, req);</span>
        <span class="plain">BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0);</span>
        <span class="plain">return stora;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Destruction. </b>Entries 0 to 4 are forgettable non-block values: only the optional text
requires destruction.
</p>


<pre class="display">
    <span class="plain">[ STORED_ACTION_TY_Destroy stora toc;</span>
        <span class="plain">toc = BlkValueRead(stora, STORA_COMMAND_TEXT_F);</span>
        <span class="plain">if (toc) BlkValueFree(toc);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Copying. </b>The only entry needing attention is, again, entry 5: if this is non-zero in
the source, then we need to create a new text block to hold a duplicate
copy of the text.
</p>


<pre class="display">
    <span class="plain">[ STORED_ACTION_TY_Copy storato storafrom tocfrom tocto;</span>
        <span class="plain">tocfrom = BlkValueRead(storafrom, STORA_COMMAND_TEXT_F);</span>
        <span class="plain">if (tocfrom == 0) return;</span>
        <span class="plain">tocto = BlkValueCreate(TEXT_TY);</span>
        <span class="plain">BlkValueCopy(tocto, tocfrom);</span>
        <span class="plain">BlkValueWrite(storato, STORA_COMMAND_TEXT_F, tocto);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Comparison. </b>There is no very convincing ordering on stored actions, but we need to
devise a comparison which will exhaustively determine whether two actions
are or are not different.
</p>


<pre class="display">
    <span class="plain">[ STORED_ACTION_TY_Compare storaleft storaright delta itleft itright;</span>
        <span class="plain">delta = BlkValueRead(storaleft, STORA_ACTION_F) - BlkValueRead(storaright, STORA_ACTION_F);</span>
        <span class="plain">if (delta) return delta;</span>
        <span class="plain">delta = BlkValueRead(storaleft, STORA_NOUN_F) - BlkValueRead(storaright, STORA_NOUN_F);</span>
        <span class="plain">if (delta) return delta;</span>
        <span class="plain">delta = BlkValueRead(storaleft, STORA_SECOND_F) - BlkValueRead(storaright, STORA_SECOND_F);</span>
        <span class="plain">if (delta) return delta;</span>
        <span class="plain">delta = BlkValueRead(storaleft, STORA_ACTOR_F) - BlkValueRead(storaright, STORA_ACTOR_F);</span>
        <span class="plain">if (delta) return delta;</span>
        <span class="plain">delta = BlkValueRead(storaleft, STORA_REQUEST_F) - BlkValueRead(storaright, STORA_REQUEST_F);</span>
        <span class="plain">if (delta) return delta;</span>
        <span class="plain">itleft = BlkValueRead(storaleft, STORA_COMMAND_TEXT_F);</span>
        <span class="plain">itright = BlkValueRead(storaright, STORA_COMMAND_TEXT_F);</span>
        <span class="plain">if ((itleft ~= 0) &amp;&amp; (itright ~= 0))</span>
            <span class="plain">return TEXT_TY_Support(COMPARE_KOVS, itleft, itright);</span>
        <span class="plain">return itleft - itright;</span>
    <span class="plain">];</span>

    <span class="plain">[ STORED_ACTION_TY_Distinguish stora1 stora2;</span>
        <span class="plain">if (STORED_ACTION_TY_Compare(stora1, stora2) == 0) rfalse;</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Hashing. </b></p>


<pre class="display">
    <span class="plain">[ STORED_ACTION_TY_Hash stora  rv it;</span>
        <span class="plain">rv = BlkValueRead(stora, STORA_ACTION_F);</span>
        <span class="plain">rv = rv * 33 + BlkValueRead(stora, STORA_NOUN_F);</span>
        <span class="plain">rv = rv * 33 + BlkValueRead(stora, STORA_SECOND_F);</span>
        <span class="plain">rv = rv * 33 + BlkValueRead(stora, STORA_ACTOR_F);</span>
        <span class="plain">rv = rv * 33 + BlkValueRead(stora, STORA_REQUEST_F);</span>
        <span class="plain">it = BlkValueRead(stora, STORA_COMMAND_TEXT_F);</span>
        <span class="plain">if (it ~= 0)</span>
            <span class="plain">rv = rv * 33 + TEXT_TY_Support(HASH_KOVS, it);</span>
        <span class="plain">return rv;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Printing. </b>We share some code here with the routines originally written for the ACTIONS
testing command. (The <code class="display"><span class="extract">DB</span></code> in <code class="display"><span class="extract">DB_Action</span></code> stands for "debugging".) When
printing a topic, it prints the relevant words from the player's command:
so if our stored action is one which contains an entry 5, then we have to
temporarily adopt this as the player's command, and restore the old player's
command once printing is done. To do this, we need to save the old player's
command, and we do that by creating a text for the duration.
</p>


<pre class="display">
    <span class="plain">[ STORED_ACTION_TY_Say stora text_of_command saved_command saved_pn saved_action K1 K2 at cf cw;</span>
        <span class="plain">if ((stora==0) || (BlkValueWeakKind(stora) ~= STORED_ACTION_TY)) return;</span>
        <span class="plain">text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F);</span>
        <span class="plain">if (text_of_command) {</span>
            <span class="plain">saved_command = BlkValueCreate(TEXT_TY);</span>
            <span class="plain">BlkValueCast(saved_command, SNIPPET_TY, players_command);</span>
            <span class="plain">SetPlayersCommand(text_of_command);</span>
        <span class="plain">}</span>
        <span class="plain">saved_pn = parsed_number; saved_action = action;</span>
        <span class="plain">action = BlkValueRead(stora, STORA_ACTION_F);</span>
        <span class="plain">cf = consult_from; cw = consult_words;</span>
        <span class="plain">at = FindAction(-1);</span>
        <span class="plain">K1 = ActionData--&gt;(at+AD_NOUN_KOV);</span>
        <span class="plain">K2 = ActionData--&gt;(at+AD_SECOND_KOV);</span>
        <span class="plain">if (K1 ~= OBJECT_TY) {</span>
            <span class="plain">parsed_number = BlkValueRead(stora, STORA_NOUN_F);</span>
            <span class="plain">if ((K1 == UNDERSTANDING_TY) &amp;&amp; (text_of_command == 0)) {</span>
                <span class="plain">if (saved_command == 0) saved_command = BlkValueCreate(TEXT_TY);</span>
                <span class="plain">BlkValueCast(saved_command, SNIPPET_TY, players_command);</span>
                <span class="plain">text_of_command = BlkValueCreate(TEXT_TY);</span>
                <span class="plain">BlkValueCopy(text_of_command, parsed_number);</span>
                <span class="plain">SetPlayersCommand(text_of_command);</span>
                <span class="plain">parsed_number = players_command;</span>
                <span class="plain">consult_from = parsed_number/100; consult_words = parsed_number%100;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">if (K2 ~= OBJECT_TY) {</span>
            <span class="plain">parsed_number = BlkValueRead(stora, STORA_SECOND_F);</span>
            <span class="plain">if ((K2 == UNDERSTANDING_TY) &amp;&amp; (text_of_command == 0)) {</span>
                <span class="plain">if (saved_command == 0) saved_command = BlkValueCreate(TEXT_TY);</span>
                <span class="plain">BlkValueCast(saved_command, SNIPPET_TY, players_command);</span>
                <span class="plain">text_of_command = BlkValueCreate(TEXT_TY);</span>
                <span class="plain">BlkValueCopy(text_of_command, parsed_number);</span>
                <span class="plain">SetPlayersCommand(text_of_command);</span>
                <span class="plain">parsed_number = players_command;</span>
                <span class="plain">consult_from = parsed_number/100; consult_words = parsed_number%100;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">DB_Action(</span>
            <span class="plain">BlkValueRead(stora, STORA_ACTOR_F),</span>
            <span class="plain">BlkValueRead(stora, STORA_REQUEST_F),</span>
            <span class="plain">BlkValueRead(stora, STORA_ACTION_F),</span>
            <span class="plain">BlkValueRead(stora, STORA_NOUN_F),</span>
            <span class="plain">BlkValueRead(stora, STORA_SECOND_F), true);</span>
        <span class="plain">parsed_number = saved_pn; action = saved_action;</span>
        <span class="plain">consult_from = cf; consult_words = cw;</span>
        <span class="plain">if (text_of_command) {</span>
            <span class="plain">SetPlayersCommand(saved_command);</span>
            <span class="plain">BlkValueFree(saved_command);</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Involvement. </b>That completes the compulsory services required for this KOV to function:
from here on, the remaining routines provide definitions of stored action-related
phrases in the Standard Rules.
</p>

<p class="inwebparagraph">An action "involves" an object if it appears as either the actor or the first
or second noun.
</p>


<pre class="display">
    <span class="plain">[ STORED_ACTION_TY_Involves stora item at;</span>
        <span class="plain">at = FindAction(BlkValueRead(stora, STORA_ACTION_F));</span>
        <span class="plain">if (at) {</span>
            <span class="plain">if ((ActionData--&gt;(at+AD_NOUN_KOV) == OBJECT_TY) &amp;&amp;</span>
                <span class="plain">(BlkValueRead(stora, STORA_NOUN_F) == item)) rtrue;</span>
            <span class="plain">if ((ActionData--&gt;(at+AD_SECOND_KOV) == OBJECT_TY) &amp;&amp;</span>
                <span class="plain">(BlkValueRead(stora, STORA_SECOND_F) == item)) rtrue;</span>
        <span class="plain">}</span>
        <span class="plain">if (BlkValueRead(stora, STORA_ACTOR_F) == item) rtrue;</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Nouns. </b>Extracting the noun or second noun from an action is a delicate business
because simply returning the values in entries 1 and 2 would not be type-safe;
it would fail to be an object if the stored action did not apply to objects.
So the following returns <code class="display"><span class="extract">nothing</span></code> if requested to produce noun or second
noun for such an action.
</p>


<pre class="display">
    <span class="plain">[ STORED_ACTION_TY_Part stora ind at ado;</span>
        <span class="plain">if (ind == STORA_NOUN_F or STORA_SECOND_F) {</span>
            <span class="plain">if (ind == STORA_NOUN_F) ado = AD_NOUN_KOV; else ado = AD_SECOND_KOV;</span>
            <span class="plain">at = FindAction(BlkValueRead(stora, STORA_ACTION_F));</span>
            <span class="plain">if ((at) &amp;&amp; (ActionData--&gt;(at+ado) == OBJECT_TY)) return BlkValueRead(stora, ind);</span>
            <span class="plain">return nothing;</span>
        <span class="plain">}</span>
        <span class="plain">return BlkValueRead(stora, ind);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Pattern Matching. </b>In order to apply an action pattern such as "doing something with the kazoo"
to a stored action, it needs to be the current action, because the code which
compiles conditions like this looks at the <code class="display"><span class="extract">action</span></code>, <code class="display"><span class="extract">noun</span></code>, ..., variables.
We don't want to do anything as disruptive as temporarily starting the stored
action and then halting it again, so instead we simply "adopt" it, saving
the slate of action variables and setting them from the stored action: almost
immediately after &mdash; the moment the condition has been tested &mdash; we "unadopt"
it again, restoring the stored values. Since the action pattern cannot itself
refer to a stored action, the following code won't be nested, and we don't
need to worry about stacking up saved copies of the action variables.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">SAT_Tmp--&gt;0</span></code> stores the outcome of the condition, and is set in code
compiled by NI.
</p>


<pre class="display">
    <span class="plain">Array SAT_Tmp--&gt;7;</span>
    <span class="plain">[ STORED_ACTION_TY_Adopt stora at;</span>
        <span class="plain">SAT_Tmp--&gt;1 = action;</span>
        <span class="plain">SAT_Tmp--&gt;2 = noun;</span>
        <span class="plain">SAT_Tmp--&gt;3 = second;</span>
        <span class="plain">SAT_Tmp--&gt;4 = actor;</span>
        <span class="plain">SAT_Tmp--&gt;5 = act_requester;</span>
        <span class="plain">SAT_Tmp--&gt;6 = parsed_number;</span>
        <span class="plain">action = BlkValueRead(stora, STORA_ACTION_F);</span>
        <span class="plain">at = FindAction(-1);</span>
        <span class="plain">if (ActionData--&gt;(at+AD_NOUN_KOV) == OBJECT_TY)</span>
            <span class="plain">noun = BlkValueRead(stora, STORA_NOUN_F);</span>
        <span class="plain">else {</span>
            <span class="plain">parsed_number = BlkValueRead(stora, STORA_NOUN_F);</span>
            <span class="plain">noun = nothing;</span>
        <span class="plain">}</span>
        <span class="plain">if (ActionData--&gt;(at+AD_SECOND_KOV) == OBJECT_TY)</span>
            <span class="plain">second = BlkValueRead(stora, STORA_SECOND_F);</span>
        <span class="plain">else {</span>
            <span class="plain">parsed_number = BlkValueRead(stora, STORA_SECOND_F);</span>
            <span class="plain">second = nothing;</span>
        <span class="plain">}</span>
        <span class="plain">actor = BlkValueRead(stora, STORA_ACTOR_F);</span>
        <span class="plain">if (BlkValueRead(stora, STORA_REQUEST_F)) act_requester = player; else act_requester = nothing;</span>
    <span class="plain">];</span>

    <span class="plain">[ STORED_ACTION_TY_Unadopt;</span>
        <span class="plain">action = SAT_Tmp--&gt;1;</span>
        <span class="plain">noun = SAT_Tmp--&gt;2;</span>
        <span class="plain">second = SAT_Tmp--&gt;3;</span>
        <span class="plain">actor = SAT_Tmp--&gt;4;</span>
        <span class="plain">act_requester = SAT_Tmp--&gt;5;</span>
        <span class="plain">parsed_number = SAT_Tmp--&gt;6;</span>
        <span class="plain">return SAT_Tmp--&gt;0;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. Current Action. </b>Although we never cast other values to stored actions, because none of them
really imply an action (not even an action name, since that gives no help
as to what the nouns might be), there is of course one action almost always
present within a story file at run-time, even if it is not a single value
as such: the action which is currently running. The following routine
translates that into a stored action &mdash; thus allowing us to store it.
</p>

<p class="inwebparagraph">This is the place where we look to see if the action applies to a topic as
either its noun or second noun, and if it does, we copy the player's
command into a text block-value in entry 5.
</p>


<pre class="display">
    <span class="plain">[ STORED_ACTION_TY_Current stora at text_of_command;</span>
        <span class="plain">if ((stora==0) || (BlkValueWeakKind(stora) ~= STORED_ACTION_TY)) return 0;</span>
        <span class="plain">BlkValueWrite(stora, STORA_ACTION_F, action);</span>
        <span class="plain">at = FindAction(-1);</span>

        <span class="plain">if (ActionData--&gt;(at+AD_NOUN_KOV) == OBJECT_TY)</span>
            <span class="plain">BlkValueWrite(stora, STORA_NOUN_F, noun);</span>
        <span class="plain">else</span>
            <span class="plain">BlkValueWrite(stora, STORA_NOUN_F, parsed_number);</span>
        <span class="plain">if (ActionData--&gt;(at+AD_SECOND_KOV) == OBJECT_TY)</span>
            <span class="plain">BlkValueWrite(stora, STORA_SECOND_F, second);</span>
        <span class="plain">else</span>
            <span class="plain">BlkValueWrite(stora, STORA_SECOND_F, parsed_number);</span>
        <span class="plain">BlkValueWrite(stora, STORA_ACTOR_F, actor);</span>
        <span class="plain">if (act_requester) BlkValueWrite(stora, STORA_REQUEST_F, true);</span>
        <span class="plain">else BlkValueWrite(stora, STORA_REQUEST_F, false);</span>

        <span class="plain">if ((at) &amp;&amp; ((ActionData--&gt;(at+AD_NOUN_KOV) == UNDERSTANDING_TY) ||</span>
                <span class="plain">(ActionData--&gt;(at+AD_SECOND_KOV) == UNDERSTANDING_TY))) {</span>
            <span class="plain">text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F);</span>
            <span class="plain">if (text_of_command == 0) {</span>
                <span class="plain">text_of_command = BlkValueCreate(TEXT_TY);</span>
                <span class="plain">BlkValueWrite(stora, STORA_COMMAND_TEXT_F, text_of_command);</span>
            <span class="plain">}</span>
            <span class="plain">BlkValueCast(text_of_command, SNIPPET_TY, players_command);</span>
        <span class="plain">} else BlkValueWrite(stora, STORA_COMMAND_TEXT_F, 0);</span>

        <span class="plain">return stora;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Trying. </b>Finally: having stored an action for perhaps many turns, we now let it happen,
either silently or not.
</p>


<pre class="display">
    <span class="plain">[ STORED_ACTION_TY_Try stora ks  text_of_command saved_command;</span>
        <span class="plain">if ((stora==0) || (BlkValueWeakKind(stora) ~= STORED_ACTION_TY)) return;</span>
        <span class="plain">if (ks) { @push keep_silent; keep_silent=1; }</span>
        <span class="plain">text_of_command = BlkValueRead(stora, STORA_COMMAND_TEXT_F);</span>
        <span class="plain">if (text_of_command) {</span>
            <span class="plain">saved_command = BlkValueCreate(TEXT_TY);</span>
            <span class="plain">BlkValueCast(saved_command, SNIPPET_TY, players_command);</span>
            <span class="plain">SetPlayersCommand(text_of_command);</span>
        <span class="plain">}</span>
        <span class="plain">TryAction(</span>
            <span class="plain">BlkValueRead(stora, STORA_REQUEST_F),</span>
            <span class="plain">BlkValueRead(stora, STORA_ACTOR_F),</span>
            <span class="plain">BlkValueRead(stora, STORA_ACTION_F),</span>
            <span class="plain">BlkValueRead(stora, STORA_NOUN_F),</span>
            <span class="plain">BlkValueRead(stora, STORA_SECOND_F));</span>
        <span class="plain">if (text_of_command) {</span>
            <span class="plain">SetPlayersCommand(saved_command);</span>
            <span class="plain">BlkValueFree(saved_command);</span>
        <span class="plain">}</span>
        <span class="plain">if (ks) { @pull keep_silent; }</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="S-rt.html">Back to 'RTP Template'</a></li><li><a href="S-tt.html">Continue with 'Tests Template'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

