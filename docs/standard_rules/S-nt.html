<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>S/mpr</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of 'S/nt' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">standard_rules Template Library</a></li><li><b>Number Template</b></li></ul><p class="purpose">Support for parsing integers.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Understanding</a></li><li><a href="#SP2">&#167;2. Truth states</a></li><li><a href="#SP3">&#167;3. Real numbers</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Understanding. </b>In our target virtual machines, numbers are stored in twos-complement form,
so that a 16-bit VM can hold the range of integers -2^{15} = -32768 to
2^{15}-1 = +32767, while a 32-bit VM can hold -2^{31} = -2147483648 to
2^{31}-1 = +2147483647: the token below accepts exactly those ranges.
</p>


<pre class="display">
    <span class="plain">[ DECIMAL_TOKEN wnc wna r n wa wl sign base digit digit_count original_wn group_wn;</span>
        <span class="plain">wnc = wn; original_wn = wn; group_wn = wn;</span>
        <span class="plain">r = DECIMAL_TOKEN_INNER();</span>
        <span class="plain">if (r ~= GPR_FAIL) return r;</span>
        <span class="plain">wn = wnc;</span>
        <span class="plain">r = ParseTokenStopped(ELEMENTARY_TT, NUMBER_TOKEN);</span>
        <span class="plain">if ((r == GPR_NUMBER) &amp;&amp; (parsed_number ~= 10000)) return r;</span>
        <span class="plain">wn = wnc;</span>
        <span class="plain">wa = WordAddress(wn);</span>
        <span class="plain">wl = WordLength(wn);</span>
        <span class="plain">sign = 1; base = 10; digit_count = 0;</span>
        <span class="plain">if (wa-&gt;0 ~= '-' or '$' or '0' or '1' or '2' or '3' or '4'</span>
            <span class="plain">or '5' or '6' or '7' or '8' or '9')</span>
            <span class="plain">return GPR_FAIL;</span>
        <span class="plain">if (wa-&gt;0 == '-') { sign = -1; wl--; wa++; }</span>
        <span class="plain">if (wl == 0) return GPR_FAIL;</span>
        <span class="plain">n = 0;</span>
        <span class="plain">while (wl &gt; 0) {</span>
            <span class="plain">if (wa-&gt;0 &gt;= 'a') digit = wa-&gt;0 - 'a' + 10;</span>
            <span class="plain">else digit = wa-&gt;0 - '0';</span>
            <span class="plain">digit_count++;</span>
            <span class="plain">switch (base) {</span>
                <span class="plain">2:  if (digit_count == 17) return GPR_FAIL;</span>
                <span class="plain">10:</span>
                    <span class="plain">#Iftrue (WORDSIZE == 2);</span>
                    <span class="plain">if (digit_count == 6) return GPR_FAIL;</span>
                    <span class="plain">if (digit_count == 5) {</span>
                        <span class="plain">if (n &gt; 3276) return GPR_FAIL;</span>
                        <span class="plain">if (n == 3276) {</span>
                            <span class="plain">if (sign == 1 &amp;&amp; digit &gt; 7) return GPR_FAIL;</span>
                            <span class="plain">if (sign == -1 &amp;&amp; digit &gt; 8) return GPR_FAIL;</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                    <span class="plain">#Ifnot; ! i.e., if (WORDSIZE == 4)</span>
                    <span class="plain">if (digit_count == 11) return GPR_FAIL;</span>
                    <span class="plain">if (digit_count == 10) {</span>
                        <span class="plain">if (n &gt; 214748364) return GPR_FAIL;</span>
                        <span class="plain">if (n == 214748364) {</span>
                            <span class="plain">if (sign == 1 &amp;&amp; digit &gt; 7) return GPR_FAIL;</span>
                            <span class="plain">if (sign == -1 &amp;&amp; digit &gt; 8) return GPR_FAIL;</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                    <span class="plain">#Endif;</span>
                <span class="plain">16: if (digit_count == 5) return GPR_FAIL;</span>
            <span class="plain">}</span>
            <span class="plain">if (digit &gt;= 0 &amp;&amp; digit &lt; base) n = base*n + digit;</span>
            <span class="plain">else return GPR_FAIL;</span>
            <span class="plain">wl--; wa++;</span>
        <span class="plain">}</span>
        <span class="plain">parsed_number = n*sign; wn++;</span>
        <span class="plain">return GPR_NUMBER;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Truth states. </b>And although truth states are not strictly speaking numbers, this seems as
good a point as any to parse them:
</p>


<pre class="display">
    <span class="plain">[ TRUTH_STATE_TOKEN original_wn wd;</span>
        <span class="plain">original_wn = wn;</span>
        <span class="plain">wd = TRUTH_STATE_TOKEN_INNER();</span>
        <span class="plain">if (wd ~= GPR_FAIL) return wd;</span>
        <span class="plain">wn = original_wn;</span>
        <span class="plain">wd = NextWordStopped();</span>
        <span class="plain">if (wd == 'true') { parsed_number = 1; return GPR_NUMBER; }</span>
        <span class="plain">if (wd == 'false') { parsed_number = 0; return GPR_NUMBER; }</span>
        <span class="plain">wn = original_wn;</span>
        <span class="plain">return GPR_FAIL;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Real numbers. </b>An I6 grammar routine (GPR) for floats. On success, this returns
GPR_NUMBER and stores a value in the global parsed_number.
</p>

<p class="inwebparagraph">This is quite a nuisance, actually, because "." is a word separator.
Also, we want to accept command sequences like "type 4. look"So we
need to collect a set of words made up of digits, signs, periods, and
the letter "e", but without any intervening whitespace, and excluding
a trailing period.
</p>

<p class="inwebparagraph">(This will fail to correctly parse "type 4.e", but I think that is a
small flaw. A player would more likely try "type 4. e" or, really,
not concatenate commands at all. It will also parse "type 4. on keyboard"
as two commands, even though "4." is a legitimate float literal.
Contrariwise, "type 4. x me" will be taken as one command. (Because the "x"
*could* be a continuation of the float, and I don't back up when it turns
out not to be.) I don't plan to worry about these cases.)
</p>


<pre class="display">
    <span class="plain">#Ifdef TARGET_GLULX;</span>
    <span class="plain">[ FLOAT_TOKEN buf bufend ix ch firstwd newstart newlen lastchar lastwasdot;</span>
        <span class="plain">if (wn &gt; num_words)</span>
            <span class="plain">return GPR_FAIL;</span>

        <span class="plain">! We're going to collect a set of words. Start with zero words.</span>
        <span class="plain">firstwd = wn;</span>
        <span class="plain">buf = WordAddress(wn);</span>
        <span class="plain">bufend = buf;</span>
        <span class="plain">lastchar = 0;</span>

        <span class="plain">while (wn &lt;= num_words) {</span>
            <span class="plain">newstart = WordAddress(wn);</span>
            <span class="plain">if (newstart ~= bufend) {</span>
                <span class="plain">! There's whitespace between the previous word and this one.</span>
                <span class="plain">! Whitespace is okay around an asterisk...</span>
                <span class="plain">if ((lastchar ~= '*' or 'x' or 'X' or $D7)</span>
                    <span class="plain">&amp;&amp; (newstart-&gt;0 ~= '*' or 'x' or 'X' or $D7)) {</span>
                    <span class="plain">! But around any other character, it's not.</span>
                    <span class="plain">! Don't include the new word.</span>
                    <span class="plain">break;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">newlen = WordLength(wn);</span>
            <span class="plain">for (ix=0 : ix&lt;newlen : ix++) {</span>
                <span class="plain">ch = newstart-&gt;ix;</span>
                <span class="plain">if (~~((ch &gt;= '0' &amp;&amp; ch &lt;= '9')</span>
                    <span class="plain">|| (ch == '-' or '+' or 'E' or 'e' or '.' or 'x' or 'X' or '*' or $D7 or $5E)))</span>
                    <span class="plain">break;</span>
            <span class="plain">}</span>
            <span class="plain">if (ix &lt; newlen) {</span>
                <span class="plain">! This word contains an invalid character.</span>
                <span class="plain">! Don't include the new word.</span>
                <span class="plain">break;</span>
            <span class="plain">}</span>
            <span class="plain">! Okay, include it.</span>
            <span class="plain">bufend = newstart + newlen;</span>
            <span class="plain">wn++;</span>
            <span class="plain">lastchar = (bufend-1)-&gt;0;</span>
            <span class="plain">lastwasdot = (newlen == 1 &amp;&amp; lastchar == '.');</span>
        <span class="plain">}</span>

        <span class="plain">if (wn &gt; firstwd &amp;&amp; lastwasdot) {</span>
            <span class="plain">! Exclude a trailing period.</span>
            <span class="plain">wn--;</span>
            <span class="plain">bufend--;</span>
        <span class="plain">}</span>

        <span class="plain">if (wn == firstwd) {</span>
            <span class="plain">! No words accepted.</span>
            <span class="plain">return GPR_FAIL;</span>
        <span class="plain">}</span>

        <span class="plain">parsed_number = FloatParse(buf, bufend-buf, true);</span>
        <span class="plain">if (parsed_number == FLOAT_NAN)</span>
            <span class="plain">return GPR_FAIL;</span>
        <span class="plain">return GPR_NUMBER;</span>
    <span class="plain">];</span>
    <span class="plain">#Endif; ! TARGET_GLULX</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="S-mpr.html">Back to 'MapRouteFinding'</a></li><li><a href="S-ot2.html">Continue with 'OrderOfPlay Template'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

