<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>S/pt</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of 'S/pt2' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">standard_rules Template Library</a></li><li><b>Printing Template</b></li></ul><p class="purpose">To manage the line skips which space paragraphs out, and to handle the printing of names of objects, pieces of text and numbers.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Say Number</a></li><li><a href="#SP2">&#167;2. Prompt</a></li><li><a href="#SP3">&#167;3. Boxed Quotations</a></li><li><a href="#SP4">&#167;4. Score Notification</a></li><li><a href="#SP5">&#167;5. Print Rank</a></li><li><a href="#SP6">&#167;6. Status Line</a></li><li><a href="#SP7">&#167;7. Status Line Utilities</a></li><li><a href="#SP8">&#167;8. Banner</a></li><li><a href="#SP9">&#167;9. Short Name Storage</a></li><li><a href="#SP10">&#167;10. Object Names I</a></li><li><a href="#SP11">&#167;11. Standard Name Printing Rule</a></li><li><a href="#SP12">&#167;12. Standard Response Issuing Rule</a></li><li><a href="#SP13">&#167;13. Internal Rule</a></li><li><a href="#SP14">&#167;14. Object Names II</a></li><li><a href="#SP15">&#167;15. Print English Number</a></li><li><a href="#SP16">&#167;16. Object Names III</a></li><li><a href="#SP17">&#167;17. Say One Of</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Say Number. </b>The global variable <code class="display"><span class="extract">say__n</span></code> is set to the numerical value of any quantity
printed, and this is used for the text substitution "[s]", so that
"You have been awake for [turn count] turn[s]." will expand correctly.
</p>


<pre class="display">
    <span class="plain">[ STextSubstitution;</span>
        <span class="plain">if (say__n ~= 1) print "s";</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Prompt. </b>This is the text printed just before we wait for the player's command: it
prompts him to type.
</p>


<pre class="display">
    <span class="plain">[ PrintPrompt i;</span>
        <span class="plain">RunTimeProblemShow();</span>
        <span class="plain">ClearRTP();</span>
        <span class="plain">style roman;</span>
        <span class="plain">EnsureBreakBeforePrompt();</span>
        <span class="plain">TEXT_TY_Say(CommandPromptText());</span>
        <span class="plain">ClearBoxedText();</span>
        <span class="plain">ClearParagraphing(14);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Boxed Quotations. </b>These appear once only, and happen outside of the paragraphing scheme: they
are normally overlaid as windows on top of the regular text. We can request
one at any time, but it will appear only at prompt time, when the screen is
fairly well guaranteed not to be scrolling. (Only fairly well since it's just
possible that Border Zone-like tricks with real-time play might be
going on, but whatever happens, there is at least a human-appreciable pause
in which the quotation can be read before being taken away again.)
</p>


<pre class="display">
    <span class="plain">Global pending_boxed_quotation; ! a routine to overlay the quotation on screen</span>

    <span class="plain">[ DisplayBoxedQuotation Q;</span>
        <span class="plain">pending_boxed_quotation = Q;</span>
    <span class="plain">];</span>

    <span class="plain">[ ClearBoxedText i;</span>
        <span class="plain">if (pending_boxed_quotation) {</span>
            <span class="plain">for (i=0: Runtime_Quotations_Displayed--&gt;i: i++)</span>
                <span class="plain">if (Runtime_Quotations_Displayed--&gt;i == pending_boxed_quotation) {</span>
                    <span class="plain">pending_boxed_quotation = 0;</span>
                    <span class="plain">return;</span>
                <span class="plain">}</span>
            <span class="plain">Runtime_Quotations_Displayed--&gt;i = pending_boxed_quotation;</span>

            <span class="plain">ClearParagraphing(15);</span>
            <span class="plain">pending_boxed_quotation();</span>
            <span class="plain">ClearParagraphing(16);</span>

            <span class="plain">pending_boxed_quotation = 0;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Score Notification. </b>This doesn't really deserve to be at I6 level at all, but since we want a
fancy text style for Glulx, ...
</p>


<pre class="display">
    <span class="plain">[ NotifyTheScore d;</span>
        <span class="plain">if ((TEMPLATE_CONFIGURATION_BITMAP &amp; USE_SCORING_TCBIT) &amp;&amp; (notify_mode == 1)) {</span>
            <span class="plain">DivideParagraphPoint();</span>
            <span class="plain">VM_Style(NOTE_VMSTY);</span>
            <span class="plain">d = score-last_score;</span>
            <span class="plain">if (d &gt; 0) { ANNOUNCE_SCORE_RM('D', d); }</span>
            <span class="plain">else if (d &lt; 0) { ANNOUNCE_SCORE_RM('E', -d); }</span>
            <span class="plain">new_line;</span>
            <span class="plain">VM_Style(NORMAL_VMSTY);</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Print Rank. </b>The table of scoring ranks is a residue from the ancient times of early IF:
it gets a tiny amount of special treatment here, even though I7 works tend
not to use these now dated conventions.
</p>


<pre class="display">
    <span class="plain">[ PrintRank i j v;</span>
        <span class="plain">if (TEMPLATE_CONFIGURATION_BITMAP &amp; RANKING_TABLE_TCBIT) {</span>
            <span class="plain">ANNOUNCE_SCORE_RM('B');</span>
            <span class="plain">j = TableRows(RANKING_TABLE);</span>
            <span class="plain">for (i=j:i&gt;=1:i--)</span>
                <span class="plain">if (score &gt;= TableLookUpEntry(RANKING_TABLE, 1, i)) {</span>
                    <span class="plain">v = TableLookUpEntry(RANKING_TABLE, 2, i);</span>
                    <span class="plain">TEXT_TY_Say(v);</span>
                    <span class="plain">".";</span>
                <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">".";</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Status Line. </b>Status line printing happens on the upper screen window, and outside of the
paragraph control system.
</p>

<p class="inwebparagraph">Support for version 6 of the Z-machine is best described as grudging. It
requires a heavily rewritten <code class="display"><span class="extract">DrawStatusLine</span></code> equivalent, to be found
in "ZMachine.i6t".
</p>


<pre class="display">
    <span class="plain">[ DrawStatusLine width posb;</span>
        <span class="plain">@push say__p; @push say__pc;</span>
        <span class="plain">BeginActivity(CONSTRUCTING_STATUS_LINE_ACT);</span>
        <span class="plain">VM_StatusLineHeight(1); VM_MoveCursorInStatusLine(1, 1);</span>
        <span class="plain">if (statuswin_current) {</span>
            <span class="plain">width = VM_ScreenWidth(); posb = width-15;</span>
            <span class="plain">spaces width;</span>
            <span class="plain">ClearParagraphing(17);</span>
            <span class="plain">if (ForActivity(CONSTRUCTING_STATUS_LINE_ACT) == false) {</span>
                <span class="plain">VM_MoveCursorInStatusLine(1, 2);</span>
                <span class="plain">TEXT_TY_Say(left_hand_status_line);</span>
                <span class="plain">VM_MoveCursorInStatusLine(1, posb);</span>
                <span class="plain">TEXT_TY_Say(right_hand_status_line);</span>
            <span class="plain">}</span>
            <span class="plain">VM_MoveCursorInStatusLine(1, 1); VM_MainWindow();</span>
        <span class="plain">}</span>
        <span class="plain">ClearParagraphing(18);</span>
        <span class="plain">EndActivity(CONSTRUCTING_STATUS_LINE_ACT);</span>
        <span class="plain">@pull say__pc; @pull say__p;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Status Line Utilities. </b>Two convenient routines for the default values of <code class="display"><span class="extract">right_hand_status_line</span></code>
and <code class="display"><span class="extract">left_hand_status_line</span></code> respectively. <code class="display"><span class="extract">SL_Location</span></code> also implements the
text substitution "[player's surroundings]".
</p>


<pre class="display">
    <span class="plain">Array T_SL_Score_Moves --&gt; CONSTANT_PACKED_TEXT_STORAGE SL_Score_Moves;</span>

    <span class="plain">[ SL_Score_Moves;</span>
        <span class="plain">if (not_yet_in_play) return;</span>
        <span class="plain">if (TEMPLATE_CONFIGURATION_BITMAP &amp; USE_SCORING_TCBIT)</span>
            <span class="plain">print sline1, "/", sline2;</span>
    <span class="plain">];</span>

    <span class="plain">Array T_SL_Location --&gt; CONSTANT_PACKED_TEXT_STORAGE SL_Location;</span>

    <span class="plain">[ SL_Location even_before;</span>
        <span class="plain">if ((not_yet_in_play) &amp;&amp; (even_before == false)) return;</span>
        <span class="plain">if (location == thedark) {</span>
            <span class="plain">BeginActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);</span>
            <span class="plain">if (ForActivity(PRINTING_NAME_OF_DARK_ROOM_ACT) == false)</span>
                <span class="plain">DARKNESS_NAME_INTERNAL_RM('A');</span>
            <span class="plain">EndActivity(PRINTING_NAME_OF_DARK_ROOM_ACT);</span>
        <span class="plain">} else {</span>
            <span class="plain">FindVisibilityLevels();</span>
            <span class="plain">if (visibility_ceiling == location) print (name) location;</span>
            <span class="plain">else print (The) visibility_ceiling;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ DARKNESS_NAME_INTERNAL_R; ];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Banner. </b>Note that NI always compiles <code class="display"><span class="extract">Story</span></code> and <code class="display"><span class="extract">Headline</span></code> texts, but does not always
compile a <code class="display"><span class="extract">Story_Author</span></code>.
</p>


<pre class="display">
    <span class="plain">[ Banner;</span>
    <span class="plain">BeginActivity(PRINTING_BANNER_TEXT_ACT);</span>
    <span class="plain">if (ForActivity(PRINTING_BANNER_TEXT_ACT) == false) {</span>
            <span class="plain">VM_Style(HEADER_VMSTY);</span>
            <span class="plain">TEXT_TY_Say(Story);</span>
            <span class="plain">VM_Style(NORMAL_VMSTY);</span>
            <span class="plain">new_line;</span>
            <span class="plain">TEXT_TY_Say(Headline);</span>
            <span class="plain">if (TEMPLATE_CONFIGURATION_BITMAP &amp; STORY_AUTHOR_TCBIT) {</span>
                <span class="plain">print " by "; TEXT_TY_Say(Story_Author);</span>
            <span class="plain">}</span>
            <span class="plain">new_line;</span>
            <span class="plain">VM_Describe_Release();</span>
            <span class="plain">print " / Inform 7 build ", (PrintI6Text) NI_BUILD_COUNT, " ";</span>
            <span class="plain">print "(I6/v"; inversion;</span>
            <span class="plain">print ") ";</span>
            <span class="plain">#Ifdef STRICT_MODE;</span>
            <span class="plain">print "S";</span>
            <span class="plain">#Endif; ! STRICT_MODE</span>
            <span class="plain">#Ifdef DEBUG;</span>
            <span class="plain">print "D";</span>
            <span class="plain">#Endif; ! DEBUG</span>
            <span class="plain">new_line;</span>
        <span class="plain">}</span>
        <span class="plain">EndActivity(PRINTING_BANNER_TEXT_ACT);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Short Name Storage. </b>None of the following functions should be called for the Z-machine if the
short name exceeds the size of the following buffer: whereas the Glulx
implementation of <code class="display"><span class="extract">VM_PrintToBuffer</span></code> will safely truncate overlong text,
that's impossible for the Z-machine, and horrible results will follow.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">CPrintOrRun</span></code> is a variation on <code class="display"><span class="extract">PrintOrRun</span></code>, simplified by not needing
to handle entire paragraphs (so, no fuss about dividing) but complicated
by having to capitalise the first letter. We do this by writing to the
buffer and then altering the first character.
</p>


<pre class="display">
    <span class="plain">Array StorageForShortName buffer 250;</span>

    <span class="plain">[ CPrintOrRun obj prop  v length i;</span>
        <span class="plain">if ((obj ofclass String or Routine) || (prop == 0))</span>
            <span class="plain">VM_PrintToBuffer (StorageForShortName, 160, obj);</span>
        <span class="plain">else {</span>
            <span class="plain">if (obj.prop == NULL) rfalse;</span>
            <span class="plain">if (metaclass(obj.prop) == Routine or String)</span>
                <span class="plain">VM_PrintToBuffer(StorageForShortName, 160, obj, prop);</span>
            <span class="plain">else return RunTimeError(2, obj, prop);</span>
        <span class="plain">}</span>

        <span class="plain">length = StorageForShortName--&gt;0;</span>

        <span class="plain">StorageForShortName-&gt;WORDSIZE = VM_LowerToUpperCase(StorageForShortName-&gt;WORDSIZE);</span>
        <span class="plain">for (i=WORDSIZE: i&lt;length+WORDSIZE: i++) print (char) StorageForShortName-&gt;i;</span>
        <span class="plain">if (i&gt;WORDSIZE) say__p = 1;</span>

        <span class="plain">return;</span>
    <span class="plain">];</span>

    <span class="plain">[ Cap str nocaps;</span>
        <span class="plain">if (nocaps) print (string) str;</span>
        <span class="plain">else CPrintOrRun(str, 0);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Object Names I. </b>We now begin the work of printing object names. In the lowest level of this
process we print just the name itself (without articles attached), and we
do it by carrying out an activity.
</p>


<pre class="display">
    <span class="plain">[ PSN__ o;</span>
        <span class="plain">if (o == 0) { LIST_WRITER_INTERNAL_RM('Y'); rtrue; }</span>
        <span class="plain">switch (metaclass(o)) {</span>
            <span class="plain">Routine:  print "&lt;routine ", o, "&gt;"; rtrue;</span>
            <span class="plain">String:   print "&lt;string ~", (string) o, "~&gt;"; rtrue;</span>
            <span class="plain">nothing:  print "&lt;illegal object number ", o, "&gt;"; rtrue;</span>
        <span class="plain">}</span>
        <span class="plain">RegardingSingleObject(o);</span>
        <span class="plain">CarryOutActivity(PRINTING_THE_NAME_ACT, o);</span>
    <span class="plain">];</span>

    <span class="plain">[ PrintShortName obj i;</span>
        <span class="plain">i = indef_mode; indef_mode = NULL;</span>
        <span class="plain">PSN__(obj); indef_mode = i;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Standard Name Printing Rule. </b>In its initial state, the "printing the name of" activity has just one rule:
the following "for" rule.
</p>


<pre class="display">
    <span class="plain">Global caps_mode = false;</span>

    <span class="plain">[ STANDARD_NAME_PRINTING_R obj;</span>
        <span class="plain">obj = parameter_value;</span>
        <span class="plain">if (obj == 0) {</span>
            <span class="plain">LIST_WRITER_INTERNAL_RM('Y'); return;</span>
        <span class="plain">}</span>
        <span class="plain">switch (metaclass(obj)) {</span>
            <span class="plain">Routine:  print "&lt;routine ", obj, "&gt;"; return;</span>
            <span class="plain">String:   print "&lt;string ~", (string) obj, "~&gt;"; return;</span>
            <span class="plain">nothing:  print "&lt;illegal object number ", obj, "&gt;"; return;</span>
        <span class="plain">}</span>
        <span class="plain">if (obj == player) {</span>
            <span class="plain">if (indef_mode == NULL &amp;&amp; caps_mode) PRINT_PROTAGONIST_INTERNAL_RM('A');</span>
            <span class="plain">else PRINT_PROTAGONIST_INTERNAL_RM('B');</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">#Ifdef LanguagePrintShortName;</span>
        <span class="plain">if (LanguagePrintShortName(obj)) return;</span>
        <span class="plain">#Endif; ! LanguagePrintShortName</span>
        <span class="plain">if (indef_mode &amp;&amp; obj.&amp;short_name_indef ~= 0 &amp;&amp;</span>
            <span class="plain">PrintOrRun(obj, short_name_indef, true) ~= 0) return;</span>
        <span class="plain">if (caps_mode &amp;&amp;</span>
            <span class="plain">obj.&amp;cap_short_name ~= 0 &amp;&amp; PrintOrRun(obj, cap_short_name, true) ~= 0) {</span>
            <span class="plain">caps_mode = false;</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">if (obj.&amp;short_name ~= 0 &amp;&amp; PrintOrRun(obj, short_name, true) ~= 0) return;</span>
        <span class="plain">print (object) obj;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Standard Response Issuing Rule. </b>To print a response, we trigger off the response issuing activity. The following
is the default "for" rule for that activity:
</p>


<pre class="display">
    <span class="plain">[ STANDARD_RESPONSE_ISSUING_R;</span>
        <span class="plain">RegardingSingleObject();</span>
        <span class="plain">TEXT_TY_Say(ResponseTexts--&gt;(parameter_value - 1));</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. Internal Rule. </b></p>


<pre class="display">
    <span class="plain">[ PRINT_PROTAGONIST_INTERNAL_R; ];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Object Names II. </b>The second level of the system for printing object names handles the placing
of articles in front of them: the red herring, an elephant,
Some bread. The following routine allows us to choose:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(a) <code class="display"><span class="extract">obj</span></code>, the object whose name is to be printed;
</li><li>(b) <code class="display"><span class="extract">acode</span></code>, the kind of article needed: capitalised definite (0), lower case
uncapitalised definite (1), or uncapitalised indefinite (2);
</li><li>(c) <code class="display"><span class="extract">pluralise</span></code>, a flag forcing to a plural form (e.g., "some" being the
pluralised form of an indefinite article in English);
</li><li>(d) <code class="display"><span class="extract">capitalise</span></code>, a flag forcing us to capitalise the article &mdash; it's by
setting this that we can achieve the fourth option missing from (b), viz.,
capitalised indefinite. (All of this is a legacy design from a time when
the I6 library did not support capitalised indefinite articles.)
</li></ul>
<p class="inwebparagraph">The routine then looks after issues such as which contraction form to
use: for instance, in English, whether to use "a" or "an" for the
indefinite singular depends on the text of the object's name.
</p>


<pre class="display">
    <span class="plain">Global short_name_case;</span>

    <span class="plain">[ PrefaceByArticle obj acode pluralise capitalise  i artform findout artval;</span>
        <span class="plain">if (obj provides articles) {</span>
            <span class="plain">artval=(obj.&amp;articles)--&gt;(acode+short_name_case*LanguageCases);</span>
            <span class="plain">if (capitalise)</span>
                <span class="plain">print (Cap) artval, " ";</span>
            <span class="plain">else</span>
                <span class="plain">print (string) artval, " ";</span>
            <span class="plain">if (pluralise) return;</span>
            <span class="plain">print (PSN__) obj; return;</span>
        <span class="plain">}</span>

        <span class="plain">i = GetGNAOfObject(obj);</span>
        <span class="plain">if (pluralise) {</span>
            <span class="plain">if (i &lt; 3 || (i &gt;= 6 &amp;&amp; i &lt; 9)) i = i + 3;</span>
        <span class="plain">}</span>
        <span class="plain">i = LanguageGNAsToArticles--&gt;i;</span>

        <span class="plain">artform = LanguageArticles</span>
            <span class="plain">+ 3*WORDSIZE*LanguageContractionForms*(short_name_case + i*LanguageCases);</span>

        <span class="plain">#Iftrue (LanguageContractionForms == 2);</span>
        <span class="plain">if (artform--&gt;acode ~= artform--&gt;(acode+3)) findout = true;</span>
        <span class="plain">#Endif; ! LanguageContractionForms</span>
        <span class="plain">#Iftrue (LanguageContractionForms == 3);</span>
        <span class="plain">if (artform--&gt;acode ~= artform--&gt;(acode+3)) findout = true;</span>
        <span class="plain">if (artform--&gt;(acode+3) ~= artform--&gt;(acode+6)) findout = true;</span>
        <span class="plain">#Endif; ! LanguageContractionForms</span>
        <span class="plain">#Iftrue (LanguageContractionForms == 4);</span>
        <span class="plain">if (artform--&gt;acode ~= artform--&gt;(acode+3)) findout = true;</span>
        <span class="plain">if (artform--&gt;(acode+3) ~= artform--&gt;(acode+6)) findout = true;</span>
        <span class="plain">if (artform--&gt;(acode+6) ~= artform--&gt;(acode+9)) findout = true;</span>
        <span class="plain">#Endif; ! LanguageContractionForms</span>
        <span class="plain">#Iftrue (LanguageContractionForms &gt; 4);</span>
        <span class="plain">findout = true;</span>
        <span class="plain">#Endif; ! LanguageContractionForms</span>

        <span class="plain">#Ifdef TARGET_ZCODE;</span>
        <span class="plain">if (standard_interpreter ~= 0 &amp;&amp; findout) {</span>
            <span class="plain">StorageForShortName--&gt;0 = 160;</span>
            <span class="plain">@output_stream 3 StorageForShortName;</span>
            <span class="plain">if (pluralise) print (number) pluralise; else print (PSN__) obj;</span>
            <span class="plain">@output_stream -3;</span>
            <span class="plain">acode = acode + 3*LanguageContraction(StorageForShortName + 2);</span>
        <span class="plain">}</span>
        <span class="plain">#Ifnot; ! TARGET_GLULX</span>
        <span class="plain">if (findout) {</span>
            <span class="plain">if (pluralise)</span>
                <span class="plain">Glulx_PrintAnyToArray(StorageForShortName, 160, EnglishNumber, pluralise);</span>
            <span class="plain">else</span>
                <span class="plain">Glulx_PrintAnyToArray(StorageForShortName, 160, PSN__, obj);</span>
            <span class="plain">acode = acode + 3*LanguageContraction(StorageForShortName);</span>
        <span class="plain">}</span>
        <span class="plain">#Endif; ! TARGET_</span>

        <span class="plain">Cap (artform--&gt;acode, ~~capitalise); ! print article</span>
        <span class="plain">if (pluralise) return;</span>
        <span class="plain">print (PSN__) obj;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15. Print English Number. </b>Another traditional name, this: in fact it prints the number as text in
whatever is the current language of play.
</p>


<pre class="display">
    <span class="plain">[ EnglishNumber n; LanguageNumber(n); ];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16. Object Names III. </b>The routines accessible from outside this segment.
</p>


<pre class="display">
    <span class="plain">[ IndefArt obj i;</span>
        <span class="plain">if (obj == 0) { LIST_WRITER_INTERNAL_RM('Y'); rtrue; }</span>
        <span class="plain">i = indef_mode; indef_mode = true;</span>
        <span class="plain">if (obj has proper) { indef_mode = NULL; print (PSN__) obj; indef_mode = i; return; }</span>
        <span class="plain">if ((obj provides article) &amp;&amp; (TEXT_TY_Compare(obj.article, EMPTY_TEXT_VALUE) ~= 0)) {</span>
            <span class="plain">PrintOrRun(obj, article, true); print " ", (PSN__) obj; indef_mode = i;</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">PrefaceByArticle(obj, 2); indef_mode = i;</span>
    <span class="plain">];</span>

    <span class="plain">[ CIndefArt obj i;</span>
        <span class="plain">if (obj == 0) { LIST_WRITER_INTERNAL_RM('X'); rtrue; }</span>
        <span class="plain">i = indef_mode; indef_mode = true;</span>
        <span class="plain">if (obj has proper) {</span>
            <span class="plain">indef_mode = NULL;</span>
            <span class="plain">caps_mode = true;</span>
            <span class="plain">print (PSN__) obj;</span>
            <span class="plain">indef_mode = i;</span>
            <span class="plain">caps_mode = false;</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">if ((obj provides article) &amp;&amp; (TEXT_TY_Compare(obj.article, EMPTY_TEXT_VALUE) ~= 0)) {</span>
            <span class="plain">TEXT_TY_Say_Capitalised(obj.article); print " ", (PSN__) obj; indef_mode = i;</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">PrefaceByArticle(obj, 2, 0, 1); indef_mode = i;</span>
    <span class="plain">];</span>

    <span class="plain">[ DefArt obj i;</span>
        <span class="plain">i = indef_mode; indef_mode = false;</span>
        <span class="plain">if ((~~obj ofclass Object) || obj has proper) {</span>
            <span class="plain">indef_mode = NULL; print (PSN__) obj; indef_mode = i;</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">PrefaceByArticle(obj, 1); indef_mode = i;</span>
    <span class="plain">];</span>

    <span class="plain">[ CDefArt obj i;</span>
        <span class="plain">i = indef_mode; indef_mode = false;</span>
        <span class="plain">if ((obj ofclass Object) &amp;&amp; (obj has proper || obj == player)) {</span>
            <span class="plain">indef_mode = NULL;</span>
            <span class="plain">caps_mode = true;</span>
            <span class="plain">print (PSN__) obj;</span>
            <span class="plain">indef_mode = i;</span>
            <span class="plain">caps_mode = false;</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">if ((~~obj ofclass Object) || obj has proper) {</span>
            <span class="plain">indef_mode = NULL; print (PSN__) obj; indef_mode = i;</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">PrefaceByArticle(obj, 0); indef_mode = i;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17. Say One Of. </b>These routines are described in the Extensions chapter of the Inform
documentation.
</p>


<pre class="display">
    <span class="plain">[ I7_SOO_PAR oldval count; if (count &lt;= 1) return count; return random(count); ];</span>
    <span class="plain">[ I7_SOO_RAN oldval count v; if (count &lt;= 1) return count;</span>
        <span class="plain">v = oldval; while (v == oldval) v = random(count); return v; ];</span>
    <span class="plain">[ I7_SOO_STI oldval count v; if (oldval) return oldval; return I7_SOO_PAR(oldval, count); ];</span>
    <span class="plain">[ I7_SOO_CYC oldval count; oldval++; if (oldval &gt; count) oldval = 1; return oldval; ];</span>
    <span class="plain">[ I7_SOO_STOP oldval count; oldval++; if (oldval &gt; count) oldval = count; return oldval; ];</span>
    <span class="plain">[ I7_SOO_TAP oldval count tn rn c; if (count &lt;= 1) return count; tn = count*(count+1)/2;</span>
        <span class="plain">rn = random(tn); for (c=1:c&lt;=count:c++) { rn = rn - c; if (rn&lt;=0) return (count-c+1); } ];</span>
    <span class="plain">[ I7_SOO_TRAN oldval count; if (oldval&lt;count) return oldval+1;</span>
        <span class="plain">return count + 1 + I7_SOO_RAN(oldval%(count+1), count); ];</span>
    <span class="plain">[ I7_SOO_TPAR oldval count; if (oldval&lt;count) return oldval+1;</span>
        <span class="plain">return count + 1 + I7_SOO_PAR(oldval%(count+1), count); ];</span>

    <span class="plain">Array I7_SOO_SHUF-&gt;32;</span>

    <span class="plain">[ I7_SOO_SHU oldval count sd ct v i j s ssd scope cc base;</span>
        <span class="plain">base = count+1;</span>
        <span class="plain">v = oldval%base; oldval = oldval/base; ct = oldval%base; sd = oldval/base;</span>
        <span class="plain">if (count &gt; 32) return I7_SOO_PAR(oldval, count);</span>
        <span class="plain">if (count &lt;= 1) v = count;</span>
        <span class="plain">else {</span>
            <span class="plain">!print "^In v=", v, " ct=", ct, " sd=", sd, "^";</span>
            <span class="plain">cc = base*base;</span>
            <span class="plain">scope = (MAX_POSITIVE_NUMBER-1)/cc;</span>
            <span class="plain">!print "Scope = ", scope, "^";</span>
            <span class="plain">if (sd == 0) { sd = random(scope); ct=0; }</span>
            <span class="plain">for (i=0:i&lt;count:i++) I7_SOO_SHUF-&gt;i = i;</span>
            <span class="plain">ssd = sd;</span>
            <span class="plain">for (i=0:i&lt;count-1:i++) {</span>
                <span class="plain">j = (sd)%(count-i)+i; sd = (sd*31973)+17; if (sd&lt;0) sd=-sd;</span>
                <span class="plain">s = I7_SOO_SHUF-&gt;j; I7_SOO_SHUF-&gt;j = I7_SOO_SHUF-&gt;i; I7_SOO_SHUF-&gt;i = s;</span>
            <span class="plain">}</span>
            <span class="plain">!for (i=0:i&lt;count:i++) print I7_SOO_SHUF-&gt;i, " "; print "^";</span>
            <span class="plain">v = (I7_SOO_SHUF-&gt;ct)+1;</span>
            <span class="plain">ct++; if (ct &gt;= count) { ct = 0; ssd = 0; }</span>
        <span class="plain">}</span>
        <span class="plain">!print "Out v=", v, " ct=", ct, " ssd=", sd, "^";</span>
        <span class="plain">!print "Return ", v + ct*base + ssd*base*base, "^";</span>
        <span class="plain">return v + ct*base + ssd*base*base;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="S-pt.html">Back to 'Parser Template'</a></li><li><a href="S-rt.html">Continue with 'RTP Template'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

