<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>S/st</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of 'S/tt' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">standard_rules Template Library</a></li><li><b>Tests Template</b></li></ul><p class="purpose">The command grammar and I6 implementation for testing commands such as TEST, ACTIONS and PURLOIN.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Abstract Command</a></li><li><a href="#SP2">&#167;2. Actions Command</a></li><li><a href="#SP3">&#167;3. Gonear Command</a></li><li><a href="#SP4">&#167;4. Purloin Command</a></li><li><a href="#SP5">&#167;5. Random Command</a></li><li><a href="#SP6">&#167;6. Relations Command</a></li><li><a href="#SP7">&#167;7. Responses Command</a></li><li><a href="#SP8">&#167;8. Rules Command</a></li><li><a href="#SP9">&#167;9. Scenes Command</a></li><li><a href="#SP10">&#167;10. Scope Command</a></li><li><a href="#SP11">&#167;11. Showheap Command</a></li><li><a href="#SP12">&#167;12. ShowMe Command</a></li><li><a href="#SP13">&#167;13. Showverb Command</a></li><li><a href="#SP14">&#167;14. Test Command</a></li><li><a href="#SP15">&#167;15. Trace Command</a></li><li><a href="#SP16">&#167;16. Tree Command</a></li><li><a href="#SP17">&#167;17. Grammar</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Abstract Command. </b>The code below is compiled only if the symbol <code class="display"><span class="extract">DEBUG</span></code> is defined, which it
always is for normal runs in the Inform user interface, but not for Release
runs.
</p>

<p class="inwebparagraph">Not all of these commands are documented; this is intentional. They may be
changed in name or function. This is all of the testing commands except for
the GLKLIST command, which is in Glulx.i6t (and does not exist when the
target VM is the Z-machine).
</p>

<p class="inwebparagraph">We take the commands in alphabetical order, beginning with ABSTRACT, which
moves an object to a new position in the object tree.
</p>


<pre class="display">
    <span class="plain">[ XAbstractSub;</span>
        <span class="plain">if (XTestMove(noun, second)) return;</span>
        <span class="plain">move noun to second;</span>
        <span class="plain">"[Abstracted.]";</span>
    <span class="plain">];</span>

    <span class="plain">[ XTestMove obj dest;</span>
        <span class="plain">if (obj &lt;= InformLibrary) print_ret "[Can't move ", (name) obj, ": it's a system object.]";</span>
        <span class="plain">if (obj.component_parent) print_ret "[Can't move ", (name) obj, ": it's part of ",</span>
            <span class="plain">(the) obj.component_parent, ".]";</span>
        <span class="plain">while (dest) {</span>
            <span class="plain">if (dest == obj) print_ret "[Can't move ", (name) obj, ": it would contain itself.]";</span>
            <span class="plain">dest = CoreOfParentOfCoreOf(dest);</span>
        <span class="plain">}</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Actions Command. </b>ACTIONS turns tracing of actions on.
</p>


<pre class="display">
    <span class="plain">[ ActionsOnSub; trace_actions = 1; say__p = 1; "Actions listing on."; ];</span>
    <span class="plain">[ ActionsOffSub; trace_actions = 0; say__p = 1; "Actions listing off."; ];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Gonear Command. </b>GONEAR teleports the player to the vicinity of some named item.
</p>


<pre class="display">
    <span class="plain">[ GonearSub;</span>
        <span class="plain">PlayerTo(LocationOf(noun));</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Purloin Command. </b>To PURLOIN is to acquire something without reference to any rules on accessibility.
</p>


<pre class="display">
    <span class="plain">[ XPurloinSub;</span>
        <span class="plain">if (XTestMove(noun, player)) return;</span>
        <span class="plain">move noun to player; give noun moved; give noun ~concealed;</span>
        <span class="plain">say__p = 1;</span>
        <span class="plain">"[Purloined.]";</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Random Command. </b>RANDOM forces the random-number generator to a predictable seed value.
</p>


<pre class="display">
    <span class="plain">[ PredictableSub;</span>
        <span class="plain">VM_Seed_RNG(-100);</span>
        <span class="plain">say__p = 1;</span>
        <span class="plain">"[Random number generator now predictable.]";</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Relations Command. </b>RELATIONS lists the current state of the mutable relations.
</p>


<pre class="display">
    <span class="plain">[ ShowRelationsSub;</span>
    <span class="plain">IterateRelations(ShowOneRelation);</span>
    <span class="plain">];</span>

    <span class="plain">[ ShowOneRelation rel;</span>
        <span class="plain">if ((RlnGetF(rel, RR_PERMISSIONS)) &amp; (RELS_SHOW)) {</span>
            <span class="plain">(RlnGetF(rel, RR_HANDLER))(rel, RELS_SHOW);</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Responses Command. </b>RESPONSES lists the known responses.
</p>


<pre class="display">
    <span class="plain">Global suppress_text_substitution = false;</span>
    <span class="plain">[ ShowResponsesSub a i j reg wd set_mode;</span>
        <span class="plain">if (NO_RESPONSES == 0) "There are no lettered responses.";</span>
        <span class="plain">wn = 2;</span>
        <span class="plain">if (NextWordStopped() == 'now') set_mode = 1; else wn--;</span>
        <span class="plain">if (NextWordStopped() == 'set') set_mode = 2; else wn--;</span>
        <span class="plain">wd = NextWordStopped(); wn--;</span>
        <span class="plain">if (wd == 'all') reg = 0;</span>
        <span class="plain">else {</span>
            <span class="plain">reg = -1;</span>
            <span class="plain">if (wd ~= -1) reg = TryNumber(wn);</span>
            <span class="plain">if (reg &lt; 0) {</span>
                <span class="plain">say__p = 1;</span>
                <span class="plain">print "&gt;--&gt; The following sets of responses are available:^";</span>
                <span class="plain">print "    RESPONSES ALL^";</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">for (a=0, i=1, j=0: ResponseDivisions--&gt;a: a=a+3, i++) {</span>
            <span class="plain">if (ResponseDivisions--&gt;a ~= EMPTY_TEXT_PACKED) j++;</span>
            <span class="plain">if ((reg == 0) || (reg == j)) {</span>
                <span class="plain">if (ResponseDivisions--&gt;a ~= EMPTY_TEXT_PACKED) {</span>
                    <span class="plain">if (set_mode) {</span>
                        <span class="plain">print "[", (string) ResponseDivisions--&gt;a, "]^";</span>
                    <span class="plain">} else {</span>
                        <span class="plain">print (string) ResponseDivisions--&gt;a, ":^";</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
                <span class="plain">ShowResponsesRange(ResponseDivisions--&gt;(a+1), ResponseDivisions--&gt;(a+2), set_mode);</span>
            <span class="plain">}</span>
            <span class="plain">if (reg &lt; 0) {</span>
                <span class="plain">if (ResponseDivisions--&gt;a ~= EMPTY_TEXT_PACKED) {</span>
                    <span class="plain">print "    RESPONSES ", j, ": ", (string) ResponseDivisions--&gt;a, "^";</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ ShowResponsesRange from to set_mode i;</span>
        <span class="plain">say__p = 1;</span>
        <span class="plain">for (i=from: i&lt;=to: i++) {</span>
            <span class="plain">switch (set_mode) {</span>
                <span class="plain">1: print "now ";</span>
                <span class="plain">2: ;</span>
                <span class="plain">0: print "    ";</span>
            <span class="plain">}</span>
            <span class="plain">print (PrintResponse) i;</span>
            <span class="plain">switch (set_mode) {</span>
                <span class="plain">1: print " is ";</span>
                <span class="plain">2: print " is ";</span>
                <span class="plain">0: print ": ";</span>
            <span class="plain">}</span>
            <span class="plain">suppress_text_substitution = true;</span>
            <span class="plain">CarryOutActivity(PRINTING_RESPONSE_ACT, i);</span>
            <span class="plain">suppress_text_substitution = false;</span>
            <span class="plain">switch (set_mode) {</span>
                <span class="plain">1: print ";";</span>
                <span class="plain">2: print ".";</span>
            <span class="plain">}</span>
            <span class="plain">print "^";</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Rules Command. </b>RULES changes the level of rule tracing.
</p>


<pre class="display">
    <span class="plain">[ RulesOnSub;</span>
        <span class="plain">debug_rules = 1; say__p = 1;</span>
        <span class="plain">"Rules tracing now switched on. Type ~rules off~ to switch it off again,</span>
        <span class="plain">or ~rules all~ to include even rules which do not apply.";</span>
    <span class="plain">];</span>
    <span class="plain">[ RulesAllSub;</span>
        <span class="plain">debug_rules = 2; say__p = 1;</span>
        <span class="plain">"Rules tracing now switched to ~all~. Type ~rules off~ to switch it off again.";</span>
    <span class="plain">];</span>
    <span class="plain">[ RulesOffSub;</span>
        <span class="plain">debug_rules = 0; say__p = 1;</span>
        <span class="plain">"Rules tracing now switched off. Type ~rules~ to switch it on again.";</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Scenes Command. </b>SCENES switches scene-change tracing on or off, and also shows the current position.
</p>


<pre class="display">
    <span class="plain">[ ScenesOnSub;</span>
        <span class="plain">debug_scenes = 1;</span>
        <span class="plain">ShowSceneStatus(); say__p = 1;</span>
        <span class="plain">"(Scene monitoring now switched on. Type ~scenes off~ to switch it off again.)";</span>
    <span class="plain">];</span>
    <span class="plain">[ ScenesOffSub;</span>
        <span class="plain">debug_scenes = 0; say__p = 1;</span>
        <span class="plain">"(Scene monitoring now switched off. Type ~scenes~ to switch it on again.)";</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Scope Command. </b>SCOPE prints a numbered list of all objects in scope to the player.
</p>


<pre class="display">
    <span class="plain">Global x_scope_count;</span>
    <span class="plain">[ ScopeSub;</span>
        <span class="plain">x_scope_count = 0;</span>
        <span class="plain">LoopOverScope(Print_ScL, noun);</span>
        <span class="plain">if (x_scope_count == 0) "Nothing is in scope.";</span>
    <span class="plain">];</span>
    <span class="plain">[ Print_ScL obj; print_ret ++x_scope_count, ": ", (a) obj, " (", obj, ")"; ];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Showheap Command. </b>SHOWHEAP is for debugging the memory heap, and is intended for Inform
maintainers rather than users.
</p>


<pre class="display">
    <span class="plain">[ ShowHeapSub;</span>
        <span class="plain">HeapDebug();</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. ShowMe Command. </b>SHOWME is probably the most useful testing command: it shows the state of the
current room, or a named item.
</p>


<pre class="display">
    <span class="plain">[ ShowMeSub t_0;</span>
        <span class="plain">t_0 = noun;</span>
        <span class="plain">if (noun == nothing) noun = real_location;</span>
        <span class="plain">if (ShowMeRecursively(noun, 0, (noun == real_location))) {</span>
            <span class="plain">if (noun == real_location)</span>
                <span class="plain">print "* denotes things which are not in scope^";</span>
        <span class="plain">}</span>
        <span class="plain">if (t_0 ofclass K2_thing) {</span>
            <span class="plain">print "location:"; ShowRLocation(noun, true); print "^";</span>
        <span class="plain">}</span>
        <span class="plain">ShowMeDetails(t_0);</span>
    <span class="plain">];</span>

    <span class="plain">[ ShowRLocation obj top;</span>
        <span class="plain">if (obj ofclass K1_room) return;</span>
        <span class="plain">print " ";</span>
        <span class="plain">if (parent(obj)) {</span>
            <span class="plain">if (obj has worn) print "worn by ";</span>
            <span class="plain">else {</span>
                <span class="plain">if (parent(obj) has animate) print "carried by ";</span>
                <span class="plain">if (parent(obj) has container) print "in ";</span>
                <span class="plain">if (parent(obj) ofclass K1_room) print "in ";</span>
                <span class="plain">if (parent(obj) has supporter) print "on ";</span>
            <span class="plain">}</span>
            <span class="plain">print (the) parent(obj);</span>
            <span class="plain">ShowRLocation(parent(obj));</span>
        <span class="plain">} else {</span>
            <span class="plain">if (obj.component_parent) {</span>
                <span class="plain">if (top == false) print ", which is ";</span>
                <span class="plain">print "part of ", (the) obj.component_parent;</span>
                <span class="plain">ShowRLocation(obj.component_parent);</span>
            <span class="plain">}</span>
            <span class="plain">else print "out of play";</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ ShowMeRecursively obj depth f c i k;</span>
        <span class="plain">spaces(2*depth);</span>
        <span class="plain">if (f &amp;&amp; (depth &gt; 0) &amp;&amp; (TestScope(obj, player) == false)) { print "*"; c = true; }</span>
        <span class="plain">print (name) obj;</span>
        <span class="plain">if (depth &gt; 0) {</span>
            <span class="plain">if (obj.component_parent) print " (part of ", (name) obj.component_parent, ")";</span>
            <span class="plain">if (obj has worn) print " (worn)";</span>
        <span class="plain">}</span>
        <span class="plain">if (obj provides KD_Count) {</span>
            <span class="plain">k = KindHierarchy--&gt;((obj.KD_Count)*2);</span>
            <span class="plain">if ((k ~= K2_thing) || (depth==0)) {</span>
                <span class="plain">print " - ";</span>
                <span class="plain">if (k == K4_door or K5_container) {</span>
                    <span class="plain">if (obj has transparent) print "transparent ";</span>
                    <span class="plain">if (obj has locked) print "locked ";</span>
                    <span class="plain">else if (obj has open) print "open ";</span>
                    <span class="plain">else print "closed ";</span>
                <span class="plain">}</span>
                <span class="plain">print (I7_Kind_Name) k;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">print "^";</span>
        <span class="plain">if (obj.component_child) c = c | ShowMeRecursively(obj.component_child, depth+2, f);</span>
        <span class="plain">if ((depth&gt;0) &amp;&amp; (obj.component_sibling))</span>
            <span class="plain">c = c | ShowMeRecursively(obj.component_sibling, depth, f);</span>
        <span class="plain">if (child(obj)) c = c | ShowMeRecursively(child(obj), depth+2, f);</span>
        <span class="plain">if ((depth&gt;0) &amp;&amp; (sibling(obj))) c = c | ShowMeRecursively(sibling(obj), depth, f);</span>
        <span class="plain">return c;</span>
    <span class="plain">];</span>

    <span class="plain">[ AllowInShowme pr;</span>
        <span class="plain">if (pr == workflag or concealed or mentioned) rfalse;</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. Showverb Command. </b>SHOWVERB is a holdover from old I6 days, but still quite useful. It writes
out the I6 command verb grammar for the supplied command.
</p>


<pre class="display">
    <span class="plain">[ ShowVerbSub address lines meta i x;</span>
        <span class="plain">wn = 2; x = NextWordStopped();</span>
        <span class="plain">if (x == 0 || ((x-&gt;#dict_par1) &amp; 1) == 0)</span>
            <span class="plain">"Try typing ~showverb~ and then the name of a verb.";</span>
        <span class="plain">meta = ((x-&gt;#dict_par1) &amp; 2)/2;</span>
        <span class="plain">i = DictionaryWordToVerbNum(x);</span>
        <span class="plain">address = VM_CommandTableAddress(i);</span>
        <span class="plain">lines = address-&gt;0;</span>
        <span class="plain">address++;</span>
        <span class="plain">print "Verb ";</span>
        <span class="plain">if (meta) print "meta ";</span>
        <span class="plain">VM_PrintCommandWords(i);</span>
        <span class="plain">new_line;</span>
        <span class="plain">if (lines == 0) print "has no grammar lines.^";</span>
        <span class="plain">for (: lines&gt;0 : lines--) {</span>
            <span class="plain">address = UnpackGrammarLine(address);</span>
            <span class="plain">print "    "; DebugGrammarLine(); new_line;</span>
        <span class="plain">}</span>
        <span class="plain">ParaContent();</span>
    <span class="plain">];</span>

    <span class="plain">[ DebugGrammarLine pcount;</span>
        <span class="plain">print " * ";</span>
        <span class="plain">for (: line_token--&gt;pcount ~= ENDIT_TOKEN : pcount++) {</span>
            <span class="plain">if ((line_token--&gt;pcount)-&gt;0 &amp; $10) print "/ ";</span>
            <span class="plain">print (DebugToken) line_token--&gt;pcount, " ";</span>
        <span class="plain">}</span>
        <span class="plain">print "-&gt; ", (DebugAction) action_to_be;</span>
        <span class="plain">if (action_reversed) print " reverse";</span>
    <span class="plain">];</span>

    <span class="plain">[ DebugToken token;</span>
        <span class="plain">AnalyseToken(token);</span>
        <span class="plain">switch (found_ttype) {</span>
        <span class="plain">ILLEGAL_TT:</span>
            <span class="plain">print "&lt;illegal token number ", token, "&gt;";</span>
        <span class="plain">ELEMENTARY_TT:</span>
            <span class="plain">switch (found_tdata) {</span>
            <span class="plain">NOUN_TOKEN:           print "noun";</span>
            <span class="plain">HELD_TOKEN:           print "held";</span>
            <span class="plain">MULTI_TOKEN:          print "multi";</span>
            <span class="plain">MULTIHELD_TOKEN:      print "multiheld";</span>
            <span class="plain">MULTIEXCEPT_TOKEN:    print "multiexcept";</span>
            <span class="plain">MULTIINSIDE_TOKEN:    print "multiinside";</span>
            <span class="plain">CREATURE_TOKEN:       print "creature";</span>
            <span class="plain">SPECIAL_TOKEN:        print "special";</span>
            <span class="plain">NUMBER_TOKEN:         print "number";</span>
            <span class="plain">TOPIC_TOKEN:          print "topic";</span>
            <span class="plain">ENDIT_TOKEN:          print "END";</span>
            <span class="plain">}</span>
        <span class="plain">PREPOSITION_TT:</span>
            <span class="plain">print "'", (address) found_tdata, "'";</span>
        <span class="plain">ROUTINE_FILTER_TT:</span>
            <span class="plain">print "noun=Routine(", found_tdata, ")";</span>
        <span class="plain">ATTR_FILTER_TT:</span>
            <span class="plain">print (DebugAttribute) found_tdata;</span>
        <span class="plain">SCOPE_TT:</span>
            <span class="plain">print "scope=Routine(", found_tdata, ")";</span>
        <span class="plain">GPR_TT:</span>
            <span class="plain">print "Routine(", found_tdata, ")";</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Test Command. </b>TEST runs a short script of commands from the source text.
</p>


<pre class="display">
    <span class="plain">#ifdef DEBUG;</span>

    <span class="plain">#ifdef TARGET_GLULX;</span>
    <span class="plain">Constant TEST_STACK_SIZE = 128;</span>
    <span class="plain">#ifnot;</span>
    <span class="plain">Constant TEST_STACK_SIZE = 48;</span>
    <span class="plain">#endif;</span>

    <span class="plain">Array test_stack --&gt; TEST_STACK_SIZE;</span>
    <span class="plain">Global test_sp = 0;</span>
    <span class="plain">[ TestStart T R l k;</span>
        <span class="plain">if (test_sp &gt;= TEST_STACK_SIZE) "&gt;--&gt; Testing too many levels deep";</span>
        <span class="plain">test_stack--&gt;test_sp = T;</span>
        <span class="plain">test_stack--&gt;(test_sp+1) = 0;</span>
        <span class="plain">test_stack--&gt;(test_sp+3) = l;</span>
        <span class="plain">test_sp = test_sp + 4;</span>
        <span class="plain">if ((R--&gt;0) &amp;&amp; (R--&gt;0 ~= real_location)) {</span>
            <span class="plain">print "(first moving to ", (name) R--&gt;0, ")^";</span>
            <span class="plain">PlayerTo(R--&gt;0, 1);</span>
        <span class="plain">}</span>
        <span class="plain">k=1;</span>
        <span class="plain">while (R--&gt;k) {</span>
            <span class="plain">if (R--&gt;k notin player) {</span>
                <span class="plain">print "(first acquiring ", (the) R--&gt;k, ")^";</span>
                <span class="plain">move R--&gt;k to player;</span>
            <span class="plain">}</span>
            <span class="plain">k++;</span>
        <span class="plain">}</span>
        <span class="plain">print "(Testing.)^"; say__p = 1;</span>
    <span class="plain">];</span>
    <span class="plain">[ TestKeyboardPrimitive a_buffer a_table p i j l spaced ch;</span>
        <span class="plain">if (test_sp == 0) {</span>
            <span class="plain">test_stack--&gt;2 = 1;</span>
            <span class="plain">return VM_ReadKeyboard(a_buffer, a_table);</span>
        <span class="plain">}</span>
        <span class="plain">else {</span>
            <span class="plain">p = test_stack--&gt;(test_sp-4);</span>
            <span class="plain">i = test_stack--&gt;(test_sp-3);</span>
            <span class="plain">l = test_stack--&gt;(test_sp-1);</span>
            <span class="plain">print "[";</span>
            <span class="plain">print test_stack--&gt;2;</span>
            <span class="plain">print "] ";</span>
            <span class="plain">test_stack--&gt;2 = test_stack--&gt;2 + 1;</span>
            <span class="plain">style bold;</span>
            <span class="plain">while ((i &lt; l) &amp;&amp; (p-&gt;i ~= '/')) {</span>
                <span class="plain">ch = p-&gt;i;</span>
                <span class="plain">if (spaced || (ch ~= ' ')) {</span>
                    <span class="plain">if ((p-&gt;i == '[') &amp;&amp; (p-&gt;(i+1) == '/') &amp;&amp; (p-&gt;(i+2) == ']')) {</span>
                        <span class="plain">ch = '/'; i = i+2;</span>
                    <span class="plain">}</span>
                    <span class="plain">a_buffer-&gt;(j+WORDSIZE) = ch;</span>
                    <span class="plain">print (char) ch;</span>
                    <span class="plain">i++; j++;</span>
                    <span class="plain">spaced = true;</span>
                <span class="plain">} else i++;</span>
            <span class="plain">}</span>
            <span class="plain">style roman;</span>
            <span class="plain">print "^";</span>
            <span class="plain">#ifdef TARGET_ZCODE;</span>
            <span class="plain">a_buffer-&gt;1 = j;</span>
            <span class="plain">#ifnot; ! TARGET_GLULX</span>
            <span class="plain">a_buffer--&gt;0 = j;</span>
            <span class="plain">#endif;</span>
            <span class="plain">VM_Tokenise(a_buffer, a_table);</span>
            <span class="plain">if (p-&gt;i == '/') i++;</span>
            <span class="plain">if (i &gt;= l) {</span>
                <span class="plain">test_sp = test_sp - 4;</span>
            <span class="plain">} else test_stack--&gt;(test_sp-3) = i;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">#ENDIF;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15. Trace Command. </b>Another holdover from I6: TRACE sets the level of parser tracing, on a scale
of 0 (off, the default) to 5.
</p>


<pre class="display">
    <span class="plain">[ TraceOnSub; parser_trace=1; say__p = 1; "[Trace on.]"; ];</span>

    <span class="plain">[ TraceLevelSub;</span>
        <span class="plain">parser_trace = parsed_number; say__p = 1;</span>
        <span class="plain">print "[Parser tracing set to level ", parser_trace, ".]^";</span>
    <span class="plain">];</span>

    <span class="plain">[ TraceOffSub; parser_trace=0; say__p = 1; "Trace off."; ];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16. Tree Command. </b>TREE prints out the I6 object tree, though this is not always very helpful
in I7 terms. It should arguably be withdrawn, but doesn't seem to do any harm.
</p>


<pre class="display">
    <span class="plain">[ XTreeSub i;</span>
        <span class="plain">if (noun == 0) {</span>
            <span class="plain">objectloop (i)</span>
                <span class="plain">if (i ofclass Object &amp;&amp; parent(i) == 0) XObj(i);</span>
        <span class="plain">}</span>
        <span class="plain">else XObj(noun,1);</span>
    <span class="plain">];</span>

    <span class="plain">[ XObj obj f;</span>
        <span class="plain">if (parent(obj) == 0) print (name) obj; else print (a) obj;</span>
        <span class="plain">print " (", obj, ") ";</span>
        <span class="plain">if (f == 1 &amp;&amp; parent(obj) ~= 0)</span>
            <span class="plain">print "(in ", (name) parent(obj), " ", parent(obj), ")";</span>
        <span class="plain">new_line;</span>
        <span class="plain">if (child(obj) == 0) rtrue;</span>
        <span class="plain">if (obj == Class)</span>
            <span class="plain">WriteListFrom(child(obj), NEWLINE_BIT+INDENT_BIT+ALWAYS_BIT+NOARTICLE_BIT, 1);</span>
        <span class="plain">else</span>
            <span class="plain">WriteListFrom(child(obj), NEWLINE_BIT+INDENT_BIT+ALWAYS_BIT+FULLINV_BIT, 1);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17. Grammar. </b>In the old I6 parser, testing commands had their own scope hardwired in to the
code: this worked by comparing the verb command word directly against <code class="display"><span class="extract">'scope'</span></code>
and the like. That would go wrong if the testing commands were translated into
other languages, and was a crude design at best. The following scope token is
better: using this token instead of <code class="display"><span class="extract">multi</span></code> provides a noun with universal
scope (but restricted to I7 objects, so I6 pseudo-objects like <code class="display"><span class="extract">compass</span></code> are
not picked up) and able to accept multiple objects.
</p>


<pre class="display">
    <span class="plain">[ testcommandnoun obj o2;</span>
        <span class="plain">switch (scope_stage) {</span>
            <span class="plain">1: rtrue; ! allow multiple objects</span>
            <span class="plain">2: objectloop (obj)</span>
                <span class="plain">if ((obj ofclass Object) &amp;&amp; (obj provides KD_Count))</span>
                    <span class="plain">PlaceInScope(obj, true);</span>
            <span class="plain">3: print "There seems to be no such object anywhere in the model world.^";</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">Verb meta 'abstract'</span>
        <span class="plain">* scope=testcommandnoun 'to' scope=testcommandnoun -&gt; XAbstract;</span>
    <span class="plain">Verb meta 'actions'</span>
        <span class="plain">*                                           -&gt; ActionsOn</span>
        <span class="plain">* 'on'                                      -&gt; ActionsOn</span>
        <span class="plain">* 'off'                                     -&gt; ActionsOff;</span>
    <span class="plain">Verb meta 'gonear'</span>
        <span class="plain">* scope=testcommandnoun                     -&gt; Gonear;</span>
    <span class="plain">Verb meta 'purloin'</span>
        <span class="plain">* scope=testcommandnoun                     -&gt; XPurloin;</span>
    <span class="plain">Verb meta 'random'</span>
        <span class="plain">*                                           -&gt; Predictable;</span>
    <span class="plain">Verb meta 'relations'</span>
        <span class="plain">*                                           -&gt; ShowRelations;</span>
    <span class="plain">Verb meta 'responses'</span>
        <span class="plain">*                                           -&gt; ShowResponses</span>
        <span class="plain">* special                                   -&gt; ShowResponses</span>
        <span class="plain">* 'now' special                             -&gt; ShowResponses</span>
        <span class="plain">* 'set' special                             -&gt; ShowResponses;</span>
    <span class="plain">Verb meta 'rules'</span>
        <span class="plain">*                                           -&gt; RulesOn</span>
        <span class="plain">* 'all'                                     -&gt; RulesAll</span>
        <span class="plain">* 'on'                                      -&gt; RulesOn</span>
        <span class="plain">* 'off'                                     -&gt; RulesOff;</span>
    <span class="plain">Verb meta 'scenes'</span>
        <span class="plain">*                                           -&gt; ScenesOn</span>
        <span class="plain">* 'on'                                      -&gt; ScenesOn</span>
        <span class="plain">* 'off'                                     -&gt; ScenesOff;</span>
    <span class="plain">Verb meta 'scope'</span>
        <span class="plain">*                                           -&gt; Scope</span>
        <span class="plain">* scope=testcommandnoun                     -&gt; Scope;</span>
    <span class="plain">Verb meta 'showheap'</span>
        <span class="plain">*                                           -&gt; ShowHeap;</span>
    <span class="plain">Verb meta 'showme'</span>
        <span class="plain">*                                           -&gt; ShowMe</span>
        <span class="plain">* scope=testcommandnoun                     -&gt; ShowMe;</span>
    <span class="plain">Verb meta 'showverb'</span>
        <span class="plain">* special                                   -&gt; ShowVerb;</span>
    <span class="plain">Verb meta 'test'</span>
        <span class="plain">*                                           -&gt; TestScript</span>
        <span class="plain">* special                                   -&gt; TestScript;</span>
    <span class="plain">Verb meta 'trace'</span>
        <span class="plain">*                                           -&gt; TraceOn</span>
        <span class="plain">* number                                    -&gt; TraceLevel</span>
        <span class="plain">* 'on'                                      -&gt; TraceOn</span>
        <span class="plain">* 'off'                                     -&gt; TraceOff;</span>
    <span class="plain">Verb meta 'tree'</span>
        <span class="plain">*                                           -&gt; XTree</span>
        <span class="plain">* scope=testcommandnoun                     -&gt; XTree;</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="S-st.html">Back to 'StoredAction Template'</a></li><li><a href="S-tt2.html">Continue with 'Time Template'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

