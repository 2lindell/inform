<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Conditions and Phrases</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Preform-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../compiler.html">compiler tools</a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul><h2>Compiler Webs</h2><ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul><h2>Inbuild Modules</h2><ul>
<li><a href="../supervisor-module/index.html">supervisor</a></li>
</ul><h2>Inform7 Modules</h2><ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../assertions-module/index.html">assertions</a></li>
<li><a href="index.html"><span class="selectedlink">values</span></a></li>
<li><a href="../knowledge-module/index.html">knowledge</a></li>
<li><a href="../imperative-module/index.html">imperative</a></li>
<li><a href="../runtime-module/index.html">runtime</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul><h2>Inter Modules</h2><ul>
<li><a href="../bytecode-module/index.html">bytecode</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul><h2>Services</h2><ul>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../calculus-module/index.html">calculus</a></li>
<li><a href="../html-module/index.html">html</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Conditions and Phrases' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../compiler.html">Inform7</a></li><li><a href="index.html">values</a></li><li><a href="index.html#4">Chapter 4: The S-Parser</a></li><li><b>Conditions and Phrases</b></li></ul></div>
<p class="purpose">To parse the text of To... phrases, say phrases and conditions.</p>

<ul class="toc"><li><a href="4-cap.html#SP1">&#167;1. Conditions</a></li><li><a href="4-cap.html#SP7">&#167;7. Command phrases</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. Conditions. </b>In Inform syntax, a condition is an excerpt of text which measures the truth of
something. We will call it "pure" if it is self-sufficient, rather than
referring anaphorically to some implied subject. For instance, "if the bucket
is an open container" contains a pure condition, but "if an open container"
is impure. We are very wary of impure conditions, and don't allow the
logical operations or chronological restrictions to apply to them. So the
only valid impure conditions are description noun phrases.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-condition-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-cond-pure&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                     </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-descriptive-np&gt;</span><span class="Preform-plain-syntax">                  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2.  </b>Now for pure conditions. Note that logical "and" and "or" are implemented
directly right here, rather than being phrases defined in the Standard Rules,
and that they aren't the same as the "and" and "or" used a list dividers.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-cond-pure&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">(</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-cond-pure&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">)</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                 </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-cond-pure&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">,</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">and</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-cond-pure&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Conditions::new_LOGICAL_AND(RP[1], RP[2]) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-cond-pure&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">and</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-cond-pure&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">   </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Conditions::new_LOGICAL_AND(RP[1], RP[2]) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-cond-pure&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">,</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">or</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-cond-pure&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Conditions::new_LOGICAL_OR(RP[1], RP[2]) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-cond-pure&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">or</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-cond-pure&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Conditions::new_LOGICAL_OR(RP[1], RP[2]) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-cond-with-chronology&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">          </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-cond-atomic&gt;</span><span class="Preform-plain-syntax">                     </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3.  </b>Chronological restrictions include, for instance,
</p>

<blockquote>
    <p>if the gate is open for the first time, ...</p>
</blockquote>

<p class="commentary">where the condition is divided as
</p>

<blockquote>
    <p>if the gate is open / for the first time</p>
</blockquote>

<p class="commentary">and &lt;s-cond-atomic&gt; is used to parse the first half. While it's possible
to express this in Preform grammar, the result doesn't run quickly, so the
following implements this as a hand-coded nonterminal instead.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-cond-with-chronology&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    #</span><span class="Preform-identifier-syntax">ifdef</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">IF_MODULE</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">time_period</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">tp</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Occurrence::parse</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">tp</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">wording</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">RW</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Occurrence::unused_wording</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">tp</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> ((</span><span class="Preform-identifier-syntax">Wordings::nonempty</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">RW</span><span class="Preform-plain-syntax">)) &amp;&amp; (</span><span class="Preform-function-syntax">&lt;s-cond-atomic&gt;</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">RW</span><span class="Preform-plain-syntax">))) {</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">atomic_cnd</span><span class="Preform-plain-syntax"> = </span><span class="Preform-function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">atomic_cnd</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">Node::is</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">CONSTANT_NT</span><span class="Preform-plain-syntax">)) {</span>
<span class="Preform-plain-syntax">                </span><span class="Preform-identifier-syntax">action_pattern</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">ap</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">ARvalues::to_action_pattern</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">                </span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">AConditions::new_action_TEST_VALUE</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">ap</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">            }</span>
<span class="Preform-plain-syntax">            ==&gt; { -, </span><a href="2-cnd.html#SP10" class="function-link"><span class="Preform-function-syntax">Conditions::attach_historic_requirement</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">tp</span><span class="Preform-plain-syntax">) };</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">        }</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    #</span><span class="Preform-identifier-syntax">endif</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4.  </b>The syntax for the logical operation "not" is more complicated, because
it only sometimes work by simply preceding the text with "not". Consider
this, for instance:
</p>

<blockquote>
    <p>if not we are carrying the torch, ...</p>
</blockquote>

<p class="commentary">As a result, we can't handle negation in &lt;s-cond-pure&gt;, and have to
work into the grammar below on a case by case basis. And where we do allow
"not", we always check the positive sense first &mdash; people do sometimes
create phrase options like "not printing anything", for example, which
begin with the word "not".
</p>

<p class="commentary">As a condition, an action pattern is implicitly considered as a test of
what the current action is:
</p>

<blockquote>
    <p>if examining an open door, ...</p>
</blockquote>

<p class="commentary">This wouldn't work so well for the past tense form:
</p>

<blockquote>
    <p>if examined an open door, ...</p>
</blockquote>

<p class="commentary">because it seems too clunky as neither quite active nor passive. Who examined
the open door? So Inform uses the following version instead:
</p>

<blockquote>
    <p>if we have examined an open door, ...</p>
</blockquote>

<p class="commentary">thus adopting the "science we". Not very elegant, but the alternatives were
difficult to parse. "We are" is allowed for consistency's sake, but does
nothing, i.e., "we are taking" and "taking" are synonymous. Translators
to other languages may want to find more elegant solutions.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-cond-atomic&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-phrase-option-in-use&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                      </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">not</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-phrase-option-in-use&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Conditions::negate(RP[1]) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-nonexistential-phrase-to-decide&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">           </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-past-action-pattern-as-condition&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">          </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-past-action-pattern-as-negated-condition&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Conditions::negate(RP[1]) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-action-pattern-as-condition&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">               </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-action-pattern-as-negated-condition&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">       </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Conditions::negate(RP[1]) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-sentence&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-existential-phrase-to-decide&gt;</span><span class="Preform-plain-syntax">                </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5.  </b>As before, we try to get better sensitivity to ambiguities by dividing the
test for a phrase-to-decide into two, so that the following is used at a
different point if the excerpt begins "there is" than if it doesn't. The
point of this is that some phrases to decide have wording which coincides
with a description, and in general the phrase should win, but in the case
of "there is" we make the presumption that the author intends a sentence
testing the existence of something.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-nonexistential-phrase-to-decide&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;existential-verb-phrase&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">   </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { fail }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-phrase-to-decide&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">not</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-phrase-to-decide&gt;</span><span class="Preform-plain-syntax">      </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Conditions::negate(RP[1]) }</span>

<span class="Preform-function-syntax">&lt;s-existential-phrase-to-decide&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">^&lt;existential-verb-phrase&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { fail }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-phrase-to-decide&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">not</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-phrase-to-decide&gt;</span><span class="Preform-plain-syntax">      </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Conditions::negate(RP[1]) }</span>

<span class="Preform-function-syntax">&lt;existential-verb-phrase&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-existential&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">is/are</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">...</span>

<span class="Preform-function-syntax">&lt;s-phrase-to-decide&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Lexicon::retrieve</span><span class="Preform-plain-syntax">(</span><span class="Preform-constant-syntax">COND_PHRASE_MC</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Node::new_with_words</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">PHRASE_TO_DECIDE_VALUE_NT</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><a href="4-cap.html#SP10" class="function-link"><span class="Preform-function-syntax">SPCond::add_ilist</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">tval</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Node::new_with_words</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">TEST_VALUE_NT</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">tval</span><span class="Preform-plain-syntax">-&gt;</span><span class="Preform-identifier-syntax">down</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">        ==&gt; { -, </span><span class="Preform-identifier-syntax">tval</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6.  </b>The following only matches the phrase option names for the phrase currently
being compiled; all others are out of scope.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-phrase-option-in-use&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">phrase_being_compiled</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">int</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">i</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Routines::ToPhrases::parse_phrase_option_used</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">phrase_being_compiled</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">i</span><span class="Preform-plain-syntax"> &gt;= </span><span class="Preform-constant-syntax">0</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">            ==&gt; { -, </span><a href="2-cnd.html#SP9" class="function-link"><span class="Preform-function-syntax">Conditions::new_TEST_PHRASE_OPTION</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">i</span><span class="Preform-plain-syntax">) };</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">        }</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7. Command phrases. </b>The final clutch of nonterminals in the S-grammar handles individual commands,
written in their semicolon-divided list in the body of a rule or "To..."
definition. For instance, in the not very sensible rule:
</p>

<blockquote>
    <p>Instead of jumping: now the score is 10; say "Greetings!" instead.</p>
</blockquote>

<p class="commentary">Inform will use &lt;s-command&gt; to parse the text of the two commands in the rule
body. &lt;s-command&gt; parses the text with little attempt to judge whether the
parameters of the phrase match; it simply records possibilities for
typechecking to choose between much later on.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-command&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">(</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-command&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">)</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                            </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-to-phrase&gt;</span><span class="Preform-plain-syntax">                                </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>

<span class="Preform-function-syntax">&lt;s-say-command&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">(</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-say-command&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">)</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                        </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-adaptive-text&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                          </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-text-substitution&gt;</span><span class="Preform-plain-syntax">                        </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>

<span class="Preform-function-syntax">&lt;s-adaptive-text&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-local-variable&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                         </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { fail }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;adaptive-verb&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">verb</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                       </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, SPCond::say_verb(RP[1], R[1], NULL, W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;adaptive-adjective&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">adjective</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">             </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, SPCond::say_adjective(RP[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;adaptive-verb&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                            </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, SPCond::say_verb(RP[1], R[1], NULL, W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;modal-verb&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;adaptive-verb-infinitive&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">verb</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cap.html#SP7_3" class="named-paragraph-link"><span class="named-paragraph">Annotate the verb with a modal</span><span class="named-paragraph-number">7.3</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;modal-verb&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;adaptive-verb-infinitive&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-cap.html#SP7_3" class="named-paragraph-link"><span class="named-paragraph">Annotate the verb with a modal</span><span class="named-paragraph-number">7.3</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;adaptive-adjective&gt;</span><span class="Preform-plain-syntax">                         </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, SPCond::say_adjective(RP[1], W) }</span>

<span class="Preform-function-syntax">&lt;adaptive-adjective&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">Projects::get_language_of_play</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">Task::project</span><span class="Preform-plain-syntax">()) == </span><span class="Preform-identifier-syntax">DefaultLanguage::get</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">NULL</span><span class="Preform-plain-syntax">))</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">FALSE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">adjective</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">adj</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">LOOP_OVER</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">adj</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">adjective</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">wording</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">AW</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Clusters::get_form_general</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">adj</span><span class="Preform-plain-syntax">-&gt;</span><span class="Preform-identifier-syntax">adjective_names</span><span class="Preform-plain-syntax">,</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-identifier-syntax">Projects::get_language_of_play</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">Task::project</span><span class="Preform-plain-syntax">()), </span><span class="Preform-constant-syntax">1</span><span class="Preform-plain-syntax">, -1);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">Wordings::match</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">AW</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">)) {</span>
<span class="Preform-plain-syntax">            ==&gt; { </span><span class="Preform-identifier-syntax">FALSE</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">adj</span><span class="Preform-plain-syntax">};</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">        }</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP7_1" class="paragraph-anchor"></a><b>&#167;7.1.  </b>"To..." phrases are easy, or at least, easy to delegate:
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-to-phrase&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Lexicon::retrieve</span><span class="Preform-plain-syntax">(</span><span class="Preform-constant-syntax">VOID_PHRASE_MC</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Node::new_with_words</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">PHRASE_TO_DECIDE_VALUE_NT</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><a href="4-cap.html#SP10" class="function-link"><span class="Preform-function-syntax">SPCond::add_ilist</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        ==&gt; { -, </span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP7_2" class="paragraph-anchor"></a><b>&#167;7.2.  </b></p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-text-substitution&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Lexicon::retrieve</span><span class="Preform-plain-syntax">(</span><span class="Preform-constant-syntax">SAY_PHRASE_MC</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Node::new_with_words</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">PHRASE_TO_DECIDE_VALUE_NT</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><a href="4-cap.html#SP10" class="function-link"><span class="Preform-function-syntax">SPCond::add_ilist</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        ==&gt; { -, </span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP7_3" class="paragraph-anchor"></a><b>&#167;7.3.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Annotate the verb with a modal</span><span class="named-paragraph-number">7.3</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">neg</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">R</span><span class="plain-syntax">[1]) || (</span><span class="identifier-syntax">R</span><span class="plain-syntax">[2])) </span><span class="identifier-syntax">neg</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    ==&gt; { -, </span><a href="4-cap.html#SP9" class="function-link"><span class="function-syntax">SPCond::say_verb</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2], </span><span class="identifier-syntax">neg</span><span class="plain-syntax">, </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">W</span><span class="plain-syntax">) };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-cap.html#SP7">&#167;7</a> (twice).</li></ul>
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8.  </b>Invocation nodes for adaptive-text adjectives hold references to their masculine
singulars.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">SPCond::say_adjective</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">SPCond::say_adjective</span></span>:<br/><a href="4-cap.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">aph</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new_with_words</span><span class="plain-syntax">(</span><span class="identifier-syntax">PHRASE_TO_DECIDE_VALUE_NT</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">inv</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Invocations::new</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Invocations::set_word_range</span><span class="plain-syntax">(</span><span class="identifier-syntax">inv</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Invocations::set_adjective</span><span class="plain-syntax">(</span><span class="identifier-syntax">inv</span><span class="plain-syntax">, </span><span class="identifier-syntax">aph</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">INVOCATION_LIST_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Invocations::add_to_list</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">, </span><span class="identifier-syntax">inv</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">spec</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9.  </b>Invocation nodes for adaptive-text verbs hold references to their first
person plurals.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">SPCond::say_verb</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">SPCond::say_verb</span></span>:<br/><a href="4-cap.html#SP7">&#167;7</a>, <a href="4-cap.html#SP7_3">&#167;7.3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">verb_conjugation</span><span class="plain-syntax"> *</span><span class="identifier-syntax">vc</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">neg</span><span class="plain-syntax">, </span><span class="identifier-syntax">verb_conjugation</span><span class="plain-syntax"> *</span><span class="identifier-syntax">mvc</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new_with_words</span><span class="plain-syntax">(</span><span class="identifier-syntax">PHRASE_TO_DECIDE_VALUE_NT</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">inv</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Invocations::new</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Invocations::set_word_range</span><span class="plain-syntax">(</span><span class="identifier-syntax">inv</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Invocations::set_verb_conjugation</span><span class="plain-syntax">(</span><span class="identifier-syntax">inv</span><span class="plain-syntax">, </span><span class="identifier-syntax">vc</span><span class="plain-syntax">, </span><span class="identifier-syntax">mvc</span><span class="plain-syntax">, </span><span class="identifier-syntax">neg</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">INVOCATION_LIST_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Invocations::add_to_list</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">, </span><span class="identifier-syntax">inv</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">spec</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10.  </b>There are three basic kinds of phrase: those used as commands
(i.e., void procedures in C terms), those used as values (returning values
other than true/false) and those used as conditions (returning true or false).
These are stored in a way making basically the same use of a specification's
references, so all three are handled by the following code.
</p>

<p class="commentary">The usage of a phrase is called an "invocation" of it, and sometimes more than
one invocation appears, for two reasons: a "say" phrase can contain a sequence
of invocations to follow, one after another; and sometimes it will only be clear
at run-time which of several possible definitions is to apply, so the
possibilities will all be invoked.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">SPCond::add_ilist</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">SPCond::add_ilist</span></span>:<br/><a href="4-cap.html#SP5">&#167;5</a>, <a href="4-cap.html#SP7_1">&#167;7.1</a>, <a href="4-cap.html#SP7_2">&#167;7.2</a><br/>Type Expressions and Values - <a href="4-teav.html#SP19">&#167;19</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="4-cap.html#SP10_1" class="named-paragraph-link"><span class="named-paragraph">Build the invocation list</span><span class="named-paragraph-number">10.1</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">len</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Invocations::length_of_list</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">len</span><span class="plain-syntax"> &gt;= </span><span class="identifier-syntax">MAX_INVOCATIONS_PER_PHRASE</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="4-cap.html#SP10_2" class="named-paragraph-link"><span class="named-paragraph">Issue overcomplicated phrase problem message</span><span class="named-paragraph-number">10.2</span></a></span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">len</span><span class="plain-syntax"> &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Invocations::sort_list</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10_1" class="paragraph-anchor"></a><b>&#167;10.1.  </b>There are multiple invocations, each produced from another node in the
S-tree as we run sideways through the alternative readings.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Build the invocation list</span><span class="named-paragraph-number">10.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (; </span><span class="identifier-syntax">p</span><span class="plain-syntax">; </span><span class="identifier-syntax">p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_alternative</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">phrase</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ph</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RETRIEVE_POINTER_phrase</span><span class="plain-syntax">(</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Lexicon::get_data</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_meaning</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">)));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">inv</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Phrases::Parser::parse_against</span><span class="plain-syntax">(</span><span class="identifier-syntax">ph</span><span class="plain-syntax">, </span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Phrases::TypeData::is_the_primordial_say</span><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">ph</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">type_data</span><span class="plain-syntax">)) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            (</span><a href="2-rvl.html#SP21" class="function-link"><span class="function-syntax">Rvalues::is_CONSTANT_of_kind</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Invocations::get_token_as_parsed</span><span class="plain-syntax">(</span><span class="identifier-syntax">inv</span><span class="plain-syntax">, </span><span class="constant-syntax">0</span><span class="plain-syntax">), </span><span class="identifier-syntax">K_text</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">INVOCATION_LIST_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Node::set_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Invocations::add_to_list</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">, </span><span class="identifier-syntax">inv</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-cap.html#SP10">&#167;10</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP10_2" class="paragraph-anchor"></a><b>&#167;10.2.  </b>This problem used to be experienced for long say phrases in a situation
where many kinds of value have been created, so that "say V" for a value V
was heavily ambiguous &mdash; pumping up the number of invocations generated. In
2010, the introduction of generics into Inform made it possible to define
"say V" just once, and after that it became so difficult to reach this
limit that we were unable to construct a test case for it.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue overcomplicated phrase problem message</span><span class="named-paragraph-number">10.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="comment-syntax"> truncate to just one</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::quote_source</span><span class="plain-syntax">(1, </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::handmade_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">BelievedImpossible</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::issue_problem_segment</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="string-syntax">"In %1, the phrase being constructed is just too "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"long and complicated, and will need to be simplified. (This "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"sometimes happens with a 'say', or a piece of text, containing "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"many text substitutions in succession: if so, it may be worth "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"defining some more powerful text substitutions - for instance "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"writing 'To say super-duper: ...', giving the gory details, "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"and then using the single substitution '[super-duper]' in the "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"original phrase."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::issue_problem_end</span><span class="plain-syntax">();</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-cap.html#SP10">&#167;10</a>.</li></ul>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="4-varc.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-vm.html">1</a></li><li class="progresschapter"><a href="2-spc.html">2</a></li><li class="progresschapter"><a href="3-pl.html">3</a></li><li class="progresscurrentchapter">4</li><li class="progresssection"><a href="4-ets.html">ets</a></li><li class="progresssection"><a href="4-cad.html">cad</a></li><li class="progresssection"><a href="4-teav.html">teav</a></li><li class="progresssection"><a href="4-varc.html">varc</a></li><li class="progresscurrent">cap</li><li class="progressnextoff">&#10095;</li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

