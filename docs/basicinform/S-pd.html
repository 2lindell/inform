<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>S/prm</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of 'S/pd' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">basicinform 1</a></li><li><b>Phrase Definitions</b></li></ul><p class="purpose">The phrases making up the Inform language, and in terms of which all other phrases and rules are defined.</p>

<ul class="toc"><li><a href="#SP4">&#167;4. Say phrases</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1.  </b>All phrases of the Inform language itself are defined here. The Standard
Rules extension adds more, specialised for interactive fiction creation,
but the bones of the language are here. For example, we will define what
the plus sign will mean, and how Inform should compile "say N in words",
where N is a number. Inform has no phrase definitions built in, as such;
but it does contain assumptions about control structures such as "say ...",
"repeat ...", "let ...", "otherwise ..." and so on will behave. Those, we
would not be able to redefine in fundamentally different ways. In most
respects, though, we are more or less free to define any language we like.
</p>

<p class="inwebparagraph">At first sight, these phrase definitions look little more than simple
transliterations, and this was one source of early criticism of Inform 7.
Phrases appeared to have very simplistic definitions, with the natural
language simply being a verbose description of obviously equivalent C-like
code. However, the simplicity is misleading, because the definitions below
tend to conceal where the complexity of the translation process suddenly
increases. If the preamble includes "(c - condition)", and the definition
includes the expansion <code class="display"><span class="extract">{c}</span></code>, then the text forming c is translated in a way
much more profound than any simple substitution process could describe.
Type-checking also complicates the code produced below, since Inform
automatically generates the code needed to perform run-time type checking at
any point where doubt remains as to the phrase definition which must be used.
</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>Many of these phrases have what are called inline definitions, written
using the <code class="display"><span class="extract">(-</span></code> and <code class="display"><span class="extract">-)</span></code> notation. Non-inline phrases are compiled as
functions, which are then called when they need to be used. For example,
"To say the magic number: say 17." compiles to a function, and when
another phrase includes the instruction "say the magic number", that
instruction compiles a call to this function. But an inline phrase
instead generates Inter instructions to do something directly. (That
something may in fact still be just a function call, but not always.)
The Inter code to be generated is expressed by the contents of the
definition between the <code class="display"><span class="extract">(-</span></code> and <code class="display"><span class="extract">-)</span></code> markers, and is written in a
marked-up form of Inform 6 notation. This is much more concise and
readable than if the Inter code were written out longhand, but it may
give the misleading impression that Inform inline definitions can only
produce Inform 6 code. That is not so: they produce Inter code, which
can then be translated as needed.
</p>

<p class="inwebparagraph">Most of the definitions here also have annotations to positions in the
main Inform dcumentation: for example, <code class="display"><span class="extract">(documented at phs_s)</span></code>. This has
no effect on the code compiled, and is used only when Inform generates
certain problem messages; if the source text misuses the phrase, the problem
can then give a reference to the relevant documentation. <code class="display"><span class="extract">phs_s</span></code> is a
typical example of a "documentation token", and is only a label. See the
source of the Inform documentation for how this markup is done.
</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>Unit tests for the phrases below have test case names beginning <code class="display"><span class="extract">BIP-</span></code>,
which stands for "Basic Inform phrase". In fact, these come in pairs, one for
each virtual machine we customarily generate code to. For example, <code class="display"><span class="extract">BIP-Say</span></code>
tests the "say" phrase for the Z-machine target, and <code class="display"><span class="extract">BIP-Say-G</span></code> does the same
for the Glulx target. But in the commentary below, test cases will be listed
only once.
</p>

<p class="inwebparagraph">It follows that running <code class="display"><span class="extract">intest -from inform7 BIP-%c+</span></code> will test all of
these phrases on all platforms, since this regular expression matches all
test case names beginning with "BIP-".
</p>


<pre class="display">
    <span class="plain">Part Two - Phrasebook</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Say phrases. </b>We begin with saying phrases: the very first phrase to exist is the one
printing a single value &mdash; literal text, a number, a time, an object, or
really almost anything, since the vast majority of kinds in Inform are
sayable. There used to be separate definitions for saying text, numbers
and unicode characters here, but they were removed in June 2015 as being
redundant. Though they did no harm, they made some problem messages longer
than necessary by obliging them to cite a longer list of possible readings
of a misread phrase.
</p>

<p class="inwebparagraph">The three inline definitions here neatly demonstrate the three sorts of
things which appear inside <code class="display"><span class="extract">(-</span></code> and <code class="display"><span class="extract">-)</span></code>. The definition for "To say s",
which looks more familiar as the "[s]" text substitution, is straightforwardly
Inform 6 notation. The definition for "To say (something - number) in words"
is I6 notation except for the <code class="display"><span class="extract">{something}</span></code> part in braces: this expands
to the value used by the code causing compilation. For example, if the code
to be compiled is "say 17 in words" then <code class="display"><span class="extract">{something}</span></code> here would expand to
the constant 17. The definition for "To say (val)" is much more complex than
I6 notation could convey, and so a more complex escape notation is needed,
<code class="display"><span class="extract">{-say:val:K}</span></code>, which tells Inform o compile code which will say <code class="display"><span class="extract">val</span></code> with
whatever method is appropriate to its kind <code class="display"><span class="extract">K</span></code>. For documentation on these
escape notations, see the core Inform source code.
</p>

<p class="inwebparagraph">The global variable <code class="display"><span class="extract">say__n</span></code> tracks the last number printed. For the "in
words" definition, we need to set it by hand, since Inform doesn't otherwise
realise that number-printing is what we are doing here. For definitions of
functions such as <code class="display"><span class="extract">STextSubstitution</span></code>, see the source for the <code class="display"><span class="extract">basic_inform</span></code>
template library, which is also where <code class="display"><span class="extract">say__n</span></code> is defined.
</p>

<p class="inwebparagraph">See test case <code class="display"><span class="extract">BIP-Say</span></code>.
</p>


<pre class="display">
    <span class="plain">Section 1 - Saying Values</span>

    <span class="plain">To say (val - sayable value of kind K)</span>
        <span class="plain">(documented at ph_say):</span>
        <span class="plain">(- {-say:val:K} -).</span>
    <span class="plain">To say (something - number) in words</span>
        <span class="plain">(documented at phs_numwords):</span>
        <span class="plain">(- print (number) say__n=({something}); -).</span>
    <span class="plain">To say s</span>
        <span class="plain">(documented at phs_s):</span>
        <span class="plain">(- STextSubstitution(); -).</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>"Showme" is a debugging version of "say" which can print some version of
the value, and the kind, of just about anything.
</p>

<p class="inwebparagraph">See test case <code class="display"><span class="extract">BIP-Showme</span></code>.
</p>


<pre class="display">
    <span class="plain">To showme (val - value)</span>
        <span class="plain">(documented at ph_showme):</span>
        <span class="plain">(- {-show-me:val} -).</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>Objects are the most difficult things to say, because of the elaborate
apparatus for managing their natural-language representations. In particular,
we need to say them with a definite or indefinite article, which can either
be capitalised or not, and as part of that we need to keep track of whether
they are proper nouns; in languages other than English, there are also gender
and case to worry about.
</p>

<p class="inwebparagraph">Note that "To say ..." phrases are case sensitive on the first word, so that
"to say a something" and "to say A something" are different.
</p>

<p class="inwebparagraph">A curiosity of Inform 6's syntax, arising I think mostly from the need to
save property memory in "Curses" (1993), the work of IF for which Inform 1
had been created, is that it lacks a <code class="display"><span class="extract">print (A) ...</span></code> statement. The omission
is made good by using a routine in the template library instead.
</p>

<p class="inwebparagraph">See test case <code class="display"><span class="extract">BIP-SayName</span></code>.
</p>


<pre class="display">
    <span class="plain">Section 2 - Saying Names</span>

    <span class="plain">To say a (something - object)</span>
        <span class="plain">(documented at phs_a):</span>
        <span class="plain">(- print (a) {something}; -).</span>
    <span class="plain">To say an (something - object)</span>
        <span class="plain">(documented at phs_a):</span>
        <span class="plain">(- print (a) {something}; -).</span>
    <span class="plain">To say A (something - object)</span>
        <span class="plain">(documented at phs_A):</span>
        <span class="plain">(- CIndefArt({something}); -).</span>
    <span class="plain">To say An (something - object)</span>
        <span class="plain">(documented at phs_A):</span>
        <span class="plain">(- CIndefArt({something}); -).</span>
    <span class="plain">To say the (something - object)</span>
        <span class="plain">(documented at phs_the):</span>
        <span class="plain">(- print (the) {something}; -).</span>
    <span class="plain">To say The (something - object)</span>
        <span class="plain">(documented at phs_The):</span>
        <span class="plain">(- print (The) {something}; -).</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>Now for "[if ...]", which expands into a rather assembly-language-like
usage of <code class="display"><span class="extract">jump</span></code> statements, I6's form of goto. For instance, the text
"[if the score is 10]It's ten![otherwise]It's not ten, alas." compiles
thus:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">if (~~(score == 10)) jump L_Say3;</span>
        <span class="plain">    ...</span>
        <span class="plain">jump L_SayX2; .L_Say3;</span>
        <span class="plain">    ...</span>
        <span class="plain">.L_Say4; .L_SayX2;</span>
</pre>

<p class="inwebparagraph">Though labels actually have local namespaces in I6 routines, we use
globally unique labels throughout the whole program: compiling the same
phrase again would involve say labels 5 and 6 and "say exit" label 3.
This example text demonstrates the reason we <code class="display"><span class="extract">jump</span></code> about, rather than
making use of <code class="display"><span class="extract">if... else...</span></code> and bracing groups of statements: it is legal
in I7 either to conclude with or to omit the "[end if]". (If statements
in I6 compile to jump instructions in any event, and on our virtual
machines there is no speed penalty for branches.) We also need the same
definitions to accommodate what amounts to a switch statement. The trickier
text "[if the score is 10]It's ten![otherwise if the score is 8]It's
eight?[otherwise]It's not ten, alas." comes out as:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">if (~~(score == 10)) jump L_Say5;</span>
        <span class="plain">    ...</span>
        <span class="plain">jump L_SayX3; .L_Say5; if (~~(score == 8)) jump L_Say6;</span>
        <span class="plain">    ...</span>
        <span class="plain">jump L_SayX3; .L_Say6;</span>
        <span class="plain">    ...</span>
        <span class="plain">.L_Say7; .L_SayX3;</span>
</pre>

<p class="inwebparagraph">In either form of the construct, control passes into at most one of the
pieces of text. The terminal labels (the two on the final line) are
automatically generated; often &mdash; when there is a simple "otherwise" or
"end if" to conclude the construct &mdash; they are not needed, but labels are
quick to process in I6, are soon discarded from I6's memory when not needed
any more, and compile no code.
</p>

<p class="inwebparagraph">We assume in each case that the next say label number to be free is always
the start of the next block, and that the next say exit label number is always
the one at the end of the current construct. This is true because NI does
not allow "say if" to be nested.
</p>


<pre class="display">
    <span class="plain">Section SR5/1/3 - Saying - Say if and otherwise</span>

    <span class="plain">To say if (c - condition)</span>
        <span class="plain">(documented at phs_if): (-</span>
        <span class="plain">if (~~({c})) jump {-label:Say};</span>
            <span class="plain">-).</span>
    <span class="plain">To say unless (c - condition)</span>
        <span class="plain">(documented at phs_unless): (-</span>
        <span class="plain">if ({c}) jump {-label:Say};</span>
            <span class="plain">-).</span>
    <span class="plain">To say otherwise/else if (c - condition)</span>
        <span class="plain">(documented at phs_elseif): (-</span>
        <span class="plain">jump {-label:SayX}; .{-label:Say}{-counter-up:Say}; if (~~({c})) jump {-label:Say};</span>
            <span class="plain">-).</span>
    <span class="plain">To say otherwise/else unless (c - condition)</span>
        <span class="plain">(documented at phs_elseunless): (-</span>
        <span class="plain">jump {-label:SayX}; .{-label:Say}{-counter-up:Say}; if ({c}) jump {-label:Say};</span>
            <span class="plain">-).</span>
    <span class="plain">To say otherwise</span>
        <span class="plain">(documented at phs_otherwise): (-</span>
        <span class="plain">jump {-label:SayX}; .{-label:Say}{-counter-up:Say};</span>
            <span class="plain">-).</span>
    <span class="plain">To say else</span>
        <span class="plain">(documented at phs_otherwise): (-</span>
        <span class="plain">jump {-label:SayX}; .{-label:Say}{-counter-up:Say};</span>
            <span class="plain">-).</span>
    <span class="plain">To say end if</span>
        <span class="plain">(documented at phs_endif): (-</span>
        <span class="plain">.{-label:Say}{-counter-up:Say}; .{-label:SayX}{-counter-up:SayX};</span>
            <span class="plain">-).</span>
    <span class="plain">To say end unless</span>
        <span class="plain">(documented at phs_endunless): (-</span>
        <span class="plain">.{-label:Say}{-counter-up:Say}; .{-label:SayX}{-counter-up:SayX};</span>
            <span class="plain">-).</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>The other control structure: the random variations form of saying. This
part of the Standard Rules was in effect contributed by the community: it
reimplements a form of Jon Ingold's former extension Text Variations, which
itself built on code going back to the days of I6.
</p>

<p class="inwebparagraph">The head phrase here has one of the most complicated definitions in the SR,
but is actually documented fairly explicitly in the Extensions chapter
of "Writing with Inform", so we won't repeat all that here. Essentially
it uses its own allocated cell of storage in an array to remember a state
between uses, and compiles as a switch statement based on the current state.
</p>


<pre class="display">
    <span class="plain">Section SR5/1/4 - Saying - Say one of</span>

    <span class="plain">To say one of -- beginning say_one_of (documented at phs_oneof): (-</span>
        <span class="plain">{-counter-makes-array:say_one_of}</span>
        <span class="plain">{-counter-makes-array:say_one_flag}</span>
        <span class="plain">if ({-counter-storage:say_one_flag}--&gt;{-counter:say_one_flag} == false) {</span>
            <span class="plain">{-counter-storage:say_one_of}--&gt;{-counter:say_one_of} = {-final-segment-marker}({-counter-storage:say_one_of}--&gt;{-counter:say_one_of}, {-segment-count});</span>
            <span class="plain">{-counter-storage:say_one_flag}--&gt;{-counter:say_one_flag} = true;</span>
        <span class="plain">}</span>
        <span class="plain">if (say__comp == false) {-counter-storage:say_one_flag}--&gt;{-counter:say_one_flag}{-counter-up:say_one_flag} = false;</span>
        <span class="plain">switch (({-counter-storage:say_one_of}--&gt;{-counter:say_one_of}{-counter-up:say_one_of})%({-segment-count}+1)-1)</span>
    <span class="plain">{-open-brace}</span>
            <span class="plain">0: -).</span>
    <span class="plain">To say or -- continuing say_one_of (documented at phs_or):</span>
        <span class="plain">(- @nop; {-segment-count}: -).</span>
    <span class="plain">To say at random -- ending say_one_of with marker I7_SOO_RAN (documented at phs_random):</span>
        <span class="plain">(- {-close-brace} -).</span>
    <span class="plain">To say purely at random -- ending say_one_of with marker I7_SOO_PAR (documented at phs_purelyrandom):</span>
        <span class="plain">(- {-close-brace} -).</span>
    <span class="plain">To say then at random -- ending say_one_of with marker I7_SOO_TRAN (documented at phs_thenrandom):</span>
        <span class="plain">(- {-close-brace} -).</span>
    <span class="plain">To say then purely at random -- ending say_one_of with marker I7_SOO_TPAR (documented at phs_thenpurelyrandom):</span>
        <span class="plain">(- {-close-brace} -).</span>
    <span class="plain">To say sticky random -- ending say_one_of with marker I7_SOO_STI (documented at phs_sticky):</span>
        <span class="plain">(- {-close-brace} -).</span>
    <span class="plain">To say as decreasingly likely outcomes -- ending say_one_of with marker I7_SOO_TAP (documented at phs_decreasing):</span>
        <span class="plain">(- {-close-brace} -).</span>
    <span class="plain">To say in random order -- ending say_one_of with marker I7_SOO_SHU (documented at phs_order):</span>
        <span class="plain">(- {-close-brace} -).</span>
    <span class="plain">To say cycling -- ending say_one_of with marker I7_SOO_CYC (documented at phs_cycling):</span>
        <span class="plain">(- {-close-brace} -).</span>
    <span class="plain">To say stopping -- ending say_one_of with marker I7_SOO_STOP (documented at phs_stopping):</span>
        <span class="plain">(- {-close-brace} -).</span>

    <span class="plain">To say first time -- beginning say_first_time (documented at phs_firsttime):</span>
        <span class="plain">(- {-counter-makes-array:say_first_time}</span>
        <span class="plain">if ((say__comp == false) &amp;&amp; (({-counter-storage:say_first_time}--&gt;{-counter:say_first_time}{-counter-up:say_first_time})++ == 0)) {-open-brace}</span>
            <span class="plain">-).</span>
    <span class="plain">To say only -- ending say_first_time (documented at phs_firsttime):</span>
        <span class="plain">(- {-close-brace} -).</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>For an explanation of the paragraph breaking algorithm, see the template
file "Printing.i6t".
</p>


<pre class="display">
    <span class="plain">Section SR5/1/5 - Saying - Paragraph control</span>

    <span class="plain">To say line break -- running on</span>
        <span class="plain">(documented at phs_linebreak):</span>
        <span class="plain">(- new_line; -).</span>
    <span class="plain">To say no line break -- running on</span>
        <span class="plain">(documented at phs_nolinebreak): do nothing.</span>
    <span class="plain">To say conditional paragraph break -- running on</span>
        <span class="plain">(documented at phs_condparabreak):</span>
        <span class="plain">(- DivideParagraphPoint(); -).</span>
    <span class="plain">To say command clarification break -- running on</span>
        <span class="plain">(documented at phs_clarifbreak):</span>
        <span class="plain">(- CommandClarificationBreak(); -).</span>
    <span class="plain">To say paragraph break -- running on</span>
        <span class="plain">(documented at phs_parabreak):</span>
        <span class="plain">(- DivideParagraphPoint(); new_line; -).</span>
    <span class="plain">To say run paragraph on -- running on</span>
        <span class="plain">(documented at phs_runparaon):</span>
        <span class="plain">(- RunParagraphOn(); -).</span>
    <span class="plain">To say run paragraph on with special look spacing -- running on</span>
        <span class="plain">(documented at phs_runparaonsls):</span>
        <span class="plain">(- SpecialLookSpacingBreak(); -).</span>
    <span class="plain">To decide if a paragraph break is pending</span>
        <span class="plain">(documented at ph_breakpending):</span>
        <span class="plain">(- (say__p) -).</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>Now some text substitutions which are the equivalent of escape characters.
(In double-quoted I6 text, the notation for a literal quotation mark is a
tilde <code class="display"><span class="extract">~</span></code>.)
</p>


<pre class="display">
    <span class="plain">Section SR5/1/6 - Saying - Special characters</span>

    <span class="plain">To say bracket -- running on</span>
        <span class="plain">(documented at phs_bracket):</span>
        <span class="plain">(- print "["; -).</span>
    <span class="plain">To say close bracket -- running on</span>
        <span class="plain">(documented at phs_closebracket):</span>
        <span class="plain">(- print "]"; -).</span>
    <span class="plain">To say apostrophe/' -- running on</span>
        <span class="plain">(documented at phs_apostrophe):</span>
        <span class="plain">(- print "'"; -).</span>
    <span class="plain">To say quotation mark -- running on</span>
        <span class="plain">(documented at phs_quotemark):</span>
        <span class="plain">(- print "~"; -).</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b>Now some visual effects, which may or may not be rendered the way the user
hopes: that's partly up to the virtual machine, unfortunately.
</p>


<pre class="display">
    <span class="plain">Section SR5/1/7 - Saying - Fonts and visual effects</span>

    <span class="plain">To say bold type -- running on</span>
        <span class="plain">(documented at phs_bold):</span>
        <span class="plain">(- style bold; -).</span>
    <span class="plain">To say italic type -- running on</span>
        <span class="plain">(documented at phs_italic):</span>
        <span class="plain">(- style underline; -).</span>
    <span class="plain">To say roman type -- running on</span>
        <span class="plain">(documented at phs_roman):</span>
        <span class="plain">(- style roman; -).</span>
    <span class="plain">To say fixed letter spacing -- running on</span>
        <span class="plain">(documented at phs_fixedspacing):</span>
        <span class="plain">(- font off; -).</span>
    <span class="plain">To say variable letter spacing -- running on</span>
        <span class="plain">(documented at phs_varspacing):</span>
        <span class="plain">(- font on; -).</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b>"Do nothing" is useful mainly when other syntax has backed us into
something clumsy, but it can't be dispensed with. (In the examples, it used
to be used when conditions were awkward to negate &mdash; if condition, do nothing,
otherwise blah blah blah &mdash; but the creation of "unless" made it possible
to remove most of the "do nothing"s.)
</p>


<pre class="display">
    <span class="plain">Section SR5/3/8 - Control phrases - Stop or go</span>

    <span class="plain">To do nothing (documented at ph_nothing):</span>
        <span class="plain">(- ; -).</span>
    <span class="plain">To stop (documented at ph_stop):</span>
        <span class="plain">(- rtrue; -) - in to only.</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b>See test case <code class="display"><span class="extract">Showme</span></code>.
</p>


<pre class="display">
    <span class="plain">To decide what K is the default value of (V - name of kind of value of kind K)</span>
        <span class="plain">(documented at ph_defaultvalue):</span>
        <span class="plain">(- {-new:K} -).</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14.  </b>And so, at last...
</p>


<pre class="display">
    <span class="plain">Basic Inform ends here.</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b>...except that this is not quite true, because like most extensions they
then quote some documentation for Inform to weave into index pages: though
here it's more of a polite refusal than a manual, since the entire system
documentation is really the description of what was defined in this
extension.
</p>


<pre class="display">
    <span class="plain">---- DOCUMENTATION ----</span>

    <span class="plain">Unlike other extensions, the Standard Rules are compulsorily included</span>
    <span class="plain">with every project. They define the phrases, kinds and relations which</span>
    <span class="plain">are basic to Inform, and which are described throughout the documentation.</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="S-prm.html">Back to 'Preamble'</a></li><li><i>(This section ends Sections.)</i></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

