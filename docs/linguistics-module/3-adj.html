<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>3/daq</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '3/adj' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">linguistics</a></li><li><a href="index.html#3">Chapter 3: Grammatical Categories I</a></li><li><b>Adjectives</b></li></ul><p class="purpose">To record the names of all adjectives.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Adjectives are not their meanings</a></li><li><a href="#SP2">&#167;2. Adjectival phrases</a></li><li><a href="#SP6">&#167;6. Parsing adjectives</a></li><li><a href="#SP8">&#167;8. Testing agreement</a></li><li><a href="#SP9">&#167;9. Logging</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Adjectives are not their meanings. </b>Adjectives are simpler than verbs, since they define unary rather than
binary predicates. The word "open" applies to only one term &mdash; logically, we
regard it as <code class="display"><span class="extract">open(x)</span></code>, whereas a verb like "suspects" would appear
in formulae as <code class="display"><span class="extract">suspects(x, y)</span></code>.
</p>

<p class="inwebparagraph">But they are nevertheless complicated enough to have multiple meanings. For
instance, two of the senses of "empty" in the Standard Rules are:
</p>

<blockquote>
    <p>Definition: a text is empty rather than non-empty if it is "".</p>

</blockquote>

<blockquote>
    <p>Definition: a table name is empty rather than non-empty if the number of filled rows in it is 0.</p>

</blockquote>

<p class="inwebparagraph">(Which also defines two of the senses of "non-empty", another adjective.)
The clause <code class="display"><span class="extract">empty(x)</span></code> can be fully understood only when we know what
kind of value x has; for a text, the first sense applies, and for a table
name, the second.
</p>

<p class="inwebparagraph">Adjectives may also need to inflect, though not in English. (Let's not argue
about the word "blond"/"blonde", which is the only counterexample anybody
ever brings up.)
</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Adjectival phrases. </b>Because of this we need a structure to represent an adjective as
distinct from its meaning, and this is it.
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">adjectival_phrase</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">name_cluster</span><span class="plain"> *</span><span class="identifier">adjective_names</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">CORE_MODULE</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">aph_iname</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">package_request</span><span class="plain"> *</span><span class="identifier">aph_package</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="identifier">ADJECTIVE_MEANING_TYPE</span><span class="plain"> *</span><span class="identifier">meanings</span><span class="plain">;</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">adjectival_phrase</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure adjectival_phrase is private to this section.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>The following declares a new adjective, creating it only if necessary:
</p>


<pre class="display">
    <span class="reserved">adjectival_phrase</span><span class="plain"> *</span><span class="functiontext">Adjectives::declare</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">PREFORM_LANGUAGE_TYPE</span><span class="plain"> *</span><span class="identifier">nl</span><span class="plain">) {</span>
        <span class="reserved">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="reserved">adjectival_phrase</span><span class="plain">) {</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">C</span><span class="plain"> = </span><span class="identifier">Clusters::get_name_in_play</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">-</span><span class="element">&gt;adjective_names</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">nl</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::match</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">aph</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Adjectives::from_word_range</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">nl</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::declare is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>Whereas this simply creates it:
</p>


<pre class="display">
    <span class="reserved">adjectival_phrase</span><span class="plain"> *</span><span class="functiontext">Adjectives::from_word_range</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">PREFORM_LANGUAGE_TYPE</span><span class="plain"> *</span><span class="identifier">nl</span><span class="plain">) {</span>
        <span class="reserved">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="identifier">aph</span><span class="plain"> = </span><span class="functiontext">Adjectives::parse</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">aph</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">aph</span><span class="plain">;</span>
        <span class="identifier">aph</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">adjectival_phrase</span><span class="plain">);</span>
        <span class="identifier">aph</span><span class="plain">-</span><span class="element">&gt;adjective_names</span><span class="plain"> = </span><span class="identifier">Clusters::new</span><span class="plain">();</span>
        <span class="identifier">Clusters::add_with_agreements</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">-</span><span class="element">&gt;adjective_names</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">nl</span><span class="plain">);</span>
        <span class="identifier">aph</span><span class="plain">-</span><span class="element">&gt;meanings</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">EMPTY_ADJECTIVE_MEANING</span>
        <span class="identifier">aph</span><span class="plain">-</span><span class="element">&gt;meanings</span><span class="plain"> = </span><span class="identifier">EMPTY_ADJECTIVE_MEANING</span><span class="plain">();</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">CORE_MODULE</span>
        <span class="identifier">compilation_module</span><span class="plain"> *</span><span class="identifier">C</span><span class="plain"> = </span><span class="identifier">Modules::current</span><span class="plain">();</span>
        <span class="identifier">package_request</span><span class="plain"> *</span><span class="identifier">R</span><span class="plain"> = </span><span class="identifier">Packaging::request_resource</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="identifier">ADJECTIVES_SUBPACKAGE</span><span class="plain">);</span>
        <span class="identifier">aph</span><span class="plain">-</span><span class="element">&gt;aph_package</span><span class="plain"> = </span><span class="identifier">Packaging::request</span><span class="plain">(</span><span class="identifier">Packaging::supply_iname</span><span class="plain">(</span><span class="identifier">R</span><span class="plain">, </span><span class="identifier">ADJECTIVE_PR_COUNTER</span><span class="plain">), </span><span class="identifier">R</span><span class="plain">, </span><span class="identifier">adjective_ptype</span><span class="plain">);</span>
        <span class="identifier">aph</span><span class="plain">-</span><span class="element">&gt;aph_iname</span><span class="plain"> = </span><span class="identifier">InterNames::one_off</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"adjective"</span><span class="plain">, </span><span class="identifier">aph</span><span class="plain">-</span><span class="element">&gt;aph_package</span><span class="plain">);</span>
        <span class="identifier">Inter::Symbols::set_flag</span><span class="plain">(</span><span class="identifier">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">-</span><span class="element">&gt;aph_iname</span><span class="plain">), </span><span class="identifier">MAKE_NAME_UNIQUE</span><span class="plain">);</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">nl</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) &amp;&amp; (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))) {</span>
            <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">ADJECTIVE_NAME_VETTING</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ADJECTIVE_NAME_VETTING</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="plain">#</span><span class="identifier">endif</span>
                <span class="functiontext">ExcerptMeanings::register</span><span class="plain">(</span><span class="constant">ADJECTIVE_MC</span><span class="plain">,</span>
                    <span class="identifier">W</span><span class="plain">, </span><span class="identifier">STORE_POINTER_adjectival_phrase</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">));</span>
                <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">n</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)</span>
                    <span class="identifier">Preform::mark_word</span><span class="plain">(</span><span class="identifier">n</span><span class="plain">, &lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt;);</span>
            <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">ADJECTIVE_NAME_VETTING</span>
            <span class="plain">}</span>
            <span class="plain">#</span><span class="identifier">endif</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">aph</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::from_word_range is used in <a href="#SP3">&#167;3</a>.</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b></p>


<pre class="display">
    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">Adjectives::get_text</span><span class="plain">(</span><span class="reserved">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">plural</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">Clusters::get_name</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">-</span><span class="element">&gt;adjective_names</span><span class="plain">, </span><span class="identifier">plural</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::get_text is used in <a href="#SP9">&#167;9</a>, 3/au (<a href="3-au.html#SP2">&#167;2</a>).</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Parsing adjectives. </b>This does what its name suggests: matches the name of any adjective known to
Inform.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="functiontext">ExParser::parse_excerpt</span><span class="plain">(</span><span class="constant">ADJECTIVE_MC</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">) {</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RETRIEVE_POINTER_adjectival_phrase</span><span class="plain">(</span>
                <span class="functiontext">ExcerptMeanings::data</span><span class="plain">(</span><span class="identifier">ParseTree::get_meaning</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">)));</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>These are registered as excerpt meanings with the <code class="display"><span class="extract">ADJECTIVE_MC</span></code> meaning
code, so parsing a word range to match an adjective is easy. By construction
there is only one <code class="display"><span class="extract">adjectival_phrase</span></code> for any given excerpt of text, so
the following is unambiguous:
</p>


<pre class="display">
    <span class="reserved">adjectival_phrase</span><span class="plain"> *</span><span class="functiontext">Adjectives::parse</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::parse is used in <a href="#SP4">&#167;4</a>.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Testing agreement. </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Adjectives::test_adjective</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain"> = </span><span class="functiontext">Adjectives::declare</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">aph</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) { </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"Failed test\</span><span class="plain">n</span><span class="string">"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain">; }</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">g</span><span class="plain">, </span><span class="identifier">n</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">g</span><span class="plain"> = </span><span class="identifier">NEUTER_GENDER</span><span class="plain">; </span><span class="identifier">g</span><span class="plain"> &lt;= </span><span class="identifier">FEMININE_GENDER</span><span class="plain">; </span><span class="identifier">g</span><span class="plain">++) {</span>
            <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">g</span><span class="plain">) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">NEUTER_GENDER</span><span class="plain">: </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"neuter "</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">MASCULINE_GENDER</span><span class="plain">: </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"masculine "</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">FEMININE_GENDER</span><span class="plain">: </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"feminine "</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">n</span><span class="plain"> = 1; </span><span class="identifier">n</span><span class="plain"> &lt;= 2; </span><span class="identifier">n</span><span class="plain">++) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">n</span><span class="plain"> == 1) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"singular: "</span><span class="plain">); </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" / plural: "</span><span class="plain">);</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">C</span><span class="plain"> = </span><span class="identifier">Clusters::get_name_general</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">-</span><span class="element">&gt;adjective_names</span><span class="plain">,</span>
                    <span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">n</span><span class="plain">, </span><span class="identifier">g</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%W"</span><span class="plain">, </span><span class="identifier">C</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"^"</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::test_adjective appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Logging. </b>To identify an adjective in the debugging log:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Adjectives::log</span><span class="plain">(</span><span class="reserved">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">aph</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) { </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"&lt;null adjectival phrase&gt;"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain">; }</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="functiontext">Adjectives::get_text</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Streams::I6_escapes_enabled</span><span class="plain">(</span><span class="identifier">DL</span><span class="plain">)) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"'%W'"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"A%d'%W'"</span><span class="plain">, </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
    <span class="plain">}</span>

</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::log appears nowhere else.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="3-daq.html">Back to 'Determiners and Quantifiers'</a></li><li><a href="3-au.html">Continue with 'Adjective Usages'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

