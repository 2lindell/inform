<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>4/vrb</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '4/vu' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">linguistics</a></li><li><a href="index.html#4">Chapter 4: Grammatical Categories II</a></li><li><b>Verb Usages</b></li></ul><p class="purpose">To parse the many forms a verb can take.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP3">&#167;3. Verb usages</a></li><li><a href="#SP5">&#167;5. Verb usage tiers</a></li><li><a href="#SP6">&#167;6. Registration</a></li><li><a href="#SP7">&#167;7. Registration of regular verbs</a></li><li><a href="#SP12">&#167;12. Miscellaneous utility routines</a></li><li><a href="#SP14">&#167;14. Parsing source text against verb usages</a></li><li><a href="#SP23">&#167;23. Optimisation</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>The "permitted verb" is just a piece of temporary context used in parsing:
it's convenient for the verb currently being considered to be stored in
a global variable.
</p>


<pre class="display">
    <span class="reserved">verb_identity</span><span class="plain"> *</span><span class="identifier">permitted_verb_identity</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Verb usages. </b>We already have the ability to conjugate verbs &mdash; to turn "to have" into "I have",
"you have", "he has", "they have had", "we will have" and so on &mdash; from the
Inflections module. However, we won't necessarily want to recognise all of
those forms in sentences in the source text. For example, Inform only looks
at present tense forms of verbs in the third person, or at imperative forms.
</p>

<p class="inwebparagraph">To be recognised as referring to a given verb, a conjugated form of it must
be turned into one of the following structures:
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">verb_usage</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">word_assemblage</span><span class="plain"> </span><span class="identifier">vu_text</span><span class="plain">;			</span>    <span class="comment">text to recognise</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">vu_allow_unexpected_upper_case</span><span class="plain">; 	</span>    <span class="comment">for verbs like "to Hoover" or "to Google"</span>

        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">verb_identity</span><span class="plain"> *</span><span class="identifier">verb_used</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">negated_form_of_verb</span><span class="plain">; 				</span>    <span class="comment">is this a negated form?</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">mood</span><span class="plain">;								</span>    <span class="comment">active/passive: one of the two <code class="display"><span class="extract">*_MOOD</span></code> values</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">tensed</span><span class="plain">; 							</span>    <span class="comment">one of the <code class="display"><span class="extract">*_TENSE</span></code> values</span>

        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">CORE_MODULE</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">lexicon_entry</span><span class="plain"> *</span><span class="identifier">vu_lex_entry</span><span class="plain">; 	</span>    <span class="comment">for use when indexing</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">where_vu_created</span><span class="plain">; 	</span>    <span class="comment">for use if problem messages needed</span>

        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">next_in_search_list</span><span class="plain">; </span>    <span class="comment">within a linked list of all usages in length order</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">next_within_tier</span><span class="plain">;	</span>    <span class="comment">within the linked list for this tier (see below)</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">verb_usage</span><span class="plain">;</span>

    <span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">regular_to_be</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">"is"</span>
    <span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">negated_to_be</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">"is not"</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure verb_usage is accessed in 5/vp and here.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>One simple search list arranges these in order of (word count) length:
</p>


<pre class="display">
    <span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu_search_list</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">head of linked list of usages in length order</span>

    <span class="definitionkeyword">define</span> <span class="identifier">LOOP_OVER_USAGES</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">)</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">vu</span><span class="plain"> = </span><span class="identifier">vu_search_list</span><span class="plain">; </span><span class="identifier">vu</span><span class="plain">; </span><span class="identifier">vu</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;next_in_search_list</span><span class="plain">)</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Verb usage tiers. </b>A particular challenge of parsing natural language is to decide the most likely
word in a sentence to be its primary verb. (The verb in "Heatwave Bone Breaks
Clog Hospital" is not "to break".) This is especially challenging when the
noun phrases can't be understood since they refer to things not yet created.
In Inform, for example, "Peter wears a felt hat" might be the only reference
anywhere in the source text to either Peter or the hat, which must each be
created in response to this sentence, and therefore can't be used to
understand it.
</p>

<p class="inwebparagraph">The model we use is to sort verb usages into "tiers", each with a numerical
"priority", which is a non-negative number. Tier 0 verb usages are never
recognised. Otherwise, the lower the priority number, the more likely it
is that this verb is meant. If two usages belong to the same tier, then
the earlier one in the sentence is preferred.
</p>

<p class="inwebparagraph">The tiers are stored as a linked list, in priority order:
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">verb_usage_tier</span><span class="plain"> {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">priority</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">tier_contents</span><span class="plain">; </span>    <span class="comment">head of linked list for this tier</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">verb_usage_tier</span><span class="plain"> *</span><span class="identifier">next_tier</span><span class="plain">;</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">verb_usage_tier</span><span class="plain">;</span>

    <span class="reserved">verb_usage_tier</span><span class="plain"> *</span><span class="identifier">first_search_tier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">head of linked list of tiers</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure verb_usage_tier is accessed in 5/vp and here.</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Registration. </b>Here we create a single verb usage; note that the empty text cannot be used.
</p>


<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">set_where_created</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="reserved">verb_usage</span><span class="plain"> *</span><span class="functiontext">VerbUsages::register_single_usage</span><span class="plain">(</span><span class="identifier">word_assemblage</span><span class="plain"> </span><span class="identifier">wa</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">negated</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">tense</span><span class="plain">,</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">mood</span><span class="plain">, </span><span class="reserved">verb_identity</span><span class="plain"> *</span><span class="identifier">vi</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">unexpected_upper_casing_used</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::nonempty</span><span class="plain">(</span><span class="identifier">wa</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">VERB_USAGES</span><span class="plain">, </span><span class="string">"new usage: '%A'\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, &amp;</span><span class="identifier">wa</span><span class="plain">);</span>
        <span class="functiontext">VerbUsages::mark_as_verb</span><span class="plain">(</span><span class="identifier">WordAssemblages::first_word</span><span class="plain">(&amp;</span><span class="identifier">wa</span><span class="plain">));</span>
        <span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">verb_usage</span><span class="plain">);</span>
        <span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;vu_text</span><span class="plain"> = </span><span class="identifier">wa</span><span class="plain">;</span>
        <span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;negated_form_of_verb</span><span class="plain"> = </span><span class="identifier">negated</span><span class="plain">; </span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;tensed</span><span class="plain"> = </span><span class="identifier">tense</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">CORE_MODULE</span>
        <span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;vu_lex_entry</span><span class="plain"> = </span><span class="identifier">current_main_verb</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;where_vu_created</span><span class="plain"> = </span><span class="identifier">set_where_created</span><span class="plain">;</span>
        <span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;verb_used</span><span class="plain"> = </span><span class="identifier">vi</span><span class="plain">;</span>
        <span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;mood</span><span class="plain"> = </span><span class="identifier">mood</span><span class="plain">;</span>
        <span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;vu_allow_unexpected_upper_case</span><span class="plain"> = </span><span class="identifier">unexpected_upper_casing_used</span><span class="plain">;</span>
        <span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;next_within_tier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;next_in_search_list</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        &lt;<span class="cwebmacro">Add to the length-order search list</span> <span class="cwebmacronumber">6.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">vu</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function VerbUsages::register_single_usage is used in <a href="#SP8_1_2_1">&#167;8.1.2.1</a>.</p>

<p class="inwebparagraph"><a id="SP6_1"></a><b>&#167;6.1.  </b>These are insertion-sorted into a list in order of word count, with oldest
first in the case of equal length:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Add to the length-order search list</span> <span class="cwebmacronumber">6.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vu_search_list</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">vu_search_list</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">;</span>
        <span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">evu</span><span class="plain"> = </span><span class="identifier">vu_search_list</span><span class="plain">, *</span><span class="identifier">prev</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="identifier">evu</span><span class="plain">; </span><span class="identifier">prev</span><span class="plain"> = </span><span class="identifier">evu</span><span class="plain">, </span><span class="identifier">evu</span><span class="plain"> = </span><span class="identifier">evu</span><span class="plain">-</span><span class="element">&gt;next_in_search_list</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::longer</span><span class="plain">(&amp;</span><span class="identifier">wa</span><span class="plain">, &amp;(</span><span class="identifier">evu</span><span class="plain">-</span><span class="element">&gt;vu_text</span><span class="plain">)) &gt; 0) {</span>
                    <span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;next_in_search_list</span><span class="plain"> = </span><span class="identifier">evu</span><span class="plain">;</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prev</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">vu_search_list</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">;</span>
                    <span class="reserved">else</span><span class="plain"> </span><span class="identifier">prev</span><span class="plain">-</span><span class="element">&gt;next_in_search_list</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">;</span>
                    <span class="reserved">break</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">evu</span><span class="plain">-</span><span class="element">&gt;next_in_search_list</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
                    <span class="identifier">evu</span><span class="plain">-</span><span class="element">&gt;next_in_search_list</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">;</span>
                    <span class="reserved">break</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Registration of regular verbs. </b>It would be tiresome to have to call the above routine for every possible
conjugated form of a verb individually, so the following takes care of
a whole verb at once.
</p>

<p class="inwebparagraph">The copular verb has no passive, since it doesn't distinguish between
subject and object. In English, we can say "the hat is worn by Peter"
as equivalent to "Peter wears the hat", but not "1 is been by X" as
equivalent to "X is 1".
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">VerbUsages::register_all_usages_of_verb</span><span class="plain">(</span><span class="reserved">verb_identity</span><span class="plain"> *</span><span class="identifier">vi</span><span class="plain">,</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">unexpected_upper_casing_used</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">priority</span><span class="plain">) {</span>
        <span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain"> = </span><span class="identifier">vi</span><span class="plain">-</span><span class="element">&gt;conjugation</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vc</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">CORE_MODULE</span>
        <span class="identifier">Index::Lexicon::new_main_verb</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">infinitive</span><span class="plain">, </span><span class="identifier">VERB_LEXE</span><span class="plain">);</span>
        <span class="plain">#</span><span class="identifier">endif</span>

        <span class="functiontext">VerbUsages::register_moods_of_verb</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">ACTIVE_MOOD</span><span class="plain">, </span><span class="identifier">vi</span><span class="plain">,</span>
            <span class="identifier">unexpected_upper_casing_used</span><span class="plain">, </span><span class="identifier">priority</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vi</span><span class="plain"> != </span><span class="identifier">copular_verb</span><span class="plain">) {</span>
            <span class="functiontext">VerbUsages::register_moods_of_verb</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">PASSIVE_MOOD</span><span class="plain">, </span><span class="identifier">vi</span><span class="plain">,</span>
                <span class="identifier">unexpected_upper_casing_used</span><span class="plain">, </span><span class="identifier">priority</span><span class="plain">);</span>
            &lt;<span class="cwebmacro">Add present participle forms</span> <span class="cwebmacronumber">7.1</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function VerbUsages::register_all_usages_of_verb appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP7_1"></a><b>&#167;7.1.  </b>With the present participle the meaning is back the right way around: for
instance, "to be fetching" has the same meaning as "to fetch". At any rate,
Inform's linguistic model is not subtle enough to distinguish the difference,
in terms of a continuous rather than instantaneous process, which a human
reader might be aware of.
</p>

<p class="inwebparagraph">Partly because of that, we don't allow these forms for the copular verb:
"He is being difficult" doesn't quite mean "He is difficult", which is the
best sense we could make of it, and "He is being in the Dining Room" has
an unfortunate mock-Indian sound to it.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Add present participle forms</span> <span class="cwebmacronumber">7.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::nonempty</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">present_participle</span><span class="plain">)) {</span>
            <span class="reserved">preposition_identity</span><span class="plain"> *</span><span class="identifier">prep</span><span class="plain"> =</span>
                <span class="functiontext">Prepositions::make</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">present_participle</span><span class="plain">, </span><span class="identifier">unexpected_upper_casing_used</span><span class="plain">);</span>
            <span class="functiontext">Verbs::add_form</span><span class="plain">(</span><span class="identifier">copular_verb</span><span class="plain">, </span><span class="identifier">prep</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">,</span>
                <span class="functiontext">VerbMeanings::new_indirection</span><span class="plain">(</span><span class="identifier">vi</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">), </span><span class="constant">SVO_FS_BIT</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7">&#167;7</a>.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>Note that forms using the auxiliary "to be" are given meanings which indirect
to the meanings of the main verb: thus "Y is owned by X" is indirected to
the reversal of the meaning "X owns Y", and "X is owning Y" to the unreversed
meaning. Both forms are then internally implemented as prepositional forms
of "to be", which is convenient however dubious in linguistic terms.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">VerbUsages::register_moods_of_verb</span><span class="plain">(</span><span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">mood</span><span class="plain">,</span>
        <span class="reserved">verb_identity</span><span class="plain"> *</span><span class="identifier">vi</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">unexpected_upper_casing_used</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">priority</span><span class="plain">) {</span>
        <span class="identifier">verb_tabulation</span><span class="plain"> *</span><span class="identifier">vt</span><span class="plain"> = &amp;(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">tabulations</span><span class="plain">[</span><span class="identifier">mood</span><span class="plain">]);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::nonempty</span><span class="plain">(</span><span class="identifier">vt</span><span class="plain">-&gt;</span><span class="identifier">to_be_auxiliary</span><span class="plain">)) {</span>
            <span class="reserved">preposition_identity</span><span class="plain"> *</span><span class="identifier">prep</span><span class="plain"> =</span>
                <span class="functiontext">Prepositions::make</span><span class="plain">(</span><span class="identifier">vt</span><span class="plain">-&gt;</span><span class="identifier">to_be_auxiliary</span><span class="plain">, </span><span class="identifier">unexpected_upper_casing_used</span><span class="plain">);</span>
            <span class="functiontext">Verbs::add_form</span><span class="plain">(</span><span class="identifier">copular_verb</span><span class="plain">, </span><span class="identifier">prep</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">,</span>
                <span class="functiontext">VerbMeanings::new_indirection</span><span class="plain">(</span><span class="identifier">vi</span><span class="plain">, (</span><span class="identifier">mood</span><span class="plain"> == </span><span class="identifier">PASSIVE_MOOD</span><span class="plain">)?</span><span class="identifier">TRUE</span><span class="plain">:</span><span class="identifier">FALSE</span><span class="plain">),</span>
                <span class="constant">SVO_FS_BIT</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        &lt;<span class="cwebmacro">Register usages</span> <span class="cwebmacronumber">8.1</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function VerbUsages::register_moods_of_verb is used in <a href="#SP7">&#167;7</a>.</p>

<p class="inwebparagraph"><a id="SP8_1"></a><b>&#167;8.1.  </b>The sequence of registration is important here, and it's done this way to
minimise false readings due to overlaps. We take future or other exotic
tenses (say, the French past historic) first; then the perfect tenses,
then the imperfect; within that, we take negated forms first, then positive;
within that, we take present before past tense; within that, we run through
the persons from 1PS to 3PP.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Register usages</span> <span class="cwebmacronumber">8.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">tense</span><span class="plain"> = </span><span class="identifier">WILLBE_TENSE</span><span class="plain">; </span><span class="identifier">tense</span><span class="plain"> &lt; </span><span class="identifier">NO_KNOWN_TENSES</span><span class="plain">; </span><span class="identifier">tense</span><span class="plain">++)</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">sense</span><span class="plain"> = 1; </span><span class="identifier">sense</span><span class="plain"> &gt;= 0; </span><span class="identifier">sense</span><span class="plain">--)</span>
                &lt;<span class="cwebmacro">Register usages in this combination</span> <span class="cwebmacronumber">8.1.2</span>&gt;<span class="plain">;</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">t1</span><span class="plain"> = </span><span class="identifier">HASBEEN_TENSE</span><span class="plain">, </span><span class="identifier">t2</span><span class="plain"> = </span><span class="identifier">HADBEEN_TENSE</span><span class="plain">;</span>
        &lt;<span class="cwebmacro">Register usages in these tenses</span> <span class="cwebmacronumber">8.1.1</span>&gt;<span class="plain">;</span>
        <span class="identifier">t1</span><span class="plain"> = </span><span class="identifier">IS_TENSE</span><span class="plain">; </span><span class="identifier">t2</span><span class="plain"> = </span><span class="identifier">WAS_TENSE</span><span class="plain">;</span>
        &lt;<span class="cwebmacro">Register usages in these tenses</span> <span class="cwebmacronumber">8.1.1</span>&gt;<span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP8_1_1"></a><b>&#167;8.1.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Register usages in these tenses</span> <span class="cwebmacronumber">8.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">sense</span><span class="plain"> = 1; </span><span class="identifier">sense</span><span class="plain"> &gt;= 0; </span><span class="identifier">sense</span><span class="plain">--) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">tense</span><span class="plain"> = </span><span class="identifier">t1</span><span class="plain">;</span>
            &lt;<span class="cwebmacro">Register usages in this combination</span> <span class="cwebmacronumber">8.1.2</span>&gt;<span class="plain">;</span>
            <span class="identifier">tense</span><span class="plain"> = </span><span class="identifier">t2</span><span class="plain">;</span>
            &lt;<span class="cwebmacro">Register usages in this combination</span> <span class="cwebmacronumber">8.1.2</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8_1">&#167;8.1</a> (twice).</p>

<p class="inwebparagraph"><a id="SP8_1_2"></a><b>&#167;8.1.2.  </b>Note that before a usage is registered, we call out to the client to find
out whether it's needed.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Register usages in this combination</span> <span class="cwebmacronumber">8.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">person</span><span class="plain"> = 0; </span><span class="identifier">person</span><span class="plain"> &lt; </span><span class="identifier">NO_KNOWN_PERSONS</span><span class="plain">; </span><span class="identifier">person</span><span class="plain">++) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">priority</span><span class="plain">;</span>
            <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">ALLOW_VERB_USAGE_IN_ASSERTIONS</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ALLOW_VERB_USAGE_IN_ASSERTIONS</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">tense</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">, </span><span class="identifier">person</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">p</span><span class="plain"> = 0;</span>
            <span class="plain">#</span><span class="reserved">else</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">VerbUsages::allow_in_assertions</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">tense</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">, </span><span class="identifier">person</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">p</span><span class="plain"> = 0;</span>
            <span class="plain">#</span><span class="identifier">endif</span>
            <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">ALLOW_VERB_USAGE_GENERALLY</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ALLOW_VERB_USAGE_GENERALLY</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">tense</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">, </span><span class="identifier">person</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">p</span><span class="plain"> = -1;</span>
            <span class="plain">#</span><span class="reserved">else</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">VerbUsages::allow_generally</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">tense</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">, </span><span class="identifier">person</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">p</span><span class="plain"> = -1;</span>
            <span class="plain">#</span><span class="identifier">endif</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain"> &gt;= 0) </span>&lt;<span class="cwebmacro">Actually register this usage</span> <span class="cwebmacronumber">8.1.2.1</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8_1">&#167;8.1</a>, <a href="#SP8_1_1">&#167;8.1.1</a> (twice).</p>

<p class="inwebparagraph"><a id="SP8_1_2_1"></a><b>&#167;8.1.2.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Actually register this usage</span> <span class="cwebmacronumber">8.1.2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain"> = </span><span class="functiontext">VerbUsages::register_single_usage</span><span class="plain">(</span><span class="identifier">vt</span><span class="plain">-&gt;</span><span class="identifier">vc_text</span><span class="plain">[</span><span class="identifier">tense</span><span class="plain">][</span><span class="identifier">sense</span><span class="plain">][</span><span class="identifier">person</span><span class="plain">],</span>
            <span class="plain">(</span><span class="identifier">sense</span><span class="plain">==1)?</span><span class="identifier">TRUE</span><span class="plain">:</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">tense</span><span class="plain">, </span><span class="identifier">mood</span><span class="plain">, </span><span class="identifier">vi</span><span class="plain">, </span><span class="identifier">unexpected_upper_casing_used</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vu</span><span class="plain">) </span><span class="functiontext">VerbUsages::set_search_priority</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vi</span><span class="plain"> == </span><span class="identifier">copular_verb</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">tense</span><span class="plain"> == </span><span class="identifier">IS_TENSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">person</span><span class="plain"> == </span><span class="identifier">THIRD_PERSON_SINGULAR</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sense</span><span class="plain"> == 1) </span><span class="identifier">negated_to_be</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">;</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="identifier">regular_to_be</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8_1_2">&#167;8.1.2</a>.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>Here are the default decisions on what usages are allowed; the defaults are
what are used by Inform. In assertions:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">VerbUsages::allow_in_assertions</span><span class="plain">(</span><span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">tense</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">sense</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">person</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">tense</span><span class="plain"> == </span><span class="identifier">IS_TENSE</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">sense</span><span class="plain"> == 0) &amp;&amp;</span>
            <span class="plain">((</span><span class="identifier">person</span><span class="plain"> == </span><span class="identifier">THIRD_PERSON_SINGULAR</span><span class="plain">) || (</span><span class="identifier">person</span><span class="plain"> == </span><span class="identifier">THIRD_PERSON_PLURAL</span><span class="plain">)))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function VerbUsages::allow_in_assertions is used in <a href="#SP8_1_2">&#167;8.1.2</a>.</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>And in other usages (e.g., in Inform's "now the pink door is not open"):
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">VerbUsages::allow_generally</span><span class="plain">(</span><span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">tense</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">sense</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">person</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (((</span><span class="identifier">tense</span><span class="plain"> == </span><span class="identifier">IS_TENSE</span><span class="plain">) || (</span><span class="identifier">tense</span><span class="plain"> == </span><span class="identifier">WAS_TENSE</span><span class="plain">) ||</span>
            <span class="plain">(</span><span class="identifier">tense</span><span class="plain"> == </span><span class="identifier">HASBEEN_TENSE</span><span class="plain">) || (</span><span class="identifier">tense</span><span class="plain"> == </span><span class="identifier">HADBEEN_TENSE</span><span class="plain">)) &amp;&amp;</span>
            <span class="plain">((</span><span class="identifier">person</span><span class="plain"> == </span><span class="identifier">THIRD_PERSON_SINGULAR</span><span class="plain">) || (</span><span class="identifier">person</span><span class="plain"> == </span><span class="identifier">THIRD_PERSON_PLURAL</span><span class="plain">)))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function VerbUsages::allow_generally is used in <a href="#SP8_1_2">&#167;8.1.2</a>.</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b>That just leaves the business of setting the "priority" of a usage. As
noted above, priority 0 usages are ignored, while otherwise low numbers
beat high ones. For example, in "The verb to be means the equality relation",
the verb "be" might have priority 2 and so be beaten by the verb "mean",
with priority 1.
</p>

<p class="inwebparagraph">We must add the new usage to the tier with the given priority, creating
that tier if need be. Newly created tiers are insertion-sorted into a
list, with lower priority numbers before higher ones.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">VerbUsages::set_search_priority</span><span class="plain">(</span><span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">p</span><span class="plain">) {</span>
        <span class="reserved">verb_usage_tier</span><span class="plain"> *</span><span class="identifier">tier</span><span class="plain"> = </span><span class="identifier">first_search_tier</span><span class="plain">, *</span><span class="identifier">last_tier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">VERB_USAGES</span><span class="plain">, </span><span class="string">"Usage '%A' has priority %d\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, &amp;(</span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;vu_text</span><span class="plain">), </span><span class="identifier">p</span><span class="plain">);</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">tier</span><span class="plain">) &amp;&amp; (</span><span class="identifier">tier</span><span class="plain">-</span><span class="element">&gt;priority</span><span class="plain"> &lt;= </span><span class="identifier">p</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">tier</span><span class="plain">-</span><span class="element">&gt;priority</span><span class="plain"> == </span><span class="identifier">p</span><span class="plain">) {</span>
                <span class="functiontext">VerbUsages::add_to_tier</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">, </span><span class="identifier">tier</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="identifier">last_tier</span><span class="plain"> = </span><span class="identifier">tier</span><span class="plain">;</span>
            <span class="identifier">tier</span><span class="plain"> = </span><span class="identifier">tier</span><span class="plain">-</span><span class="element">&gt;next_tier</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">tier</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">verb_usage_tier</span><span class="plain">);</span>
        <span class="identifier">tier</span><span class="plain">-</span><span class="element">&gt;priority</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">;</span>
        <span class="identifier">tier</span><span class="plain">-</span><span class="element">&gt;tier_contents</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="functiontext">VerbUsages::add_to_tier</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">, </span><span class="identifier">tier</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">last_tier</span><span class="plain">) {</span>
            <span class="identifier">tier</span><span class="plain">-</span><span class="element">&gt;next_tier</span><span class="plain"> = </span><span class="identifier">last_tier</span><span class="plain">-</span><span class="element">&gt;next_tier</span><span class="plain">;</span>
            <span class="identifier">last_tier</span><span class="plain">-</span><span class="element">&gt;next_tier</span><span class="plain"> = </span><span class="identifier">tier</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">tier</span><span class="plain">-</span><span class="element">&gt;next_tier</span><span class="plain"> = </span><span class="identifier">first_search_tier</span><span class="plain">;</span>
            <span class="identifier">first_search_tier</span><span class="plain"> = </span><span class="identifier">tier</span><span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">VerbUsages::add_to_tier</span><span class="plain">(</span><span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">, </span><span class="reserved">verb_usage_tier</span><span class="plain"> *</span><span class="identifier">tier</span><span class="plain">) {</span>
        <span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">known</span><span class="plain"> = </span><span class="identifier">tier</span><span class="plain">-</span><span class="element">&gt;tier_contents</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">known</span><span class="plain">) &amp;&amp; (</span><span class="identifier">known</span><span class="plain">-</span><span class="element">&gt;next_within_tier</span><span class="plain">))</span>
            <span class="identifier">known</span><span class="plain"> = </span><span class="identifier">known</span><span class="plain">-</span><span class="element">&gt;next_within_tier</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">known</span><span class="plain">) </span><span class="identifier">known</span><span class="plain">-</span><span class="element">&gt;next_within_tier</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">;</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">tier</span><span class="plain">-</span><span class="element">&gt;tier_contents</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">;</span>
        <span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;next_within_tier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function VerbUsages::set_search_priority is used in <a href="#SP8_1_2_1">&#167;8.1.2.1</a>.</p>

<p class="endnote">The function VerbUsages::add_to_tier appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Miscellaneous utility routines. </b>A usage is "foreign" if it belongs to a language other than English:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">VerbUsages::is_foreign</span><span class="plain">(</span><span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;verb_used</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;verb_used</span><span class="plain">-</span><span class="element">&gt;conjugation</span><span class="plain">-&gt;</span><span class="identifier">defined_in</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;verb_used</span><span class="plain">-</span><span class="element">&gt;conjugation</span><span class="plain">-&gt;</span><span class="identifier">defined_in</span><span class="plain"> != </span><span class="identifier">English_language</span><span class="plain">)) {</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function VerbUsages::is_foreign appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b>And some access routines.
</p>


<pre class="display">
    <span class="identifier">VERB_MEANING_TYPE</span><span class="plain"> *</span><span class="functiontext">VerbUsages::get_regular_meaning</span><span class="plain">(</span><span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">, </span><span class="reserved">preposition_identity</span><span class="plain"> *</span><span class="identifier">prep</span><span class="plain">, </span><span class="reserved">preposition_identity</span><span class="plain"> *</span><span class="identifier">second_prep</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vu</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">verb_meaning</span><span class="plain"> *</span><span class="identifier">uvm</span><span class="plain"> = </span><span class="functiontext">Verbs::regular_meaning</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;verb_used</span><span class="plain">, </span><span class="identifier">prep</span><span class="plain">, </span><span class="identifier">second_prep</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">uvm</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">VERB_MEANING_TYPE</span><span class="plain"> *</span><span class="identifier">root</span><span class="plain"> = </span><span class="functiontext">VerbMeanings::get_relational_meaning</span><span class="plain">(</span><span class="identifier">uvm</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;mood</span><span class="plain"> == </span><span class="identifier">PASSIVE_MOOD</span><span class="plain">) &amp;&amp; (</span><span class="identifier">root</span><span class="plain"> != </span><span class="identifier">VERB_MEANING_EQUALITY</span><span class="plain">))</span>
            <span class="identifier">root</span><span class="plain"> = </span><span class="identifier">VERB_MEANING_REVERSAL</span><span class="plain">(</span><span class="identifier">root</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">root</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">VerbUsages::get_tense_used</span><span class="plain">(</span><span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;tensed</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">VerbUsages::is_used_negatively</span><span class="plain">(</span><span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;negated_form_of_verb</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function VerbUsages::get_regular_meaning is used in <a href="#SP18">&#167;18</a>.</p>

<p class="endnote">The function VerbUsages::get_tense_used appears nowhere else.</p>

<p class="endnote">The function VerbUsages::is_used_negatively appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Parsing source text against verb usages. </b>Given a particular VU, and a word range <code class="display"><span class="extract">w1</span></code> to <code class="display"><span class="extract">w2</span></code>, we test whether the
range begins with but does not consist only of the text of the VU. We return
the first word after the VU text if it does (which will therefore be a
word number still inside the range), or -1 if it doesn't.
</p>

<p class="inwebparagraph">It is potentially quite slow to test every word against every possible verb,
even though there are typically fairly few verbs in the S-grammar, so we
confine ourselves to words flagged in the vocabulary as being used in verbs.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">VerbUsages::parse_against_verb</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;vu_allow_unexpected_upper_case</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">Word::unexpectedly_upper_case</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)))) </span><span class="reserved">return</span><span class="plain"> -1;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">WordAssemblages::parse_as_strictly_initial_text</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, &amp;(</span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;vu_text</span><span class="plain">));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function VerbUsages::parse_against_verb is used in <a href="#SP15">&#167;15</a>, <a href="#SP16">&#167;16</a>, <a href="#SP17">&#167;17</a>, <a href="#SP18">&#167;18</a>, <a href="#SP19">&#167;19</a>, <a href="#SP20">&#167;20</a>, 5/vp (<a href="5-vp.html#SP7_3_1">&#167;7.3.1</a>).</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b>We now define a whole run of internals to parse verbs. As examples,
</p>

<blockquote>
    <p>is</p>

</blockquote>

<blockquote>
    <p>has not been</p>

</blockquote>

<blockquote>
    <p>was carried by</p>

</blockquote>

<p class="inwebparagraph">are all, in the sense we mean it here, "verbs".
</p>

<p class="inwebparagraph">We never match a verb if it is unexpectedly given in upper case form. Thus
"The Glory That Is Rome is a room" will be read as "(The Glory That Is
Rome) is (a room)", not "(The Glory That) is (Rome is a room)".
</p>

<p class="inwebparagraph">The following picks up any verb which can be used in an SVO sentence and
which has a meaning.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">meaningful</span><span class="plain">-</span><span class="identifier">nonimperative</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> ? {</span>
        <span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_USAGES</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">) {</span>
            <span class="reserved">verb_identity</span><span class="plain"> *</span><span class="identifier">vi</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;verb_used</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">verb_form</span><span class="plain"> *</span><span class="identifier">vf</span><span class="plain"> = </span><span class="identifier">vi</span><span class="plain">-</span><span class="element">&gt;list_of_forms</span><span class="plain">; </span><span class="identifier">vf</span><span class="plain">; </span><span class="identifier">vf</span><span class="plain"> = </span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;next_form</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">VerbMeanings::is_meaningless</span><span class="plain">(&amp;(</span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;list_of_senses</span><span class="plain">-</span><span class="element">&gt;vm</span><span class="plain">)) == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp;</span>
                    <span class="plain">(</span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;form_structures</span><span class="plain"> &amp; (</span><span class="constant">SVO_FS_BIT</span><span class="plain"> + </span><span class="constant">SVOO_FS_BIT</span><span class="plain">))) {</span>
                    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain"> = </span><span class="functiontext">VerbUsages::parse_against_verb</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">vu</span><span class="plain">);</span>
                    <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">i</span><span class="plain">&gt;</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">i</span><span class="plain">&lt;=</span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))) {</span>
                        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;preposition</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) ||</span>
                            <span class="plain">(</span><span class="identifier">WordAssemblages::is_at</span><span class="plain">(&amp;(</span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;preposition</span><span class="plain">-</span><span class="element">&gt;prep_text</span><span class="plain">), </span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)))) {</span>
                            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">;</span>
                            <span class="identifier">permitted_verb_identity</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;verb_used</span><span class="plain">;</span>
                            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">-1;</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16.  </b>A copular verb is one which implies the equality relation: in practice,
that means it's "to be". So the following matches "is", "were not",
and so on.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">copular</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> ? {</span>
        <span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">preform_backtrack</span><span class="plain">) { </span><span class="identifier">vu</span><span class="plain"> = </span><span class="identifier">preform_backtrack</span><span class="plain">; </span><span class="reserved">goto</span><span class="plain"> </span><span class="identifier">BacktrackFrom</span><span class="plain">; }</span>
        <span class="identifier">LOOP_OVER_USAGES</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;verb_used</span><span class="plain"> == </span><span class="identifier">copular_verb</span><span class="plain">) {</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain"> = </span><span class="functiontext">VerbUsages::parse_against_verb</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">vu</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">i</span><span class="plain">&gt;</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">i</span><span class="plain">&lt;=</span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))) {</span>
                    <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain"> -(</span><span class="identifier">i</span><span class="plain">-1);</span>
                <span class="plain">}</span>
                <span class="identifier">BacktrackFrom</span><span class="plain">: ;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17.  </b>A noncopular verb is anything that isn't copular, but here we also require
it to be in the present tense and the negative sense. So, for example, "does
not carry" qualifies; "is not" or "supports" don't qualify.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">negated</span><span class="plain">-</span><span class="identifier">noncopular</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">present</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> ? {</span>
        <span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">preform_backtrack</span><span class="plain">) { </span><span class="identifier">vu</span><span class="plain"> = </span><span class="identifier">preform_backtrack</span><span class="plain">; </span><span class="reserved">goto</span><span class="plain"> </span><span class="identifier">BacktrackFrom</span><span class="plain">; }</span>
        <span class="identifier">LOOP_OVER_USAGES</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;tensed</span><span class="plain"> == </span><span class="identifier">IS_TENSE</span><span class="plain">) &amp;&amp;</span>
                <span class="plain">(</span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;verb_used</span><span class="plain"> != </span><span class="identifier">copular_verb</span><span class="plain">) &amp;&amp;</span>
                <span class="plain">(</span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;negated_form_of_verb</span><span class="plain"> == </span><span class="identifier">TRUE</span><span class="plain">)) {</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain"> = </span><span class="functiontext">VerbUsages::parse_against_verb</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">vu</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">i</span><span class="plain">&gt;</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">i</span><span class="plain">&lt;=</span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))) {</span>
                    <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain"> -(</span><span class="identifier">i</span><span class="plain">-1);</span>
                <span class="plain">}</span>
                <span class="identifier">BacktrackFrom</span><span class="plain">: ;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18.  </b>A universal verb is one which implies the universal relation: in practice,
that means it's "to relate".
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">universal</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> ? {</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">VERB_MEANING_UNIVERSAL</span>
        <span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_USAGES</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">VerbUsages::get_regular_meaning</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">) == </span><span class="identifier">VERB_MEANING_UNIVERSAL</span><span class="plain">) {</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain"> = </span><span class="functiontext">VerbUsages::parse_against_verb</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">vu</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">i</span><span class="plain">&gt;</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">i</span><span class="plain">&lt;=</span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))) {</span>
                    <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">-1;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19.  </b>Any verb usage which is negative in sense: this is used only to diagnose problems.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">negated</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> ? {</span>
        <span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">preform_backtrack</span><span class="plain">) { </span><span class="identifier">vu</span><span class="plain"> = </span><span class="identifier">preform_backtrack</span><span class="plain">; </span><span class="reserved">goto</span><span class="plain"> </span><span class="identifier">BacktrackFrom</span><span class="plain">; }</span>
        <span class="identifier">LOOP_OVER_USAGES</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;negated_form_of_verb</span><span class="plain"> == </span><span class="identifier">TRUE</span><span class="plain">) {</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain"> = </span><span class="functiontext">VerbUsages::parse_against_verb</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">vu</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">i</span><span class="plain">&gt;</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">i</span><span class="plain">&lt;=</span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))) {</span>
                    <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain"> -(</span><span class="identifier">i</span><span class="plain">-1);</span>
                <span class="plain">}</span>
                <span class="identifier">BacktrackFrom</span><span class="plain">: ;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP20"></a><b>&#167;20.  </b>Any verb usage which is in the past tense: this is used only to diagnose problems.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">past</span><span class="plain">-</span><span class="identifier">tense</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> ? {</span>
        <span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">preform_backtrack</span><span class="plain">) { </span><span class="identifier">vu</span><span class="plain"> = </span><span class="identifier">preform_backtrack</span><span class="plain">; </span><span class="reserved">goto</span><span class="plain"> </span><span class="identifier">BacktrackFrom</span><span class="plain">; }</span>
        <span class="identifier">LOOP_OVER_USAGES</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;tensed</span><span class="plain"> != </span><span class="identifier">IS_TENSE</span><span class="plain">) {</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain"> = </span><span class="functiontext">VerbUsages::parse_against_verb</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">vu</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">i</span><span class="plain">&gt;</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">i</span><span class="plain">&lt;=</span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))) {</span>
                    <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain"> -(</span><span class="identifier">i</span><span class="plain">-1);</span>
                <span class="plain">}</span>
                <span class="identifier">BacktrackFrom</span><span class="plain">: ;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP21"></a><b>&#167;21.  </b>The following are used only when recognising text expansions for adaptive
uses of verbs:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">adaptive</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">verb_conjugation</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">auxiliary_only</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">PREFORM_ADAPTIVE_PERSON</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">defined_in</span><span class="plain">);</span>
                <span class="identifier">word_assemblage</span><span class="plain"> *</span><span class="identifier">we_form</span><span class="plain"> = &amp;(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">tabulations</span><span class="plain">[</span><span class="identifier">ACTIVE_MOOD</span><span class="plain">].</span><span class="identifier">vc_text</span><span class="plain">[</span><span class="identifier">IS_TENSE</span><span class="plain">][0][</span><span class="identifier">p</span><span class="plain">]);</span>
                <span class="identifier">word_assemblage</span><span class="plain"> *</span><span class="identifier">we_dont_form</span><span class="plain"> = &amp;(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">tabulations</span><span class="plain">[</span><span class="identifier">ACTIVE_MOOD</span><span class="plain">].</span><span class="identifier">vc_text</span><span class="plain">[</span><span class="identifier">IS_TENSE</span><span class="plain">][1][</span><span class="identifier">p</span><span class="plain">]);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::compare_with_wording</span><span class="plain">(</span><span class="identifier">we_form</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)) {</span>
                    <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">vc</span><span class="plain">; *</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::compare_with_wording</span><span class="plain">(</span><span class="identifier">we_dont_form</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)) {</span>
                    <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">vc</span><span class="plain">; *</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="plain">&lt;</span><span class="identifier">adaptive</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">infinitive</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">verb_conjugation</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">auxiliary_only</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="identifier">word_assemblage</span><span class="plain"> *</span><span class="identifier">infinitive_form</span><span class="plain"> = &amp;(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">infinitive</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::compare_with_wording</span><span class="plain">(</span><span class="identifier">infinitive_form</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)) {</span>
                    <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">vc</span><span class="plain">; *</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP22"></a><b>&#167;22.  </b>These three nonterminals are used by Inform only to recognise constant
names for verbs. For example, the parsing of the Inform constants "the verb take"
or "the verb to be able to see" use these.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">instance</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="reserved">verb_form</span><span class="plain"> *</span><span class="identifier">vf</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">vf</span><span class="plain">, </span><span class="reserved">verb_form</span><span class="plain">) {</span>
            <span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain"> = </span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;underlying_verb</span><span class="plain">-</span><span class="element">&gt;conjugation</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">vc</span><span class="plain">) &amp;&amp; (</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">auxiliary_only</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">instance_of_verb</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::compare_with_wording</span><span class="plain">(&amp;(</span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;pos_reference_text</span><span class="plain">), </span><span class="identifier">W</span><span class="plain">)) {</span>
                    <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">vf</span><span class="plain">; *</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::compare_with_wording</span><span class="plain">(&amp;(</span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;neg_reference_text</span><span class="plain">), </span><span class="identifier">W</span><span class="plain">)) {</span>
                    <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">vf</span><span class="plain">; *</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="plain">&lt;</span><span class="identifier">instance</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">-</span><span class="identifier">infinitive</span><span class="plain">-</span><span class="identifier">form</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="reserved">verb_form</span><span class="plain"> *</span><span class="identifier">vf</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">vf</span><span class="plain">, </span><span class="reserved">verb_form</span><span class="plain">) {</span>
            <span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain"> = </span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;underlying_verb</span><span class="plain">-</span><span class="element">&gt;conjugation</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">vc</span><span class="plain">) &amp;&amp; (</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">auxiliary_only</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">instance_of_verb</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::compare_with_wording</span><span class="plain">(&amp;(</span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;infinitive_reference_text</span><span class="plain">), </span><span class="identifier">W</span><span class="plain">)) {</span>
                    <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">vf</span><span class="plain">; *</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="plain">&lt;</span><span class="identifier">modal</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">verb_conjugation</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">auxiliary_only</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">PREFORM_ADAPTIVE_PERSON</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">defined_in</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">tabulations</span><span class="plain">[</span><span class="identifier">ACTIVE_MOOD</span><span class="plain">].</span><span class="identifier">modal_auxiliary_usage</span><span class="plain">[</span><span class="identifier">IS_TENSE</span><span class="plain">][0][</span><span class="identifier">p</span><span class="plain">] != 0) {</span>
                    <span class="identifier">word_assemblage</span><span class="plain"> *</span><span class="identifier">we_form</span><span class="plain"> = &amp;(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">tabulations</span><span class="plain">[</span><span class="identifier">ACTIVE_MOOD</span><span class="plain">].</span><span class="identifier">vc_text</span><span class="plain">[</span><span class="identifier">IS_TENSE</span><span class="plain">][0][</span><span class="identifier">p</span><span class="plain">]);</span>
                    <span class="identifier">word_assemblage</span><span class="plain"> *</span><span class="identifier">we_dont_form</span><span class="plain"> = &amp;(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">tabulations</span><span class="plain">[</span><span class="identifier">ACTIVE_MOOD</span><span class="plain">].</span><span class="identifier">vc_text</span><span class="plain">[</span><span class="identifier">IS_TENSE</span><span class="plain">][1][</span><span class="identifier">p</span><span class="plain">]);</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::compare_with_wording</span><span class="plain">(</span><span class="identifier">we_form</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)) {</span>
                        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">vc</span><span class="plain">; *</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                    <span class="plain">}</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::compare_with_wording</span><span class="plain">(</span><span class="identifier">we_dont_form</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)) {</span>
                        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">vc</span><span class="plain">; *</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP23"></a><b>&#167;23. Optimisation. </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">VerbUsages::mark_as_verb</span><span class="plain">(</span><span class="identifier">vocabulary_entry</span><span class="plain"> *</span><span class="identifier">ve</span><span class="plain">) {</span>
        <span class="identifier">Preform::set_nt_incidence</span><span class="plain">(</span><span class="identifier">ve</span><span class="plain">, &lt;</span><span class="identifier">meaningful</span><span class="plain">-</span><span class="identifier">nonimperative</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt;);</span>
        <span class="identifier">Preform::set_nt_incidence</span><span class="plain">(</span><span class="identifier">ve</span><span class="plain">, &lt;</span><span class="identifier">copular</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt;);</span>
        <span class="identifier">Preform::set_nt_incidence</span><span class="plain">(</span><span class="identifier">ve</span><span class="plain">, &lt;</span><span class="identifier">negated</span><span class="plain">-</span><span class="identifier">noncopular</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">present</span><span class="plain">&gt;);</span>
        <span class="identifier">Preform::set_nt_incidence</span><span class="plain">(</span><span class="identifier">ve</span><span class="plain">, &lt;</span><span class="identifier">universal</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt;);</span>
        <span class="identifier">Preform::set_nt_incidence</span><span class="plain">(</span><span class="identifier">ve</span><span class="plain">, &lt;</span><span class="identifier">negated</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt;);</span>
        <span class="identifier">Preform::set_nt_incidence</span><span class="plain">(</span><span class="identifier">ve</span><span class="plain">, &lt;</span><span class="identifier">past</span><span class="plain">-</span><span class="identifier">tense</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt;);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">VerbUsages::preform_optimiser</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">Preform::mark_nt_as_requiring_itself_first</span><span class="plain">(&lt;</span><span class="identifier">meaningful</span><span class="plain">-</span><span class="identifier">nonimperative</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt;);</span>
        <span class="identifier">Preform::mark_nt_as_requiring_itself_first</span><span class="plain">(&lt;</span><span class="identifier">copular</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt;);</span>
        <span class="identifier">Preform::mark_nt_as_requiring_itself_first</span><span class="plain">(&lt;</span><span class="identifier">negated</span><span class="plain">-</span><span class="identifier">noncopular</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">present</span><span class="plain">&gt;);</span>
        <span class="identifier">Preform::mark_nt_as_requiring_itself_first</span><span class="plain">(&lt;</span><span class="identifier">universal</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt;);</span>
        <span class="identifier">Preform::mark_nt_as_requiring_itself_first</span><span class="plain">(&lt;</span><span class="identifier">negated</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt;);</span>
        <span class="identifier">Preform::mark_nt_as_requiring_itself_first</span><span class="plain">(&lt;</span><span class="identifier">past</span><span class="plain">-</span><span class="identifier">tense</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt;);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function VerbUsages::mark_as_verb is used in <a href="#SP6">&#167;6</a>.</p>

<p class="endnote">The function VerbUsages::preform_optimiser is used in 1/lm (<a href="1-lm.html#SP4">&#167;4</a>).</p>

<hr class="tocbar">
<ul class="toc"><li><a href="4-vrb.html">Back to 'Verbs'</a></li><li><a href="4-prp.html">Continue with 'Prepositions'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

