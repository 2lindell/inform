<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>5/np</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../compiler.html"><b>compiler</b></a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul>
<h2>Compiler Webs</h2>
<ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul>
<h2>Inbuild Modules</h2>
<ul>
<li><a href="../inbuild-module/index.html">inbuild</a></li>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../html-module/index.html">html</a></li>
</ul>
<h2>Inform7 Modules</h2>
<ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul>
<h2>Inter Modules</h2>
<ul>
<li><a href="../inter-module/index.html">inter</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of '5/vp' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="../compiler.html">Compiler Modules</a></li><li><a href="index.html">linguistics</a></li><li><a href="index.html#5">Chapter 5: Diagramming Sentences</a></li><li><b>Verb Phrases</b></li></ul><p class="purpose">To construct standard verb-phrase nodes in the parse tree.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Regular and existential verb phrases</a></li><li><a href="#SP6">&#167;6. Main nonterminal</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Regular and existential verb phrases. </b>Here we address the general case of an assertion sentence with a primary verb
in it. Note that we must expect at least some of the noun phrases in these
sentences to be previously unknown. To parse
</p>

<blockquote>
    <p>The coral snake is in the green bucket.</p>

</blockquote>

<p class="inwebparagraph">at a time when neither snake nor bucket has been mentioned before, we
really have little option but to look for "is" plus preposition,
and cannot use the words either side as any support for the hypothesis
that this is indeed the verb.
</p>

<p class="inwebparagraph">Perhaps surprisingly we will choose to regard the "in" here as being
part of the object phrase for the sentence. It might seem to belong to
the verb rather than to a noun phrase, but an implementation motivated
by that wouldn't work, for two reasons. First, English allows subject-verb
inversions such as "In the green bucket is the coral snake", where the
"in" has moved some distance from the verb "is". Second, we have to allow
some use of zeugma. Zeugma is sometimes thought to be rare in English and
to be basically a comedy effect, as in the famous Flanders and Swann lyric:
</p>

<blockquote>
    <p>She made no reply, up her mind, and a dash for the door.</p>

</blockquote>

<p class="inwebparagraph">in which three completely different senses of the same verb are used,
but in which the verb appears only once. It might seem reasonable for a
language like Inform simply to disallow this. Unfortunately, less
extreme zeugmas occur all the time:
</p>

<blockquote>
    <p>The red door is west of the Dining Room and east of the Ballroom.</p>

</blockquote>

<p class="inwebparagraph">So we will have to allow information about relationships to annotate
noun phrases, not just verb phrases.
</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>We will use the term "existential" for a "there is..." sentence such as:
</p>

<blockquote>
    <p>There are four coins on the table.</p>

</blockquote>

<p class="inwebparagraph">The subject here is the meaningless noun phrase "there". English is defective
in not allowing optional subjects: it would be more logical to say "if an open
door is", but in fact we say "if there is an open door".
</p>

<p class="inwebparagraph">Note that we will recognise "there" as a placeholder only in the subject
position. English does allow it as an object, but then it's anaphoric,
referring back to a previously discussed place &mdash; "I go into the lobby.
Julia is there." Since Inform can't handle anaphora, this isn't for us.
</p>

<p class="inwebparagraph">The most difficult existential sentences are those involving a second
verb, such as:
</p>

<blockquote>
    <p>There are four coins which are on the table.</p>

</blockquote>

<p class="inwebparagraph">The noun phrase of an existential sentence is recognised thus:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">existential</span><span class="plain">-</span><span class="identifier">np</span><span class="plain">&gt; ::=</span>
        <span class="identifier">there</span><span class="plain">							==&gt; </span><span class="identifier">ParseTree::new</span><span class="plain">(</span><span class="identifier">UNKNOWN_NT</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>We will want to spot adverbs of certainty adjacent to the verb itself;
English allows these either side, so "A man is usually happy" and "Peter
certainly is happy" are both possible. Note that these adverbs can divide
a verb from its preposition(s): consider "The rain in Spain lies mainly in
the plain", where "mainly" divides "lies" from "in".
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">pre</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">certainty</span><span class="plain">&gt; ::=</span>
        <span class="plain">... &lt;</span><span class="identifier">certainty</span><span class="plain">&gt;					==&gt; </span><span class="identifier">R</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">post</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">certainty</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">certainty</span><span class="plain">&gt; ...					==&gt; </span><span class="identifier">R</span><span class="plain">[1]</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>Relative clauses ("a woman who is on the stage") are detected by the presence
of a marker word before the verb (in this example, "who"). Of course, such
a word doesn't always mean we have a relative clause, so we will need to be a
little careful using this nonterminal.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">relative</span><span class="plain">-</span><span class="identifier">clause</span><span class="plain">-</span><span class="identifier">marker</span><span class="plain">&gt; ::=</span>
        <span class="identifier">which</span><span class="plain">/</span><span class="identifier">who</span><span class="plain">/</span><span class="identifier">that</span>

    <span class="plain">&lt;</span><span class="identifier">pre</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">rc</span><span class="plain">-</span><span class="identifier">marker</span><span class="plain">&gt; ::=</span>
        <span class="plain">... &lt;</span><span class="identifier">relative</span><span class="plain">-</span><span class="identifier">clause</span><span class="plain">-</span><span class="identifier">marker</span><span class="plain">&gt;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>For purely pragmatic reasons, we'll want to avoid reading prepositions (and
thus implicit relative clauses, such as "the cat in the hat") where they occur
after the word "called" in a sentence. For example, "a cat called Puss in
Boots" must not be thought to be in Boots.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">phrase</span><span class="plain">-</span><span class="identifier">with</span><span class="plain">-</span><span class="identifier">calling</span><span class="plain">&gt; ::=</span>
        <span class="plain">... </span><span class="identifier">called</span><span class="plain"> ...</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Main nonterminal. </b>And so this nonterminal turns a sentence into a small parse tree. Between 2010
and early 2016, this was implemented in straight Preform rather than as an
internal, but that became simply too complicated to maintain once imperative
verbs were added to the grammar. Still, it was a pity.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">sentence</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">trace_sentences</span><span class="plain">) { </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Parsing the sentence: %W\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">); </span><span class="identifier">LOG_INDENT</span><span class="plain">; }</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">rv</span><span class="plain"> = </span><span class="functiontext">VerbPhrases::seek</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">X</span><span class="plain">, </span><span class="identifier">XP</span><span class="plain">, 0);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">trace_sentences</span><span class="plain">) {</span>
            <span class="identifier">LOG_OUTDENT</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">rv</span><span class="plain">) {</span>
                <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Passed\</span><span class="plain">n</span><span class="string">"</span><span class="plain">); </span><span class="identifier">LOG_INDENT</span><span class="plain">;</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">N</span><span class="plain"> = *</span><span class="identifier">XP</span><span class="plain">; </span><span class="identifier">N</span><span class="plain">; </span><span class="identifier">N</span><span class="plain"> = </span><span class="identifier">N</span><span class="plain">-&gt;</span><span class="identifier">next</span><span class="plain">) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"$T"</span><span class="plain">, </span><span class="identifier">N</span><span class="plain">);</span>
                <span class="identifier">LOG_OUTDENT</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Failed\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">rv</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>The following routine is only very slightly recursive. It's used either
as above, to parse a whole sentence like "The coral snake is in the green
bucket", or else is called (once) from within itself to parse just the
"four coins which are on the table" part of a difficult existential sentence
such as "There are four coins which are on the table."
</p>

<p class="inwebparagraph">In the latter case, the call parameter <code class="display"><span class="extract">existential_OP_edge</span></code> will be the word
number of the last word which can be safely considered as a possible
preposition. (That would just be the position of the word "table", in this
example, but in a sentence such as "There is a cat called Puss in Boots" the
last safe preposition position is "cat", the word before "called".)
</p>

<p class="inwebparagraph">The sequence in which usages are considered is very important, since we are
going to return the first legal usage found. We also want to be reasonably
efficient in minimising the number of comparisons. We therefore first map out
which word positions might be the beginning of verb phrases.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">VIABILITY_MAP_SIZE</span><span class="plain"> 100</span>
</pre>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">VerbPhrases::seek</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">X</span><span class="plain">, </span><span class="reserved">void</span><span class="plain"> **</span><span class="identifier">XP</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">existential_OP_edge</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">viable</span><span class="plain">[</span><span class="constant">VIABILITY_MAP_SIZE</span><span class="plain">];</span>
        &lt;<span class="cwebmacro">Calculate the viability map</span> <span class="cwebmacronumber">7.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">trace_sentences</span><span class="plain">) </span>&lt;<span class="cwebmacro">Log the viability map</span> <span class="cwebmacronumber">7.2</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Seek verb usages</span> <span class="cwebmacronumber">7.3</span>&gt;<span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function VerbPhrases::seek is used in <a href="#SP6">&#167;6</a>, <a href="#SP7_3_1_2">&#167;7.3.1.2</a>.</p>

<p class="inwebparagraph"><a id="SP7_1"></a><b>&#167;7.1.  </b>If the word at position <code class="display"><span class="extract">i</span></code> doesn't occur in any verb known to us, then
that has viability 0. Otherwise: if this position is outside of any brackets,
the viability is 1, and if it's inside, then 2; except that if the position
is one where a negated verb other than "to be" can be found, then we blank
that stretch of words out with 3s. This blanking out enables us to skip over
negations like the "does not have" in
</p>

<blockquote>
    <p>The Solomon Islands does not have an air force.</p>

</blockquote>

<p class="inwebparagraph">and to avoid matching the subsequent "have". But the copular verb "to be" is
exempt from this. For the time being, if we see something like "Velma is not a
thinker" then we will parse it as "(Velma) is (not a thinker)", allowing "not
a thinker" to be a noun phrase. Assertions are generally supposed to be
positive statements, not negative ones, but we don't necessarily know about
this one yet. If "thinker" is an either/or property with a single possible
antonym &mdash; "doer", let's say &mdash; then we want to construe this sentence as if
it read "Velma is a doer". So, anyway, we allow "not" at the front of the
object noun phrase, and disallow "is not" and "are not" in order that this can
happen.
</p>

<p class="inwebparagraph">For example,
</p>

<blockquote>
    <p>The soldier can see that (this is true) they do not carry rifles.</p>

</blockquote>

<p class="inwebparagraph">produces
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">viable map: the[1] -- can[1] see[1] -- ([2] -- is[2] -- )[1] -- do[3] not[3] carry[3] --</span>
</pre>

<p class="inwebparagraph">Note that we sometimes get false positives when testing whether the word occurs
in a verb (hence the way open bracket is marked here), but that doesn't matter,
since non-zero-ness in the viability map is used only to speed up parsing.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Calculate the viability map</span> <span class="cwebmacronumber">7.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=0; (</span><span class="identifier">i</span><span class="plain">&lt;=</span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">i</span><span class="plain">&lt;</span><span class="constant">VIABILITY_MAP_SIZE</span><span class="plain">); </span><span class="identifier">i</span><span class="plain">++) </span><span class="identifier">viable</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] = 0;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">bl</span><span class="plain"> = 0;</span>
        <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pos</span><span class="plain"> == </span><span class="identifier">existential_OP_edge</span><span class="plain">) </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Lexer::word</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">) == </span><span class="identifier">OPENBRACKET_V</span><span class="plain">) || (</span><span class="identifier">Lexer::word</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">) == </span><span class="identifier">OPENBRACE_V</span><span class="plain">)) </span><span class="identifier">bl</span><span class="plain">++;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Lexer::word</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">) == </span><span class="identifier">CLOSEBRACKET_V</span><span class="plain">) || (</span><span class="identifier">Lexer::word</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">) == </span><span class="identifier">CLOSEBRACE_V</span><span class="plain">)) </span><span class="identifier">bl</span><span class="plain">--;</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain"> = </span><span class="identifier">pos</span><span class="plain"> - </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain"> &gt;= </span><span class="constant">VIABILITY_MAP_SIZE</span><span class="plain">) </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Preform::test_nt_incidence</span><span class="plain">(</span><span class="identifier">Lexer::word</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">), &lt;</span><span class="identifier">meaningful</span><span class="plain">-</span><span class="identifier">nonimperative</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt;) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">viable</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] = 0;</span>
            <span class="reserved">else</span><span class="plain"> {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bl</span><span class="plain"> == 0) </span><span class="identifier">viable</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] = 1; </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">viable</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] = 2;</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">pos_to</span><span class="plain"> = -(&lt;</span><span class="identifier">negated</span><span class="plain">-</span><span class="identifier">noncopular</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">present</span><span class="plain">&gt;(</span><span class="identifier">Wordings::from</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">pos</span><span class="plain">)));</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pos_to</span><span class="plain"> &gt; </span><span class="identifier">pos</span><span class="plain">) {</span>
                    <span class="reserved">while</span><span class="plain"> (</span><span class="identifier">pos_to</span><span class="plain"> &gt;= </span><span class="identifier">pos</span><span class="plain">) {</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain"> &lt; </span><span class="constant">VIABILITY_MAP_SIZE</span><span class="plain">) </span><span class="identifier">viable</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] = 3;</span>
                        <span class="identifier">pos</span><span class="plain">++, </span><span class="identifier">i</span><span class="plain">++;</span>
                    <span class="plain">}</span>
                    <span class="identifier">pos</span><span class="plain">--;</span>
                <span class="plain">}</span>
                <span class="reserved">if</span><span class="plain"> (((</span><span class="identifier">viable</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] == 1) || (</span><span class="identifier">viable</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] == 2)) &amp;&amp; (</span><span class="identifier">existential_OP_edge</span><span class="plain"> &gt; 0)) {</span>
                    <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">S</span><span class="plain"> = </span><span class="identifier">Wordings::up_to</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">pos</span><span class="plain"> - 1);</span>
                    <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">pre</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">rc</span><span class="plain">-</span><span class="identifier">marker</span><span class="plain">&gt;(</span><span class="identifier">S</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">viable</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] = 0;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7">&#167;7</a>.</p>

<p class="inwebparagraph"><a id="SP7_2"></a><b>&#167;7.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Log the viability map</span> <span class="cwebmacronumber">7.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"viable map: "</span><span class="plain">);</span>
        <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain"> = </span><span class="identifier">pos</span><span class="plain"> - </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain"> &gt;= </span><span class="constant">VIABILITY_MAP_SIZE</span><span class="plain">) </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">viable</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"%W[%d] "</span><span class="plain">, </span><span class="identifier">Wordings::one_word</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">), </span><span class="identifier">viable</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]);</span>
            <span class="reserved">else</span><span class="plain"> </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"-- "</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7">&#167;7</a>.</p>

<p class="inwebparagraph"><a id="SP7_3"></a><b>&#167;7.3.  </b>We are in fact interested only in word positions with viability 1 or 2, and
in practice viability 2 positions are very unlikely to be correct, so we
will first make every effort to match a verb at a viability 1 position.
(Why do we allow viability 2 matches at all? Really just so that we can
report them as problems.)
</p>

<p class="inwebparagraph">Within that constraint, we check in two passes. On pass 1, we skip over any
verb usage which might be part of a relative clause, in that it's preceded
by a relative clause marker; on pass 2, should we ever get that far, this
restriction is lifted. Thus for example in the sentence
</p>

<blockquote>
    <p>A man who does not carry an octopus is happy.</p>

</blockquote>

<p class="inwebparagraph">we would skip over the words of "does not carry" on pass 1 because they are
preceded by "who". The reason we go on to pass 2 is not that relative clauses
are ever allowed here: they aren't. It's that we might have misunderstood
the relative clause marker. For example, in
</p>

<blockquote>
    <p>Telling it that is gossipy behaviour.</p>

</blockquote>

<p class="inwebparagraph">the "that" doesn't introduce a relative clause; "telling it that" is a
well-formed noun phrase.
</p>

<p class="inwebparagraph">Within each pass, we try each priority tier in turn (except the priority 0
tier, which is never allowed). Within each tier, we look for the leftmost
position of the current viability at which a verb usage occurs, and if two
such occur at the same position, we take the longer (or if they are of
equal length, the earliest defined).
</p>

<p class="inwebparagraph">The reason we need tiers is that many plausible sentences contain multiple
apparent uses of verbs. Consider:
</p>

<blockquote>
    <p>Fred has carrying capacity 2.</p>

</blockquote>

<p class="inwebparagraph">where "has" and "carrying" could each be read as part of a verb phrase.
(In Inform, "To have" is on a higher tier than "to carry".) Or:
</p>

<blockquote>
    <p>The Fisher-Price carry cot is a container.</p>

</blockquote>

<p class="inwebparagraph">In this sentence, "carry" is intended as part of the subject noun phrase,
but Inform has no way of telling that: if we didn't give "to be" priority
over "to carry" we would construe this sentence as saying that a group of
people called The Fisher-Price, perhaps a rock group, are carrying an
object called "cot is a container", perhaps their new EP of remixed
techno lullabies. (Far fewer plausible noun phrases contain "is" than
contain other verbs such as "carry".)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Seek verb usages</span> <span class="cwebmacronumber">7.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">viability_level</span><span class="plain"> = 1; </span><span class="identifier">viability_level</span><span class="plain"> &lt;= 2; </span><span class="identifier">viability_level</span><span class="plain">++)</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">pass</span><span class="plain"> = 1; </span><span class="identifier">pass</span><span class="plain"> &lt;= 2; </span><span class="identifier">pass</span><span class="plain">++)</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">verb_usage_tier</span><span class="plain"> *</span><span class="identifier">tier</span><span class="plain"> = </span><span class="identifier">first_search_tier</span><span class="plain">; </span><span class="identifier">tier</span><span class="plain">; </span><span class="identifier">tier</span><span class="plain"> = </span><span class="identifier">tier</span><span class="plain">-</span><span class="element">&gt;next_tier</span><span class="plain">)</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">tier</span><span class="plain">-</span><span class="element">&gt;priority</span><span class="plain"> != 0)</span>
                        <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">) {</span>
                            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">j</span><span class="plain"> = </span><span class="identifier">pos</span><span class="plain"> - </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
                            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">j</span><span class="plain">&lt;</span><span class="constant">VIABILITY_MAP_SIZE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">viable</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">] != </span><span class="identifier">viability_level</span><span class="plain">)) </span><span class="reserved">continue</span><span class="plain">;</span>
                            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">TW</span><span class="plain"> = </span><span class="identifier">Wordings::from</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">pos</span><span class="plain">);</span>
                            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain"> = </span><span class="identifier">tier</span><span class="plain">-</span><span class="element">&gt;tier_contents</span><span class="plain">; </span><span class="identifier">vu</span><span class="plain">; </span><span class="identifier">vu</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;next_within_tier</span><span class="plain">)</span>
                                &lt;<span class="cwebmacro">Consider whether this usage is being made at this position</span> <span class="cwebmacronumber">7.3.1</span>&gt;<span class="plain">;</span>
                        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7">&#167;7</a>.</p>

<p class="inwebparagraph"><a id="SP7_3_1"></a><b>&#167;7.3.1.  </b>At this point <code class="display"><span class="extract">TW</span></code> is the tail of the wording: its first word is what we
think might be the verb. For example, given
</p>

<blockquote>
    <p>The coral snake is in the green bucket.</p>

</blockquote>

<p class="inwebparagraph">we might have "is in the green bucket". We must test whether our verb usage
appears at the front of <code class="display"><span class="extract">TW</span></code>, and if so, whether it's meaningful. But in
fact we will make these checks in reverse order, for efficiency's sake.
(There are potentially a great many meaningless verbs, because of the
way adaptive text is handled in Inform.)
</p>

<p class="inwebparagraph">A further complication is that we will reject this usage if it occurs
somewhere forbidden: for example, if a verb form is only allowed in an SVO
configuration, we will ignore it if <code class="display"><span class="extract">TW</span></code> is the whole of <code class="display"><span class="extract">W</span></code>, because then the
verb would begin at the first word of the sentence. Conversely, if it is only
allowed in an imperative VO configuration, it's required to be there. Thus if
the whole sentence is "Carries Peter" then we won't match "carries", because
it's at the front; and if it's "Peter test me with flash cards", we won't
match "test... with..." because it's not at the front.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Consider whether this usage is being made at this position</span> <span class="cwebmacronumber">7.3.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">verb_identity</span><span class="plain"> *</span><span class="identifier">vi</span><span class="plain"> = </span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;verb_used</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain"> = -1;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">ISW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="identifier">IOW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">certainty</span><span class="plain"> = </span><span class="constant">UNKNOWN_CE</span><span class="plain">, </span><span class="identifier">pre_certainty</span><span class="plain"> = </span><span class="constant">UNKNOWN_CE</span><span class="plain">, </span><span class="identifier">post_certainty</span><span class="plain"> = </span><span class="constant">UNKNOWN_CE</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">verb_form</span><span class="plain"> *</span><span class="identifier">vf</span><span class="plain"> = </span><span class="identifier">vi</span><span class="plain">-</span><span class="element">&gt;list_of_forms</span><span class="plain">; </span><span class="identifier">vf</span><span class="plain">; </span><span class="identifier">vf</span><span class="plain"> = </span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;next_form</span><span class="plain">) {</span>
            <span class="reserved">verb_meaning</span><span class="plain"> *</span><span class="identifier">vm</span><span class="plain"> = &amp;(</span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;list_of_senses</span><span class="plain">-</span><span class="element">&gt;vm</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">VerbMeanings::is_meaningless</span><span class="plain">(</span><span class="identifier">vm</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain"> &lt; 0) {</span>
                    <span class="identifier">i</span><span class="plain"> = </span><span class="functiontext">VerbUsages::parse_against_verb</span><span class="plain">(</span><span class="identifier">TW</span><span class="plain">, </span><span class="identifier">vu</span><span class="plain">);</span>
                    <span class="reserved">if</span><span class="plain"> (!((</span><span class="identifier">i</span><span class="plain">&gt;</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">TW</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">i</span><span class="plain">&lt;=</span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">TW</span><span class="plain">)))) </span><span class="reserved">break</span><span class="plain">;</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;form_structures</span><span class="plain"> &amp; (</span><span class="constant">VO_FS_BIT</span><span class="plain"> + </span><span class="constant">VOO_FS_BIT</span><span class="plain">)) {</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pos</span><span class="plain"> &gt; </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="reserved">break</span><span class="plain">;</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pos</span><span class="plain"> == </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="reserved">break</span><span class="plain">;</span>
                    <span class="plain">}</span>
                    &lt;<span class="cwebmacro">Now we definitely have the verb usage at the front</span> <span class="cwebmacronumber">7.3.1.1</span>&gt;<span class="plain">;</span>
                <span class="plain">}</span>
                &lt;<span class="cwebmacro">Check whether the rest of the verb form pans out</span> <span class="cwebmacronumber">7.3.1.2</span>&gt;<span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7_3">&#167;7.3</a>.</p>

<p class="inwebparagraph"><a id="SP7_3_1_1"></a><b>&#167;7.3.1.1.  </b>So now we know that the verb definitely appears. We form <code class="display"><span class="extract">ISW</span></code> as the
wording for the subject phrase and <code class="display"><span class="extract">IOW</span></code> the object phrase. Adverbs of
certainty are removed from these.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Now we definitely have the verb usage at the front</span> <span class="cwebmacronumber">7.3.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">ISW</span><span class="plain"> = </span><span class="identifier">Wordings::up_to</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">pos</span><span class="plain">-1);</span>
        <span class="identifier">IOW</span><span class="plain"> = </span><span class="identifier">Wordings::from</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">i</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">pre</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">certainty</span><span class="plain">&gt;(</span><span class="identifier">ISW</span><span class="plain">)) {</span>
            <span class="identifier">pre_certainty</span><span class="plain"> = &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;;</span>
            <span class="identifier">ISW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">pre</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">certainty</span><span class="plain">&gt;, 1);</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">post</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">certainty</span><span class="plain">&gt;(</span><span class="identifier">IOW</span><span class="plain">)) {</span>
            <span class="identifier">post_certainty</span><span class="plain"> = &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;;</span>
            <span class="identifier">IOW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">post</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">certainty</span><span class="plain">&gt;, 1);</span>
        <span class="plain">}</span>
        <span class="identifier">certainty</span><span class="plain"> = </span><span class="identifier">pre_certainty</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">certainty</span><span class="plain"> == </span><span class="constant">UNKNOWN_CE</span><span class="plain">) </span><span class="identifier">certainty</span><span class="plain"> = </span><span class="identifier">post_certainty</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">trace_sentences</span><span class="plain">) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Found usage, pass %d tier %d: (%W) $w (%W)\</span><span class="plain">n</span><span class="string">"</span><span class="plain">,</span>
            <span class="identifier">pass</span><span class="plain">, </span><span class="identifier">tier</span><span class="plain">-</span><span class="element">&gt;priority</span><span class="plain">, </span><span class="identifier">ISW</span><span class="plain">, </span><span class="identifier">vi</span><span class="plain">, </span><span class="identifier">IOW</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7_3_1">&#167;7.3.1</a>.</p>

<p class="inwebparagraph"><a id="SP7_3_1_2"></a><b>&#167;7.3.1.2.  </b>If the verb form is, say, "place in ... with ...", and we have detected the
verb as "places" in the sentence "Henry places the cherry on the cake", we
still must reject this usage because it's missing the essential prepositions
"in" and "with". (It would, however, pass if the verb form were "place... on...".)
</p>

<p class="inwebparagraph">This is also where we detect whether we have an existential sentence such as
"There is a man in the Dining Room." If so, we will have to allow for the
preposition "in" to be divided from the verb "is". But we will first check
(by using our one level of recursion) whether the tail of the sentence makes
sense in its own right. In this example it doesn't, but for "There is a man
who is in the Dining Room" (note the additional "is"), it would.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Check whether the rest of the verb form pans out</span> <span class="cwebmacronumber">7.3.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SW</span><span class="plain"> = </span><span class="identifier">ISW</span><span class="plain">, </span><span class="identifier">OW</span><span class="plain"> = </span><span class="identifier">IOW</span><span class="plain">, </span><span class="identifier">O2W</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">VW</span><span class="plain"> = </span><span class="identifier">Wordings::up_to</span><span class="plain">(</span><span class="identifier">TW</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">OW</span><span class="plain">) - 1);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">existential_OP_edge</span><span class="plain"> &gt; 0) { </span>    <span class="comment">i.e., if we are looking for "(S which) verbs (O)"</span>
            <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">pre</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">rc</span><span class="plain">-</span><span class="identifier">marker</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">)) { </span>    <span class="comment">there is indeed a "which" at the end of <code class="display"><span class="extract">SW</span></code></span>
                <span class="identifier">SW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">pre</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">rc</span><span class="plain">-</span><span class="identifier">marker</span><span class="plain">&gt;, 1); </span>    <span class="comment">so trim it off</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">trace_sentences</span><span class="plain">) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Trimmed to: (%W) $w (%W)\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">SW</span><span class="plain">, </span><span class="identifier">vi</span><span class="plain">, </span><span class="identifier">OW</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>

        <span class="reserved">preposition_identity</span><span class="plain"> *</span><span class="identifier">prep</span><span class="plain"> = </span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;preposition</span><span class="plain">;</span>
        <span class="reserved">preposition_identity</span><span class="plain"> *</span><span class="identifier">second_prep</span><span class="plain"> = </span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;second_clause_preposition</span><span class="plain">;</span>

        <span class="reserved">preposition_identity</span><span class="plain"> *</span><span class="identifier">required_first</span><span class="plain"> = </span><span class="identifier">prep</span><span class="plain">;</span>
        <span class="reserved">preposition_identity</span><span class="plain"> *</span><span class="identifier">required_second</span><span class="plain"> = </span><span class="identifier">second_prep</span><span class="plain">;</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">existential</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">structures</span><span class="plain"> = </span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;form_structures</span><span class="plain">, </span><span class="identifier">last_preposition_position</span><span class="plain"> = </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">OW</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">existential_OP_edge</span><span class="plain"> == 0) &amp;&amp; (</span><span class="identifier">vi</span><span class="plain"> == </span><span class="identifier">copular_verb</span><span class="plain">) &amp;&amp; (</span><span class="identifier">required_second</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">existential</span><span class="plain">-</span><span class="identifier">np</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">))) {</span>
            <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">phrase</span><span class="plain">-</span><span class="identifier">with</span><span class="plain">-</span><span class="identifier">calling</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">))</span>
                <span class="identifier">last_preposition_position</span><span class="plain"> = </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">phrase</span><span class="plain">-</span><span class="identifier">with</span><span class="plain">-</span><span class="identifier">calling</span><span class="plain">&gt;, 1));</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">rv</span><span class="plain"> = </span><span class="functiontext">VerbPhrases::seek</span><span class="plain">(</span><span class="identifier">OW</span><span class="plain">, </span><span class="identifier">X</span><span class="plain">, </span><span class="identifier">XP</span><span class="plain">, </span><span class="identifier">last_preposition_position</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">rv</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">rv</span><span class="plain">;</span>
            <span class="identifier">existential</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="identifier">structures</span><span class="plain"> = </span><span class="constant">SVOO_FS_BIT</span><span class="plain">; </span><span class="identifier">required_first</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="identifier">required_second</span><span class="plain"> = </span><span class="identifier">prep</span><span class="plain">;</span>
        <span class="plain">}</span>

        &lt;<span class="cwebmacro">Check whether we do indeed have these required prepositions in place</span> <span class="cwebmacronumber">7.3.1.2.1</span>&gt;<span class="plain">;</span>

        <span class="comment">we couldn't check for this before, since we need to skip past the prepositions too</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">pass</span><span class="plain"> == 1) &amp;&amp; (&lt;</span><span class="identifier">pre</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">rc</span><span class="plain">-</span><span class="identifier">marker</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">))) { </span><span class="identifier">pos</span><span class="plain"> = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">OW</span><span class="plain">) - 1; </span><span class="reserved">continue</span><span class="plain">; }</span>

        &lt;<span class="cwebmacro">Check whether any sense of this verb form will accept this usage and succeed if so</span> <span class="cwebmacronumber">7.3.1.2.2</span>&gt;<span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7_3_1">&#167;7.3.1</a>.</p>

<p class="inwebparagraph"><a id="SP7_3_1_2_1"></a><b>&#167;7.3.1.2.1.  </b>This part at least is boringly straightforward.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Check whether we do indeed have these required prepositions in place</span> <span class="cwebmacronumber">7.3.1.2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">usage_succeeds</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">required_first</span><span class="plain">) {</span>
            <span class="identifier">usage_succeeds</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (!((</span><span class="identifier">required_first</span><span class="plain">-</span><span class="element">&gt;allow_unexpected_upper_case</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp;</span>
                <span class="plain">(</span><span class="identifier">Word::unexpectedly_upper_case</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">OW</span><span class="plain">)))))</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::is_at</span><span class="plain">(&amp;(</span><span class="identifier">required_first</span><span class="plain">-</span><span class="element">&gt;prep_text</span><span class="plain">),</span>
                        <span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">OW</span><span class="plain">), </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">TW</span><span class="plain">))) {</span>
                    <span class="identifier">OW</span><span class="plain"> = </span><span class="identifier">Wordings::from</span><span class="plain">(</span><span class="identifier">OW</span><span class="plain">,</span>
                        <span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">OW</span><span class="plain">) + </span><span class="identifier">WordAssemblages::length</span><span class="plain">(&amp;(</span><span class="identifier">required_first</span><span class="plain">-</span><span class="element">&gt;prep_text</span><span class="plain">)));</span>
                    <span class="identifier">VW</span><span class="plain"> = </span><span class="identifier">Wordings::up_to</span><span class="plain">(</span><span class="identifier">TW</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">OW</span><span class="plain">) - 1);</span>
                    <span class="identifier">usage_succeeds</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">usage_succeeds</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">trace_sentences</span><span class="plain">) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"$w + $p + $p : failed for lack of $p\</span><span class="plain">n</span><span class="string">"</span><span class="plain">,</span>
                    <span class="identifier">vi</span><span class="plain">, </span><span class="identifier">prep</span><span class="plain">, </span><span class="identifier">second_prep</span><span class="plain">, </span><span class="identifier">prep</span><span class="plain">);</span>
                <span class="reserved">continue</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">required_second</span><span class="plain">) {</span>
            <span class="identifier">usage_succeeds</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">found</span><span class="plain"> = -1;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">j</span><span class="plain">=</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">OW</span><span class="plain">) + 1; </span><span class="identifier">j</span><span class="plain"> &lt; </span><span class="identifier">last_preposition_position</span><span class="plain">; </span><span class="identifier">j</span><span class="plain">++) {</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">TOW</span><span class="plain"> = </span><span class="identifier">Wordings::from</span><span class="plain">(</span><span class="identifier">OW</span><span class="plain">, </span><span class="identifier">j</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::is_at</span><span class="plain">(&amp;(</span><span class="identifier">required_second</span><span class="plain">-</span><span class="element">&gt;prep_text</span><span class="plain">),</span>
                    <span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">TOW</span><span class="plain">), </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">TOW</span><span class="plain">))) {</span>
                    <span class="identifier">found</span><span class="plain"> = </span><span class="identifier">j</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">found</span><span class="plain"> &gt;= 0) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">existential</span><span class="plain">) </span><span class="identifier">SW</span><span class="plain"> = </span><span class="identifier">Wordings::up_to</span><span class="plain">(</span><span class="identifier">OW</span><span class="plain">, </span><span class="identifier">found</span><span class="plain">-1);</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="identifier">O2W</span><span class="plain"> = </span><span class="identifier">Wordings::up_to</span><span class="plain">(</span><span class="identifier">OW</span><span class="plain">, </span><span class="identifier">found</span><span class="plain">-1);</span>
                <span class="identifier">OW</span><span class="plain"> = </span><span class="identifier">Wordings::from</span><span class="plain">(</span><span class="identifier">OW</span><span class="plain">, </span><span class="identifier">found</span><span class="plain"> + </span><span class="identifier">WordAssemblages::length</span><span class="plain">(&amp;(</span><span class="identifier">required_second</span><span class="plain">-</span><span class="element">&gt;prep_text</span><span class="plain">)));</span>
                <span class="identifier">usage_succeeds</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">usage_succeeds</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">trace_sentences</span><span class="plain">) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"$w + $p + $p : failed for lack of $p\</span><span class="plain">n</span><span class="string">"</span><span class="plain">,</span>
                    <span class="identifier">vi</span><span class="plain">, </span><span class="identifier">prep</span><span class="plain">, </span><span class="identifier">second_prep</span><span class="plain">, </span><span class="identifier">second_prep</span><span class="plain">);</span>
                <span class="reserved">continue</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7_3_1_2">&#167;7.3.1.2</a>.</p>

<p class="inwebparagraph"><a id="SP7_3_1_2_2"></a><b>&#167;7.3.1.2.2.  </b>Now we're getting somewhere. The verb and any prepositions required by this
form are all in place, and we know this would be a meaningful sentence. So
we start building the diagram tree for the sentence at last, with the node
representing the verb.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Check whether any sense of this verb form will accept this usage and succeed if so</span> <span class="cwebmacronumber">7.3.1.2.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">possessive</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">VerbMeanings::get_relational_meaning</span><span class="plain">(</span><span class="identifier">vm</span><span class="plain">) == </span><span class="identifier">VERB_MEANING_POSSESSION</span><span class="plain">)</span>
            <span class="identifier">possessive</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">VP_PN</span><span class="plain"> = </span><span class="identifier">ParseTree::new</span><span class="plain">(</span><span class="constant">AVERB_NT</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">certainty</span><span class="plain"> != </span><span class="constant">UNKNOWN_CE</span><span class="plain">)</span>
            <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="constant">verbal_certainty_ANNOT</span><span class="plain">, </span><span class="identifier">certainty</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vu</span><span class="plain">) </span><span class="identifier">ParseTree::set_verb</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">vu</span><span class="plain">);</span>
        <span class="identifier">ParseTree::set_preposition</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">prep</span><span class="plain">);</span>
        <span class="identifier">ParseTree::set_second_preposition</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">second_prep</span><span class="plain">);</span>

        <span class="identifier">ParseTree::set_text</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">VW</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">possessive</span><span class="plain">) </span><span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="constant">possessive_verb_ANNOT</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">existential</span><span class="plain">) </span><span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="constant">sentence_is_existential_ANNOT</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">pre_certainty</span><span class="plain"> != </span><span class="constant">UNKNOWN_CE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">post_certainty</span><span class="plain"> != </span><span class="constant">UNKNOWN_CE</span><span class="plain">))</span>
            <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="constant">linguistic_error_here_ANNOT</span><span class="plain">, </span><span class="constant">TwoLikelihoods_LINERROR</span><span class="plain">);</span>

        <span class="identifier">VP_PN</span><span class="plain"> = </span><span class="functiontext">VerbPhrases::accept</span><span class="plain">(</span><span class="identifier">vf</span><span class="plain">, </span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">SW</span><span class="plain">, </span><span class="identifier">OW</span><span class="plain">, </span><span class="identifier">O2W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">VP_PN</span><span class="plain">) {</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">VP_PN</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">trace_sentences</span><span class="plain">) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Accepted as $w + $p + $p\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">vi</span><span class="plain">, </span><span class="identifier">prep</span><span class="plain">, </span><span class="identifier">second_prep</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">trace_sentences</span><span class="plain">) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Rejected as $w + $p + $p\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">vi</span><span class="plain">, </span><span class="identifier">prep</span><span class="plain">, </span><span class="identifier">second_prep</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7_3_1_2">&#167;7.3.1.2</a>.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>This routine completes the sentence diagram by adding further nodes to
represent the subject and object phrases. How this is done depends on the
sense of the verb: for example, in Inform, "X is an activity" produces a
rather different subtree to "Peter is a man". What happens is that each
possible sense of the verb form (in this case "is" with no prepositions)
is tried in turn: each one is asked, in effect, do you want this sentence?
</p>

<p class="inwebparagraph">This is where, at last, special sentence meaning functions come into their
own: they are called with the task <code class="display"><span class="extract">ACCEPT_SMFT</span></code> to see if they are willing
to accept this sentence, whose noun phrases are stored in the <code class="display"><span class="extract">NPs</span></code> array.
If they do want it, they should build the necessary diagram and return <code class="display"><span class="extract">TRUE</span></code>.
</p>

<p class="inwebparagraph">If all the special meanings decline, we can fall back on a regular meaning.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">MAX_NPS_IN_VP</span><span class="plain"> 3</span>
</pre>

<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">VerbPhrases::accept</span><span class="plain">(</span><span class="reserved">verb_form</span><span class="plain"> *</span><span class="identifier">vf</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SW</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">O2W</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">NPs</span><span class="plain">[</span><span class="constant">MAX_NPS_IN_VP</span><span class="plain">];</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="constant">MAX_NPS_IN_VP</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) </span><span class="identifier">NPs</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">NPs</span><span class="plain">[0] = </span><span class="identifier">SW</span><span class="plain">; </span><span class="identifier">NPs</span><span class="plain">[1] = </span><span class="identifier">OW</span><span class="plain">; </span><span class="identifier">NPs</span><span class="plain">[2] = </span><span class="identifier">O2W</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">verb_sense</span><span class="plain"> *</span><span class="identifier">vs</span><span class="plain"> = (</span><span class="identifier">vf</span><span class="plain">)?</span><span class="identifier">vf</span><span class="plain">-</span><span class="element">&gt;list_of_senses</span><span class="plain">:</span><span class="identifier">NULL</span><span class="plain">; </span><span class="identifier">vs</span><span class="plain">; </span><span class="identifier">vs</span><span class="plain"> = </span><span class="identifier">vs</span><span class="plain">-</span><span class="element">&gt;next_sense</span><span class="plain">) {</span>
            <span class="reserved">verb_meaning</span><span class="plain"> *</span><span class="identifier">vm</span><span class="plain"> = &amp;(</span><span class="identifier">vs</span><span class="plain">-</span><span class="element">&gt;vm</span><span class="plain">);</span>
            <span class="identifier">ParseTree::set_verb_meaning</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">vm</span><span class="plain">);</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">rev</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="identifier">special_meaning_fn</span><span class="plain"> </span><span class="identifier">soa</span><span class="plain"> = </span><span class="functiontext">VerbMeanings::get_special_meaning</span><span class="plain">(</span><span class="identifier">vm</span><span class="plain">, &amp;</span><span class="identifier">rev</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">soa</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">rev</span><span class="plain">) { </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">NPs</span><span class="plain">[0]; </span><span class="identifier">NPs</span><span class="plain">[0] = </span><span class="identifier">NPs</span><span class="plain">[1]; </span><span class="identifier">NPs</span><span class="plain">[1] = </span><span class="identifier">W</span><span class="plain">; }</span>
                <span class="reserved">if</span><span class="plain"> ((*</span><span class="identifier">soa</span><span class="plain">)(</span><span class="constant">ACCEPT_SMFT</span><span class="plain">, </span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">NPs</span><span class="plain">)) {</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">VP_PN</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">rev</span><span class="plain">) { </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">NPs</span><span class="plain">[0]; </span><span class="identifier">NPs</span><span class="plain">[0] = </span><span class="identifier">NPs</span><span class="plain">[1]; </span><span class="identifier">NPs</span><span class="plain">[1] = </span><span class="identifier">W</span><span class="plain">; }</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">VerbPhrases::default_verb</span><span class="plain">(</span><span class="constant">ACCEPT_SMFT</span><span class="plain">, </span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">NPs</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">VP_PN</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function VerbPhrases::accept is used in <a href="#SP7_3_1_2_2">&#167;7.3.1.2.2</a>.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>In effect, this is the sentence meaning function for all regular meanings.
For example, "Darcy is proud" and "Darcy wears the hat" will both end up here.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">VerbPhrases::default_verb</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">NPs</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[0]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[1]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">NPs</span><span class="plain">[2])) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">ACCEPT_SMFT</span><span class="plain">: {</span>
                <span class="reserved">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain"> = </span><span class="identifier">ParseTree::get_verb</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">);</span>
                <span class="reserved">verb_identity</span><span class="plain"> *</span><span class="identifier">vsave</span><span class="plain"> = </span><span class="identifier">permitted_verb_identity</span><span class="plain">;</span>
                <span class="identifier">permitted_verb_identity</span><span class="plain"> = (</span><span class="identifier">vu</span><span class="plain">)?</span><span class="identifier">vu</span><span class="plain">-</span><span class="element">&gt;verb_used</span><span class="plain">:</span><span class="identifier">NULL</span><span class="plain">;</span>

                <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"&lt;nounphrase-as-object&gt; failed"</span><span class="plain">);</span>
                <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">O_PN</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>

                <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"&lt;nounphrase-as-subject&gt; failed"</span><span class="plain">);</span>
                <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">S_PN</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>

                <span class="identifier">V</span><span class="plain">-&gt;</span><span class="identifier">next</span><span class="plain"> = </span><span class="identifier">S_PN</span><span class="plain">;</span>
                <span class="identifier">V</span><span class="plain">-&gt;</span><span class="identifier">next</span><span class="plain">-&gt;</span><span class="identifier">next</span><span class="plain"> = </span><span class="identifier">O_PN</span><span class="plain">;</span>
                &lt;<span class="cwebmacro">Insert a relationship subtree if the verb creates one without a relative phrase</span> <span class="cwebmacronumber">9.1</span>&gt;<span class="plain">;</span>

                <span class="identifier">permitted_verb_identity</span><span class="plain"> = </span><span class="identifier">vsave</span><span class="plain">;</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function VerbPhrases::default_verb is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP9_1"></a><b>&#167;9.1.  </b>If we have parsed a verb expressing a relationship other than equality, we
need to record that in the parse tree. This code does the following:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">SENTENCE_NT "Darcy wears the hat"  ---&gt;  SENTENCE_NT "Darcy wears the hat"</span>
        <span class="plain">    AVERB_NT "wears"                         AVERB_NT "wears"</span>
        <span class="plain">    PROPER_NOUN_NT "Darcy"                   PROPER_NOUN_NT "Darcy"</span>
        <span class="plain">    PROPER_NOUN_NT "hat"                     RELATIONSHIP_NT "wears" = is-worn-by</span>
        <span class="plain">                                                 PROPER_NOUN_NT "hat"</span>
</pre>

<p class="inwebparagraph">The meaning is reversed here because we are applying it to the object of the
sentence not the subject: we thus turn the idea of Darcy wearing the hat into
the exactly equivalent idea of the hat being worn by Darcy.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Insert a relationship subtree if the verb creates one without a relative phrase</span> <span class="cwebmacronumber">9.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">verb_meaning</span><span class="plain"> *</span><span class="identifier">vm</span><span class="plain"> = </span><span class="identifier">ParseTree::get_verb_meaning</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">);</span>
        <span class="identifier">VERB_MEANING_TYPE</span><span class="plain"> *</span><span class="identifier">meaning</span><span class="plain"> = </span><span class="functiontext">VerbMeanings::get_relational_meaning</span><span class="plain">(</span><span class="identifier">vm</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">meaning</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">ParseTree::set_verb_meaning</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">vm</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">possessive_verb_ANNOT</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">meaning</span><span class="plain"> != </span><span class="identifier">VERB_MEANING_EQUALITY</span><span class="plain">)) {</span>
            <span class="identifier">V</span><span class="plain">-&gt;</span><span class="identifier">next</span><span class="plain">-&gt;</span><span class="identifier">next</span><span class="plain"> = </span><span class="functiontext">NounPhrases::PN_rel</span><span class="plain">(</span>
                <span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">), </span><span class="identifier">VERB_MEANING_REVERSAL</span><span class="plain">(</span><span class="identifier">meaning</span><span class="plain">), </span><span class="constant">STANDARD_RELN</span><span class="plain">, </span><span class="identifier">O_PN</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP9">&#167;9</a>.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="5-np.html">Back to 'Noun Phrases'</a></li><li><i>(This section ends Chapter 5: Diagramming Sentences.)</i></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

