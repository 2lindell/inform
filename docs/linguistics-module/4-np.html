<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Noun Phrases</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
MathJax = {
	tex: {
		inlineMath: '$', '$'], ['\\(', '\\)'
	},
	svg: {
		fontCache: 'global'
	}
};
</script>
<script type="text/javascript" id="MathJax-script" async
	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Preform-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../compiler.html">compiler tools</a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul><h2>Compiler Webs</h2><ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul><h2>Inbuild Modules</h2><ul>
<li><a href="../supervisor-module/index.html">supervisor</a></li>
</ul><h2>Inform7 Modules</h2><ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul><h2>Inter Modules</h2><ul>
<li><a href="../bytecode-module/index.html">bytecode</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul><h2>Services</h2><ul>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../html-module/index.html">html</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="index.html"><span class="selectedlink">linguistics</span></a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Noun Phrases' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../compiler.html">Services</a></li><li><a href="index.html">linguistics</a></li><li><a href="index.html#4">Chapter 4: Diagramming Sentences</a></li><li><b>Noun Phrases</b></li></ul></div>
<p class="purpose">To construct noun-phrase subtrees for assertion sentences found in the parse tree.</p>

<ul class="toc"><li><a href="4-np.html#SP1">&#167;1. Hierarchy of noun phrases</a></li><li><a href="4-np.html#SP2">&#167;2. Raw nounphrases (NP1)</a></li><li><a href="4-np.html#SP4">&#167;4. Articled nounphrases (NP2)</a></li><li><a href="4-np.html#SP7">&#167;7. List-divided nounphrases (NP3)</a></li><li><a href="4-np.html#SP9">&#167;9. Full nounphrases (NP4)</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1"></a><b>&#167;1. Hierarchy of noun phrases. </b>Noun phrase nodes are built at four levels of elaboration, which we take in
turn:
</p>

<ul class="items"><ul class="items"><li>(NP1) Raw: where the text is entirely untouched and unannotated.
</li><li>(NP2) Articled: where any initial article is converted to an annotation.
</li><li>(NP3) List-divided: where, in addition, a list is broken up into individual items.
</li><li>(NP4) Full: where, in addition, pronouns, relative phrases establishing
relationships and properties, and so on are parsed.
</li></ul>
</li></ul>
<p class="commentary firstcommentary"><a id="SP2"></a><b>&#167;2. Raw nounphrases (NP1). </b>A raw noun phrase is always a single <span class="extract"><span class="extract-syntax">UNPARSED_NOUN_NT</span></span>. The following always
matches any non-empty text:
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;np-unparsed&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax">                 </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = Diagrams::new_UNPARSED_NOUN(W)</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP3"></a><b>&#167;3.  </b>This "balanced" version, however, requires any brackets and braces to be
used in a balanced way: thus <span class="extract"><span class="Preform-extract-syntax">frogs ( and toads )</span></span> would match, but
<span class="extract"><span class="Preform-extract-syntax">frogs ( and</span></span> would not. It therefore does not always match.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;np-balanced&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">^&lt;balanced-text&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; return FAIL_NONTERMINAL;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-unparsed&gt;</span><span class="Preform-plain-syntax">       </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1]</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP4"></a><b>&#167;4. Articled nounphrases (NP2). </b>Now an initial article becomes an annotation and is removed from the text.
Note that
</p>

<ul class="items"><li>(a) Unexpectedly upper-case articles are left well alone, as in the sentence:
</li></ul>
<blockquote>
    <p>On the table is a thing called A Town Called Alice.</p>
</blockquote>

<ul class="items"><li>(b) Articles are not removed if that would leave the text empty.
</li><li>(c) If we are in a language where the same word might either be definite or
indefinite, the latter has precedence.
</li></ul>
<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;np-articled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = NULL; return preform_lookahead_mode; </span><span class="Preform-comment-syntax"> match only when looking ahead</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;if-not-deliberately-capitalised&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;indefinite-article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-unparsed&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = NounPhrases::add_article(RP[3], RP[2]);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;if-not-deliberately-capitalised&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;definite-article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-unparsed&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = NounPhrases::add_article(RP[3], RP[2]);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-unparsed&gt;</span><span class="Preform-plain-syntax">															</span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1]</span>

<span class="Preform-function-syntax">&lt;np-articled-balanced&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">^&lt;balanced-text&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                                      </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; return FAIL_NONTERMINAL;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-articled&gt;</span><span class="Preform-plain-syntax">								                            </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1]</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP5"></a><b>&#167;5.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">NounPhrases::add_article</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">NounPhrases::add_article</span></span>:<br/><a href="4-np.html#SP4">&#167;4</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="reserved-syntax">article_usage</span><span class="plain-syntax"> *</span><span class="identifier-syntax">au</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_article</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">au</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">p</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP6"></a><b>&#167;6.  </b>The following function is only occasionally useful (for example, Inform
uses it in <a href="../core-module/19-tod.html" class="internal">Tables of Definitions (in core)</a>); takes an existing raw node
and retrospectively applies &lt;np-articled&gt; to it.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">NounPhrases::annotate_by_articles</span><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">RAW_NP</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;np-articled&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">RAW_NP</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">MODEL</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">RAW_NP</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">MODEL</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_article</span><span class="plain-syntax">(</span><span class="identifier-syntax">RAW_NP</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_article</span><span class="plain-syntax">(</span><span class="identifier-syntax">MODEL</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">RAW_NP</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP7"></a><b>&#167;7. List-divided nounphrases (NP3). </b>An "articled list" matches text like "the lion, a witch, and some wardrobes"
as a list of articled noun phrases.
</p>

<p class="commentary">Note that the requirement that non-final terms in the list have to be balanced
means that an and or a comma inside brackets can never be a divider. Thus
"the horse (and its boy)" would be one item, not two.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;np-articled-list&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = NULL; return preform_lookahead_mode; </span><span class="Preform-comment-syntax"> match only when looking ahead</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-articled-balanced&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-articled-tail&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = Diagrams::new_AND(Wordings::one_word(R[2]), RP[1], RP[2])</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-articled&gt;</span><span class="Preform-plain-syntax">                                </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1]</span>

<span class="Preform-function-syntax">&lt;np-articled-tail&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">,</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{_and}</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-articled-list&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> Wordings::first_wn(W); *XP = RP[1]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">{_,/and}</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-articled-list&gt;</span><span class="Preform-plain-syntax">                  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> Wordings::first_wn(W); *XP = RP[1]</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP8"></a><b>&#167;8.  </b>"Alternative lists" divide up at "or" rather than "and", thus matching text
such as "voluminous, middling big or poky", and the individual entries are not
articled.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;np-alternative-list&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = NULL; return preform_lookahead_mode; </span><span class="Preform-comment-syntax"> match only when looking ahead</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-balanced&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-alternative-tail&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = Diagrams::new_AND(Wordings::one_word(R[2]), RP[1], RP[2])</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-unparsed&gt;</span><span class="Preform-plain-syntax">                          </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1]</span>

<span class="Preform-function-syntax">&lt;np-alternative-tail&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">,</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{_or}</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-alternative-list&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> Wordings::first_wn(W); *XP= RP[1]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">{_,/or}</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-alternative-list&gt;</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> Wordings::first_wn(W); *XP= RP[1]</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP9"></a><b>&#167;9. Full nounphrases (NP4). </b>When fully parsing the structure of a nounphrase, we have five different
constructions in play, and need to work out their precedence over each other:
rather as <span class="extract"><span class="Preform-extract-syntax">*</span></span> takes precedence over <span class="extract"><span class="Preform-extract-syntax">+</span></span> in arithmetic expressions in C, so
here we have &mdash;
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    RELATIONSHIP_NT &gt; CALLED_NT &gt; WITH_NT &gt; AND_NT &gt; KIND_NT</span>
</pre>
<p class="commentary">That is, relative clauses take precedence over callings, and so on. The
above hierarchy is arrived at thus:
</p>

<ul class="items"><li>(a) We need <span class="extract"><span class="extract-syntax">RELATIONSHIP_NT &gt; WITH_NT</span></span> so that "X is in a container with
carrying capacity 10" will work.
</li><li>(b) We need <span class="extract"><span class="extract-syntax">WITH_NT &gt; AND_NT</span></span> so that "X is a container with carrying
capacity 10 and diameter 12" will work.
</li><li>(c) We need <span class="extract"><span class="extract-syntax">CALLED_NT &gt; WITH_NT</span></span> so that "X is a container called the flask
with flange" will work.
</li><li>(d) We need <span class="extract"><span class="extract-syntax">RELATIONSHIP_NT &gt; CALLED_NT</span></span> so that "A man called Horse is in
the High Sierra" will work.
</li><li>(e) We want <span class="extract"><span class="extract-syntax">KIND_NT</span></span> to be of low precedence because it is always either
the word "kind" alone, or "kind of N" for some atomic noun N.
</li></ul>
<p class="commentary">See <a href="P-asd.html" class="internal">About Sentence Diagrams</a> for numerous examples.
</p>

<p class="commentary firstcommentary"><a id="SP10"></a><b>&#167;10.  </b>Full nounphrase parsing varies slightly according to the position of the
phrase, i.e., whether it is in the subject or object position. Thus "X is Y"
or "X is in Y" would lead to X being parsed by &lt;np-as-subject&gt;, Y by &lt;np-as-object&gt;.
They are identical except that:
</p>

<ul class="items"><li>(a) In subject position, a full nounphrase can use "there" to indicate
an existential sentence such as "there is a hair in my soup"; and
</li><li>(b) In subject position, a relative phrase cannot begin with a word which
looks like a participle.
</li></ul>
<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;np-as-subject&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;existential-np&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                                  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;if-not-deliberately-capitalised&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-relative-phrase-limited&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[2]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-nonrelative&gt;</span><span class="Preform-plain-syntax">                                                  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1]</span>

<span class="Preform-function-syntax">&lt;np-as-object&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;if-not-deliberately-capitalised&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-relative-phrase-unlimited&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[2]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-nonrelative&gt;</span><span class="Preform-plain-syntax">							                        </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1]</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP11"></a><b>&#167;11.  </b>To explain the limitation here: RPs only exist in the subject position due
to subject-verb inversion in English. Thus, "In the Garden is a tortoise" is a
legal inversion of "A tortoise is in the Garden". Following this logic we ought
to accept Yoda-like inversions such as "Holding the light sabre is the young Jedi",
but we don't want to do that, because then a sentence like "Holding Area is a room"
might have to be read as saying that a nameless room is holding something
called "Area".
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;np-relative-phrase-limited&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-relative-phrase-implicit&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                     </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;probable-participle&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">***</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                         </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; return FAIL_NONTERMINAL;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-relative-phrase-explicit&gt;</span><span class="Preform-plain-syntax">                                       </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1]</span>

<span class="Preform-function-syntax">&lt;np-relative-phrase-unlimited&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-relative-phrase-implicit&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                     </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-relative-phrase-explicit&gt;</span><span class="Preform-plain-syntax">                                       </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1]</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP12"></a><b>&#167;12.  </b>Inform guesses above that most English words ending in "-ing" are present
participles &mdash; like guessing, bluffing, cheating, and so on. But there is
a conspicuous exception to this; so any word found in &lt;non-participles&gt;
is never treated as a participle.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;non-participles&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">thing/something</span>

<span class="Preform-function-syntax">&lt;probable-participle&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">1</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">Vocabulary::test_flags</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">Wordings::first_wn</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">), </span><span class="Preform-identifier-syntax">ING_MC</span><span class="Preform-plain-syntax">)) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-function-syntax">&lt;non-participles&gt;</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">)) </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">FALSE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">FALSE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP13"></a><b>&#167;13.  </b>An implicit RP is a word like "carried", or "worn", on its own &mdash; this
implies a relation to some unspecified noun. We represent that in the tree
using the "implied noun" pronoun. For now, these are fixed.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;np-relative-phrase-implicit&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">worn</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">              </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-np.html#SP13_1" class="named-paragraph-link"><span class="named-paragraph">Act on the implicit RP worn</span><span class="named-paragraph-number">13.1</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">carried</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">           </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-np.html#SP13_2" class="named-paragraph-link"><span class="named-paragraph">Act on the implicit RP carried</span><span class="named-paragraph-number">13.2</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">initially</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">carried</span><span class="Preform-plain-syntax">   </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-np.html#SP13_3" class="named-paragraph-link"><span class="named-paragraph">Act on the implicit RP initially carried</span><span class="named-paragraph-number">13.3</span></a></span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP13_1"></a><b>&#167;13.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Act on the implicit RP worn</span><span class="named-paragraph-number">13.1</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifndef</span><span class="plain-syntax"> </span><span class="identifier-syntax">IF_MODULE</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">IF_MODULE</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">X</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">; *</span><span class="identifier-syntax">XP</span><span class="plain-syntax"> = </span><a href="1-dgr.html#SP7" class="function-link"><span class="function-syntax">Diagrams::new_implied_RELATIONSHIP</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">R_wearing</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-np.html#SP13">&#167;13</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP13_2"></a><b>&#167;13.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Act on the implicit RP carried</span><span class="named-paragraph-number">13.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifndef</span><span class="plain-syntax"> </span><span class="identifier-syntax">IF_MODULE</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">IF_MODULE</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">X</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">; *</span><span class="identifier-syntax">XP</span><span class="plain-syntax"> = </span><a href="1-dgr.html#SP7" class="function-link"><span class="function-syntax">Diagrams::new_implied_RELATIONSHIP</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">R_carrying</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-np.html#SP13">&#167;13</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP13_3"></a><b>&#167;13.3.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Act on the implicit RP initially carried</span><span class="named-paragraph-number">13.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifndef</span><span class="plain-syntax"> </span><span class="identifier-syntax">IF_MODULE</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">IF_MODULE</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">X</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">; *</span><span class="identifier-syntax">XP</span><span class="plain-syntax"> = </span><a href="1-dgr.html#SP7" class="function-link"><span class="function-syntax">Diagrams::new_implied_RELATIONSHIP</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">R_carrying</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-np.html#SP13">&#167;13</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP14"></a><b>&#167;14.  </b>An explicit RP is one which uses a preposition and then a noun phrase: for
example, "on the table" is explicit.
</p>

<p class="commentary">Note that we throw out a relative phrase if the noun phrase within it would
begin with "and" or a comma; this enables us to parse sentences concerning
directions, in particular, a little better. But it means we do not recognise
"of, by and for the people" as an RP.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;np-relative-phrase-explicit&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;permitted-preposition&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">_,/and</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">       </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; return FAIL_NONTERMINAL;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;permitted-preposition&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">_,/and</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">           </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; return FAIL_NONTERMINAL;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;permitted-preposition&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-nonrelative&gt;</span><span class="Preform-plain-syntax">   </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-np.html#SP14_1" class="named-paragraph-link"><span class="named-paragraph">Work out a meaning</span><span class="named-paragraph-number">14.1</span></a></span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP14_1"></a><b>&#167;14.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Work out a meaning</span><span class="named-paragraph-number">14.1</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="constant-syntax">VERB_MEANING_LINGUISTICS_TYPE</span><span class="plain-syntax"> *</span><span class="identifier-syntax">R</span><span class="plain-syntax"> = </span><a href="3-vm.html#SP11" class="function-link"><span class="function-syntax">VerbMeanings::get_regular_meaning_of_form</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><a href="3-vrb.html#SP11" class="function-link"><span class="function-syntax">Verbs::find_form</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">permitted_verb</span><span class="plain-syntax">, </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">R</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">XP</span><span class="plain-syntax"> = </span><a href="1-dgr.html#SP7" class="function-link"><span class="function-syntax">Diagrams::new_RELATIONSHIP</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><a href="3-vm.html#SP2" class="function-link"><span class="function-syntax">VerbMeanings::reverse_VMT</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">R</span><span class="plain-syntax">), </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-np.html#SP14">&#167;14</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP15"></a><b>&#167;15.  </b>We have now disposed of <span class="extract"><span class="extract-syntax">RELATIONSHIP_NT</span></span> and are left with the constructs:
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-plain-syntax">    CALLED_NT &gt; WITH_NT &gt; AND_NT &gt; KIND_NT</span>
</pre>
<p class="commentary">These are all handled by &lt;np-nonrelative&gt;. Two points to note:
</p>

<ul class="items"><li>(a) The first production accepts arbitrary text quickly and without allocating
memory if we're in lookahead mode &mdash; an important economy since otherwise
parsing a list of \(n\) items would have running time and memory of order \(2^n\).
</li><li>(b) If we regard the above constructs as being like operators in arithmetic,
then the operands have to match &lt;np-operand&gt;, and this requires text which has
balanced brackets. That ensures that, for example, "frog (called toad)"
is not misread as saying that "frog (" is called "toad )". But note that
the final &lt;np-articled&gt; production catches any unbalanced text, so even
text like "smile X-)" will in fact match &lt;np-nonrelative&gt;.
</li></ul>
<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;np-nonrelative&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                           </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = NULL; return preform_lookahead_mode;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-operand&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{called}</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-articled-balanced&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = Diagrams::new_CALLED(WR[1], RP[1], RP[2])</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-operand&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-with-or-having-tail&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">         </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = Diagrams::new_WITH(Wordings::one_word(R[2]), RP[1], RP[2])</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-operand&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-and-tail&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = Diagrams::new_AND(Wordings::one_word(R[2]), RP[1], RP[2])</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-kind-phrase&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                              </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;agent-pronoun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                               </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = Diagrams::new_PRONOUN(W, RP[1])</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;here-pronoun&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = Diagrams::new_PRONOUN(W, RP[1])</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-articled&gt;</span><span class="Preform-plain-syntax">                                   </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1]</span>

<span class="Preform-function-syntax">&lt;np-operand&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;if-not-deliberately-capitalised&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-relative-phrase-unlimited&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[2]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">^&lt;balanced-text&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                                  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; return FAIL_NONTERMINAL;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-nonrelative&gt;</span><span class="Preform-plain-syntax">                                                    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1]</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP16"></a><b>&#167;16.  </b>The tail of with-or-having parses for instance "with carrying capacity 5"
in the NP
</p>

<blockquote>
    <p>a container with carrying capacity 5</p>
</blockquote>

<p class="commentary">This makes use of a nifty feature of Preform: when Preform scans to see how to
divide the text, it tries &lt;np-with-or-having-tail&gt; in each possible position.
The reply can be yes, no, or no and move on a little. So if we spot "it with
action", the answer is no, and move on three words: that jumps over a "with"
which we don't want to recognise. (Because if we did, then "the locking it
with action" would be parsed as a property list, "action", attaching to a
bogus object called "locking it".)
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;np-with-or-having-tail&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">it</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">with</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">action</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">***</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                       </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; return FAIL_NONTERMINAL + Wordings::first_wn(WR[1]) - Wordings::first_wn(W);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">{with/having}</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">(/)</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">***</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; return FAIL_NONTERMINAL + Wordings::first_wn(WR[1]) - Wordings::first_wn(W);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">{with/having}</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">(</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;response-letter&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">)</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; return FAIL_NONTERMINAL + Wordings::first_wn(WR[1]) - Wordings::first_wn(W);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">{with/having}</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-new-property-list&gt;</span><span class="Preform-plain-syntax">       </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> Wordings::first_wn(WR[1]); *XP = RP[1]</span>

<span class="Preform-function-syntax">&lt;np-new-property-list&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                      </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = NULL; return preform_lookahead_mode;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-new-property&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-new-property-tail&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = Diagrams::new_AND(Wordings::one_word(R[2]), RP[1], RP[2])</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-new-property&gt;</span><span class="Preform-plain-syntax">                          </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1];</span>

<span class="Preform-function-syntax">&lt;np-new-property-tail&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">,</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{_and}</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-new-property-list&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">          </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> Wordings::first_wn(W); *XP= RP[1]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">{_,/and}</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-new-property-list&gt;</span><span class="Preform-plain-syntax">            </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> Wordings::first_wn(W); *XP= RP[1]</span>

<span class="Preform-function-syntax">&lt;np-new-property&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax">                                        </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = Diagrams::new_PROPERTY_LIST(W);</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP17"></a><b>&#167;17.  </b>The "and" tail is much easier:
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;np-and-tail&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">,</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{_and}</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-operand&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> Wordings::first_wn(W); *XP= RP[1]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">{_,/and}</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-operand&gt;</span><span class="Preform-plain-syntax">                      </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> Wordings::first_wn(W); *XP= RP[1]</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP18"></a><b>&#167;18.  </b>Kind phrases are easier:
</p>

<blockquote>
    <p>A sedan chair is a kind of vehicle. A weather pattern is a kind.</p>
</blockquote>

<p class="commentary">Note that indefinite articles are permitted before the word "kind(s)",
but definite articles are not.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;np-kind-phrase&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;indefinite-article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-kind-phrase-unarticled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[2]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;np-kind-phrase-unarticled&gt;</span><span class="Preform-plain-syntax">                         </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = RP[1]</span>

<span class="Preform-function-syntax">&lt;np-kind-phrase-unarticled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">kind/kinds</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                        </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = Diagrams::new_KIND(W, NULL)</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">kind/kinds</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">of</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;np-operand&gt;</span><span class="Preform-plain-syntax">                          </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> 0; *XP = Diagrams::new_KIND(W, RP[1])</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="3-apoo.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-lm.html">1</a></li><li class="progresschapter"><a href="2-adj.html">2</a></li><li class="progresschapter"><a href="3-vrb.html">3</a></li><li class="progresscurrentchapter">4</li><li class="progresscurrent">np</li><li class="progresssection"><a href="4-vp.html">vp</a></li><li class="progressnext"><a href="4-vp.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

