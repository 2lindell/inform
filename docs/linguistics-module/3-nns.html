<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>3/au</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../compiler.html"><b>compiler</b></a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul>
<h2>Compiler Webs</h2>
<ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul>
<h2>Inbuild Modules</h2>
<ul>
<li><a href="../inbuild-module/index.html">inbuild</a></li>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../html-module/index.html">html</a></li>
</ul>
<h2>Inform7 Modules</h2>
<ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul>
<h2>Inter Modules</h2>
<ul>
<li><a href="../inter-module/index.html">inter</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of '3/nns' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="../compiler.html">Compiler</a></li><li><a href="index.html">linguistics</a></li><li><a href="index.html#3">Chapter 3: Grammatical Categories I</a></li><li><b>Nouns</b></li></ul><p class="purpose">Nouns are an abstraction for meanings registered with the excerpt parser which serve as names for individual things or kinds of things.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Why we abstract nouns</a></li><li><a href="#SP2">&#167;2. Structure</a></li><li><a href="#SP3">&#167;3. Creation</a></li><li><a href="#SP4">&#167;4. Attaching some wording to a noun</a></li><li><a href="#SP6">&#167;6. Logging</a></li><li><a href="#SP7">&#167;7. Name access</a></li><li><a href="#SP8">&#167;8. Other utilities</a></li><li><a href="#SP9">&#167;9. Disambiguation</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Why we abstract nouns. </b>In the previous chapter, we laid out a general-purpose way to register
"excerpt meanings": to say that a given excerpt of text, such as "air
pressure", might have a particular meaning. However, we don't want to
use that system directly to represent a noun, because this would assume
that nouns come in just one wording. In reality, they are inflected to
indicate number (singular vs plural) and, in many languages, case, and
they can therefore have many wordings; they can also be translated into
other languages.
</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Structure. </b>We will give each noun a "priority", used when resolving ambiguities, but
this will be a very simple system: common nouns (i.e., names of kinds) will
be high priority, and proper names (i.e., names of instances) will be low.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">HIGH_NOUN_PRIORITY</span><span class="plain"> 1</span>
    <span class="definitionkeyword">define</span> <span class="constant">LOW_NOUN_PRIORITY</span><span class="plain"> 2</span>
    <span class="definitionkeyword">define</span> <span class="constant">MAX_NOUN_PRIORITY</span><span class="plain"> 2</span>
</pre>

<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">noun</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">name_cluster</span><span class="plain"> *</span><span class="identifier">names</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">general_pointer</span><span class="plain"> </span><span class="identifier">tagged_to</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">search_priority</span><span class="plain">; </span>    <span class="comment">in the range 1 up to <code class="display"><span class="extract">MAX_NOUN_PRIORITY</span></code></span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">match_exactly</span><span class="plain">; </span>    <span class="comment">do not allow subset parsing matches, e.g., "bottle" for "glass bottle"</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">range_number</span><span class="plain">; </span>    <span class="comment">used to enumerate</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">registration_category</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">general_pointer</span><span class="plain"> </span><span class="identifier">registration_to</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">CORE_MODULE</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">nt_I6_identifier</span><span class="plain">; </span>    <span class="comment">Name to be used in Inform 6 output</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">nt_iname</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">name_resolution_data</span><span class="plain"> </span><span class="identifier">name_resolution</span><span class="plain">; </span>    <span class="comment">see the Headings section on this</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">noun</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure noun is private to this section.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Creation. </b>Note that it's legal for the supplied text to be empty, and this does happen
for example when Inform creates the nouns of anonymous objects, as in a
sentence such as "Four people are in the Dining Room."
</p>

<p class="inwebparagraph">It may seem odd that noun structures store a pointer back to their owners;
as if the luggage tag has a suitcase hanging from it, rather than vice versa.
But this is needed because nouns can themselves be registered as excerpt
meanings. Thus, "silver medallion" might be an EM pointing to a noun,
and if it comes up in parsing then we need a way to get from the noun to
the actual medallion object.
</p>

<p class="inwebparagraph">When a noun is created, we supply a bitmap of options:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">PARSE_EXACTLY_NTOPT</span><span class="plain"> 1</span>
    <span class="definitionkeyword">define</span> <span class="constant">REGISTER_SINGULAR_NTOPT</span><span class="plain"> 2</span>
    <span class="definitionkeyword">define</span> <span class="constant">REGISTER_PLURAL_NTOPT</span><span class="plain"> 4</span>
    <span class="definitionkeyword">define</span> <span class="constant">ATTACH_TO_SEARCH_LIST_NTOPT</span><span class="plain"> 8</span>
</pre>

<pre class="display">
    <span class="reserved">noun</span><span class="plain"> *</span><span class="functiontext">Nouns::new_proper_noun</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">gender</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">options</span><span class="plain">,</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">mc</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">val</span><span class="plain">) {</span>
        <span class="identifier">general_pointer</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain"> = </span><span class="identifier">NULL_GENERAL_POINTER</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">val</span><span class="plain">) </span><span class="identifier">owner</span><span class="plain"> = </span><span class="identifier">STORE_POINTER_parse_node</span><span class="plain">(</span><span class="identifier">val</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Nouns::new_inner</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">owner</span><span class="plain">, </span><span class="constant">LOW_NOUN_PRIORITY</span><span class="plain">, </span><span class="identifier">options</span><span class="plain">, </span><span class="identifier">mc</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">gender</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">noun</span><span class="plain"> *</span><span class="functiontext">Nouns::new_common_noun</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">gender</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">options</span><span class="plain">,</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">mc</span><span class="plain">, </span><span class="identifier">general_pointer</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Nouns::new_inner</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">owner</span><span class="plain">, </span><span class="constant">HIGH_NOUN_PRIORITY</span><span class="plain">, </span><span class="identifier">options</span><span class="plain">, </span><span class="identifier">mc</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">gender</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">noun</span><span class="plain"> *</span><span class="functiontext">Nouns::new_inner</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">general_pointer</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">p</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">options</span><span class="plain">,</span>
        <span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">mc</span><span class="plain">, </span><span class="identifier">PREFORM_LANGUAGE_TYPE</span><span class="plain"> *</span><span class="identifier">foreign_language</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">gender</span><span class="plain">) {</span>
        <span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">t</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">noun</span><span class="plain">);</span>
        <span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;tagged_to</span><span class="plain"> = </span><span class="identifier">owner</span><span class="plain">;</span>
        <span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;registration_to</span><span class="plain"> = </span><span class="identifier">owner</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">mc</span><span class="plain"> == </span><span class="constant">NOUN_MC</span><span class="plain">) </span><span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;registration_to</span><span class="plain"> = </span><span class="identifier">STORE_POINTER_noun</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">);</span>
        <span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;registration_category</span><span class="plain"> = </span><span class="identifier">mc</span><span class="plain">;</span>
        <span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;range_number</span><span class="plain"> = </span><span class="identifier">t</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain"> + 1;</span>
        <span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;search_priority</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">;</span>
        <span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;match_exactly</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;names</span><span class="plain"> = </span><span class="identifier">Clusters::new</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">options</span><span class="plain"> &amp; </span><span class="constant">PARSE_EXACTLY_NTOPT</span><span class="plain">) </span><span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;match_exactly</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))</span>
            <span class="functiontext">Nouns::add_to_noun_and_reg</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">foreign_language</span><span class="plain">, </span><span class="identifier">gender</span><span class="plain">, 1, </span><span class="identifier">options</span><span class="plain">);</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">CORE_MODULE</span>
        <span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;nt_I6_identifier</span><span class="plain"> = </span><span class="identifier">Str::new</span><span class="plain">();</span>
        <span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;nt_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">options</span><span class="plain"> &amp; </span><span class="constant">ATTACH_TO_SEARCH_LIST_NTOPT</span><span class="plain">)</span>
            &lt;<span class="cwebmacro">Insert this noun into the relevant heading search list</span> <span class="cwebmacronumber">3.1</span>&gt;<span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">t</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Nouns::new_proper_noun appears nowhere else.</p>

<p class="endnote">The function Nouns::new_common_noun appears nowhere else.</p>

<p class="endnote">The function Nouns::new_inner appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP3_1"></a><b>&#167;3.1.  </b>Every heading in the source text has a search list of nouns created
under it, and this is used for disambiguation: see below.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Insert this noun into the relevant heading search list</span> <span class="cwebmacronumber">3.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Sentences::Headings::disturb</span><span class="plain">();</span>
        <span class="identifier">Sentences::Headings::attach_noun</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">);</span>
        <span class="identifier">Sentences::Headings::verify_divisions</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP3">&#167;3</a>.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Attaching some wording to a noun. </b>As noted above, each noun comes with a cluster of names, and here's where
we add a new one.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">NOUN_HAS_NO_MC</span><span class="plain"> 0</span><span class="identifier">xffffffff</span>
</pre>

<pre class="display">
    <span class="identifier">individual_name</span><span class="plain"> *</span><span class="functiontext">Nouns::add_to_noun_and_reg</span><span class="plain">(</span><span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">t</span><span class="plain">,</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">PREFORM_LANGUAGE_TYPE</span><span class="plain"> *</span><span class="identifier">foreign_language</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">gender</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">number</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">options</span><span class="plain">) {</span>
        <span class="identifier">individual_name</span><span class="plain"> *</span><span class="identifier">in</span><span class="plain"> = </span><span class="identifier">Clusters::add</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;names</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">foreign_language</span><span class="plain">, </span><span class="identifier">gender</span><span class="plain">, </span><span class="identifier">number</span><span class="plain">,</span>
            <span class="plain">(</span><span class="identifier">options</span><span class="plain"> &amp; </span><span class="constant">REGISTER_PLURAL_NTOPT</span><span class="plain">)?</span><span class="identifier">TRUE</span><span class="plain">:</span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="reserved">for</span><span class="plain"> (; </span><span class="identifier">in</span><span class="plain">; </span><span class="identifier">in</span><span class="plain"> = </span><span class="identifier">in</span><span class="plain">-&gt;</span><span class="identifier">next</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">options</span><span class="plain"> &amp; </span><span class="constant">REGISTER_SINGULAR_NTOPT</span><span class="plain">) &amp;&amp; (</span><span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;registration_category</span><span class="plain"> != </span><span class="constant">NOUN_HAS_NO_MC</span><span class="plain">)) {</span>
                <span class="reserved">excerpt_meaning</span><span class="plain"> *</span><span class="identifier">em</span><span class="plain"> = </span><span class="functiontext">ExcerptMeanings::register</span><span class="plain">(</span>
                    <span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;registration_category</span><span class="plain">,</span>
                    <span class="identifier">Declensions::in_case</span><span class="plain">(&amp;(</span><span class="identifier">in</span><span class="plain">-&gt;</span><span class="identifier">name</span><span class="plain">), </span><span class="identifier">NOMINATIVE_CASE</span><span class="plain">),</span>
                    <span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;registration_to</span><span class="plain">);</span>
                <span class="identifier">Clusters::set_principal_meaning</span><span class="plain">(</span><span class="identifier">in</span><span class="plain">, </span><span class="identifier">STORE_POINTER_excerpt_meaning</span><span class="plain">(</span><span class="identifier">em</span><span class="plain">));</span>
            <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">in</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Nouns::add_to_noun_and_reg is used in <a href="#SP3">&#167;3</a>.</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>The English singular nominative form:
</p>


<pre class="display">
    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">Nouns::nominative</span><span class="plain">(</span><span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">t</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">t</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">Clusters::get_name</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;names</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Nouns::nominative appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Logging. </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Nouns::log</span><span class="plain">(</span><span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">t</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">t</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) { </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"&lt;untagged&gt;"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain">; }</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="functiontext">Nouns::get_name</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"'"</span><span class="plain">);</span>
            <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">) {</span>
                <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"%N"</span><span class="plain">, </span><span class="identifier">i</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain"> &lt; </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">" "</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"'"</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Nouns::log appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Name access. </b></p>


<pre class="display">
    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">Nouns::get_name</span><span class="plain">(</span><span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">t</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">plural_flag</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">Clusters::get_name</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;names</span><span class="plain">, </span><span class="identifier">plural_flag</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">Nouns::get_name_in_play</span><span class="plain">(</span><span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">t</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">plural_flag</span><span class="plain">, </span><span class="identifier">PREFORM_LANGUAGE_TYPE</span><span class="plain"> *</span><span class="identifier">lang</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">Clusters::get_name_in_play</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;names</span><span class="plain">, </span><span class="identifier">plural_flag</span><span class="plain">, </span><span class="identifier">lang</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Nouns::set_plural_name</span><span class="plain">(</span><span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">t</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="identifier">Clusters::set_plural_name</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;names</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">language_of_source_text</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Nouns::full_name_includes</span><span class="plain">(</span><span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">t</span><span class="plain">, </span><span class="identifier">vocabulary_entry</span><span class="plain"> *</span><span class="identifier">wd</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">t</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="functiontext">Nouns::get_name</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wd</span><span class="plain"> == </span><span class="identifier">Lexer::word</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">))</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Nouns::get_name is used in <a href="#SP6">&#167;6</a>.</p>

<p class="endnote">The function Nouns::get_name_in_play appears nowhere else.</p>

<p class="endnote">The function Nouns::set_plural_name appears nowhere else.</p>

<p class="endnote">The function Nouns::full_name_includes appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Other utilities. </b></p>


<pre class="display">
    <span class="identifier">general_pointer</span><span class="plain"> </span><span class="functiontext">Nouns::tag_holder</span><span class="plain">(</span><span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">t</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">t</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL_GENERAL_POINTER</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;tagged_to</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Nouns::priority</span><span class="plain">(</span><span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">t</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">t</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> 0;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;search_priority</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Nouns::range_number</span><span class="plain">(</span><span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">t</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">t</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> 0;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;range_number</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Nouns::set_range_number</span><span class="plain">(</span><span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">t</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">r</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">t</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;range_number</span><span class="plain"> = </span><span class="identifier">r</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Nouns::exactitude</span><span class="plain">(</span><span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">t</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">t</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">CORE_MODULE</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">use_exact_parsing_option</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;match_exactly</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">excerpt_meaning</span><span class="plain"> *</span><span class="functiontext">Nouns::get_principal_meaning</span><span class="plain">(</span><span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">t</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">RETRIEVE_POINTER_excerpt_meaning</span><span class="plain">(</span><span class="identifier">Clusters::get_principal_meaning</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">-</span><span class="element">&gt;names</span><span class="plain">));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Nouns::tag_holder appears nowhere else.</p>

<p class="endnote">The function Nouns::priority appears nowhere else.</p>

<p class="endnote">The function Nouns::range_number appears nowhere else.</p>

<p class="endnote">The function Nouns::set_range_number appears nowhere else.</p>

<p class="endnote">The function Nouns::exactitude is used in 2/pe (<a href="2-pe.html#SP4_8_1">&#167;4.8.1</a>).</p>

<p class="endnote">The function Nouns::get_principal_meaning appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Disambiguation. </b>It's a tricky task to choose from a list of possible nouns which might
have been intended by text such as "chair". If the list is empty or
contains only one choice, no problem. Otherwise we will probably have to
reorder the noun search list, and then run through it. The code below
looks as if it picks out the match with highest score, so that the ordering
is unimportant, but in fact the score assigned to a match is based purely
on the number of words missed out (see later): that means that ambiguities
often arise between two lexically similar objects, e.g., a "blue chair"
or a "red chair" when the text simply specifies "chair". Since the code
below accepts the first noun with the highest score, the outcome is
thus determined by which of the blue and red chairs ranks highest in the
search list: and that is why the search list is so important.
</p>


<pre class="display">
    <span class="reserved">noun</span><span class="plain"> *</span><span class="functiontext">Nouns::disambiguate</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">priority</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">candidates</span><span class="plain"> = 0; </span><span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">first_nt</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p2</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">; </span><span class="identifier">p2</span><span class="plain">; </span><span class="identifier">p2</span><span class="plain"> = </span><span class="identifier">p2</span><span class="plain">-&gt;</span><span class="identifier">next_alternative</span><span class="plain">) {</span>
            <span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">nt</span><span class="plain"> = </span><span class="identifier">RETRIEVE_POINTER_noun</span><span class="plain">(</span>
                <span class="functiontext">ExcerptMeanings::data</span><span class="plain">(</span><span class="identifier">ParseTree::get_meaning</span><span class="plain">(</span><span class="identifier">p2</span><span class="plain">)));</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">nt</span><span class="plain">-</span><span class="element">&gt;search_priority</span><span class="plain"> &gt;= 1) &amp;&amp; (</span><span class="identifier">nt</span><span class="plain">-</span><span class="element">&gt;search_priority</span><span class="plain"> &lt;= </span><span class="identifier">priority</span><span class="plain">)) {</span>
                <span class="identifier">first_nt</span><span class="plain"> = </span><span class="identifier">nt</span><span class="plain">; </span><span class="identifier">candidates</span><span class="plain">++;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">candidates</span><span class="plain"> &lt;= 1) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">first_nt</span><span class="plain">;</span>

        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">CORE_MODULE</span>
        <span class="identifier">Sentences::Headings::construct_noun_search_list</span><span class="plain">();</span>
        <span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">nt</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">nt</span><span class="plain">, </span><span class="reserved">noun</span><span class="plain">)</span>
            <span class="identifier">Sentences::Headings::set_noun_search_score</span><span class="plain">(</span><span class="identifier">nt</span><span class="plain">, 0);</span>

        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p2</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">; </span><span class="identifier">p2</span><span class="plain">; </span><span class="identifier">p2</span><span class="plain"> = </span><span class="identifier">p2</span><span class="plain">-&gt;</span><span class="identifier">next_alternative</span><span class="plain">) {</span>
            <span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">nt</span><span class="plain"> = </span><span class="identifier">RETRIEVE_POINTER_noun</span><span class="plain">(</span>
                <span class="functiontext">ExcerptMeanings::data</span><span class="plain">(</span><span class="identifier">ParseTree::get_meaning</span><span class="plain">(</span><span class="identifier">p2</span><span class="plain">)));</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">nt</span><span class="plain">-</span><span class="element">&gt;search_priority</span><span class="plain"> &gt;= 1) &amp;&amp; (</span><span class="identifier">nt</span><span class="plain">-</span><span class="element">&gt;search_priority</span><span class="plain"> &lt;= </span><span class="identifier">priority</span><span class="plain">))</span>
                <span class="identifier">Sentences::Headings::set_noun_search_score</span><span class="plain">(</span><span class="identifier">nt</span><span class="plain">,</span>
                    <span class="identifier">ParseTree::get_score</span><span class="plain">(</span><span class="identifier">p2</span><span class="plain">));</span>
        <span class="plain">}</span>
        <span class="reserved">noun</span><span class="plain"> *</span><span class="identifier">best_nt</span><span class="plain"> = </span><span class="identifier">Sentences::Headings::highest_scoring_noun_searched</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">best_nt</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">best_nt</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">endif</span>

        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">first_nt</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Nouns::disambiguate appears nowhere else.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="3-au.html">Back to 'Adjective Usages'</a></li><li><i>(This section ends Chapter 3: Grammatical Categories I.)</i></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

