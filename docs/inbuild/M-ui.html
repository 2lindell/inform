<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Booklet Title</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../compiler.html"><b>compiler</b></a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul>
<h2>Compiler Webs</h2>
<ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul>
<h2>Inbuild Modules</h2>
<ul>
<li><a href="../inbuild-module/index.html">inbuild</a></li>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../html-module/index.html">html</a></li>
</ul>
<h2>Inform7 Modules</h2>
<ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul>
<h2>Inter Modules</h2>
<ul>
<li><a href="../inter-module/index.html">inter</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of 'M/ui' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="../compiler.html">Compiler Tools</a></li><li><a href="index.html">inbuild</a></li><li><a href="index.html#M">Manual</a></li><li><b>Using Inbuild</b></li></ul><p class="purpose">An introduction to the use of Inbuild on the command line.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. What Inbuild is</a></li><li><a href="#SP2">&#167;2. Installation</a></li><li><a href="#SP3">&#167;3. Basic concepts</a></li><li><a href="#SP5">&#167;5. Graphs</a></li><li><a href="#SP10">&#167;10. Building</a></li><li><a href="#SP12">&#167;12. Specifying what to act on</a></li><li><a href="#SP14">&#167;14. Nests and searches</a></li><li><a href="#SP17">&#167;17. Copy, sync and archive</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. What Inbuild is. </b>Inbuild is a rudimentary build and package manager for the Inform tools.
It consists of a large part of the front end of the Inform 7 compiler,
together with a command-line interface to access its functions. Because
it doesn't contain the middle or back ends of Inform 7, it cannot itself
compile Inform projects. But it can issue shell commands which have
this effect. When used that way, it's a little like the traditional Unix
build tool <code class="display"><span class="extract">make</span></code>.
</p>

<p class="inwebparagraph">It can also be used in <code class="display"><span class="extract">make</span></code> scripts itself. Inbuild returns an exit code
of 0 if successful, or else it throws errors to <code class="display"><span class="extract">stderr</span></code> and returns 1
if unsuccessful.
</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Installation. </b>When it runs, Inbuild needs to know where it is installed in the file
system. There is no completely foolproof, cross-platform way to know this
(on some Unixes, a program cannot determine its own location), so Inbuild
decides by the following set of rules:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(a) If the user, at the command line, specified <code class="display"><span class="extract">-at P</span></code>, for some path
<code class="display"><span class="extract">P</span></code>, then we use that.
</li><li>(b) Otherwise, if the host operating system can indeed tell us where the
executable is, we use that. This is currently implemented only on MacOS,
Windows and Linux.
</li><li>(c) Otherwise, if the environment variable <code class="display"><span class="extract">$INBUILD_PATH</span></code> exists and is
non-empty, we use that.
</li><li>(d) And if all else fails, we assume that the location is <code class="display"><span class="extract">inbuild</span></code>, with
respect to the current working directory.
</li></ul>
<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Basic concepts. </b>Inbuild manages "copies". A copy is an instance in the file system of an
asset like an Inform project, an extension, a kit of Inter code, and so on.
Those categories are called "genres". Any given copy will be a copy of
what is called an "edition", which in turn is a version of a "work".
</p>

<p class="inwebparagraph">For example, perhaps the user has two copies of version 3 of the extension
Locksmith by Emily Short, in different places in the file system, and also
a further copy of version 4. These are three different "copies", but only two
different "editions", and all are of the same "work". A work &mdash; in this case.
Locksmith by Emily Short &mdash; is identified by its title, author name and
genre &mdash; in this case, an Inform extension.
</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>Inbuild has a plethora of command-line options, but at its most basic, the
user should specify what to do and then give a list of things to do it to.
For example, here we run <code class="display"><span class="extract">-inspect</span></code> on a single copy, and get a one-line
description of what it is:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inbuild/Tangled/inbuild -inspect 'inform7/Internal/Extensions/Emily Short/Locksmith.i7x'</span>
        <span class="plain">extension: Locksmith by Emily Short v12 in directory inform7/Internal/Extensions/Emily Short</span>
</pre>

<p class="inwebparagraph">This is reassuring &mdash; the file which looks as if it ought to be a copy of
Locksmith actually is. Inbuild always looks at the contents of something,
and doesn't trust its location as any indication of what it is. For
example:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inbuild/Tangled/inbuild -inspect junk/Mystery.i7x</span>
        <span class="plain">extension: Complex Listing by Emily Short v9 in directory junk.</span>
</pre>

<p class="inwebparagraph">If Inbuild can see that something is damaged in some way, it will report that.
For example,
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">extension: Skeleton Keys by Emily Short - 1 error</span>
        <span class="plain">    1. extension misworded: the opening line does not end 'begin(s) here'</span>
</pre>

<p class="inwebparagraph">Only superficial problems can be spotted so far in advance of actually using
the software, but it's still helpful.
</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Graphs. </b>More ambitiously, we can look at the "graph" of a copy.
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inbuild/Tangled/inbuild -graph 'Basic Help Menu.i7x'</span>
        <span class="plain">[c0] Basic Help Menu by Emily Short</span>
        <span class="plain">  --use---&gt; [c26] Menus by Emily Short v3</span>
        <span class="plain">    --use---&gt; [c34] Basic Screen Effects by Emily Short v7.140425</span>
</pre>

<p class="inwebparagraph">The graph begins at the copy we asked for, and then continues through arrows
to other copies. It gives a systematic answer to the question "how do I
build or use this?". There are two kinds of arrows, use arrows and build
arrows. A use arrow from A to B means that you need to have B installed
in order to be able to use A. The above example, then, tells us that we
Menus in order to use Basic Help Menu, and we need Basic Screen Effects in
order to use Menus.
</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>Now suppose we have an Inform project called <code class="display"><span class="extract">Menu Time.inform</span></code>, whose
source text is as follows:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Include Basic Help Menu by Emily Short.</span>
        
        <span class="plain">The French Laundry is a room.</span>
</pre>

<p class="inwebparagraph">Once again, we can inspect this:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">inbuild/Tangled/inbuild -inspect 'Menu Time.inform'</span>
        <span class="plain">projectbundle: Menu Time.inform at path Menu Time.inform</span>
</pre>

<p class="inwebparagraph">We can also use <code class="display"><span class="extract">-graph</span></code>, but the output from this is surprisingly long,
because an innocent-looking source text like the above depends on many other
resources.
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">[f59] Menu Time.inform/Build/output.ulx</span>
        <span class="plain">  --build-&gt; [f58] Menu Time.inform/Build/auto.inf</span>
        <span class="plain">    --build-&gt; [f57] Menu Time.inform/Build/auto.inf</span>
        <span class="plain">      --build-&gt; [c0] Menu Time.inform</span>
        <span class="plain">        --build-&gt; [c53] Basic Help Menu by Emily Short</span>
        <span class="plain">          --use---&gt; [c47] Menus by Emily Short v3</span>
        <span class="plain">            --use---&gt; [c55] Basic Screen Effects by Emily Short v7.140425</span>
        <span class="plain">        --build-&gt; [f1] Menu Time.inform/Source/story.ni</span>
        <span class="plain">        --build-&gt; [c12] BasicInformKit</span>
</pre>

<p class="inwebparagraph">...and so on. What's going on here is that if the user wants to compile the
source text, that will (by default) mean making a story file in Glulx format,
called <code class="display"><span class="extract">output.ulx</span></code>, which sits inside the project bundle. So that is the top
node. Note that it is a "file node", not a "copy node", as we can see from the
<code class="display"><span class="extract">f</span></code> not <code class="display"><span class="extract">c</span></code> in its node number. This means that <code class="display"><span class="extract">output.ulx</span></code> is not a kind of
resource managed by Inbuild (like an extension, pr a project): it's just a
plain old file.
</p>

<p class="inwebparagraph">There's then a build arrow to another file called <code class="display"><span class="extract">auto.inf</span></code>. That's because
in order to build <code class="display"><span class="extract">output.ulx</span></code>, we first need <code class="display"><span class="extract">auto.inf</span></code> to exist. This is
a file in Inform 6 format. Something unexpected then happens: a further arrow
appears, and connects to another <code class="display"><span class="extract">auto.inf</span></code>. There aren't really two files
here: this is a device to capture the fact that generating <code class="display"><span class="extract">auto.inf</span></code> is a
two-stage process, with the intermediate results between the two stages
being held in memory rather than in a file. (These stages are, first,
converting I7 source text to inter code, and then code-generating that
inter code to I6.) Finally, though, we have a build arrow leading to the
place we might have expected to start: the <code class="display"><span class="extract">Menu Time.inform</span></code> project.
</p>

<p class="inwebparagraph">And that is where the graph branches outwards, because we need many
different resources in order to build <code class="display"><span class="extract">Menu Time.inform</span></code>. We finally see
that we need Basic Help Menu, and because that uses two other extensions
in turn, we'll need both of those as well. We need the actual file which
holds the source text inside the project bundle, <code class="display"><span class="extract">story.ni</span></code>. And then
we need various build-in extensions and kits, the first of which is
<code class="display"><span class="extract">BasicInformKit</span></code>, and that turns out to need lots of files to exist.
</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>The full <code class="display"><span class="extract">-graph</span></code> is not always what we want to see. Often all we really
want to know is: what do I need to use, or to build, something?
</p>

<p class="inwebparagraph">The command <code class="display"><span class="extract">-use-needs</span></code> applied to our example extension gives:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">extension: Basic Help Menu by Emily Short</span>
        <span class="plain">  extension: Menus by Emily Short v3</span>
        <span class="plain">    extension: Basic Screen Effects by Emily Short v7.140425</span>
</pre>

<p class="inwebparagraph">and applied to our example story gives just:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">projectbundle: Menu Time.inform</span>
</pre>

<p class="inwebparagraph">That's because once Menu Time is built, nothing else is needed to use it.
On the other hand, <code class="display"><span class="extract">-build-needs</span></code> has the opposite effect. Applied to the
extension, we get:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">extension: Basic Help Menu by Emily Short</span>
</pre>

<p class="inwebparagraph">because extensions need no building, so certainly nothing else is needed
to build them. But <code class="display"><span class="extract">-build-needs</span></code> on our story produces:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">projectbundle: Menu Time.inform</span>
        <span class="plain">  extension: Basic Help Menu by Emily Short</span>
        <span class="plain">    extension: Menus by Emily Short v3</span>
        <span class="plain">      extension: Basic Screen Effects by Emily Short v7.140425</span>
        <span class="plain">  kit: BasicInformKit</span>
        <span class="plain">    extension: Basic Inform by Graham Nelson v1</span>
        <span class="plain">    extension: English Language by Graham Nelson v1</span>
        <span class="plain">  kit: CommandParserKit</span>
        <span class="plain">    kit: WorldModelKit</span>
        <span class="plain">      extension: Standard Rules by Graham Nelson v6</span>
        <span class="plain">    extension: Standard Rules by Graham Nelson v6</span>
        <span class="plain">  language: English</span>
        <span class="plain">    kit: EnglishLanguageKit</span>
        <span class="plain">      extension: English Language by Graham Nelson v1</span>
</pre>

<p class="inwebparagraph">And there it is: six extensions, four kits and one natural language definition
are needed. Two of the extensions are listed twice: that's because they are
each needed for two different reasons.
</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>The version numbers listed above do not mean that only those exact versions
will do: they mean that this is (the best) version Inbuild has access to.
They're given because two different versions of the same extension might
make different choices about which other extensions to include. We can say
that version 3 of Menus wants to have Basic Screen Effects, but maybe someday
tbere will be a version 4 which doesn't need it.
</p>

<p class="inwebparagraph">Another issue to watch out for is that a copy may use different other copies
when compiled to different virtual machines. For example, an extension can
contain a heading of material "for Glulx only", and that heading might
comtain a line which includes another extension X. If so, then we use X on
Glulx but not on other architectures. We can also flag materual as being for
release only, or for debugging only.
</p>

<p class="inwebparagraph">Inbuild accepts the same command-line options as <code class="display"><span class="extract">inform7</span></code> does to specify
these: <code class="display"><span class="extract">-debug</span></code> for debugging features, <code class="display"><span class="extract">-release</span></code> for a release run, and
<code class="display"><span class="extract">-format=X</span></code> to select a virtual machine. (See the <code class="display"><span class="extract">inform7</span></code> documentation.)
</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>Now suppose that the project asks for something impossible, with a line
such as:
</p>

<blockquote>
    <p>Include Xylophones by Jimmy Stewart.</p>

</blockquote>

<p class="inwebparagraph">No such extension exists. If we look at the graph, or the <code class="display"><span class="extract">-build-needs</span></code> list
for the project, we see that it includes:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">missing extension: Xylophones by Jimmy Stewart, any version will do</span>
</pre>

<p class="inwebparagraph">If we had instead written:
</p>

<blockquote>
    <p>Include version 6.2 of Xylophones by Jimmy Stewart.</p>

</blockquote>

<p class="inwebparagraph">we would see:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">missing extension: Xylophones by Jimmy Stewart, need version in range [6.2,7-A)</span>
</pre>

<p class="inwebparagraph">This slightly arcane mathematical notation means that Inform would accept any
version from 6.2 upwards, provided it still begins with a 6. This is a change
over pre-2020 versions of Inform, and has been brought about by the adoption
of the semantic version number standard.
</p>

<p class="inwebparagraph">Inbuild can list missing resources with <code class="display"><span class="extract">-use-missing</span></code> and <code class="display"><span class="extract">-build-missing</span></code>
respectively. At present, it has no means of fetching missing resources from
any central repository.
</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Building. </b>The graph for a copy tells Inbuild not only what is necessary for a build,
but also how to perform that build.
</p>

<p class="inwebparagraph">As noted above, not everything needs building. Extensions do not, in particular,
so running <code class="display"><span class="extract">-build</span></code> on one will do nothing. Kits do need building: what this
does is to "assimilate" the Unform 6-notation source files inside the kit into
binary files of Inter, one for each possible architecture.
</p>

<p class="inwebparagraph">But building is mostly done with projects. If we run:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inbuild/Tangled/inbuild -build Example.inform</span>
</pre>

<p class="inwebparagraph">then Inbuild will first build everthing needed to build the Example story
file, including everything needed to use the things needed to build it, and
so on; and then will build Example itself. As with the Unix utility <code class="display"><span class="extract">make</span></code>,
this is an incremental process, and looks at the timestamps of files to see
which steps are needed and which are not. If all the kits needed by Example
are up to date, then the kits will not be re-assimilated, and so on. If the
same project is built twice in a row, and nothing about it has changed since
the first time, the second <code class="display"><span class="extract">-build</span></code> does nothing.
</p>

<p class="inwebparagraph">Inbuild uses the graph to work out what needs to be done, and then issues
a series of shell commands to other Inform tools. If any of those commands
fail (returning a non-zero exit code) then the build process halts at once.
</p>

<p class="inwebparagraph">As noted above, the <code class="display"><span class="extract">-release</span></code> switch tells Inbuild that we want to go all
the way to a release of the project, not just a build. This makes a more
extensive graph, and is likely to mean that the final step followed by
Inbuild is a call to <code class="display"><span class="extract">inblorb</span></code>, the releasing tool for Inform.
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inbuild/Tangled/inbuild -release -build Example.inform</span>
</pre>

<p class="inwebparagraph">Using the <code class="display"><span class="extract">-rebuild</span></code> command performs a build in a way which isn't incremental:
timestamps of files are ignored and everything is remade from scratch.
</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b>It takes a certain trust to just let Inbuild rip, and if you don't feel that
trust, adding the <code class="display"><span class="extract">-dry</span></code> switch causes shell commands to be printed out but
not actually executed &mdash; a dry run. If you are debugging Inbuild, you may
also want to look at the copious output produced when <code class="display"><span class="extract">-build-trace</span></code> is used.
These are not commands: they simply modify the behaviour of <code class="display"><span class="extract">-build</span></code> and
<code class="display"><span class="extract">-rebuild</span></code>.
</p>

<p class="inwebparagraph">Inbuild uses a handful of standard Unix shell commands, but it also uses
<code class="display"><span class="extract">inform7</span></code>, <code class="display"><span class="extract">inform6</span></code>, <code class="display"><span class="extract">inblorb</span></code> and <code class="display"><span class="extract">inter</span></code>. To do that, it needs to know
where they are installed. By default, Inbuild assumes they are in the same
folder as Inbuild itself, side by side. If not, you can use <code class="display"><span class="extract">-tools P</span></code> to
specify path <code class="display"><span class="extract">P</span></code> as the home of the other Intools.
</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Specifying what to act on. </b>In all of the examples above, Inbuild is given just one copy to act on.
(That action may end up invplving lots of other copies, but only one is
mentioned on the command line.) In fact it's legal to give a list of
copies to work on, one at a time, except that only one of those copies
can be an Inform project. Multiple extensions, or kits, are fine.
</p>

<p class="inwebparagraph">We can also tell Inbuild to work on everything it finds in a given directory
<code class="display"><span class="extract">D</span></code> using <code class="display"><span class="extract">-contents-of D</span></code>:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inbuild/Tangled/inbuild -inspect -contents-of inform7/Internal/Inter</span>
        <span class="plain">kit: EnglishLanguageKit at path inform7/Internal/Inter/EnglishLanguageKit</span>
        <span class="plain">kit: CommandParserKit at path inform7/Internal/Inter/CommandParserKit</span>
        <span class="plain">kit: BasicInformExtrasKit at path inform7/Internal/Inter/BasicInformExtrasKit</span>
        <span class="plain">kit: WorldModelKit at path inform7/Internal/Inter/WorldModelKit</span>
        <span class="plain">kit: BasicInformKit at path inform7/Internal/Inter/BasicInformKit</span>
</pre>

<p class="inwebparagraph">For compatibility with the <code class="display"><span class="extract">inform7</span></code> command line syntax, we can also specify
the project target using <code class="display"><span class="extract">-project</span></code>:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inbuild/Tangled/inbuild -build -project Example.inform</span>
</pre>

<p class="inwebparagraph">But this is quite unnecessary: the effect is the same as if <code class="display"><span class="extract">-project</span></code> had
been missed out.
</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b>Listing filenames or pathnames of copies on the command line, or using the
<code class="display"><span class="extract">-contents-of D</span></code> switch, is only possible if we know where in the file system
these copies are; and sometimes we do not.
</p>

<p class="inwebparagraph">If we instead specify <code class="display"><span class="extract">-matching R</span></code>, where <code class="display"><span class="extract">R</span></code> is a list of requirements,
Inbuild will act on every copy it can find which matches that. For example,
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inbuild/Tangled/inbuild -inspect -matching 'genre=kit'</span>
</pre>

<p class="inwebparagraph">lists all the kits which Inbuild can see; and
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inbuild/Tangled/inbuild -inspect -matching 'genre=extension,author=Eric Eve'</span>
</pre>

<p class="inwebparagraph">lists all extensions by Eric Eve which Inbuild can see. The legal clauses to
specify are <code class="display"><span class="extract">title</span></code>, <code class="display"><span class="extract">author</span></code>, <code class="display"><span class="extract">genre</span></code> and <code class="display"><span class="extract">version</span></code>. Note that <code class="display"><span class="extract">version=5.1.1</span></code>
would match version numbers 5.1.1, 5.1.2, 5.2.0, etc., but not 6 or above:
again, this is following semver conventions. To specify an explicit maximum
and minimum version number, use <code class="display"><span class="extract">max</span></code> and <code class="display"><span class="extract">min</span></code>. For example:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">-matching 'genre=extension,author=Emily Short,title=Locksmith,min=6.1-alpha.2,max=17.2</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Nests and searches. </b>When searching with <code class="display"><span class="extract">-matching R</span></code>, or indeed when running Inform and needing
to find certain resources, Inbuild looks inside what are called "nests".
</p>

<p class="inwebparagraph">A nest is a directory with structured subdirectories, which correspond to
the genres of copies put into them. For example, in the standard distribution
of Inform as a command-line tool, the path <code class="display"><span class="extract">inform7/Internal</span></code> is a nest:
this contains the extensions, kits and so on which are built in to Inform
when it's used as an app.
</p>

<p class="inwebparagraph">Inbuild recognises the following subdirectories of a nest as significant:
</p>

<p class="inwebparagraph">	Templates
	Pipelines
	Inter
	Languages
	Extensions
</p>

<p class="inwebparagraph">Other subdirectories can also exist, and Inbuild ignores those. The above
five containers hold website templates (used by Inblorb), Inter pipelines,
kits, language definitions, and extensions. In the case of extensions, where
there may be very many in total, a further level of subdirectory is used
for the authpr's name. Thus:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Extensions/Emily Short/Locksmith.i7x</span>
</pre>

<p class="inwebparagraph">(In some early releases of Inform 7, it was legal for this file not to have
the <code class="display"><span class="extract">.i7x</span></code> extension: but now it is compulsory.)
</p>

<p class="inwebparagraph">As of 2020, nests can contain multiple versions of the same work. To do
this, they should have a filename (or pathname) which ends with <code class="display"><span class="extract">-vN</span></code>, where
<code class="display"><span class="extract">N</span></code> is semantic version number but with any dots replaced by underscores.
Thus, we can have e.g.:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Extensions/Emily Short/Locksmith-v3_2.i7x</span>
        <span class="plain">Extensions/Emily Short/Locksmith-v4_0_0-prealpha_13.i7x</span>
</pre>

<p class="inwebparagraph">co-existing side by side. If the user asks to
</p>

<blockquote>
    <p>Include Locksmith by Emily Short.</p>

</blockquote>

<p class="inwebparagraph">then version <code class="display"><span class="extract">4.0.0-prealpha.13</span></code> will be chosen, as the one with highest
precedence in this nest (but see below for how Inbuild chooses between
versions in the same nest). But if the user asks for
</p>

<blockquote>
    <p>Include version 3 Locksmith by Emily Short.</p>

</blockquote>

<p class="inwebparagraph">then version <code class="display"><span class="extract">3.2</span></code> is the winner, as the highest-numbered extension in the
nest with the right major version number (3).
</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b>In most runs of the Inform compiler, three nests are used: the "internal"
one, so-called, which holds built-in extensions and is read-only; the
"external" one, which will be somewhere outside of the Inform GUI app, and
will hold additional extensions downloaded by the user; and the Materials
folder for an Inform project, which is a nest all by itself.
</p>

<p class="inwebparagraph">Inbuild looks for these as follows:
</p>

<ul class="items"><li>(a) <code class="display"><span class="extract">-internal N</span></code> tells Inbuild the path <code class="display"><span class="extract">N</span></code> for the internal nest; if this
is not given, the default is <code class="display"><span class="extract">inform7/Internal</span></code>.
</li><li>(b) <code class="display"><span class="extract">-external N</span></code> tells Inbuild the path <code class="display"><span class="extract">N</span></code> for the external nest; if this
is not given, the default depends on the host operating system. For example,
on MacOS it will be <code class="display"><span class="extract">~/Library/Inform</span></code> (which is what the Inform GUI app
uses too if it is not sandboxed: if it is indeed sandboxed, then it will
have a deliberately obfuscated location which MacOS does not want tools
like ours to access externally).
</li><li>(c) The Materials nest is always the Materials folder associated with the
project Inbuild is working on; if it isn't working on a project, then this
nest is of course not present.
</li></ul>
<p class="inwebparagraph">In addition, extra nests can be specified with <code class="display"><span class="extract">-nest N</span></code>.
</p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16.  </b>When Inbuild searches for some resource needed by Inform &mdash; let's continue
to use the Locksmith extension as an example &mdash; it always has some range of
version numbers in mind: it will only accept a version in that range. (The
range can be unlimited, in which case any version is acceptable.)
</p>

<p class="inwebparagraph">This may well produce multiple results: as noted above, we might have multiple
copies of Locksmith around. Inbuild first reduces the list to just those
whose version lies in the acceptable range. It then applies the following
rules:
</p>

<ul class="items"><li>(1) A copy in the Materials nest takes precedence over all others.
</li><li>(2) Otherwise, all other copies take precendence over those in the
internal nest.
</li><li>(3) Otherwise, semantic version number rules are used to determine which
copy had precedence.
</li></ul>
<p class="inwebparagraph">Suppose the Materials folder for our project contains <code class="display"><span class="extract">Locksmith-v3_2.i7x</span></code>,
while the external folder contains <code class="display"><span class="extract">Locksmith-v3_3.i7x</span></code> and <code class="display"><span class="extract">Locksmith-v4.i7x</span></code>.
Then the sentence:
</p>

<blockquote>
    <p>Include Locksmith by Emily Short.</p>

</blockquote>

<p class="inwebparagraph">would result in <code class="display"><span class="extract">Locksmith-v3_2.i7x</span></code> from Materials being used, even though
there's a later version in the external area: Materials always wins. But
</p>

<blockquote>
    <p>Include version 4 of Locksmith by Emily Short.</p>

</blockquote>

<p class="inwebparagraph">would use <code class="display"><span class="extract">Locksmith-v4.i7x</span></code> from the external area, because the copy in the
Materials folder doesn't qualify.
</p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17. Copy, sync and archive. </b>Clerical work is generally best done automatically, and Inbuild offers some
useful filing commands.
</p>

<p class="inwebparagraph">The command <code class="display"><span class="extract">-copy-to N</span></code> makes a duplicate copy in the nest <code class="display"><span class="extract">N</span></code>. For example:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inbuild/Tangled/inbuild -inspect junk/Mystery.i7x</span>
        <span class="plain">extension: Complex Listing by Emily Short v9 in directory junk.</span>
        <span class="plain">$ inbuild/Tangled/inbuild -copy-to MyNest junk/Mystery.i7x</span>
        <span class="plain">cp -f 'junk/Mystery.i7x' 'MyNest/Extensions/Emily Short/Complex Listing-v9.i7x'</span>
</pre>

<p class="inwebparagraph">Note that Inbuild replies to the <code class="display"><span class="extract">-copy-to N</span></code> command by executing a shell
command to copy what is, in this case, a single file. As when building, the
<code class="display"><span class="extract">-dry</span></code> option puts Inbuild into dry-run mode, where it prints the commands it
would like to execute but doesn't execute them.
</p>

<p class="inwebparagraph">The command <code class="display"><span class="extract">-sync-to N</span></code> is similar, but will overwrite any existing copy
already in <code class="display"><span class="extract">N</span></code>, rather than producing an error if a collision occurs.
</p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18.  </b>The <code class="display"><span class="extract">-archive-to N</span></code> command performs <code class="display"><span class="extract">-sync-to N</span></code> on any resource needed
to build the copy it is working on (with one exception, for technical reasons:
the configuration file telling Inform how to use the English natural language).
</p>

<p class="inwebparagraph">This is really only useful for Inform projects, and the abbreviated form
<code class="display"><span class="extract">-archive</span></code> performs <code class="display"><span class="extract">-archive-to</span></code> to the Materials folder for a project.
The net effect of this is that all extensions needed to build a story file
are gathered, with their correct versions, into the Materials folder; this
means that if the project and its Materials are moved to a different user's
computer, where a quite different set of extensions may be installed, then
the project will still work exactly as it originally did.
</p>

<hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

