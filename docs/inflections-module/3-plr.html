<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>3/dcl</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../compiler.html"><b>compiler tools</b></a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul>
<h2>Compiler Webs</h2>
<ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul>
<h2>Inbuild Modules</h2>
<ul>
<li><a href="../inbuild-module/index.html">inbuild</a></li>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../html-module/index.html">html</a></li>
</ul>
<h2>Inform7 Modules</h2>
<ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul>
<h2>Inter Modules</h2>
<ul>
<li><a href="../inter-module/index.html">inter</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of '3/plr' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="../compiler.html">Compiler Modules</a></li><li><a href="index.html">inflections</a></li><li><a href="index.html#3">Chapter 3: Grammatical Uses of Inflection</a></li><li><b>Pluralisation</b></li></ul><p class="purpose">To form plurals of nouns.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Dictionary</a></li><li><a href="#SP3">&#167;3. Searching the plural dictionary</a></li><li><a href="#SP4">&#167;4. The pluralizing trie</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Dictionary. </b>A modest dictionary of plurals is maintained to allow the user to record
better plurals than the ones we would make ourselves. This assumes that a
plural can be constructed without knowledge of context, but that works in
almost all cases. (Arguably "dwarf" should pluralise to "dwarfs" when
discussing stars and to "dwarves" when reading Tolkien, but it is devoutly
to be hoped that few works of IF will contain both at once.)
</p>

<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">plural_dictionary_entry</span><span class="plain"> {</span>
        <span class="identifier">PREFORM_LANGUAGE_TYPE</span><span class="plain"> *</span><span class="identifier">defined_in</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">singular_form</span><span class="plain">; </span><span class="comment">words of singular form</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">plural_form</span><span class="plain">; </span><span class="comment">words of plural form</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">plural_dictionary_entry</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure plural_dictionary_entry is accessed in 3/vc and here.</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>Note that we are entirely allowed to register a new plural for a phrase
which already has a plural in the dictionary, even for the same language,
which is why we do not trouble to search the existing dictionary here.
</p>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Pluralisation::register</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">S</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">P</span><span class="plain">, </span><span class="identifier">PREFORM_LANGUAGE_TYPE</span><span class="plain"> *</span><span class="identifier">nl</span><span class="plain">) {</span>
        <span class="reserved">plural_dictionary_entry</span><span class="plain"> *</span><span class="identifier">pde</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">plural_dictionary_entry</span><span class="plain">);</span>
        <span class="identifier">pde</span><span class="plain">-&gt;</span><span class="element">singular_form</span><span class="plain"> = </span><span class="identifier">S</span><span class="plain">;</span>
        <span class="identifier">pde</span><span class="plain">-&gt;</span><span class="element">plural_form</span><span class="plain"> = </span><span class="identifier">P</span><span class="plain">;</span>
        <span class="identifier">pde</span><span class="plain">-&gt;</span><span class="element">defined_in</span><span class="plain"> = </span><span class="identifier">nl</span><span class="plain">;</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">CONSTRUCTED_PLURALS</span><span class="plain">, </span><span class="string">"[Registering plural of %W as %W]\n"</span><span class="plain">, </span><span class="identifier">S</span><span class="plain">, </span><span class="identifier">P</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Pluralisation::register appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Searching the plural dictionary. </b>The following routine can either be called once only &mdash; in which case it
yields up the best known plural for the phrase &mdash; or iteratively, in which
case it serves up all known plurals of the given phrase, starting with the
best (the earliest defined in the text, if any plural for this phrase has
been so defined) and finishing up with the worst (a mechanically-made
one not found in the dictionary).
</p>

<pre class="display">
    <span class="reserved">plural_dictionary_entry</span><span class="plain"> *</span><span class="functiontext">Pluralisation::make</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">PW</span><span class="plain">,</span>
        <span class="reserved">plural_dictionary_entry</span><span class="plain"> *</span><span class="identifier">search_from</span><span class="plain">, </span><span class="identifier">PREFORM_LANGUAGE_TYPE</span><span class="plain"> *</span><span class="identifier">nl</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">nl</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">nl</span><span class="plain"> = </span><span class="identifier">English_language</span><span class="plain">;</span>

        <span class="reserved">plural_dictionary_entry</span><span class="plain"> *</span><span class="identifier">pde</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) { *</span><span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">; }</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">search_from</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">search_from</span><span class="plain"> = </span><span class="identifier">FIRST_OBJECT</span><span class="plain">(</span><span class="reserved">plural_dictionary_entry</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">search_from</span><span class="plain"> = </span><span class="identifier">NEXT_OBJECT</span><span class="plain">(</span><span class="identifier">search_from</span><span class="plain">, </span><span class="reserved">plural_dictionary_entry</span><span class="plain">);</span>

        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">pde</span><span class="plain"> = </span><span class="identifier">search_from</span><span class="plain">; </span><span class="identifier">pde</span><span class="plain">; </span><span class="identifier">pde</span><span class="plain"> = </span><span class="identifier">NEXT_OBJECT</span><span class="plain">(</span><span class="identifier">pde</span><span class="plain">, </span><span class="reserved">plural_dictionary_entry</span><span class="plain">))</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">pde</span><span class="plain">-&gt;</span><span class="identifier">defined_in</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">pde</span><span class="plain">-&gt;</span><span class="element">defined_in</span><span class="plain"> == </span><span class="identifier">nl</span><span class="plain">))</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::match</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">pde</span><span class="plain">-&gt;</span><span class="element">singular_form</span><span class="plain">)) {</span>
                    <span class="plain">*</span><span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">pde</span><span class="plain">-&gt;</span><span class="identifier">plural_form</span><span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">pde</span><span class="plain">;</span>
                <span class="plain">}</span>

        &lt;<span class="cwebmacro">Make a new plural by lexical writing back</span> <span class="cwebmacronumber">3.1</span>&gt;<span class="plain">;</span>

        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Pluralisation::make is used in 2/nc (<a href="2-nc.html#SP3_1">&#167;3.1</a>).</p>

<p class="inwebparagraph"><a id="SP3_1"></a><b>&#167;3.1.  </b>When the dictionary fails us, we use lexical rewriting to construct plurals
of phrases found only in the singular in the source. For instance, if the
designer says that "A wicker basket is a kind of container" then NI will
need to recognise not only "wicker basket" but also "wicker baskets", a
pair of words not found in the source text anywhere. So the following
routine takes the text <code class="display"><span class="extract">(w1, w2)</span></code> and feeds a suitable plural into the
lexer, emerging with the text <code class="display"><span class="extract">(plw1, plw2)</span></code>.
</p>

<p class="inwebparagraph">We do not write the new plural into the dictionary: there is no need, as
it can be rebuilt quickly whenever needed again.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Make a new plural by lexical writing back</span> <span class="cwebmacronumber">3.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">feed_t</span><span class="plain"> </span><span class="identifier">id</span><span class="plain"> = </span><span class="identifier">Feeds::begin</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">) &gt; </span><span class="constant">1</span><span class="plain">) </span><span class="identifier">Feeds::feed_wording</span><span class="plain">(</span><span class="identifier">Wordings::trim_last_word</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">last_wn</span><span class="plain"> = </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">original</span><span class="plain">);</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">pluralised</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">original</span><span class="plain">, </span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">Wordings::one_word</span><span class="plain">(</span><span class="identifier">last_wn</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (*(</span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">last_wn</span><span class="plain">)) == </span><span class="character">'\"'</span><span class="plain">) </span><span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">pluralised</span><span class="plain">, </span><span class="string">"some-long-text"</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="functiontext">Pluralisation::regular</span><span class="plain">(</span><span class="identifier">pluralised</span><span class="plain">, </span><span class="identifier">original</span><span class="plain">, </span><span class="identifier">nl</span><span class="plain">);</span>
        <span class="identifier">Feeds::feed_stream</span><span class="plain">(</span><span class="identifier">pluralised</span><span class="plain">);</span>
        <span class="plain">*</span><span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">Feeds::end</span><span class="plain">(</span><span class="identifier">id</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">original</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">pluralised</span><span class="plain">);</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">CONSTRUCTED_PLURALS</span><span class="plain">, </span><span class="string">"[Constructing plural of %W as %W]\n"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, *</span><span class="identifier">PW</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP3">&#167;3</a>.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. The pluralizing trie. </b>The following takes a single word, assumes it to be a noun which meaningfully
has a plural, and modifies it to the plural form.
</p>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Pluralisation::regular</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">from</span><span class="plain">, </span><span class="identifier">PREFORM_LANGUAGE_TYPE</span><span class="plain"> *</span><span class="identifier">nl</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">nl</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">nl</span><span class="plain"> = </span><span class="identifier">English_language</span><span class="plain">;</span>
        <span class="identifier">match_avinue</span><span class="plain"> *</span><span class="identifier">plural_trie</span><span class="plain"> =</span>
            <span class="functiontext">Preform::Nonparsing::define_trie</span><span class="plain">(&lt;</span><span class="identifier">singular</span><span class="plain">-</span><span class="identifier">noun</span><span class="plain">-</span><span class="identifier">to</span><span class="plain">-</span><span class="identifier">its</span><span class="plain">-</span><span class="identifier">plural</span><span class="plain">&gt;, </span><span class="identifier">TRIE_END</span><span class="plain">, </span><span class="identifier">nl</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Inflections::suffix_inflection</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">plural_trie</span><span class="plain">, </span><span class="identifier">from</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Pluralisation::regular is used in <a href="#SP3_1">&#167;3.1</a>.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="3-dcl.html">Back to 'Declensions'</a></li><li><a href="3-ga.html">Continue with 'Grading Adjectives'</a></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

