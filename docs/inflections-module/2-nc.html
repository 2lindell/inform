<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>2/tai</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../compiler.html"><b>compiler</b></a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul>
<h2>Compiler Webs</h2>
<ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul>
<h2>Inbuild Modules</h2>
<ul>
<li><a href="../inbuild-module/index.html">inbuild</a></li>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../html-module/index.html">html</a></li>
</ul>
<h2>Inform7 Modules</h2>
<ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul>
<h2>Inter Modules</h2>
<ul>
<li><a href="../inter-module/index.html">inter</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of '2/nc' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="../compiler.html">Compiler Modules</a></li><li><a href="index.html">inflections</a></li><li><a href="index.html#2">Chapter 2: Machinery</a></li><li><b>Name Clusters</b></li></ul><p class="purpose">Name clusters are sets of noun or adjective forms, perhaps multiple or in multiple languages, which have in common that they share a meaning.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Cluster</a></li><li><a href="#SP5">&#167;5. Plural fixing</a></li><li><a href="#SP6">&#167;6. Searching declensions</a></li><li><a href="#SP9">&#167;9. Meanings</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Cluster. </b>A cluster is a linked list of wordings, in effect, but they are annotated
with lingistic roles. For example, the cluster of names for the common noun
"man" might be:
</p>

<blockquote>
    <p>man (En, singular), men (En, plural), homme (Fr, singular), hommes (Fr, plural)</p>

</blockquote>

<p class="inwebparagraph">(at least in the nominative case). Clusters can be used for adjectives too.
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">name_cluster</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">individual_name</span><span class="plain"> *</span><span class="identifier">first_name</span><span class="plain">;</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">name_cluster</span><span class="plain">;</span>

    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">individual_name</span><span class="plain"> {</span>
        <span class="identifier">general_pointer</span><span class="plain"> </span><span class="identifier">principal_meaning</span><span class="plain">; </span>    <span class="comment">for the client to attach some meaning</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">declension</span><span class="plain"> </span><span class="identifier">name</span><span class="plain">; </span>    <span class="comment">text of name</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">name_number</span><span class="plain">; </span>    <span class="comment">1 for singular, 2 for plural</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">name_gender</span><span class="plain">; </span>    <span class="comment">1 is neuter, 2 is masculine, 3 is feminine</span>
        <span class="identifier">PREFORM_LANGUAGE_TYPE</span><span class="plain"> *</span><span class="identifier">name_language</span><span class="plain">; </span>    <span class="comment">always non-null</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">individual_name</span><span class="plain"> *</span><span class="identifier">next</span><span class="plain">; </span>    <span class="comment">within its cluster</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">individual_name</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure name_cluster is private to this section.</p>

<p class="endnote">The structure individual_name is accessed in 2/np and here.</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>A cluster begins empty.
</p>


<pre class="display">
    <span class="reserved">name_cluster</span><span class="plain"> *</span><span class="functiontext">Clusters::new</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">name_cluster</span><span class="plain"> *</span><span class="identifier">names</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">name_cluster</span><span class="plain">);</span>
        <span class="identifier">names</span><span class="plain">-</span><span class="element">&gt;first_name</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">names</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Clusters::new appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>The following can add either a single name, or a name and its plural(s):
</p>


<pre class="display">
    <span class="reserved">individual_name</span><span class="plain"> *</span><span class="functiontext">Clusters::add</span><span class="plain">(</span><span class="reserved">name_cluster</span><span class="plain"> *</span><span class="identifier">names</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">,</span>
        <span class="identifier">PREFORM_LANGUAGE_TYPE</span><span class="plain"> *</span><span class="identifier">nl</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">gender</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">number</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">pluralise</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">nl</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">nl</span><span class="plain"> = </span><span class="identifier">English_language</span><span class="plain">;</span>
        <span class="reserved">individual_name</span><span class="plain"> *</span><span class="identifier">in</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">individual_name</span><span class="plain">);</span>
        <span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;principal_meaning</span><span class="plain"> = </span><span class="identifier">NULL_GENERAL_POINTER</span><span class="plain">;</span>
        <span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain"> = </span><span class="functiontext">Declensions::decline</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">nl</span><span class="plain">, </span><span class="identifier">gender</span><span class="plain">, </span><span class="identifier">number</span><span class="plain">);</span>
        <span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;name_language</span><span class="plain"> = </span><span class="identifier">nl</span><span class="plain">;</span>
        <span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;name_number</span><span class="plain"> = </span><span class="identifier">number</span><span class="plain">;</span>
        <span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;name_gender</span><span class="plain"> = </span><span class="identifier">gender</span><span class="plain">;</span>
        <span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">names</span><span class="plain">-</span><span class="element">&gt;first_name</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">names</span><span class="plain">-</span><span class="element">&gt;first_name</span><span class="plain"> = </span><span class="identifier">in</span><span class="plain">;</span>
        <span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">individual_name</span><span class="plain"> *</span><span class="identifier">in2</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">in2</span><span class="plain"> = </span><span class="identifier">names</span><span class="plain">-</span><span class="element">&gt;first_name</span><span class="plain">; ((</span><span class="identifier">in2</span><span class="plain">) &amp;&amp; (</span><span class="identifier">in2</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)); </span><span class="identifier">in2</span><span class="plain"> = </span><span class="identifier">in2</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">) ;</span>
            <span class="identifier">in2</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">in</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">pluralise</span><span class="plain">) &amp;&amp; (</span><span class="identifier">number</span><span class="plain"> == 1))</span>
            &lt;<span class="cwebmacro">Add plural names as well</span> <span class="cwebmacronumber">3.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">in</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Clusters::add is used in <a href="#SP3_1">&#167;3.1</a>, <a href="#SP4">&#167;4</a>, <a href="#SP4_1">&#167;4.1</a>, <a href="#SP5">&#167;5</a>.</p>

<p class="inwebparagraph"><a id="SP3_1"></a><b>&#167;3.1.  </b>The following makes all possible plurals and registers those too. (Note
that every instance gets a plural name: even something palpably unique, like
"the Koh-i-Noor diamond".) The plural dictionary supports multiple plurals,
so there may be any number of names registered: for instance, the kind
"person" is registered with plurals "persons" and "people".
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Add plural names as well</span> <span class="cwebmacronumber">3.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">plural_dictionary_entry</span><span class="plain"> *</span><span class="identifier">pde</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">k</span><span class="plain"> = 0;</span>
        <span class="reserved">do</span><span class="plain"> {</span>
            <span class="identifier">k</span><span class="plain">++;</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
            <span class="identifier">pde</span><span class="plain"> = </span><span class="functiontext">Pluralisation::make</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, &amp;</span><span class="identifier">PW</span><span class="plain">, </span><span class="identifier">pde</span><span class="plain">, </span><span class="identifier">nl</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">PW</span><span class="plain">)) {</span>
                <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">CONSTRUCTED_PLURALS</span><span class="plain">, </span><span class="string">"(%d) Reading plural of &lt;%W&gt; as &lt;%W&gt;\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">k</span><span class="plain">,</span>
                    <span class="identifier">W</span><span class="plain">, </span><span class="identifier">PW</span><span class="plain">);</span>
                <span class="functiontext">Clusters::add</span><span class="plain">(</span><span class="identifier">names</span><span class="plain">, </span><span class="identifier">PW</span><span class="plain">, </span><span class="identifier">nl</span><span class="plain">, </span><span class="identifier">gender</span><span class="plain">, 2, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">} </span><span class="reserved">while</span><span class="plain"> (</span><span class="identifier">pde</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP3">&#167;3</a>.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>The following is more suited to adjectives, or to words which are used
adjectivally, such as past participles in French. This time we generate all
possible gender and number agreements &mdash; except in English, where no variation
occurs: please don't argue about blond/blonde.
</p>

<p class="inwebparagraph">GNA is a traditional Inform term, standing for "gender-number-animation".
At run time, it's an integer from 0 to 11 which encodes all possible
combinations. Here we only work through six, ignoring animation:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Clusters::add_with_agreements</span><span class="plain">(</span><span class="reserved">name_cluster</span><span class="plain"> *</span><span class="identifier">cl</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">PREFORM_LANGUAGE_TYPE</span><span class="plain"> *</span><span class="identifier">nl</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">nl</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">nl</span><span class="plain"> = </span><span class="identifier">English_language</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">nl</span><span class="plain"> == </span><span class="identifier">English_language</span><span class="plain">) {</span>
            <span class="functiontext">Clusters::add</span><span class="plain">(</span><span class="identifier">cl</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">nl</span><span class="plain">, </span><span class="constant">NEUTER_GENDER</span><span class="plain">, 1, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">gna</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">gna</span><span class="plain"> = 0; </span><span class="identifier">gna</span><span class="plain"> &lt; 6; </span><span class="identifier">gna</span><span class="plain">++)</span>
                &lt;<span class="cwebmacro">Generate agreement form in this GNA and add to the declension</span> <span class="cwebmacronumber">4.1</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Clusters::add_with_agreements appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP4_1"></a><b>&#167;4.1.  </b>We use tries to modify the base text, which is taken to be the neuter
singular form, into the other five forms.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Generate agreement form in this GNA and add to the declension</span> <span class="cwebmacronumber">4.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">nonterminal</span><span class="plain"> *</span><span class="identifier">step1</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">, *</span><span class="identifier">step2</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">form_number</span><span class="plain"> = 1, </span><span class="identifier">form_gender</span><span class="plain"> = </span><span class="constant">NEUTER_GENDER</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gna</span><span class="plain"> &gt;= 3) </span><span class="identifier">form_number</span><span class="plain"> = 2;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">gna</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> 0:	</span><span class="identifier">step1</span><span class="plain"> = &lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">to</span><span class="plain">-</span><span class="identifier">masculine</span><span class="plain">-</span><span class="identifier">singular</span><span class="plain">&gt;;</span>
                    <span class="identifier">form_gender</span><span class="plain"> = </span><span class="constant">MASCULINE_GENDER</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 1:	</span><span class="identifier">step1</span><span class="plain"> = &lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">to</span><span class="plain">-</span><span class="identifier">feminine</span><span class="plain">-</span><span class="identifier">singular</span><span class="plain">&gt;;</span>
                    <span class="identifier">form_gender</span><span class="plain"> = </span><span class="constant">FEMININE_GENDER</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 2:	</span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 3: </span><span class="identifier">step1</span><span class="plain"> = &lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">to</span><span class="plain">-</span><span class="identifier">masculine</span><span class="plain">-</span><span class="identifier">singular</span><span class="plain">&gt;;</span>
                    <span class="identifier">step2</span><span class="plain"> = &lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">to</span><span class="plain">-</span><span class="identifier">masculine</span><span class="plain">-</span><span class="identifier">plural</span><span class="plain">&gt;;</span>
                    <span class="identifier">form_gender</span><span class="plain"> = </span><span class="constant">MASCULINE_GENDER</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 4: </span><span class="identifier">step1</span><span class="plain"> = &lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">to</span><span class="plain">-</span><span class="identifier">feminine</span><span class="plain">-</span><span class="identifier">singular</span><span class="plain">&gt;;</span>
                    <span class="identifier">step2</span><span class="plain"> = &lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">to</span><span class="plain">-</span><span class="identifier">feminine</span><span class="plain">-</span><span class="identifier">plural</span><span class="plain">&gt;;</span>
                    <span class="identifier">form_gender</span><span class="plain"> = </span><span class="constant">FEMININE_GENDER</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 5: </span><span class="identifier">step1</span><span class="plain"> = &lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">to</span><span class="plain">-</span><span class="identifier">plural</span><span class="plain">&gt;; </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">FW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        &lt;<span class="cwebmacro">Process via the agreement trie in this pipeline</span> <span class="cwebmacronumber">4.1.1</span>&gt;<span class="plain">;</span>
        <span class="functiontext">Clusters::add</span><span class="plain">(</span><span class="identifier">cl</span><span class="plain">, </span><span class="identifier">FW</span><span class="plain">, </span><span class="identifier">nl</span><span class="plain">, </span><span class="identifier">form_gender</span><span class="plain">, </span><span class="identifier">form_number</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP4">&#167;4</a>.</p>

<p class="inwebparagraph"><a id="SP4_1_1"></a><b>&#167;4.1.1.  </b>Not much of a pipeline, really: we start with the base case and work
through one or two tries.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Process via the agreement trie in this pipeline</span> <span class="cwebmacronumber">4.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">word_assemblage</span><span class="plain"> </span><span class="identifier">wa</span><span class="plain"> = </span><span class="identifier">WordAssemblages::from_wording</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">step1</span><span class="plain">)</span>
            <span class="identifier">wa</span><span class="plain"> = </span><span class="functiontext">Inflections::apply_trie_to_wa</span><span class="plain">(</span><span class="identifier">wa</span><span class="plain">,</span>
                <span class="functiontext">Preform::Nonparsing::define_trie</span><span class="plain">(</span><span class="identifier">step1</span><span class="plain">, </span><span class="identifier">TRIE_END</span><span class="plain">, </span><span class="identifier">nl</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">step2</span><span class="plain">)</span>
            <span class="identifier">wa</span><span class="plain"> = </span><span class="functiontext">Inflections::apply_trie_to_wa</span><span class="plain">(</span><span class="identifier">wa</span><span class="plain">,</span>
                <span class="functiontext">Preform::Nonparsing::define_trie</span><span class="plain">(</span><span class="identifier">step2</span><span class="plain">, </span><span class="identifier">TRIE_END</span><span class="plain">, </span><span class="identifier">nl</span><span class="plain">));</span>
        <span class="identifier">FW</span><span class="plain"> = </span><span class="identifier">WordAssemblages::to_wording</span><span class="plain">(&amp;</span><span class="identifier">wa</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP4_1">&#167;4.1</a>.</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Plural fixing. </b>Less elegantly, we can force the plural of a name in a cluster to a given
fixed text, overwriting it if it's already there. In practice this is done
only when the built-in kinds are being given plural names; some of these
(those for kind constructors with optional wordings) have a peculiar format,
and wouldn't pass through the pluralising tries intact.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Clusters::set_plural_name</span><span class="plain">(</span><span class="reserved">name_cluster</span><span class="plain"> *</span><span class="identifier">cl</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">PREFORM_LANGUAGE_TYPE</span><span class="plain"> *</span><span class="identifier">nl</span><span class="plain">) {</span>
        <span class="reserved">individual_name</span><span class="plain"> *</span><span class="identifier">in</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">in</span><span class="plain"> = </span><span class="identifier">cl</span><span class="plain">-</span><span class="element">&gt;first_name</span><span class="plain">; </span><span class="identifier">in</span><span class="plain">; </span><span class="identifier">in</span><span class="plain"> = </span><span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;name_number</span><span class="plain"> == 2) {</span>
                <span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain"> = </span><span class="functiontext">Declensions::decline</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">nl</span><span class="plain">, </span><span class="constant">NEUTER_GENDER</span><span class="plain">, 2);</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="functiontext">Clusters::add</span><span class="plain">(</span><span class="identifier">cl</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="constant">NEUTER_GENDER</span><span class="plain">, 2, </span><span class="identifier">FALSE</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Clusters::set_plural_name appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Searching declensions. </b>These are always quite small, so there's no need for any efficient device
to search them.
</p>

<p class="inwebparagraph">The first routine finds the earliest name with the correct number (singular
or plural):
</p>


<pre class="display">
    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">Clusters::get_name</span><span class="plain">(</span><span class="reserved">name_cluster</span><span class="plain"> *</span><span class="identifier">cl</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">plural_flag</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">number_sought</span><span class="plain"> = 1;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">plural_flag</span><span class="plain">) </span><span class="identifier">number_sought</span><span class="plain"> = 2;</span>
        <span class="reserved">individual_name</span><span class="plain"> *</span><span class="identifier">in</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">in</span><span class="plain"> = </span><span class="identifier">cl</span><span class="plain">-</span><span class="element">&gt;first_name</span><span class="plain">; </span><span class="identifier">in</span><span class="plain">; </span><span class="identifier">in</span><span class="plain"> = </span><span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;name_number</span><span class="plain"> == </span><span class="identifier">number_sought</span><span class="plain">)</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Declensions::in_case</span><span class="plain">(&amp;(</span><span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain">), </span><span class="constant">NOMINATIVE_CASE</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Clusters::get_name is used in <a href="#SP7">&#167;7</a>.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>The following variant finds the earliest name in the language of play,
falling back on English if there's none registered:
</p>


<pre class="display">
    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">Clusters::get_name_in_play</span><span class="plain">(</span><span class="reserved">name_cluster</span><span class="plain"> *</span><span class="identifier">cl</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">plural_flag</span><span class="plain">, </span><span class="identifier">PREFORM_LANGUAGE_TYPE</span><span class="plain"> *</span><span class="identifier">nl</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">number_sought</span><span class="plain"> = 1;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">plural_flag</span><span class="plain">) </span><span class="identifier">number_sought</span><span class="plain"> = 2;</span>
        <span class="reserved">individual_name</span><span class="plain"> *</span><span class="identifier">in</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">in</span><span class="plain"> = </span><span class="identifier">cl</span><span class="plain">-</span><span class="element">&gt;first_name</span><span class="plain">; </span><span class="identifier">in</span><span class="plain">; </span><span class="identifier">in</span><span class="plain"> = </span><span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;name_number</span><span class="plain"> == </span><span class="identifier">number_sought</span><span class="plain">) &amp;&amp;</span>
                <span class="plain">(</span><span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;name_language</span><span class="plain"> == </span><span class="identifier">nl</span><span class="plain">))</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Declensions::in_case</span><span class="plain">(&amp;(</span><span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain">), </span><span class="constant">NOMINATIVE_CASE</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Clusters::get_name</span><span class="plain">(</span><span class="identifier">cl</span><span class="plain">, </span><span class="identifier">plural_flag</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Clusters::get_name_in_play appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>A more specific search, which can optionally test for number and gender.
</p>


<pre class="display">
    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">Clusters::get_name_general</span><span class="plain">(</span><span class="reserved">name_cluster</span><span class="plain"> *</span><span class="identifier">cl</span><span class="plain">,</span>
        <span class="identifier">PREFORM_LANGUAGE_TYPE</span><span class="plain"> *</span><span class="identifier">nl</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">number_sought</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">gender_sought</span><span class="plain">) {</span>
        <span class="reserved">individual_name</span><span class="plain"> *</span><span class="identifier">in</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">in</span><span class="plain"> = </span><span class="identifier">cl</span><span class="plain">-</span><span class="element">&gt;first_name</span><span class="plain">; </span><span class="identifier">in</span><span class="plain">; </span><span class="identifier">in</span><span class="plain"> = </span><span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (((</span><span class="identifier">number_sought</span><span class="plain"> == -1) || (</span><span class="identifier">number_sought</span><span class="plain"> == </span><span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;name_number</span><span class="plain">)) &amp;&amp;</span>
                <span class="plain">((</span><span class="identifier">gender_sought</span><span class="plain"> == -1) || (</span><span class="identifier">gender_sought</span><span class="plain"> == </span><span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;name_gender</span><span class="plain">)) &amp;&amp;</span>
                <span class="plain">(</span><span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;name_language</span><span class="plain"> == </span><span class="identifier">nl</span><span class="plain">))</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Declensions::in_case</span><span class="plain">(&amp;(</span><span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain">), </span><span class="constant">NOMINATIVE_CASE</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Clusters::get_name_general appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Meanings. </b>We will come to how excerpts of text are given meanings later on. For now, it's
enough to say that each individual name can have one, and that the pointer
to an <code class="display"><span class="extract">excerpt_meaning</span></code> records it.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Clusters::set_principal_meaning</span><span class="plain">(</span><span class="reserved">individual_name</span><span class="plain"> *</span><span class="identifier">in</span><span class="plain">, </span><span class="identifier">general_pointer</span><span class="plain"> </span><span class="identifier">meaning</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">in</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"no individual name"</span><span class="plain">);</span>
        <span class="identifier">in</span><span class="plain">-</span><span class="element">&gt;principal_meaning</span><span class="plain"> = </span><span class="identifier">meaning</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">general_pointer</span><span class="plain"> </span><span class="functiontext">Clusters::get_principal_meaning</span><span class="plain">(</span><span class="reserved">name_cluster</span><span class="plain"> *</span><span class="identifier">cl</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">cl</span><span class="plain">-</span><span class="element">&gt;first_name</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL_GENERAL_POINTER</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">cl</span><span class="plain">-</span><span class="element">&gt;first_name</span><span class="plain">-</span><span class="element">&gt;principal_meaning</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Clusters::set_principal_meaning appears nowhere else.</p>

<p class="endnote">The function Clusters::get_principal_meaning appears nowhere else.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="2-tai.html">Back to 'Tries and Inflections'</a></li><li><i>(This section ends Chapter 2: Machinery.)</i></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

