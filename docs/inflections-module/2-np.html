<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Non-Parsing Preform</title>
<link href="Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-src/Figures/Inform.png" height=72">
</a></h1>
<ul><li><a href="../compiler.html">compiler tools</a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul><h2>Compiler Webs</h2><ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul><h2>Inbuild Modules</h2><ul>
<li><a href="../supervisor-module/index.html">supervisor</a></li>
</ul><h2>Inform7 Modules</h2><ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="index.html"><span class="selectedlink">inflections</span></a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul><h2>Inter Modules</h2><ul>
<li><a href="../bytecode-module/index.html">bytecode</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul><h2>Shared Modules</h2><ul>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../html-module/index.html">html</a></li>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Non-Parsing Preform' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../compiler.html">Inform7 Modules</a></li><li><a href="index.html">inflections</a></li><li><a href="index.html#2">Chapter 2: Machinery</a></li><li><b>Non-Parsing Preform</b></li></ul></div>
<p class="purpose">Other uses for Preform grammar, including the generation of adaptive text, and word inflection.</p>

<ul class="toc"><li><a href="2-np.html#SP1">&#167;1. Introduction</a></li><li><a href="2-np.html#SP2">&#167;2. (a) Specifying generated text</a></li><li><a href="2-np.html#SP5">&#167;5. (b) Specifying replacements</a></li><li><a href="2-np.html#SP6">&#167;6. (c) Lexicon entry</a></li><li><a href="2-np.html#SP7">&#167;7. (d) Making tries</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1"></a><b>&#167;1. Introduction. </b>Looked at more generally, Preform isn't just a parser syntax: it's a general-purpose way to specify
textual patterns, so we may as well take advantage of it for miscellaneous
other needs. There are altogether five non-parsing uses for Preform; in
order of complexity,
</p>

<ul class="items"><li>(a) Specifying text being generated by Inform;
</li><li>(b) Specifying replacements of one set of words by another;
</li><li>(c) Specifying miscellaneous entries for the lexicon in the index;
</li><li>(d) Saying how to build a trie which will detect patterns in a single word and
then modify it;
</li><li>(e) Saying how to conjugate a verb, that is, how to modify the wording of a
verb ("take", say) into all of its different forms (I take, he takes, it was
taken, I am taking, and so on). This we'll leave for later.
</li></ul>
<p class="commentary">Speed is not of the essence in any of these problems.
</p>

<p class="commentary firstcommentary"><a id="SP2"></a><b>&#167;2. (a) Specifying generated text. </b>Our main operation here is a "merge". This extracts the text from a production,
substituting the ingredient text in place of any <span class="extract"><span class="extract-syntax">...</span></span> it finds. (Other
wildcards and nonterminals are ignored.) For example, merging the production
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">fried</span><span class="plain-syntax"> ... </span><span class="identifier-syntax">tomatoes</span>
</pre>
<p class="commentary">with "orange" results in "fried orange tomatoes".
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">word_assemblage</span><span class="plain-syntax"> </span><span class="function-syntax">Preform::Nonparsing::merge</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">Preform::Nonparsing::merge</span></span>:<br/><a href="2-np.html#SP3">&#167;3</a>, <a href="2-np.html#SP4">&#167;4</a><br/>Grading Adjectives - <a href="3-ga.html#SP2">&#167;2</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">nt</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">pnum</span><span class="plain-syntax">, </span><span class="identifier-syntax">word_assemblage</span><span class="plain-syntax"> </span><span class="identifier-syntax">ingredient</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">production_list</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pl</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pl</span><span class="plain-syntax"> = </span><span class="identifier-syntax">nt</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">first_production_list</span><span class="plain-syntax">; </span><span class="identifier-syntax">pl</span><span class="plain-syntax">; </span><span class="identifier-syntax">pl</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pl</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_production_list</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">N</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">production</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pr</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pl</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">first_production</span><span class="plain-syntax">; </span><span class="identifier-syntax">pr</span><span class="plain-syntax">; </span><span class="identifier-syntax">pr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pr</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_production</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">N</span><span class="plain-syntax"> == </span><span class="identifier-syntax">pnum</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">word_assemblage</span><span class="plain-syntax"> </span><span class="identifier-syntax">wa</span><span class="plain-syntax"> = </span><span class="identifier-syntax">WordAssemblages::lit_0</span><span class="plain-syntax">();</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">ptoken</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pr</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">first_ptoken</span><span class="plain-syntax">; </span><span class="identifier-syntax">pt</span><span class="plain-syntax">; </span><span class="identifier-syntax">pt</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_ptoken</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">ptoken_category</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FIXED_WORD_PTC</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">wa</span><span class="plain-syntax"> = </span><span class="identifier-syntax">WordAssemblages::join</span><span class="plain-syntax">(</span><span class="identifier-syntax">wa</span><span class="plain-syntax">, </span><span class="identifier-syntax">WordAssemblages::lit_1</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">ve_pt</span><span class="plain-syntax">));</span>
<span class="plain-syntax">                    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">ptoken_category</span><span class="plain-syntax"> == </span><span class="identifier-syntax">MULTIPLE_WILDCARD_PTC</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">wa</span><span class="plain-syntax"> = </span><span class="identifier-syntax">WordAssemblages::join</span><span class="plain-syntax">(</span><span class="identifier-syntax">wa</span><span class="plain-syntax">, </span><span class="identifier-syntax">ingredient</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    }</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">wa</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">N</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">WordAssemblages::lit_0</span><span class="plain-syntax">(); </span><span class="comment-syntax"> give up, in other words</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP3"></a><b>&#167;3.  </b>Thus we can simply extract the wording by performing a merge with the empty
ingredient text:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">word_assemblage</span><span class="plain-syntax"> </span><span class="function-syntax">Preform::Nonparsing::wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">nt</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">pnum</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="2-np.html#SP2" class="function-link"><span class="function-syntax">Preform::Nonparsing::merge</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">nt</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnum</span><span class="plain-syntax">, </span><span class="identifier-syntax">WordAssemblages::lit_0</span><span class="plain-syntax">());</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4"></a><b>&#167;4.  </b>And here we take just one word:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">vocabulary_entry</span><span class="plain-syntax"> *</span><span class="function-syntax">Preform::Nonparsing::word</span><span class="plain-syntax">(</span><span class="identifier-syntax">nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">nt</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">pnum</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">word_assemblage</span><span class="plain-syntax"> </span><span class="identifier-syntax">wa</span><span class="plain-syntax"> = </span><a href="2-np.html#SP2" class="function-link"><span class="function-syntax">Preform::Nonparsing::merge</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">nt</span><span class="plain-syntax">, </span><span class="identifier-syntax">pnum</span><span class="plain-syntax">, </span><span class="identifier-syntax">WordAssemblages::lit_0</span><span class="plain-syntax">());</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">vocabulary_entry</span><span class="plain-syntax"> **</span><span class="identifier-syntax">words</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">num_words</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WordAssemblages::as_array</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">wa</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">words</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">num_words</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">num_words</span><span class="plain-syntax"> == </span><span class="constant-syntax">1</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">words</span><span class="plain-syntax">[0];</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP5"></a><b>&#167;5. (b) Specifying replacements. </b>The following looks for a word in one nonterminal and replaces it with the
corresponding word in another. If the word isn't found, it's left unchanged.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">vocabulary_entry</span><span class="plain-syntax"> *</span><span class="function-syntax">Preform::Nonparsing::replace_word</span><span class="plain-syntax">(</span><span class="identifier-syntax">vocabulary_entry</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ve</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">nt_from</span><span class="plain-syntax">, </span><span class="identifier-syntax">nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">nt_to</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">production_list</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pl_from</span><span class="plain-syntax">, *</span><span class="identifier-syntax">pl_to</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pl_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">nt_from</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">first_production_list</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">pl_to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">nt_to</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">first_production_list</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        ((</span><span class="identifier-syntax">pl_from</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">pl_to</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">pl_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pl_from</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_production_list</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">pl_to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pl_to</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_production_list</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">production</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pr_from</span><span class="plain-syntax">, *</span><span class="identifier-syntax">pr_to</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pr_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pl_from</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">first_production</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pr_to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pl_to</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">first_production</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            ((</span><span class="identifier-syntax">pr_from</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">pr_to</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pr_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pr_from</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_production</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pr_to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pr_to</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_production</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">ptoken</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pt_from</span><span class="plain-syntax">, *</span><span class="identifier-syntax">pt_to</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pr_from</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">first_ptoken</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">pt_to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pr_to</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">first_ptoken</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                ((</span><span class="identifier-syntax">pt_from</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">pt_to</span><span class="plain-syntax">));</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">pt_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pt_from</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_ptoken</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">pt_to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pt_to</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_ptoken</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">pt_from</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">ptoken_category</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FIXED_WORD_PTC</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">                    (</span><span class="identifier-syntax">pt_to</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">ptoken_category</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FIXED_WORD_PTC</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">ve</span><span class="plain-syntax"> == </span><span class="identifier-syntax">pt_from</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">ve_pt</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">pt_to</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">ve_pt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">ve</span><span class="plain-syntax">; </span><span class="comment-syntax"> no change, in other words</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP6"></a><b>&#167;6. (c) Lexicon entry. </b>This is only a convenience for putting particles into the Lexicon:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">#</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Preform::Nonparsing::enter_lexicon</span><span class="plain-syntax">(</span><span class="identifier-syntax">nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">nt_from</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">pos</span><span class="plain-syntax">, </span><span class="reserved-syntax">char</span><span class="plain-syntax"> *</span><span class="identifier-syntax">category</span><span class="plain-syntax">, </span><span class="reserved-syntax">char</span><span class="plain-syntax"> *</span><span class="identifier-syntax">gloss</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">production_list</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pl</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pl</span><span class="plain-syntax"> = </span><span class="identifier-syntax">nt_from</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">first_production_list</span><span class="plain-syntax">; </span><span class="identifier-syntax">pl</span><span class="plain-syntax">; </span><span class="identifier-syntax">pl</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pl</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_production_list</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">production</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pr</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pl</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">first_production</span><span class="plain-syntax">; </span><span class="identifier-syntax">pr</span><span class="plain-syntax">; </span><span class="identifier-syntax">pr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pr</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_production</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">ptoken</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pr</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">first_ptoken</span><span class="plain-syntax">; </span><span class="identifier-syntax">pt</span><span class="plain-syntax">; </span><span class="identifier-syntax">pt</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_ptoken</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">ptoken</span><span class="plain-syntax"> *</span><span class="identifier-syntax">alt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">alt</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pt</span><span class="plain-syntax">; </span><span class="identifier-syntax">alt</span><span class="plain-syntax">; </span><span class="identifier-syntax">alt</span><span class="plain-syntax"> = </span><span class="identifier-syntax">alt</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">alternative_ptoken</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">vocabulary_entry</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ve</span><span class="plain-syntax"> = </span><span class="identifier-syntax">alt</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">ve_pt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">ve</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Index::Lexicon::new_entry_with_details</span><span class="plain-syntax">(</span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">, </span><span class="identifier-syntax">pos</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                            </span><span class="identifier-syntax">WordAssemblages::lit_1</span><span class="plain-syntax">(</span><span class="identifier-syntax">ve</span><span class="plain-syntax">), </span><span class="identifier-syntax">category</span><span class="plain-syntax">, </span><span class="identifier-syntax">gloss</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    }</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
<span class="plain-syntax">#</span><span class="identifier-syntax">endif</span>
</pre>
<p class="commentary firstcommentary"><a id="SP7"></a><b>&#167;7. (d) Making tries. </b>Properly speaking, we make "avinues". Note that we expect to make a different
avinue for each natural language; this matters so that we can pluralise words
correctly in both English and French in the same run of Inform, for example.
But we are going to need to use these avinues frequently, so we cache them once
created.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">match_avinue</span><span class="plain-syntax"> *</span><span class="function-syntax">Preform::Nonparsing::define_trie</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">Preform::Nonparsing::define_trie</span></span>:<br/><a href="2-np.html#SP7_1_1_2">&#167;7.1.1.2</a><br/>Name Clusters - <a href="2-nc.html#SP4_1_1">&#167;4.1.1</a><br/>Article Inflection - <a href="3-ai.html#SP1">&#167;1</a><br/>Declensions - <a href="3-dcl.html#SP3">&#167;3</a><br/>Pluralisation - <a href="3-plr.html#SP4">&#167;4</a><br/>Grading Adjectives - <a href="3-ga.html#SP2">&#167;2</a>, <a href="3-ga.html#SP3">&#167;3</a><br/>Past Participles - <a href="3-pp.html#SP2">&#167;2</a><br/>Verb Conjugation - <a href="3-vc.html#SP4_2_1">&#167;4.2.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">nt</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">end</span><span class="plain-syntax">, </span><span class="identifier-syntax">PREFORM_LANGUAGE_TYPE</span><span class="plain-syntax"> *</span><span class="identifier-syntax">nl</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">nl</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">nl</span><span class="plain-syntax"> = </span><span class="identifier-syntax">English_language</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">match_avinue</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ave</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">production_list</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pl</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pl</span><span class="plain-syntax"> = </span><span class="identifier-syntax">nt</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">first_production_list</span><span class="plain-syntax">; </span><span class="identifier-syntax">pl</span><span class="plain-syntax">; </span><span class="identifier-syntax">pl</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pl</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_production_list</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pl</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">definition_language</span><span class="plain-syntax"> == </span><span class="identifier-syntax">nl</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pl</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">as_avinue</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">pl</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">as_avinue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="2-np.html#SP7_1" class="named-paragraph-link"><span class="named-paragraph">Construct a new avinue from this nonterminal</span><span class="named-paragraph-number">7.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pl</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">as_avinue</span><span class="plain-syntax"> = </span><span class="identifier-syntax">ave</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">ave</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP7_1"></a><b>&#167;7.1.  </b>The grammar for this nonterminal is either a "list grammar", meaning that it
lists other nonterminals which each define avinues, and we have to string those
together into one long avinue; or else it contains the actual content of a
single avinue.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Construct a new avinue from this nonterminal</span><span class="named-paragraph-number">7.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">list_grammar</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NOT_APPLICABLE</span><span class="plain-syntax">; </span><span class="comment-syntax"> i.e., we don't know yet</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">production</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pr</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pl</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">first_production</span><span class="plain-syntax">; </span><span class="identifier-syntax">pr</span><span class="plain-syntax">; </span><span class="identifier-syntax">pr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pr</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_production</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">ptoken</span><span class="plain-syntax"> *</span><span class="identifier-syntax">first</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pr</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">first_ptoken</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">first</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">ptoken</span><span class="plain-syntax"> *</span><span class="identifier-syntax">second</span><span class="plain-syntax"> = </span><span class="identifier-syntax">first</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_ptoken</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">second</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">second</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_ptoken</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Preform::log_production</span><span class="plain-syntax">(</span><span class="identifier-syntax">pr</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><a href="3-vc.html#SP12" class="function-link"><span class="function-syntax">Conjugation::trie_definition_error</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">nt</span><span class="plain-syntax">, </span><span class="identifier-syntax">pr</span><span class="plain-syntax">, </span><span class="string-syntax">"trie line with more than 2 words"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="2-np.html#SP7_1_1" class="named-paragraph-link"><span class="named-paragraph">Consider the one- or two-token production in this nonterminal</span><span class="named-paragraph-number">7.1.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="2-np.html#SP7">&#167;7</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP7_1_1"></a><b>&#167;7.1.1.  </b>Each production contains one or two tokens. There are four possibilities for
the production:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    (1)   ... &lt;some-nonterminal&gt;</span>
<span class="plain-syntax">    (2)   &lt;some-nonterminal&gt; ...</span>
<span class="plain-syntax">    (3)   &lt;some-nonterminal&gt;</span>
<span class="plain-syntax">    (4)   pattern-word instructions-word</span>
</pre>
<p class="commentary">Cases (1), (2) and (3) are allowed only in list grammars; case (4) is allowed
only in content grammars. The <span class="extract"><span class="extract-syntax">...</span></span> indicates whether the trie in the named
nonterminal will act on the start or end of a word &mdash; this is needed only to
override the normal convention.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Consider the one- or two-token production in this nonterminal</span><span class="named-paragraph-number">7.1.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">this_end</span><span class="plain-syntax"> = </span><span class="identifier-syntax">end</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">ptoken</span><span class="plain-syntax"> *</span><span class="identifier-syntax">entry</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">first</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">ptoken_category</span><span class="plain-syntax"> == </span><span class="identifier-syntax">MULTIPLE_WILDCARD_PTC</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">second</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">second</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">ptoken_category</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NONTERMINAL_PTC</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">entry</span><span class="plain-syntax"> = </span><span class="identifier-syntax">second</span><span class="plain-syntax">; </span><span class="identifier-syntax">this_end</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRIE_END</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">first</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">ptoken_category</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NONTERMINAL_PTC</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">second</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">second</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">ptoken_category</span><span class="plain-syntax"> == </span><span class="identifier-syntax">MULTIPLE_WILDCARD_PTC</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">entry</span><span class="plain-syntax"> = </span><span class="identifier-syntax">first</span><span class="plain-syntax">; </span><span class="identifier-syntax">this_end</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRIE_START</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">first</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">ptoken_category</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NONTERMINAL_PTC</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">second</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">entry</span><span class="plain-syntax"> = </span><span class="identifier-syntax">first</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">entry</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">list_grammar</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="2-np.html#SP7_1_1_1" class="named-paragraph-link"><span class="named-paragraph">Throw problem for a mixed trie nonterminal</span><span class="named-paragraph-number">7.1.1.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="2-np.html#SP7_1_1_2" class="named-paragraph-link"><span class="named-paragraph">Recurse to make an avinue from the nonterminal named here, and add it to our result</span><span class="named-paragraph-number">7.1.1.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">list_grammar</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">list_grammar</span><span class="plain-syntax"> == </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="2-np.html#SP7_1_1_1" class="named-paragraph-link"><span class="named-paragraph">Throw problem for a mixed trie nonterminal</span><span class="named-paragraph-number">7.1.1.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">second</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><a href="3-vc.html#SP12" class="function-link"><span class="function-syntax">Conjugation::trie_definition_error</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">nt</span><span class="plain-syntax">, </span><span class="identifier-syntax">pr</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="string-syntax">"there should be two words here, a pattern and an instruction"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="2-np.html#SP7_1_1_3" class="named-paragraph-link"><span class="named-paragraph">Add this pattern and instruction to the trie, creating it if we haven't already started one</span><span class="named-paragraph-number">7.1.1.3</span></a></span><span class="character-syntax">;</span>
<span class="character-syntax">        list_grammar = FALSE;</span>
<span class="character-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="2-np.html#SP7_1">&#167;7.1</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP7_1_1_1"></a><b>&#167;7.1.1.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Throw problem for a mixed trie nonterminal</span><span class="named-paragraph-number">7.1.1.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><a href="3-vc.html#SP12" class="function-link"><span class="function-syntax">Conjugation::trie_definition_error</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">nt</span><span class="plain-syntax">, </span><span class="identifier-syntax">pr</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"this should either be a list of other nonterminals, or a list of patterns "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"and instructions, but not a mixture"</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="2-np.html#SP7_1_1">&#167;7.1.1</a> (twice).</li></ul>
<p class="commentary firstcommentary"><a id="SP7_1_1_2"></a><b>&#167;7.1.1.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Recurse to make an avinue from the nonterminal named here, and add it to our result</span><span class="named-paragraph-number">7.1.1.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">match_avinue</span><span class="plain-syntax"> *</span><span class="identifier-syntax">next_mt</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Tries::duplicate_avinue</span><span class="plain-syntax">(</span><a href="2-np.html#SP7" class="function-link"><span class="function-syntax">Preform::Nonparsing::define_trie</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">entry</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">nt_pt</span><span class="plain-syntax">, </span><span class="identifier-syntax">this_end</span><span class="plain-syntax">, </span><span class="identifier-syntax">nl</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">ave</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">ave</span><span class="plain-syntax"> = </span><span class="identifier-syntax">next_mt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">match_avinue</span><span class="plain-syntax"> *</span><span class="identifier-syntax">m</span><span class="plain-syntax"> = </span><span class="identifier-syntax">ave</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">while</span><span class="plain-syntax"> (</span><span class="identifier-syntax">m</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">) </span><span class="identifier-syntax">m</span><span class="plain-syntax"> = </span><span class="identifier-syntax">m</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">m</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">next_mt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="2-np.html#SP7_1_1">&#167;7.1.1</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP7_1_1_3"></a><b>&#167;7.1.1.3.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Add this pattern and instruction to the trie, creating it if we haven't already started one</span><span class="named-paragraph-number">7.1.1.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">ave</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">ave</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Tries::new_avinue</span><span class="plain-syntax">(</span><span class="identifier-syntax">end</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">from</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">from</span><span class="plain-syntax">, </span><span class="string-syntax">"%V"</span><span class="plain-syntax">, </span><span class="identifier-syntax">first</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">ve_pt</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Tries::add_to_avinue</span><span class="plain-syntax">(</span><span class="identifier-syntax">ave</span><span class="plain-syntax">, </span><span class="identifier-syntax">from</span><span class="plain-syntax">, </span><span class="identifier-syntax">Vocabulary::get_exemplar</span><span class="plain-syntax">(</span><span class="identifier-syntax">second</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">ve_pt</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">from</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="2-np.html#SP7_1_1">&#167;7.1.1</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP8"></a><b>&#167;8.  </b>The following may be useful for debugging:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Preform::Nonparsing::log_avinues</span><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">nonterminal</span><span class="plain-syntax"> *</span><span class="identifier-syntax">nt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">nt</span><span class="plain-syntax">, </span><span class="identifier-syntax">nonterminal</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">production_list</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pl</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pl</span><span class="plain-syntax"> = </span><span class="identifier-syntax">nt</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">first_production_list</span><span class="plain-syntax">; </span><span class="identifier-syntax">pl</span><span class="plain-syntax">; </span><span class="identifier-syntax">pl</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pl</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_production_list</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pl</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">as_avinue</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"\n\n%V ($J)\n%a"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">nt</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">nonterminal_id</span><span class="plain-syntax">, </span><span class="identifier-syntax">pl</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">definition_language</span><span class="plain-syntax">, </span><span class="identifier-syntax">pl</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">as_avinue</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="2-ld.html">&#10094;</a></li><li class="progresschapter"><a href="1-im.html">1</a></li><li class="progresscurrentchapter">2</li><li class="progresssection"><a href="2-ld.html">ld</a></li><li class="progresscurrent">np</li><li class="progresssection"><a href="2-tai.html">tai</a></li><li class="progresssection"><a href="2-nc.html">nc</a></li><li class="progresschapter"><a href="3-ai.html">3</a></li><li class="progresschapter"><a href="4-ei.html">4</a></li><li class="progressnext"><a href="2-tai.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

