<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Compile Schemas</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
MathJax = {
	tex: {
		inlineMath: '$', '$'], ['\\(', '\\)'
	},
	svg: {
		fontCache: 'global'
	}
};
</script>
<script type="text/javascript" id="MathJax-script" async
	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../compiler.html">compiler tools</a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul><h2>Compiler Webs</h2><ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul><h2>Inbuild Modules</h2><ul>
<li><a href="../supervisor-module/index.html">supervisor</a></li>
</ul><h2>Inform7 Modules</h2><ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../assertions-module/index.html">assertions</a></li>
<li><a href="../values-module/index.html">values</a></li>
<li><a href="../knowledge-module/index.html">knowledge</a></li>
<li><a href="index.html"><span class="selectedlink">imperative</span></a></li>
<li><a href="../runtime-module/index.html">runtime</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul><h2>Inter Modules</h2><ul>
<li><a href="../bytecode-module/index.html">bytecode</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul><h2>Services</h2><ul>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../calculus-module/index.html">calculus</a></li>
<li><a href="../html-module/index.html">html</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Compile Schemas' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../compiler.html">Inform7</a></li><li><a href="index.html">imperative</a></li><li><a href="index.html#3">Chapter 3: Propositions</a></li><li><b>Compile Schemas</b></li></ul></div>
<p class="purpose">Here we compile fragments of code from paraphrases written in Inform 6 notation, and use that ability to compile general predicate calculus terms.</p>

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1.  </b>We provide the following functions as a sort of API for emitting schemas.
Recall that an <span class="extract"><span class="extract-syntax">i6_schema</span></span>, defined in <a href="../calculus-module/3-cs.html" class="internal">Compilation Schemas (in calculus)</a>,
is a basically textual prototype of a fragment of code.
</p>

<p class="commentary">These functions really differ only in how the parameters are to be specified;
typical schemas look like <span class="extract"><span class="extract-syntax">X(*1, true) == *2</span></span>, say, where some values go
in place of <span class="extract"><span class="extract-syntax">*1</span></span> and <span class="extract"><span class="extract-syntax">*2</span></span>. Those are the parameters, and they can be supplied
in several different ways.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CompileSchemas::from_terms_in_void_context</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">CompileSchemas::from_terms_in_void_context</span></span>:<br/>Compile Deferred Propositions - <a href="3-cdp.html#SP6">&#167;6</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sch</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pt1</span><span class="plain-syntax">, </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pt2</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><a href="3-cs.html#SP2" class="function-link"><span class="function-syntax">CompileSchemas::sch_emit_inner</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">sch</span><span class="plain-syntax">, </span><span class="identifier-syntax">pt1</span><span class="plain-syntax">, </span><span class="identifier-syntax">pt2</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CompileSchemas::from_terms_in_val_context</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">CompileSchemas::from_terms_in_val_context</span></span>:<br/><a href="3-cs.html#SP5_3">&#167;5.3</a><br/>Stack Frames - <a href="2-sf.html#SP21">&#167;21</a><br/>Compile Invocations Inline - <a href="4-cii.html#SP6_5_4">&#167;6.5.4</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sch</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pt1</span><span class="plain-syntax">, </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pt2</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><a href="3-cs.html#SP2" class="function-link"><span class="function-syntax">CompileSchemas::sch_emit_inner</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">sch</span><span class="plain-syntax">, </span><span class="identifier-syntax">pt1</span><span class="plain-syntax">, </span><span class="identifier-syntax">pt2</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CompileSchemas::from_local_variables_in_void_context</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">CompileSchemas::from_local_variables_in_void_context</span></span>:<br/>Compile Loops - <a href="3-cl.html#SP1_2">&#167;1.2</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sch</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">local_variable</span><span class="plain-syntax"> *</span><span class="identifier-syntax">v1</span><span class="plain-syntax">, </span><span class="reserved-syntax">local_variable</span><span class="plain-syntax"> *</span><span class="identifier-syntax">v2</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">pt1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Terms::new_constant</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Lvalues::new_LOCAL_VARIABLE</span><span class="plain-syntax">(</span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">, </span><span class="identifier-syntax">v1</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">pt2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Terms::new_constant</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Lvalues::new_LOCAL_VARIABLE</span><span class="plain-syntax">(</span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">, </span><span class="identifier-syntax">v2</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><a href="3-cs.html#SP1" class="function-link"><span class="function-syntax">CompileSchemas::from_terms_in_void_context</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">sch</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">pt1</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">pt2</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CompileSchemas::from_local_variables_in_val_context</span><span class="plain-syntax">(</span><span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sch</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">local_variable</span><span class="plain-syntax"> *</span><span class="identifier-syntax">v1</span><span class="plain-syntax">, </span><span class="reserved-syntax">local_variable</span><span class="plain-syntax"> *</span><span class="identifier-syntax">v2</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">pt1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Terms::new_constant</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Lvalues::new_LOCAL_VARIABLE</span><span class="plain-syntax">(</span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">, </span><span class="identifier-syntax">v1</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">pt2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Terms::new_constant</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Lvalues::new_LOCAL_VARIABLE</span><span class="plain-syntax">(</span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">, </span><span class="identifier-syntax">v2</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><a href="3-cs.html#SP1" class="function-link"><span class="function-syntax">CompileSchemas::from_terms_in_val_context</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">sch</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">pt1</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">pt2</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CompileSchemas::from_annotated_schema</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">CompileSchemas::from_annotated_schema</span></span>:<br/>Compile Atoms - <a href="3-ca.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">annotated_i6_schema</span><span class="plain-syntax"> *</span><span class="identifier-syntax">asch</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">asch</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">negate_schema</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">NOT_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><a href="3-cs.html#SP1" class="function-link"><span class="function-syntax">CompileSchemas::from_terms_in_void_context</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">asch</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">schema</span><span class="plain-syntax">, &amp;(</span><span class="identifier-syntax">asch</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">pt0</span><span class="plain-syntax">), &amp;(</span><span class="identifier-syntax">asch</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">pt1</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">asch</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">negate_schema</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2.  </b>And this is where the actual emission is done, though in fact the heavy
lifting is all done in <a href="../building-module/2-is.html" class="internal">Inter Schemas (in building)</a>. Essentially all we do is
to call <span class="extract"><span class="extract-syntax">EmitInterSchemas::emit</span></span>, with our compilation state &mdash; such as it is &mdash;
stored in an <span class="extract"><span class="extract-syntax">i6s_emission_state</span></span>. It then calls our nominated function on
each component part of the scheme, in its parsed and dismantled form.
</p>

<p class="commentary">In case we receive an untypechecked term (e.g., arising from a local variable
as above), we fill in its kind.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">i6s_emission_state</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ops_termwise</span><span class="plain-syntax">[2];</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">by_ref</span><span class="plain-syntax">;</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">i6s_emission_state</span><span class="plain-syntax">;</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CompileSchemas::sch_emit_inner</span><button class="popup" onclick="togglePopup('usagePopup5')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup5">Usage of <span class="code-font"><span class="function-syntax">CompileSchemas::sch_emit_inner</span></span>:<br/><a href="3-cs.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sch</span><span class="plain-syntax">, </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pt1</span><span class="plain-syntax">, </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pt2</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">void_context</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">i6s_emission_state</span><span class="plain-syntax"> </span><span class="identifier-syntax">ems</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">pt1</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">pt1</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">constant</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">pt1</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">term_checked_as_kind</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">pt1</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">term_checked_as_kind</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Specifications::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt1</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">constant</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">pt2</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">pt2</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">constant</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">pt2</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">term_checked_as_kind</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">pt2</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">term_checked_as_kind</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Specifications::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt2</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">constant</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">ems</span><span class="plain-syntax">.</span><span class="element-syntax">ops_termwise</span><span class="plain-syntax">[0] = </span><span class="identifier-syntax">pt1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">ems</span><span class="plain-syntax">.</span><span class="element-syntax">ops_termwise</span><span class="plain-syntax">[1] = </span><span class="identifier-syntax">pt2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">ems</span><span class="plain-syntax">.</span><span class="element-syntax">by_ref</span><span class="plain-syntax"> = </span><span class="identifier-syntax">sch</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">compiled</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">dereference_mode</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">value_holster</span><span class="plain-syntax"> </span><span class="identifier-syntax">VH</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Holsters::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">void_context</span><span class="plain-syntax">?</span><span class="identifier-syntax">INTER_VOID_VHMODE:INTER_VAL_VHMODE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">EmitInterSchemas::emit</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), &amp;</span><span class="identifier-syntax">VH</span><span class="plain-syntax">, </span><span class="identifier-syntax">sch</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">compiled</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">ems</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        &amp;</span><a href="3-cs.html#SP3" class="function-link"><span class="function-syntax">CompileSchemas::from_schema_token</span></a><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>The structure i6s_emission_state is private to this section.</li></ul>
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3.  </b>So, then, this is called on each token in turn from the original schema. Note
that we only receive two commands here, as compared with the profusion of
commands received by the analogous function <a href="4-cii.html#SP6" class="internal">CSIInline::from_schema_token</a> used
for inline definitions; this is because the range of notation in I6 schemas inside
the compiler is much smaller.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CompileSchemas::from_schema_token</span><button class="popup" onclick="togglePopup('usagePopup6')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup6">Usage of <span class="code-font"><span class="function-syntax">CompileSchemas::from_schema_token</span></span>:<br/><a href="3-cs.html#SP2">&#167;2</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">value_holster</span><span class="plain-syntax"> *</span><span class="identifier-syntax">VH</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inter_schema_token</span><span class="plain-syntax"> *</span><span class="identifier-syntax">t</span><span class="plain-syntax">, </span><span class="reserved-syntax">void</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ems_s</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">prim_cat</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">i6s_emission_state</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ems</span><span class="plain-syntax"> = (</span><span class="reserved-syntax">i6s_emission_state</span><span class="plain-syntax"> *) </span><span class="identifier-syntax">ems_s</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">m</span><span class="plain-syntax"> = </span><span class="identifier-syntax">t</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">inline_modifiers</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">by_reference</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">m</span><span class="plain-syntax"> &amp; </span><span class="identifier-syntax">BY_REFERENCE_ISSBM</span><span class="plain-syntax">)?</span><span class="identifier-syntax">TRUE:</span><span class="plain-syntax">(</span><span class="identifier-syntax">ems</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">by_ref</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">t</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">inline_command</span><span class="plain-syntax"> == </span><span class="identifier-syntax">substitute_ISINC</span><span class="plain-syntax">)   </span><span class="named-paragraph-container code-font"><a href="3-cs.html#SP3_1" class="named-paragraph-link"><span class="named-paragraph">Perform substitution</span><span class="named-paragraph-number">3.1</span></a></span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">t</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">inline_command</span><span class="plain-syntax"> == </span><span class="identifier-syntax">combine_ISINC</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="3-cs.html#SP3_2" class="named-paragraph-link"><span class="named-paragraph">Perform combine</span><span class="named-paragraph-number">3.2</span></a></span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"unimplemented command in schema"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP3_1" class="paragraph-anchor"></a><b>&#167;3.1.  </b>This deals with a <span class="extract"><span class="extract-syntax">*1</span></span> or <span class="extract"><span class="extract-syntax">*2</span></span> token, which are placeholders for the tokens:
we substitute in <span class="extract"><span class="extract-syntax">ems-&gt;ops_termwise[0]</span></span> or <span class="extract"><span class="extract-syntax">ems-&gt;ops_termwise[1]</span></span> respectively.
Here <span class="extract"><span class="extract-syntax">this</span></span> is the term in question, and <span class="extract"><span class="extract-syntax">other</span></span> the other of the two.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Perform substitution</span><span class="named-paragraph-number">3.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">N</span><span class="plain-syntax"> = </span><span class="identifier-syntax">t</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">constant_number</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">N</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">N</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">2</span><span class="plain-syntax">)) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"schemas are currently limited to *1 and *2"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">this</span><span class="plain-syntax"> = </span><span class="identifier-syntax">ems</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ops_termwise</span><span class="plain-syntax">[</span><span class="identifier-syntax">N</span><span class="plain-syntax">], *</span><span class="identifier-syntax">other</span><span class="plain-syntax"> = </span><span class="identifier-syntax">ems</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ops_termwise</span><span class="plain-syntax">[1-</span><span class="identifier-syntax">N</span><span class="plain-syntax">];</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">rule</span><span class="plain-syntax"> *</span><span class="identifier-syntax">R</span><span class="plain-syntax"> = </span><span class="identifier-syntax">adopted_rule_for_compilation</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">M</span><span class="plain-syntax"> = </span><span class="identifier-syntax">adopted_marker_for_compilation</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">m</span><span class="plain-syntax"> &amp; </span><span class="identifier-syntax">ADOPT_LOCAL_STACK_FRAME_ISSBM</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Rvalues::is_CONSTANT_of_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">other</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">constant</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_response</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">adopted_rule_for_compilation</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Rvalues::to_rule</span><span class="plain-syntax">(</span><span class="identifier-syntax">other</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">constant</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">adopted_marker_for_compilation</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Strings::get_marker_from_response_spec</span><span class="plain-syntax">(</span><span class="identifier-syntax">other</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">constant</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">m</span><span class="plain-syntax"> &amp; </span><span class="identifier-syntax">CAST_TO_KIND_OF_OTHER_TERM_ISSBM</span><span class="plain-syntax">) </span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">other</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">term_checked_as_kind</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><a href="3-cs.html#SP4" class="function-link"><span class="function-syntax">CompileSchemas::compile_term_of_token</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">this</span><span class="plain-syntax">, </span><span class="identifier-syntax">m</span><span class="plain-syntax">, </span><span class="identifier-syntax">K</span><span class="plain-syntax">, </span><span class="identifier-syntax">by_reference</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">adopted_rule_for_compilation</span><span class="plain-syntax"> = </span><span class="identifier-syntax">R</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">adopted_marker_for_compilation</span><span class="plain-syntax"> = </span><span class="identifier-syntax">M</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-cs.html#SP3">&#167;3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP3_2" class="paragraph-anchor"></a><b>&#167;3.2.  </b>This is for <span class="extract"><span class="extract-syntax">*&amp;</span></span>, which can only be used on the second term (i.e., term 1).
If that is a combination of two values then we unpack those and compile them
both, one after the other.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Perform combine</span><span class="named-paragraph-number">3.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">emit_without_combination</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pt0</span><span class="plain-syntax"> = </span><span class="identifier-syntax">ems</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ops_termwise</span><span class="plain-syntax">[0], *</span><span class="identifier-syntax">pt1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">ems</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ops_termwise</span><span class="plain-syntax">[1];</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">pt0</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">pt1</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">reln_K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pt0</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">term_checked_as_kind</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">comb_K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pt1</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">term_checked_as_kind</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Kinds::get_construct</span><span class="plain-syntax">(</span><span class="identifier-syntax">reln_K</span><span class="plain-syntax">) == </span><span class="identifier-syntax">CON_relation</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">Kinds::get_construct</span><span class="plain-syntax">(</span><span class="identifier-syntax">comb_K</span><span class="plain-syntax">) == </span><span class="identifier-syntax">CON_combination</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">req_A</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, *</span><span class="identifier-syntax">req_B</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::definite</span><span class="plain-syntax">(</span><span class="identifier-syntax">req_A</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="identifier-syntax">req_A</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::definite</span><span class="plain-syntax">(</span><span class="identifier-syntax">req_B</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="identifier-syntax">req_B</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Kinds::binary_construction_material</span><span class="plain-syntax">(</span><span class="identifier-syntax">reln_K</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">req_A</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">req_B</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec_A</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, *</span><span class="identifier-syntax">spec_B</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Rvalues::to_pair</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt1</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">constant</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">spec_A</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">spec_B</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">ems</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">by_ref</span><span class="plain-syntax">) </span><a href="3-cv.html#SP5" class="function-link"><span class="function-syntax">CompileValues::to_code_val_of_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec_A</span><span class="plain-syntax">, </span><span class="identifier-syntax">req_A</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">else</span><span class="plain-syntax">             </span><a href="3-cv.html#SP5" class="function-link"><span class="function-syntax">CompileValues::to_fresh_code_val_of_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec_A</span><span class="plain-syntax">, </span><span class="identifier-syntax">req_A</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">ems</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">by_ref</span><span class="plain-syntax">) </span><a href="3-cv.html#SP5" class="function-link"><span class="function-syntax">CompileValues::to_code_val_of_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec_B</span><span class="plain-syntax">, </span><span class="identifier-syntax">req_B</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">else</span><span class="plain-syntax">             </span><a href="3-cv.html#SP5" class="function-link"><span class="function-syntax">CompileValues::to_fresh_code_val_of_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec_B</span><span class="plain-syntax">, </span><span class="identifier-syntax">req_B</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">emit_without_combination</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">emit_without_combination</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><a href="3-cs.html#SP4" class="function-link"><span class="function-syntax">CompileSchemas::compile_term_of_token</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">pt1</span><span class="plain-syntax">, </span><span class="identifier-syntax">m</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">by_reference</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::val</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_number</span><span class="plain-syntax">, </span><span class="identifier-syntax">LITERAL_IVAL</span><span class="plain-syntax">, </span><span class="constant-syntax">0</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-cs.html#SP3">&#167;3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4.  </b>In either case (substitution or combination) we can end up down here. One
of four things can happen to the term arising from a token:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CompileSchemas::compile_term_of_token</span><button class="popup" onclick="togglePopup('usagePopup7')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup7">Usage of <span class="code-font"><span class="function-syntax">CompileSchemas::compile_term_of_token</span></span>:<br/><a href="3-cs.html#SP3_1">&#167;3.1</a>, <a href="3-cs.html#SP3_2">&#167;3.2</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pt</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">m</span><span class="plain-syntax">, </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cast_to</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">by_reference</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"no term"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">m</span><span class="plain-syntax"> &amp; </span><span class="identifier-syntax">GIVE_KIND_ID_ISSBM</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="3-cs.html#SP4_1" class="named-paragraph-link"><span class="named-paragraph">Compile weak ID of the kind of this term</span><span class="named-paragraph-number">4.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">m</span><span class="plain-syntax"> &amp; </span><span class="identifier-syntax">GIVE_COMPARISON_ROUTINE_ISSBM</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="3-cs.html#SP4_2" class="named-paragraph-link"><span class="named-paragraph">Compile comparison function for the kind</span><span class="named-paragraph-number">4.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="3-cs.html#SP4_3" class="named-paragraph-link"><span class="named-paragraph">Compile term as an lvalue or an rvalue</span><span class="named-paragraph-number">4.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4_1" class="paragraph-anchor"></a><b>&#167;4.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Compile weak ID of the kind of this term</span><span class="named-paragraph-number">4.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">RTKinds::emit_weak_id_as_val</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">term_checked_as_kind</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-cs.html#SP4">&#167;4</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP4_2" class="paragraph-anchor"></a><b>&#167;4.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Compile comparison function for the kind</span><span class="named-paragraph-number">4.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">inter_name</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cr</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">term_checked_as_kind</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">cr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Kinds::Behaviour::get_comparison_routine_as_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">term_checked_as_kind</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">cr</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Hierarchy::find</span><span class="plain-syntax">(</span><span class="identifier-syntax">SIGNEDCOMPARE_HL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Produce::val_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">cr</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-cs.html#SP4">&#167;4</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP4_3" class="paragraph-anchor"></a><b>&#167;4.3.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Compile term as an lvalue or an rvalue</span><span class="named-paragraph-number">4.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">storage_mode</span><span class="plain-syntax"> = </span><span class="identifier-syntax">COMPILE_LVALUE_NORMALLY</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">m</span><span class="plain-syntax"> &amp; </span><span class="identifier-syntax">LVALUE_CONTEXT_ISSBM</span><span class="plain-syntax">)      </span><span class="identifier-syntax">storage_mode</span><span class="plain-syntax"> = </span><span class="identifier-syntax">COMPILE_LVALUE_AS_LVALUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">m</span><span class="plain-syntax"> &amp; </span><span class="identifier-syntax">STORAGE_AS_FUNCTION_ISSBM</span><span class="plain-syntax">) </span><span class="identifier-syntax">storage_mode</span><span class="plain-syntax"> = </span><span class="identifier-syntax">COMPILE_LVALUE_AS_FUNCTION</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">cpt</span><span class="plain-syntax"> = *</span><span class="identifier-syntax">pt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">m</span><span class="plain-syntax"> &amp; </span><span class="identifier-syntax">DEREFERENCE_PROPERTY_ISSBM</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">cpt</span><span class="plain-syntax">.</span><span class="identifier-syntax">constant</span><span class="plain-syntax">, </span><span class="identifier-syntax">CONSTANT_NT</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Kinds::get_construct</span><span class="plain-syntax">(</span><span class="identifier-syntax">Specifications::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">cpt</span><span class="plain-syntax">.</span><span class="identifier-syntax">constant</span><span class="plain-syntax">)) == </span><span class="identifier-syntax">CON_property</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">cpt</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Terms::new_constant</span><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Lvalues::new_PROPERTY_VALUE</span><span class="plain-syntax">(</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">Node::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">cpt</span><span class="plain-syntax">.</span><span class="identifier-syntax">constant</span><span class="plain-syntax">), </span><span class="identifier-syntax">Rvalues::new_self_object_constant</span><span class="plain-syntax">()));</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">storage_mode</span><span class="plain-syntax"> != </span><span class="identifier-syntax">COMPILE_LVALUE_NORMALLY</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        ((</span><span class="identifier-syntax">cpt</span><span class="plain-syntax">.</span><span class="identifier-syntax">constant</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Lvalues::is_lvalue</span><span class="plain-syntax">(</span><span class="identifier-syntax">cpt</span><span class="plain-syntax">.</span><span class="identifier-syntax">constant</span><span class="plain-syntax">)))) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">value_holster</span><span class="plain-syntax"> </span><span class="identifier-syntax">VH</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Holsters::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">INTER_VAL_VHMODE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Lvalues::compile_in_mode</span><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">VH</span><span class="plain-syntax">, </span><span class="identifier-syntax">cpt</span><span class="plain-syntax">.</span><span class="identifier-syntax">constant</span><span class="plain-syntax">, </span><span class="identifier-syntax">storage_mode</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><a href="3-cs.html#SP5" class="function-link"><span class="function-syntax">CompileSchemas::compile_term</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">cpt</span><span class="plain-syntax">, </span><span class="identifier-syntax">cast_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">by_reference</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-cs.html#SP4">&#167;4</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5.  </b>We are now ready to compile a general predicate-calculus term, which is the
first milestone on our goal of compiling general propositions. The following
function is called from the above in the case when a term must be compiled
in an rvalue context, but also by <a href="3-cdp.html" class="internal">Compile Deferred Propositions</a>.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CompileSchemas::compile_term</span><button class="popup" onclick="togglePopup('usagePopup8')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup8">Usage of <span class="code-font"><span class="function-syntax">CompileSchemas::compile_term</span></span>:<br/><a href="3-cs.html#SP4_3">&#167;4.3</a><br/>Compile Deferred Propositions - <a href="3-cdp.html#SP3_6_1_2_5">&#167;3.6.1.2.5</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">pt</span><span class="plain-syntax">, </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">by_reference</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">variable</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="3-cs.html#SP5_1" class="named-paragraph-link"><span class="named-paragraph">Compile variable term</span><span class="named-paragraph-number">5.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">constant</span><span class="plain-syntax">)      </span><span class="named-paragraph-container code-font"><a href="3-cs.html#SP5_2" class="named-paragraph-link"><span class="named-paragraph">Compile constant term</span><span class="named-paragraph-number">5.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">function</span><span class="plain-syntax">)      </span><span class="named-paragraph-container code-font"><a href="3-cs.html#SP5_3" class="named-paragraph-link"><span class="named-paragraph">Compile function term</span><span class="named-paragraph-number">5.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"Broken pcalc term"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP5_1" class="paragraph-anchor"></a><b>&#167;5.1.  </b>Variables (in the predicate calculus sense) are compiled to Inter locals
with the same names &mdash; that is, they are called <span class="extract"><span class="extract-syntax">x</span></span>, <span class="extract"><span class="extract-syntax">y</span></span>, <span class="extract"><span class="extract-syntax">z</span></span>, ... and so on.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Compile variable term</span><span class="named-paragraph-number">5.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">local_variable</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lvar</span><span class="plain-syntax"> = </span><a href="2-lv.html#SP14" class="function-link"><span class="function-syntax">LocalVariables::find_pcalc_var</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">variable</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">lvar</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"var is %d\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">variable</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"no local exists which corresponds to calculus variable"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inter_symbol</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lvar_s</span><span class="plain-syntax"> = </span><a href="2-lv.html#SP1" class="function-link"><span class="function-syntax">LocalVariables::declare</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">lvar</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Produce::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">lvar_s</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-cs.html#SP5">&#167;5</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP5_2" class="paragraph-anchor"></a><b>&#167;5.2.  </b>Constants are compiled using <a href="3-cv.html" class="internal">Compile Values</a>, but note that we typecheck
any use of a phrase to decide a value here, because this might not otherwise
yet have been checked.
</p>

<p class="commentary">Cindered constants resulting from a deferral (see <a href="3-cad.html" class="internal">Cinders and Deferrals</a>)
become <span class="extract"><span class="extract-syntax">const_0</span></span>, <span class="extract"><span class="extract-syntax">const_1</span></span>, ... These will only be valid inside a deferred
function, but that is fine because they cannot arise anywhere else.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Compile constant term</span><span class="named-paragraph-number">5.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">cinder</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">local_variable</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lvar</span><span class="plain-syntax"> = </span><a href="3-cad.html#SP6" class="function-link"><span class="function-syntax">Cinders::find_cinder_var</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">cinder</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">lvar</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"absent calculus variable"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inter_symbol</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lvar_s</span><span class="plain-syntax"> = </span><a href="2-lv.html#SP1" class="function-link"><span class="function-syntax">LocalVariables::declare</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">lvar</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">lvar_s</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Specifications::is_phrasal</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">constant</span><span class="plain-syntax">)) </span><span class="identifier-syntax">Dash::check_value</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">constant</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">by_reference</span><span class="plain-syntax">) </span><a href="3-cv.html#SP5" class="function-link"><span class="function-syntax">CompileValues::to_code_val_of_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">constant</span><span class="plain-syntax">, </span><span class="identifier-syntax">K</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">else</span><span class="plain-syntax">              </span><a href="3-cv.html#SP5" class="function-link"><span class="function-syntax">CompileValues::to_fresh_code_val_of_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">constant</span><span class="plain-syntax">, </span><span class="identifier-syntax">K</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-cs.html#SP5">&#167;5</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP5_3" class="paragraph-anchor"></a><b>&#167;5.3.  </b>Functions \(f_R(t)\) are compiled by expanding a schema for \(f_R\) with \(t\)
as parameter.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Compile function term</span><span class="named-paragraph-number">5.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">function</span><span class="plain-syntax">)-&gt;</span><span class="identifier-syntax">bp</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> *</span><span class="identifier-syntax">fn</span><span class="plain-syntax"> = </span><span class="identifier-syntax">BinaryPredicates::get_term_as_fn_of_other</span><span class="plain-syntax">(</span><span class="identifier-syntax">bp</span><span class="plain-syntax">, </span><span class="constant-syntax">1</span><span class="plain-syntax">-</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">function</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">from_term</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">fn</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"function of non-functional predicate"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="3-cs.html#SP1" class="function-link"><span class="function-syntax">CompileSchemas::from_terms_in_val_context</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">fn</span><span class="plain-syntax">, &amp;(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">function</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">fn_of</span><span class="plain-syntax">), </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-cs.html#SP5">&#167;5</a>.</li></ul>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="3-cv.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-im.html">1</a></li><li class="progresschapter"><a href="2-sf.html">2</a></li><li class="progresscurrentchapter">3</li><li class="progresssection"><a href="3-cv.html">cv</a></li><li class="progresscurrent">cs</li><li class="progresssection"><a href="3-ca.html">ca</a></li><li class="progresssection"><a href="3-cp.html">cp</a></li><li class="progresssection"><a href="3-cl.html">cl</a></li><li class="progresssection"><a href="3-dtd.html">dtd</a></li><li class="progresssection"><a href="3-cad.html">cad</a></li><li class="progresssection"><a href="3-cdp.html">cdp</a></li><li class="progresschapter"><a href="4-cbal.html">4</a></li><li class="progressnext"><a href="3-ca.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

