<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>5/itg</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../compiler.html"><b>compiler</b></a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul>
<h2>Compiler Webs</h2>
<ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul>
<h2>Inbuild Modules</h2>
<ul>
<li><a href="../inbuild-module/index.html">inbuild</a></li>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../html-module/index.html">html</a></li>
</ul>
<h2>Inform7 Modules</h2>
<ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul>
<h2>Inter Modules</h2>
<ul>
<li><a href="../inter-module/index.html">inter</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of '5/tfg' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="../compiler.html">Compiler</a></li><li><a href="index.html">if</a></li><li><a href="index.html#5">Chapter 5: Command Grammar</a></li><li><b>Traverse for Grammar</b></li></ul><p class="purpose">To create and manipulate grammar, primarily by parsing and acting upon Understand... sentences in the source text.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP9">&#167;9. Dividing Understand into cases</a></li><li><a href="#SP16_2_1">&#167;16.2.1. Understand command verbs</a></li><li><a href="#SP19">&#167;19. Understand property names</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>We cache grammar occurring in the source text in conditions, and so forth:
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">cached_understanding</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">understanding_text</span><span class="plain">; </span>    <span class="comment">word range of the understanding text</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">cu_iname</span><span class="plain">; </span>    <span class="comment">the runtime name for this <code class="display"><span class="extract">Consult_Grammar_N</span></code> routine</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">cached_understanding</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure cached_understanding is private to this section.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>And this will help with parsing:
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">understanding_item</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">quoted_text</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">property</span><span class="plain"> *</span><span class="identifier">quoted_property</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">understanding_item</span><span class="plain"> *</span><span class="identifier">next</span><span class="plain">;</span>
    <span class="plain">} </span><span class="reserved">understanding_item</span><span class="plain">;</span>

    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">understanding_reference</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">reference_text</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">gv_result</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">mword</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">mistaken</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">pluralised_reference</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">reversed_reference</span><span class="plain">;</span>
        <span class="reserved">action_name</span><span class="plain"> *</span><span class="identifier">an_reference</span><span class="plain">;</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec_reference</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">understanding_reference</span><span class="plain"> *</span><span class="identifier">next</span><span class="plain">;</span>
    <span class="plain">} </span><span class="reserved">understanding_reference</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure understanding_item is accessed in 2/ri, 3/em, 3/scn, 3/tm2, 3/ts, 4/act, 4/anl, 4/ap, 4/nap, 5/gl and here.</p>

<p class="endnote">The structure understanding_reference is accessed in 2/ri, 3/em, 3/scn, 3/tm2, 3/ts, 4/act, 4/anl, 4/ap, 4/nap, 5/gl and here.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>New grammar arrives in the system in two ways: primarily by means of explicit
Understand sentences in the source text, but also secondarily in the form
of table entries or other values used to match against snippets. For example:
</p>

<blockquote>
    <p>Understand "drill [something]" as drilling.</p>

</blockquote>

<blockquote>
    <p>if the player's command matches "room [number]", ...</p>

</blockquote>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>Understand sentences can also revoke existing grammar, in some cases, as
we shall see. They are not read in the main assertion traverse, since they
depend on too much not known then: they have a traverse of their own, and
so do not use the sentence handler system adopted by the main assertion
traverse.
</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">base_problem_count</span><span class="plain"> = 0;</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::understand_as_SMF</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">NPs</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[1]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">O2W</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[2]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) { </span>    <span class="comment">"Understand... as..."</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ACCEPT_SMFT</span><span class="plain">:</span>
                <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">verb_id_ANNOT</span><span class="plain">, </span><span class="identifier">SPECIAL_MEANING_VB</span><span class="plain">);</span>
                <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt;(</span><span class="identifier">O2W</span><span class="plain">);</span>
                <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">);</span>
                <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">TRAVERSE_FOR_GRAMMAR_SMFT</span><span class="plain">:</span>
                <span class="identifier">base_problem_count</span><span class="plain"> = </span><span class="identifier">problem_count</span><span class="plain">;</span>
                <span class="functiontext">PL::Parsing::understand_sentence</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">), </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">));</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::understand_as_SMF appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::traverse</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">ParseTree::traverse</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="functiontext">PL::Parsing::visit</span><span class="plain">);</span>
    <span class="plain">}</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::visit</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">) == </span><span class="identifier">SENTENCE_NT</span><span class="plain">) &amp;&amp; (</span><span class="identifier">p</span><span class="plain">-&gt;</span><span class="identifier">down</span><span class="plain">))</span>
            <span class="identifier">Assertions::Traverse::try_special_meaning</span><span class="plain">(</span><span class="identifier">TRAVERSE_FOR_GRAMMAR_SMFT</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">-&gt;</span><span class="identifier">down</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::traverse appears nowhere else.</p>

<p class="endnote">The function PL::Parsing::visit appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>The secondary means of acquiring new grammar is used when compiling type
specifications of type <code class="display"><span class="extract">VALUE/UNDERSTANDING</span></code> and when compiling the entries
of "topic" columns in tables. These will usually be simple constructions of
individual grammar lines, but they need to belong to a grammar verb (GV)
nevertheless, even if they are the only thing on that GV. Such GVs compile
to routines for parsing snippets, and no pointers exist to them in other
NI data structures: the result of the routine below, assuming no problems
are issued, is simply that the name of a snippet-parsing routine is printed.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::compile_understanding</span><span class="plain">(</span><span class="identifier">inter_t</span><span class="plain"> *</span><span class="identifier">val1</span><span class="plain">, </span><span class="identifier">inter_t</span><span class="plain"> *</span><span class="identifier">val2</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">table_entry</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">nominative</span><span class="plain">-</span><span class="identifier">pronoun</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) { *</span><span class="identifier">val1</span><span class="plain"> = </span><span class="identifier">LITERAL_IVAL</span><span class="plain">; *</span><span class="identifier">val2</span><span class="plain"> = 0; }</span>
        <span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">cached_understanding</span><span class="plain"> *</span><span class="identifier">cu</span><span class="plain">;</span>
            <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">cu</span><span class="plain">, </span><span class="reserved">cached_understanding</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::match</span><span class="plain">(</span><span class="identifier">cu</span><span class="plain">-</span><span class="element">&gt;understanding_text</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)) {</span>
                    <span class="identifier">Emit::to_ival</span><span class="plain">(</span><span class="identifier">val1</span><span class="plain">, </span><span class="identifier">val2</span><span class="plain">, </span><span class="identifier">cu</span><span class="plain">-</span><span class="element">&gt;cu_iname</span><span class="plain">);</span>
                    <span class="reserved">return</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="identifier">base_problem_count</span><span class="plain"> = </span><span class="identifier">problem_count</span><span class="plain">;</span>
            <span class="functiontext">PL::Parsing::Tokens::General::prepare_consultation_gv</span><span class="plain">();</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">table_entry</span><span class="plain">) {</span>
                <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">k</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">) {</span>
                    <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">quoted</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">&gt;(</span><span class="identifier">Wordings::one_word</span><span class="plain">(</span><span class="identifier">k</span><span class="plain">))) {</span>
                        <span class="functiontext">PL::Parsing::understand_block</span><span class="plain">(</span><span class="identifier">Wordings::one_word</span><span class="plain">(</span><span class="identifier">k</span><span class="plain">), </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="functiontext">PL::Parsing::understand_block</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Tokens::General::print_consultation_gv_name</span><span class="plain">();</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">iname</span><span class="plain">) {</span>
                <span class="identifier">cu</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">cached_understanding</span><span class="plain">);</span>
                <span class="identifier">cu</span><span class="plain">-</span><span class="element">&gt;understanding_text</span><span class="plain"> = </span><span class="identifier">W</span><span class="plain">;</span>
                <span class="identifier">cu</span><span class="plain">-</span><span class="element">&gt;cu_iname</span><span class="plain"> = </span><span class="identifier">iname</span><span class="plain">;</span>
                <span class="identifier">Emit::to_ival</span><span class="plain">(</span><span class="identifier">val1</span><span class="plain">, </span><span class="identifier">val2</span><span class="plain">, </span><span class="identifier">iname</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::compile_understanding appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Dividing Understand into cases. </b>We will need some context variables.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">COMMAND_UNDERSTAND_FORM</span><span class="plain"> 1</span>
    <span class="definitionkeyword">define</span> <span class="constant">PROPERTY_UNDERSTAND_FORM</span><span class="plain"> 2</span>
    <span class="definitionkeyword">define</span> <span class="constant">GRAMMAR_UNDERSTAND_FORM</span><span class="plain"> 3</span>
    <span class="definitionkeyword">define</span> <span class="constant">NOTHING_UNDERSTAND_FORM</span><span class="plain"> 4</span>
    <span class="definitionkeyword">define</span> <span class="constant">NO_UNDERSTAND_FORM</span><span class="plain"> 5</span>
</pre>
<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>Understand sentences take three different forms &mdash; so different, in fact,
that we will parse the subject NP to see which form we have, and only then
parse the object NP (using a different grammar for each of the three forms).
As examples:
</p>

<blockquote>
    <p>Understand "photograph [something]" as photographing.</p>

</blockquote>

<blockquote>
    <p>Understand the command "access" as "open".</p>

</blockquote>

<blockquote>
    <p>Understand the unbroken property as describing the pot.</p>

</blockquote>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt; ::=</span>
        <span class="identifier">nothing</span><span class="plain"> |											==&gt; </span><span class="constant">NOTHING_UNDERSTAND_FORM</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span>
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; |						==&gt; </span><span class="constant">PROPERTY_UNDERSTAND_FORM</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="identifier">the</span><span class="plain"> </span><span class="identifier">command</span><span class="plain">/</span><span class="identifier">commands</span><span class="plain"> &lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">regular</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; |	==&gt; </span><span class="constant">COMMAND_UNDERSTAND_FORM</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="identifier">the</span><span class="plain"> </span><span class="identifier">verb</span><span class="plain">/</span><span class="identifier">verbs</span><span class="plain"> ... |								==&gt; </span>&lt;<span class="cwebmacro">Issue PM_OldVerbUsage problem</span> <span class="cwebmacronumber">10.1</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">regular</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt;							==&gt; </span><span class="constant">GRAMMAR_UNDERSTAND_FORM</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP10_1"></a><b>&#167;10.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_OldVerbUsage problem</span> <span class="cwebmacronumber">10.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">NO_UNDERSTAND_FORM</span><span class="plain">;</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_OldVerbUsage</span><span class="plain">),</span>
            <span class="string">"this is an outdated form of words"</span><span class="plain">,</span>
            <span class="string">"and Inform now prefers 'Understand the command ...' "</span>
            <span class="string">"rather than 'Understand the verb ...'. (Since this "</span>
            <span class="string">"change was made in beta-testing, quite a few old "</span>
            <span class="string">"source texts still use the old form: the authors "</span>
            <span class="string">"of Inform apologise for any nuisance incurred.)"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP10">&#167;10</a>.</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b>In the first two cases, a list of quoted text appears:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">regular</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; ::=</span>
        <span class="plain">... |														==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">preform_lookahead_mode</span><span class="plain">; </span>    <span class="comment">match only when looking ahead</span>
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">regular</span><span class="plain">-</span><span class="identifier">entry</span><span class="plain">&gt; &lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">regular</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; |	==&gt; </span>&lt;<span class="cwebmacro">Compose understand item list</span> <span class="cwebmacronumber">11.1</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">regular</span><span class="plain">-</span><span class="identifier">entry</span><span class="plain">&gt;									==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>

    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">regular</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; ::=</span>
        <span class="plain">, </span><span class="identifier">_and</span><span class="plain">/</span><span class="identifier">or</span><span class="plain"> &lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">regular</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; |						==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="identifier">_</span><span class="plain">,/</span><span class="identifier">and</span><span class="plain">/</span><span class="identifier">or</span><span class="plain"> &lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">regular</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt;							==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>

    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">regular</span><span class="plain">-</span><span class="identifier">entry</span><span class="plain">&gt; ::=</span>
        <span class="plain">...															==&gt; </span>&lt;<span class="cwebmacro">Make understand item</span> <span class="cwebmacronumber">11.2</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b>In the third case, the subject NP is a list of property names written in the
formal way (with "property").
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; ::=</span>
        <span class="plain">... |														==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">preform_lookahead_mode</span><span class="plain">; </span>    <span class="comment">match only when looking ahead</span>
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">entry</span><span class="plain">&gt; &lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; |	==&gt; </span>&lt;<span class="cwebmacro">Compose understand item list</span> <span class="cwebmacronumber">11.1</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">entry</span><span class="plain">&gt;									==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>

    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; ::=</span>
        <span class="plain">, </span><span class="identifier">_and</span><span class="plain">/</span><span class="identifier">or</span><span class="plain"> &lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; |						==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="identifier">_</span><span class="plain">,/</span><span class="identifier">and</span><span class="plain">/</span><span class="identifier">or</span><span class="plain"> &lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt;						==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>

    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">entry</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">property</span><span class="plain"> |									==&gt; </span>&lt;<span class="cwebmacro">Make understand property item</span> <span class="cwebmacronumber">12.2</span>&gt;
        <span class="plain">... </span><span class="identifier">property</span><span class="plain">												==&gt; </span>&lt;<span class="cwebmacro">Issue PM_UnknownUnderstandProperty problem</span> <span class="cwebmacronumber">12.1</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP12_1"></a><b>&#167;12.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_UnknownUnderstandProperty problem</span> <span class="cwebmacronumber">12.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (!</span><span class="identifier">preform_lookahead_mode</span><span class="plain">)</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnknownUnderstandProperty</span><span class="plain">),</span>
            <span class="string">"I don't understand what property that refers to"</span><span class="plain">,</span>
            <span class="string">"but it doesn't seem to be a property I know. An example of "</span>
            <span class="string">"correct usage is 'understand the transparent property as "</span>
            <span class="string">"describing a container.'"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP11_1"></a><b>&#167;11.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compose understand item list</span> <span class="cwebmacronumber">11.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">understanding_item</span><span class="plain"> *</span><span class="identifier">ui1</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="reserved">understanding_item</span><span class="plain"> *</span><span class="identifier">ui2</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2];</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ui1</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) { *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">ui2</span><span class="plain">; }</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ui2</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) { *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">ui1</span><span class="plain">; }</span>
        <span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">ui1</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">ui2</span><span class="plain">;</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">ui1</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11">&#167;11</a>, <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP11_2"></a><b>&#167;11.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make understand item</span> <span class="cwebmacronumber">11.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (!</span><span class="identifier">preform_lookahead_mode</span><span class="plain">) {</span>
            <span class="reserved">understanding_item</span><span class="plain"> *</span><span class="identifier">ui</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">understanding_item</span><span class="plain">);</span>
            <span class="identifier">ui</span><span class="plain">-</span><span class="element">&gt;quoted_text</span><span class="plain"> = </span><span class="identifier">W</span><span class="plain">;</span>
            <span class="identifier">ui</span><span class="plain">-</span><span class="element">&gt;quoted_property</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="identifier">ui</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">ui</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11">&#167;11</a>.</p>

<p class="inwebparagraph"><a id="SP12_2"></a><b>&#167;12.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make understand property item</span> <span class="cwebmacronumber">12.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (!</span><span class="identifier">preform_lookahead_mode</span><span class="plain">) {</span>
            <span class="reserved">understanding_item</span><span class="plain"> *</span><span class="identifier">ui</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">understanding_item</span><span class="plain">);</span>
            <span class="identifier">ui</span><span class="plain">-</span><span class="element">&gt;quoted_text</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
            <span class="identifier">ui</span><span class="plain">-</span><span class="element">&gt;quoted_property</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
            <span class="identifier">ui</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">ui</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b></p>


<pre class="display">
    <span class="reserved">understanding_reference</span><span class="plain"> </span><span class="identifier">ur_being_parsed</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14.  </b>Now we turn to the object phrase. As noted above, we use three different
grammars for this; one for each of the possible subject phrase forms. The
first is the most popularly used:
</p>

<blockquote>
    <p>Understand "take [something]" as taking.</p>

</blockquote>

<p class="inwebparagraph">It's not widely known, but the object phrase here can be a list.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">uncond</span><span class="plain">&gt; </span><span class="identifier">when</span><span class="plain">/</span><span class="reserved">while</span><span class="plain"> ... |	==&gt; 2; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">uncond</span><span class="plain">&gt;						==&gt; 1; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">uncond</span><span class="plain">&gt; ::=</span>
        <span class="plain">... |													==&gt; 0; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">preform_lookahead_mode</span><span class="plain">; </span>    <span class="comment">match only when looking ahead</span>
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">entry</span><span class="plain">&gt; &lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; |	==&gt; </span>&lt;<span class="cwebmacro">Compose understand reference list</span> <span class="cwebmacronumber">14.1</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">entry</span><span class="plain">&gt;								==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; ::=</span>
        <span class="plain">, </span><span class="identifier">_and</span><span class="plain">/</span><span class="identifier">or</span><span class="plain"> &lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">uncond</span><span class="plain">&gt; |			==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="identifier">_</span><span class="plain">,/</span><span class="identifier">and</span><span class="plain">/</span><span class="identifier">or</span><span class="plain"> &lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">uncond</span><span class="plain">&gt;			==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">entry</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">this</span><span class="plain">&gt;									==&gt; 0; </span><span class="reserved">if</span><span class="plain"> (!</span><span class="identifier">preform_lookahead_mode</span><span class="plain">) </span>&lt;<span class="cwebmacro">Deal with UT vars</span> <span class="cwebmacronumber">14.2</span>&gt;<span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP14_1"></a><b>&#167;14.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compose understand reference list</span> <span class="cwebmacronumber">14.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">understanding_reference</span><span class="plain"> *</span><span class="identifier">ui1</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="reserved">understanding_reference</span><span class="plain"> *</span><span class="identifier">ui2</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2];</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ui1</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) { *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">ui2</span><span class="plain">; }</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ui2</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) { *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">ui1</span><span class="plain">; }</span>
        <span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">ui1</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">ui2</span><span class="plain">;</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">ui1</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP14">&#167;14</a>.</p>

<p class="inwebparagraph"><a id="SP14_2"></a><b>&#167;14.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Deal with UT vars</span> <span class="cwebmacronumber">14.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">R</span><span class="plain">[1] == -1) {</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">understanding_reference</span><span class="plain"> *</span><span class="identifier">ur</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">understanding_reference</span><span class="plain">);</span>
            <span class="plain">*</span><span class="identifier">ur</span><span class="plain"> = </span><span class="identifier">ur_being_parsed</span><span class="plain">;</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">ur</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP14">&#167;14</a>.</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b>Each of the items in the object phrase list is matched against:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">this</span><span class="plain">&gt; ::=</span>
        <span class="plain">... |										==&gt; 0; </span>&lt;<span class="cwebmacro">Clear UT vars</span> <span class="cwebmacronumber">15.1</span>&gt;<span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">preform_lookahead_mode</span><span class="plain">; </span>    <span class="comment">match only when looking ahead</span>
        <span class="identifier">a</span><span class="plain"> </span><span class="identifier">mistake</span><span class="plain"> |									==&gt; 0; </span><span class="identifier">ur_being_parsed</span><span class="element">.gv_result</span><span class="plain"> = </span><span class="constant">GV_IS_COMMAND</span><span class="plain">; </span><span class="identifier">ur_being_parsed</span><span class="element">.mistaken</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">a</span><span class="plain"> </span><span class="identifier">mistake</span><span class="plain"> ( &lt;</span><span class="identifier">quoted</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">&gt; ) |				==&gt; 0; </span><span class="identifier">ur_being_parsed</span><span class="element">.gv_result</span><span class="plain"> = </span><span class="constant">GV_IS_COMMAND</span><span class="plain">; </span><span class="identifier">ur_being_parsed</span><span class="element">.mistaken</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="identifier">ur_being_parsed</span><span class="element">.mword</span><span class="plain"> = </span><span class="identifier">R</span><span class="plain">[1]</span>
        <span class="identifier">a</span><span class="plain"> </span><span class="identifier">mistake</span><span class="plain"> ... |								==&gt; </span>&lt;<span class="cwebmacro">Issue PM_TextlessMistake problem</span> <span class="cwebmacronumber">15.2</span>&gt;
        <span class="identifier">the</span><span class="plain"> </span><span class="identifier">plural</span><span class="plain"> </span><span class="identifier">of</span><span class="plain"> &lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">ref</span><span class="plain">&gt; |			==&gt; </span><span class="identifier">R</span><span class="plain">[1]; </span><span class="identifier">ur_being_parsed</span><span class="element">.pluralised_reference</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">plural</span><span class="plain"> </span><span class="identifier">of</span><span class="plain"> &lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">ref</span><span class="plain">&gt; |				==&gt; </span><span class="identifier">R</span><span class="plain">[1]; </span><span class="identifier">ur_being_parsed</span><span class="element">.pluralised_reference</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">&lt;</span><span class="identifier">quoted</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">&gt; |								==&gt; 0; </span><span class="identifier">ur_being_parsed</span><span class="element">.gv_result</span><span class="plain"> = </span><span class="constant">GV_IS_TOKEN</span><span class="plain">;</span>
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">ref</span><span class="plain">&gt; ( </span><span class="identifier">with</span><span class="plain"> </span><span class="identifier">nouns</span><span class="plain"> </span><span class="identifier">reversed</span><span class="plain"> ) |	==&gt; </span><span class="identifier">R</span><span class="plain">[1]; </span><span class="identifier">ur_being_parsed</span><span class="element">.reversed_reference</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">ref</span><span class="plain">&gt;							==&gt; </span><span class="identifier">R</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">ref</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">action</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |								==&gt; 0; </span><span class="identifier">ur_being_parsed</span><span class="element">.an_reference</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">descriptive</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">&gt; |		==&gt; 0; </span><span class="identifier">ur_being_parsed</span><span class="element">.spec_reference</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt; |								==&gt; </span>&lt;<span class="cwebmacro">Issue PM_UnderstandVariable problem</span> <span class="cwebmacronumber">15.3</span>&gt;
        <span class="plain">...											==&gt; </span>&lt;<span class="cwebmacro">Issue PM_UnderstandVague problem</span> <span class="cwebmacronumber">15.4</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP15_1"></a><b>&#167;15.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Clear UT vars</span> <span class="cwebmacronumber">15.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">ur_being_parsed</span><span class="element">.reference_text</span><span class="plain"> = </span><span class="identifier">W</span><span class="plain">;</span>
        <span class="identifier">ur_being_parsed</span><span class="element">.mword</span><span class="plain"> = -1;</span>
        <span class="identifier">ur_being_parsed</span><span class="element">.mistaken</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">ur_being_parsed</span><span class="element">.pluralised_reference</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">ur_being_parsed</span><span class="element">.reversed_reference</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">ur_being_parsed</span><span class="element">.an_reference</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">ur_being_parsed</span><span class="element">.spec_reference</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">ur_being_parsed</span><span class="element">.next</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">ur_being_parsed</span><span class="element">.gv_result</span><span class="plain"> = </span><span class="constant">GV_IS_OBJECT</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP15">&#167;15</a>.</p>

<p class="inwebparagraph"><a id="SP15_2"></a><b>&#167;15.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_TextlessMistake problem</span> <span class="cwebmacronumber">15.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = -1;</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_TextlessMistake</span><span class="plain">),</span>
            <span class="string">"when 'understand' results in a mistake it can only be "</span>
            <span class="string">"followed by a textual message in brackets"</span><span class="plain">,</span>
            <span class="string">"so for instance 'understand \</span><span class="plain">"</span><span class="string">take\</span><span class="plain">"</span><span class="string"> as a mistake "</span>
            <span class="string">"(\</span><span class="plain">"</span><span class="string">In this sort of game, a noun is required there.\</span><span class="plain">"</span><span class="string">).'"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP15">&#167;15</a>.</p>

<p class="inwebparagraph"><a id="SP15_3"></a><b>&#167;15.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_UnderstandVariable problem</span> <span class="cwebmacronumber">15.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = -1;</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Offending pseudo-meaning is: %W\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnderstandVariable</span><span class="plain">),</span>
            <span class="string">"this meaning is a value that varies"</span><span class="plain">,</span>
            <span class="string">"whereas I need something fixed. "</span>
            <span class="string">"(The most common case of this is saying that something should be "</span>
            <span class="string">"understood as 'the player', which is actually a variable, because "</span>
            <span class="string">"the perspective of play can change. Writing 'yourself' instead will "</span>
            <span class="string">"usually do.)"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP15">&#167;15</a>.</p>

<p class="inwebparagraph"><a id="SP15_4"></a><b>&#167;15.4.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_UnderstandVague problem</span> <span class="cwebmacronumber">15.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = -1;</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Offending pseudo-meaning is: %W\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">Actually issue PM_UnderstandVague problem</span> <span class="cwebmacronumber">15.4.1</span>&gt;<span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP15">&#167;15</a>.</p>

<p class="inwebparagraph"><a id="SP15_4_1"></a><b>&#167;15.4.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Actually issue PM_UnderstandVague problem</span> <span class="cwebmacronumber">15.4.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnderstandVague</span><span class="plain">),</span>
            <span class="string">"'understand ... as ...' should be followed "</span>
            <span class="string">"by a meaning"</span><span class="plain">,</span>
            <span class="string">"which might be an action (e.g., "</span>
            <span class="string">"'understand \</span><span class="plain">"</span><span class="string">take [something]\</span><span class="plain">"</span><span class="string"> as taking'), a "</span>
            <span class="string">"thing ('understand \</span><span class="plain">"</span><span class="string">stove\</span><span class="plain">"</span><span class="string"> as the oven') or more "</span>
            <span class="string">"generally a value ('understand \</span><span class="plain">"</span><span class="string">huitante\</span><span class="plain">"</span><span class="string"> as 80'), "</span>
            <span class="string">"or a named token for use in further grammar "</span>
            <span class="string">"('understand \</span><span class="plain">"</span><span class="string">near [something]\</span><span class="plain">"</span><span class="string"> as \</span><span class="plain">"</span><span class="string">[location "</span>
            <span class="string">"phrase]\</span><span class="plain">"</span><span class="string">'). Also, the meaning needs to be precise, "</span>
            <span class="string">"so 'understand \</span><span class="plain">"</span><span class="string">x\</span><span class="plain">"</span><span class="string"> as a number' is not "</span>
            <span class="string">"allowed - it does not say which number."</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP15_4">&#167;15.4</a>, <a href="#SP21">&#167;21</a>.</p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16.  </b>The second form of the sentence has an object phrase like so:
</p>

<blockquote>
    <p>Understand the command "snatch" as "take".</p>

</blockquote>

<p class="inwebparagraph">Here the grammar is very simple, and the object can't be a list.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">command</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt; ::=</span>
        <span class="plain">...</span><span class="element"> when</span><span class="plain">/</span><span class="reserved">while</span><span class="plain"> ... |			==&gt; </span>&lt;<span class="cwebmacro">Issue PM_UnderstandCommandWhen problem</span> <span class="cwebmacronumber">16.1</span>&gt;
        <span class="identifier">something</span><span class="plain"> </span><span class="identifier">new</span><span class="plain"> |					==&gt; 0</span>
        <span class="plain">&lt;</span><span class="identifier">quoted</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">&gt; |					==&gt; </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)</span>
        <span class="plain">...								==&gt; </span>&lt;<span class="cwebmacro">Issue PM_NotOldCommand problem</span> <span class="cwebmacronumber">16.2</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP16_1"></a><b>&#167;16.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_UnderstandCommandWhen problem</span> <span class="cwebmacronumber">16.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = -1;</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnderstandCommandWhen</span><span class="plain">),</span>
            <span class="string">"'understand the command ... as ...' is not allowed to have a "</span>
            <span class="string">"'... when ...' clause"</span><span class="plain">,</span>
            <span class="string">"for the moment at any rate."</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP16">&#167;16</a>.</p>

<p class="inwebparagraph"><a id="SP16_2"></a><b>&#167;16.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_NotOldCommand problem</span> <span class="cwebmacronumber">16.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = -1;</span>
        &lt;<span class="cwebmacro">Actually issue PM_NotOldCommand problem</span> <span class="cwebmacronumber">16.2.2</span>&gt;<span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP16">&#167;16</a>.</p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17.  </b>The third and final form of the sentence has an object phrase like so:
</p>

<blockquote>
    <p>Understand the unbroken property as describing the pot.</p>

</blockquote>

<p class="inwebparagraph">Once again, the object can't be a list. Syntactically the item(s) referred
to or described can be of any kind, but in fact we restrict to kinds of object.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">unconditional</span><span class="plain">&gt; </span><span class="identifier">when</span><span class="plain">/</span><span class="reserved">while</span><span class="plain"> ... |	==&gt; 2; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]; &lt;&lt;</span><span class="identifier">level</span><span class="plain">&gt;&gt; = </span><span class="identifier">R</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">unconditional</span><span class="plain">&gt;						==&gt; 1; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]; &lt;&lt;</span><span class="identifier">level</span><span class="plain">&gt;&gt; = </span><span class="identifier">R</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">unconditional</span><span class="plain">&gt; ::=</span>
        <span class="identifier">referring</span><span class="plain"> </span><span class="identifier">to</span><span class="plain"> &lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">reference</span><span class="plain">&gt; |	==&gt; 1; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="identifier">describing</span><span class="plain"> &lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">reference</span><span class="plain">&gt; |	==&gt; 2; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">...												==&gt; </span>&lt;<span class="cwebmacro">Issue PM_BadUnderstandProperty problem</span> <span class="cwebmacronumber">17.2</span>&gt;

    <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">reference</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">&gt; |				==&gt; </span>&lt;<span class="cwebmacro">Make reference from kind, if a kind of object</span> <span class="cwebmacronumber">17.1</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">instance</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt; |	==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">Instances::as_subject</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1]);</span>
        <span class="plain">...						==&gt; </span>&lt;<span class="cwebmacro">Issue PM_BadUnderstandPropertyAs problem</span> <span class="cwebmacronumber">17.3</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP17_1"></a><b>&#167;17.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make reference from kind, if a kind of object</span> <span class="cwebmacronumber">17.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::lt</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)) *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP17">&#167;17</a>.</p>

<p class="inwebparagraph"><a id="SP17_2"></a><b>&#167;17.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_BadUnderstandProperty problem</span> <span class="cwebmacronumber">17.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = 0;</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BadUnderstandProperty</span><span class="plain">),</span>
            <span class="string">"'understand the ... property as ...' is only allowed if "</span>
            <span class="string">"followed by 'describing ...' or 'referring to ...'"</span><span class="plain">,</span>
            <span class="string">"so for instance 'understand the transparent property as "</span>
            <span class="string">"describing a container.'"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP17">&#167;17</a>.</p>

<p class="inwebparagraph"><a id="SP17_3"></a><b>&#167;17.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_BadUnderstandPropertyAs problem</span> <span class="cwebmacronumber">17.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BadUnderstandPropertyAs</span><span class="plain">),</span>
            <span class="string">"I don't understand what single thing or kind of thing that refers to"</span><span class="plain">,</span>
            <span class="string">"but it does need to be an object (or kind of object) and not "</span>
            <span class="string">"some other sort of value. For instance, 'understand the transparent "</span>
            <span class="string">"property as describing a container.' is okay because 'a container' "</span>
            <span class="string">"is a kind of object."</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP17">&#167;17</a>.</p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::understand_sentence</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">ASW</span><span class="plain">) {</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR</span><span class="plain">, </span><span class="string">"Parsing understand &lt;%W&gt; as &lt;%W&gt;\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">ASW</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> &gt; </span><span class="identifier">base_problem_count</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> &gt; </span><span class="identifier">base_problem_count</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">understanding_item</span><span class="plain"> *</span><span class="identifier">ui_list</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">form</span><span class="plain"> = &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">form</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">COMMAND_UNDERSTAND_FORM</span><span class="plain">: </span>&lt;<span class="cwebmacro">Process Understand command</span> <span class="cwebmacronumber">18.1</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">PROPERTY_UNDERSTAND_FORM</span><span class="plain">: </span>&lt;<span class="cwebmacro">Process Understand property</span> <span class="cwebmacronumber">18.2</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GRAMMAR_UNDERSTAND_FORM</span><span class="plain">: </span>    <span class="comment">and</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOTHING_UNDERSTAND_FORM</span><span class="plain">: </span>&lt;<span class="cwebmacro">Process Understand grammar</span> <span class="cwebmacronumber">18.3</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::understand_sentence is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP18_1"></a><b>&#167;18.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Process Understand command</span> <span class="cwebmacronumber">18.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">command</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;(</span><span class="identifier">ASW</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> &gt; </span><span class="identifier">base_problem_count</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt; != 0) ? (</span><span class="identifier">Wordings::one_word</span><span class="plain">(&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;)) : </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (; </span><span class="identifier">ui_list</span><span class="plain">; </span><span class="identifier">ui_list</span><span class="plain"> = </span><span class="identifier">ui_list</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> &gt; </span><span class="identifier">base_problem_count</span><span class="plain">) </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="functiontext">PL::Parsing::understand_the_command</span><span class="plain">(</span><span class="identifier">ui_list</span><span class="plain">-</span><span class="element">&gt;quoted_text</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18">&#167;18</a>.</p>

<p class="inwebparagraph"><a id="SP18_2"></a><b>&#167;18.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Process Understand property</span> <span class="cwebmacronumber">18.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;(</span><span class="identifier">ASW</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> &gt; </span><span class="identifier">base_problem_count</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">UW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
        <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt; == 2) </span><span class="identifier">UW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">property</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;, 1);</span>
        <span class="reserved">for</span><span class="plain"> (; </span><span class="identifier">ui_list</span><span class="plain">; </span><span class="identifier">ui_list</span><span class="plain"> = </span><span class="identifier">ui_list</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> &gt; </span><span class="identifier">base_problem_count</span><span class="plain">) </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="functiontext">PL::Parsing::understand_property_block</span><span class="plain">(</span><span class="identifier">ui_list</span><span class="plain">-</span><span class="element">&gt;quoted_property</span><span class="plain">, &lt;&lt;</span><span class="identifier">level</span><span class="plain">&gt;&gt;, </span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">UW</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18">&#167;18</a>.</p>

<p class="inwebparagraph"><a id="SP18_3"></a><b>&#167;18.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Process Understand grammar</span> <span class="cwebmacronumber">18.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;(</span><span class="identifier">ASW</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> &gt; </span><span class="identifier">base_problem_count</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">understanding_reference</span><span class="plain"> *</span><span class="identifier">ur_list_from</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">UW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt; == 2) </span><span class="identifier">UW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">understand</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;, 1);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">form</span><span class="plain"> == </span><span class="constant">NOTHING_UNDERSTAND_FORM</span><span class="plain">) {</span>
            <span class="reserved">understanding_reference</span><span class="plain"> *</span><span class="identifier">ur_list</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">ur_list</span><span class="plain"> = </span><span class="identifier">ur_list_from</span><span class="plain">; </span><span class="identifier">ur_list</span><span class="plain">; </span><span class="identifier">ur_list</span><span class="plain"> = </span><span class="identifier">ur_list</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> &gt; </span><span class="identifier">base_problem_count</span><span class="plain">) </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="functiontext">PL::Parsing::understand_nothing</span><span class="plain">(</span><span class="identifier">ur_list</span><span class="plain">, </span><span class="identifier">UW</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">for</span><span class="plain"> (; </span><span class="identifier">ui_list</span><span class="plain">; </span><span class="identifier">ui_list</span><span class="plain"> = </span><span class="identifier">ui_list</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">) {</span>
                <span class="reserved">understanding_reference</span><span class="plain"> *</span><span class="identifier">ur_list</span><span class="plain">;</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">ur_list</span><span class="plain"> = </span><span class="identifier">ur_list_from</span><span class="plain">; </span><span class="identifier">ur_list</span><span class="plain">; </span><span class="identifier">ur_list</span><span class="plain"> = </span><span class="identifier">ur_list</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">) {</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> &gt; </span><span class="identifier">base_problem_count</span><span class="plain">) </span><span class="reserved">break</span><span class="plain">;</span>
                    <span class="functiontext">PL::Parsing::understand_block</span><span class="plain">(</span><span class="identifier">ui_list</span><span class="plain">-</span><span class="element">&gt;quoted_text</span><span class="plain">, </span><span class="identifier">ur_list</span><span class="plain">, </span><span class="identifier">UW</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18">&#167;18</a>.</p>

<p class="inwebparagraph"><a id="SP16_2_1"></a><b>&#167;16.2.1. Understand command verbs. </b>These sentences allow us to control the assignment of command verbs such
as TAKE or EXAMINE to grammars, which will normally be an automatic process
based on grammar lines (see below). We can make one command verb an alias
for another, or revoke this by making it "something new".
</p>

<p class="inwebparagraph">After some debate, we decided that it ought to be legal to declare
"Understand the command "wibble" as something new" even in cases
where no "wibble" command existed already: extensions might want this
to assure that they have exclusive use of a command, for instance. So the
problem message for this case is now commented out.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::understand_the_command</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">ASW</span><span class="plain">) {</span>
        <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Wordings::last_word</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">Word::dequote</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
        <span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">p</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]; </span><span class="identifier">i</span><span class="plain">++)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] == </span><span class="character">' '</span><span class="plain">) {</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_SpacyCommand</span><span class="plain">),</span>
                    <span class="string">"'understand the command ... as ...' is only allowed when "</span>
                    <span class="string">"the old command is a single word"</span><span class="plain">,</span>
                    <span class="string">"so for instance 'understand the command \</span><span class="plain">"</span><span class="string">capture\</span><span class="plain">"</span><span class="string"> as \</span><span class="plain">"</span><span class="string">get\</span><span class="plain">"</span><span class="string">' "</span>
                    <span class="string">"is okay, but 'understand the command \</span><span class="plain">"</span><span class="string">capture the flag\</span><span class="plain">"</span><span class="string"> as "</span>
                    <span class="string">"\</span><span class="plain">"</span><span class="string">get\</span><span class="plain">"</span><span class="string">' is not."</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::find_command</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">ASW</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">) </span><span class="functiontext">PL::Parsing::Verbs::remove_command</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">)	{</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">PL::Parsing::Verbs::is_empty</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">)) {</span>
                    <span class="identifier">DESTROY</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain">);</span>
                    <span class="identifier">gv</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_NotNewCommand</span><span class="plain">),</span>
                        <span class="string">"'understand the command ... as ...' is only allowed when "</span>
                        <span class="string">"the new command has no meaning already"</span><span class="plain">,</span>
                        <span class="string">"so for instance 'understand \</span><span class="plain">"</span><span class="string">drop\</span><span class="plain">"</span><span class="string"> as \</span><span class="plain">"</span><span class="string">throw\</span><span class="plain">"</span><span class="string">' is not "</span>
                        <span class="string">"allowed because \</span><span class="plain">"</span><span class="string">drop\</span><span class="plain">"</span><span class="string"> already has a meaning."</span><span class="plain">);</span>
                    <span class="reserved">return</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="identifier">Word::dequote</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ASW</span><span class="plain">));</span>
            <span class="identifier">gv</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::find_command</span><span class="plain">(</span><span class="identifier">ASW</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
                &lt;<span class="cwebmacro">Actually issue PM_NotOldCommand problem</span> <span class="cwebmacronumber">16.2.2</span>&gt;<span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="functiontext">PL::Parsing::Verbs::add_command</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::understand_the_command is used in <a href="#SP18_1">&#167;18.1</a>.</p>

<p class="inwebparagraph"><a id="SP16_2_2"></a><b>&#167;16.2.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Actually issue PM_NotOldCommand problem</span> <span class="cwebmacronumber">16.2.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_NotOldCommand</span><span class="plain">),</span>
            <span class="string">"'understand the command ... as ...' should end with a command "</span>
            <span class="string">"already defined"</span><span class="plain">,</span>
            <span class="string">"as in 'understand the command \</span><span class="plain">"</span><span class="string">steal\</span><span class="plain">"</span><span class="string"> as \</span><span class="plain">"</span><span class="string">take\</span><span class="plain">"</span><span class="string">'. (This "</span>
            <span class="string">"problem is sometimes seen when the wrong sort of Understand... "</span>
            <span class="string">"sentence has been used: 'Understand the command \</span><span class="plain">"</span><span class="string">steal\</span><span class="plain">"</span><span class="string"> as "</span>
            <span class="string">"\</span><span class="plain">"</span><span class="string">take\</span><span class="plain">"</span><span class="string">.' tells me to treat the command STEAL as a "</span>
            <span class="string">"synonym for TAKE when reading the player's commands, whereas "</span>
            <span class="string">"'Understand \</span><span class="plain">"</span><span class="string">steal [something]\</span><span class="plain">"</span><span class="string"> as taking.' tells me that "</span>
            <span class="string">"here is a specific grammar for what can be said using the "</span>
            <span class="string">"STEAL command.)"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP16_2">&#167;16.2</a>, <a href="#SP16_2_1">&#167;16.2.1</a>.</p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19. Understand property names. </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::understand_property_block</span><span class="plain">(</span><span class="identifier">property</span><span class="plain"> *</span><span class="identifier">pr</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">level</span><span class="plain">, </span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">WHENW</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Properties::is_either_or</span><span class="plain">(</span><span class="identifier">pr</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">Str::len</span><span class="plain">(</span><span class="identifier">Kinds::Behaviour::get_recognition_only_GPR</span><span class="plain">(</span><span class="identifier">Properties::Valued::kind</span><span class="plain">(</span><span class="identifier">pr</span><span class="plain">))) == 0) &amp;&amp;</span>
            <span class="plain">((</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">Properties::Valued::kind</span><span class="plain">(</span><span class="identifier">pr</span><span class="plain">), </span><span class="identifier">K_object</span><span class="plain">)) ||</span>
                <span class="plain">(</span><span class="identifier">Kinds::Behaviour::request_I6_GPR</span><span class="plain">(</span><span class="identifier">Properties::Valued::kind</span><span class="plain">(</span><span class="identifier">pr</span><span class="plain">)) == </span><span class="identifier">FALSE</span><span class="plain">))) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BadReferringProperty</span><span class="plain">),</span>
                <span class="string">"that property is of a kind which I can't recognise in "</span>
                <span class="string">"typed commands"</span><span class="plain">,</span>
                <span class="string">"so that it cannot be understand as describing or referring to "</span>
                <span class="string">"something. I can understand either/or properties, properties "</span>
                <span class="string">"with a limited list of named possible values, numbers, times "</span>
                <span class="string">"of day, or units; but certain built-into-Inform kinds of value "</span>
                <span class="string">"(like snippet or rulebook, for instance) I can't use."</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">PL::Parsing::Visibility::seek</span><span class="plain">(</span><span class="identifier">pr</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">level</span><span class="plain">, </span><span class="identifier">WHENW</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnknownUnpermittedProperty</span><span class="plain">),</span>
                <span class="string">"that property is not allowed for the thing or kind in question"</span><span class="plain">,</span>
                <span class="string">"just as (ordinarily) 'understand the open property as describing a "</span>
                <span class="string">"device' would not be allowed because it makes no sense to call a "</span>
                <span class="string">"device 'open'."</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::understand_property_block is used in <a href="#SP18_2">&#167;18.2</a>.</p>

<p class="inwebparagraph"><a id="SP20"></a><b>&#167;20.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::understand_nothing</span><span class="plain">(</span><span class="reserved">understanding_reference</span><span class="plain"> *</span><span class="identifier">ur</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">WHENW</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">ur</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">ur</span><span class="plain">-</span><span class="element">&gt;gv_result</span><span class="plain"> != </span><span class="constant">GV_IS_OBJECT</span><span class="plain">) || (</span><span class="identifier">ur</span><span class="plain">-</span><span class="element">&gt;an_reference</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnderstandNothingNonAction</span><span class="plain">),</span>
                <span class="string">"'Understand nothing as ...' must be followed by an action"</span><span class="plain">,</span>
                <span class="string">"such as 'Understand nothing as taking.'"</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">WHENW</span><span class="plain">)) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnderstandNothingWhen</span><span class="plain">),</span>
                <span class="string">"'Understand nothing as ...' must be unconditional"</span><span class="plain">,</span>
                <span class="string">"so your 'when' or 'while' condition will have to go."</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">action_name</span><span class="plain"> *</span><span class="identifier">an</span><span class="plain"> = </span><span class="identifier">ur</span><span class="plain">-</span><span class="element">&gt;an_reference</span><span class="plain">;</span>
            <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR_CONSTRUCTION</span><span class="plain">, </span><span class="string">"Understand nothing as: $l\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">an</span><span class="plain">);</span>
            <span class="functiontext">PL::Actions::remove_gl</span><span class="plain">(</span><span class="identifier">an</span><span class="plain">);</span>
            <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">;</span>
            <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain">) </span><span class="functiontext">PL::Parsing::Verbs::remove_action</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="identifier">an</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::understand_nothing is used in <a href="#SP18_3">&#167;18.3</a>.</p>

<p class="inwebparagraph"><a id="SP21"></a><b>&#167;21.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::understand_block</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">understanding_reference</span><span class="plain"> *</span><span class="identifier">ur</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">WHENW</span><span class="plain">,</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">table_entry</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">gv_is</span><span class="plain"> = </span><span class="constant">GV_IS_COMMAND</span><span class="plain">,</span>
            <span class="identifier">reversed</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">mistake_text_at</span><span class="plain"> = 0, </span><span class="identifier">mistakenly</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">pluralised</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">file_under</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">action_name</span><span class="plain"> *</span><span class="identifier">an</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">grammar_line</span><span class="plain"> *</span><span class="identifier">gl</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">to_pn</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">gv_prn</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">gl_value</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">pcalc_prop</span><span class="plain"> *</span><span class="identifier">u_prop</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> &gt; </span><span class="identifier">base_problem_count</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">quoted</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">table_entry</span><span class="plain">)</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">),</span>
                    <span class="string">"a table entry in a 'topic' column must be a single double-quoted "</span>
                    <span class="string">"text"</span><span class="plain">,</span>
                    <span class="string">"such as \</span><span class="plain">"</span><span class="string">eternity\</span><span class="plain">"</span><span class="string"> or \</span><span class="plain">"</span><span class="string">peruvian skies\</span><span class="plain">"</span><span class="string">."</span><span class="plain">);</span>
            <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">TEST_COMPILATION_MODE</span><span class="plain">(</span><span class="identifier">SPECIFICATIONS_CMODE</span><span class="plain">))</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_NontextualUnderstandInAP</span><span class="plain">),</span>
                    <span class="string">"the topic here should be in the form of a textual description"</span><span class="plain">,</span>
                    <span class="string">"as in 'asking about \</span><span class="plain">"</span><span class="string">[something]\</span><span class="plain">"</span><span class="string">'."</span><span class="plain">);</span>
            <span class="reserved">else</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_NontextualUnderstand</span><span class="plain">),</span>
                    <span class="string">"'understand' should be followed by a textual description"</span><span class="plain">,</span>
                    <span class="string">"as in 'understand \</span><span class="plain">"</span><span class="string">take [something]\</span><span class="plain">"</span><span class="string"> as taking the noun'."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Word::well_formed_text_routine</span><span class="plain">(</span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnderstandMismatch</span><span class="plain">),</span>
                <span class="string">"'understand' should be followed by text in which brackets "</span>
                <span class="string">"'[' and ']' match"</span><span class="plain">,</span>
                <span class="string">"so for instance 'understand \</span><span class="plain">"</span><span class="string">take [something]\</span><span class="plain">"</span><span class="string"> as taking the noun' "</span>
                <span class="string">"is fine, but 'understand \</span><span class="plain">"</span><span class="string">take]\</span><span class="plain">"</span><span class="string"> as taking' is not."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">mistake_text_at</span><span class="plain"> = 0;</span>
        <span class="identifier">mistakenly</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ur</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">gv_is</span><span class="plain"> = </span><span class="constant">GV_IS_CONSULT</span><span class="plain">;</span>
        <span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">an</span><span class="plain"> = </span><span class="identifier">ur</span><span class="plain">-</span><span class="element">&gt;an_reference</span><span class="plain">;</span>
            <span class="identifier">pluralised</span><span class="plain"> = </span><span class="identifier">ur</span><span class="plain">-</span><span class="element">&gt;pluralised_reference</span><span class="plain">;</span>
            <span class="identifier">reversed</span><span class="plain"> = </span><span class="identifier">ur</span><span class="plain">-</span><span class="element">&gt;reversed_reference</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ur</span><span class="plain">-</span><span class="element">&gt;mword</span><span class="plain"> &gt;= 0) </span><span class="identifier">mistake_text_at</span><span class="plain"> = </span><span class="identifier">ur</span><span class="plain">-</span><span class="element">&gt;mword</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ur</span><span class="plain">-</span><span class="element">&gt;mistaken</span><span class="plain">) </span><span class="identifier">mistakenly</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="identifier">gv_is</span><span class="plain"> = </span><span class="identifier">ur</span><span class="plain">-</span><span class="element">&gt;gv_result</span><span class="plain">;</span>

            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_OBJECT</span><span class="plain">) {</span>
                <span class="identifier">gv_is</span><span class="plain"> = </span><span class="constant">GV_IS_COMMAND</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">an</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
                    <span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">target</span><span class="plain">;</span>
                    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">ur</span><span class="plain">-</span><span class="element">&gt;spec_reference</span><span class="plain">;</span>
                    <span class="identifier">target</span><span class="plain"> = </span><span class="identifier">Specifications::object_exactly_described_if_any</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">target</span><span class="plain">) {</span>
                        <span class="identifier">subj</span><span class="plain"> = </span><span class="identifier">Instances::as_subject</span><span class="plain">(</span><span class="identifier">target</span><span class="plain">);</span>
                        <span class="identifier">gv_is</span><span class="plain"> = </span><span class="constant">GV_IS_OBJECT</span><span class="plain">;</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Descriptions::is_qualified</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) {</span>
                            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Offending description: $T"</span><span class="plain">, </span><span class="identifier">spec</span><span class="plain">);</span>
                            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnderstandAsQualified</span><span class="plain">),</span>
                                <span class="string">"I cannot understand text as meaning an object "</span>
                                <span class="string">"qualified by relative clauses or properties"</span><span class="plain">,</span>
                                <span class="string">"only a specific thing, a specific value or a kind. "</span>
                                <span class="string">"(But the same effect can usually be achieved with "</span>
                                <span class="string">"a 'when' clause. For instance, although 'Understand "</span>
                                <span class="string">"\</span><span class="plain">"</span><span class="string">bad luck\</span><span class="plain">"</span><span class="string"> as the broken mirror' is not allowed, "</span>
                                <span class="string">"'Understand \</span><span class="plain">"</span><span class="string">bad luck\</span><span class="plain">"</span><span class="string"> as the mirror when the "</span>
                                <span class="string">"mirror is broken' produces the desired effect.)"</span><span class="plain">);</span>
                            <span class="reserved">return</span><span class="plain">;</span>
                        <span class="plain">}</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                        <span class="identifier">RetryValue</span><span class="plain">:</span>
                        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR_CONSTRUCTION</span><span class="plain">, </span><span class="string">"Understand as specification: $T"</span><span class="plain">, </span><span class="identifier">spec</span><span class="plain">);</span>
                        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Specifications::is_kind_like</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) &amp;&amp;</span>
                            <span class="plain">(</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">Specifications::to_kind</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">), </span><span class="identifier">K_object</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)) </span><span class="reserved">goto</span><span class="plain"> </span><span class="identifier">ImpreciseProblemMessage</span><span class="plain">;</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTreeUsage::is_phrasal</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) </span><span class="reserved">goto</span><span class="plain"> </span><span class="identifier">ImpreciseProblemMessage</span><span class="plain">;</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Rvalues::is_nothing_object_constant</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) </span><span class="reserved">goto</span><span class="plain"> </span><span class="identifier">ImpreciseProblemMessage</span><span class="plain">;</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTreeUsage::is_rvalue</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) {</span>
                            <span class="identifier">K</span><span class="plain"> = </span><span class="identifier">ParseTree::get_kind_of_value</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
                            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Behaviour::request_I6_GPR</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">)) {</span>
                                <span class="identifier">gl_value</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">;</span>
                                <span class="identifier">gv_is</span><span class="plain"> = </span><span class="constant">GV_IS_VALUE</span><span class="plain">;</span>
                            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::get_construct</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">) == </span><span class="identifier">CON_activity</span><span class="plain">)</span>
                                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnderstandAsActivity</span><span class="plain">),</span>
                                    <span class="string">"this 'understand ... as ...' gives text "</span>
                                    <span class="string">"meaning an activity"</span><span class="plain">,</span>
                                    <span class="string">"rather than an action. Since activities "</span>
                                    <span class="string">"happen when Inform decides they need to "</span>
                                    <span class="string">"happen, not in response to typed commands, "</span>
                                    <span class="string">"this doesn't make sense."</span><span class="plain">);</span>
                                <span class="reserved">else</span>
                                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnderstandAsBadValue</span><span class="plain">),</span>
                                    <span class="string">"'understand ... as ...' gives text "</span>
                                    <span class="string">"meaning a value whose kind is not allowed"</span><span class="plain">,</span>
                                    <span class="string">"and should be a value such as 100."</span><span class="plain">);</span>
                                <span class="reserved">return</span><span class="plain">;</span>
                            <span class="plain">}</span>
                        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) {</span>
                            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Descriptions::to_instance</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">) == </span><span class="identifier">NULL</span><span class="plain">) &amp;&amp;</span>
                                <span class="plain">(</span><span class="identifier">Kinds::Compare::lt</span><span class="plain">(</span><span class="identifier">Specifications::to_kind</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">),</span>
                                    <span class="identifier">K_object</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)</span>
                                <span class="plain">&amp;&amp; (</span><span class="identifier">Descriptions::number_of_adjectives_applied_to</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">) == 1)</span>
                                <span class="plain">&amp;&amp; (</span><span class="identifier">AdjectiveUsages::get_parity</span><span class="plain">(</span><span class="identifier">Calculus::Propositions::first_adjective_usage</span><span class="plain">(</span><span class="identifier">Specifications::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">), </span><span class="identifier">NULL</span><span class="plain">)))) {</span>
                                <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain"> =</span>
                                    <span class="identifier">AdjectiveUsages::get_aph</span><span class="plain">(</span><span class="identifier">Calculus::Propositions::first_adjective_usage</span><span class="plain">(</span><span class="identifier">Specifications::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">), </span><span class="identifier">NULL</span><span class="plain">));</span>
                                <span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">q</span><span class="plain"> = </span><span class="identifier">Adjectives::Meanings::has_ENUMERATIVE_meaning</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">);</span>
                                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">q</span><span class="plain">) {</span>
                                    <span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">Rvalues::from_instance</span><span class="plain">(</span><span class="identifier">q</span><span class="plain">);</span>
                                    <span class="reserved">goto</span><span class="plain"> </span><span class="identifier">RetryValue</span><span class="plain">;</span>
                                <span class="plain">}</span>
                                <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain"> = </span><span class="identifier">Adjectives::Meanings::has_EORP_meaning</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
                                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prn</span><span class="plain">) {</span>
                                    <span class="identifier">gv_is</span><span class="plain"> = </span><span class="constant">GV_IS_PROPERTY_NAME</span><span class="plain">;</span>
                                    <span class="identifier">gv_prn</span><span class="plain"> = </span><span class="identifier">prn</span><span class="plain">;</span>
                                    <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR_CONSTRUCTION</span><span class="plain">, </span><span class="string">"Grammar confirmed for property $Y\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">gv_prn</span><span class="plain">);</span>
                                <span class="plain">}</span>
                            <span class="plain">}</span>
                            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Descriptions::is_qualified</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">gv_prn</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)) {</span>
                                <span class="identifier">u_prop</span><span class="plain"> = </span><span class="identifier">Calculus::Propositions::copy</span><span class="plain">(</span><span class="identifier">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
                                <span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">Specifications::to_kind</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
                            <span class="plain">}</span>
                            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">Specifications::to_kind</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
                            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">K</span><span class="plain">) &amp;&amp; (</span><span class="identifier">Kinds::Compare::lt</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">))) {</span>
                                <span class="identifier">subj</span><span class="plain"> = </span><span class="identifier">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
                                <span class="identifier">gv_is</span><span class="plain"> = </span><span class="constant">GV_IS_OBJECT</span><span class="plain">;</span>
                            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv_prn</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">goto</span><span class="plain"> </span><span class="identifier">ImpreciseProblemMessage</span><span class="plain">;</span>
                        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                            <span class="identifier">ImpreciseProblemMessage</span><span class="plain">:</span>
                            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Offending pseudo-meaning is: $T"</span><span class="plain">, </span><span class="identifier">spec</span><span class="plain">);</span>
                            &lt;<span class="cwebmacro">Actually issue PM_UnderstandVague problem</span> <span class="cwebmacronumber">15.4.1</span>&gt;<span class="plain">;</span>
                            <span class="reserved">return</span><span class="plain">;</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>

        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">pluralised</span><span class="plain">) &amp;&amp; (</span><span class="identifier">gv_is</span><span class="plain"> != </span><span class="constant">GV_IS_OBJECT</span><span class="plain">)) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnderstandPluralValue</span><span class="plain">),</span>
                <span class="string">"'understand' as a plural can only apply to things, rooms or kinds "</span>
                <span class="string">"of things or rooms"</span><span class="plain">,</span>
                <span class="string">"so 'Understand \</span><span class="plain">"</span><span class="string">paperwork\</span><span class="plain">"</span><span class="string"> as the plural of a document.' is "</span>
                <span class="string">"fine (assuming a document is a kind of thing), but 'Understand "</span>
                <span class="string">"\</span><span class="plain">"</span><span class="string">dozens\</span><span class="plain">"</span><span class="string"> as the plural of 12' is not."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">skip</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">literal_punct</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">; </span><span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">p</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]; </span><span class="identifier">i</span><span class="plain">++) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] == </span><span class="character">'['</span><span class="plain">) </span><span class="identifier">skip</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] == </span><span class="character">']'</span><span class="plain">) </span><span class="identifier">skip</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">skip</span><span class="plain">) </span><span class="reserved">continue</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">p</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] == </span><span class="character">'.'</span><span class="plain">) || (</span><span class="identifier">p</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] == </span><span class="character">','</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">p</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] == </span><span class="character">'!'</span><span class="plain">) || (</span><span class="identifier">p</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] == </span><span class="character">'?'</span><span class="plain">) || (</span><span class="identifier">p</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] == </span><span class="character">':'</span><span class="plain">) || (</span><span class="identifier">p</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] == </span><span class="character">';'</span><span class="plain">))</span>
                <span class="identifier">literal_punct</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">literal_punct</span><span class="plain">) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LiteralPunctuation</span><span class="plain">),</span>
                <span class="string">"'understand' text cannot contain literal punctuation"</span><span class="plain">,</span>
                <span class="string">"or more specifically cannot contain any of these: . , ! ? : ; "</span>
                <span class="string">"since they are already used in various ways by the parser, and "</span>
                <span class="string">"would not correctly match here."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>

        <span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">Feeds::feed_text_full</span><span class="plain">(</span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)), </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="constant">GRAMMAR_PUNCTUATION_MARKS</span><span class="plain">);</span>
        <span class="identifier">to_pn</span><span class="plain"> = </span><span class="identifier">NounPhrases::new_raw</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Tokens::break_into_tokens</span><span class="plain">(</span><span class="identifier">to_pn</span><span class="plain">, </span><span class="identifier">XW</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">to_pn</span><span class="plain">-&gt;</span><span class="identifier">down</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnderstandEmptyText</span><span class="plain">),</span>
                <span class="string">"'understand' should be followed by text which contains at least "</span>
                <span class="string">"one word or square-bracketed token"</span><span class="plain">,</span>
                <span class="string">"so for instance 'understand \</span><span class="plain">"</span><span class="string">take [something]\</span><span class="plain">"</span><span class="string"> as taking' "</span>
                <span class="string">"is fine, but 'understand \</span><span class="plain">"</span><span class="string">\</span><span class="plain">"</span><span class="string"> as the fog' is not. The same "</span>
                <span class="string">"applies to the contents of 'topic' columns in tables, since "</span>
                <span class="string">"those are also instructions for understanding."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_COMMAND</span><span class="plain">) {</span>
            <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR_CONSTRUCTION</span><span class="plain">, </span><span class="string">"Command grammar: $T\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">to_pn</span><span class="plain">);</span>

            <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">XW</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain"> &lt; </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">))</span>
                    <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">compare_word</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">COMMA_V</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">compare_word</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">+1, </span><span class="identifier">COMMA_V</span><span class="plain">))) {</span>
                        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnderstandCommaCommand</span><span class="plain">),</span>
                            <span class="string">"'understand' as an action cannot involve a comma"</span><span class="plain">,</span>
                            <span class="string">"since a command leading to an action never does. "</span>
                            <span class="string">"(Although Inform understands commands like 'PETE, LOOK' "</span>
                            <span class="string">"only the part after the comma is read as an action command: "</span>
                            <span class="string">"the part before the comma is read as the name of someone, "</span>
                            <span class="string">"according to the usual rules for parsing a name.) "</span>
                            <span class="string">"Because of the way Inform processes text with square "</span>
                            <span class="string">"brackets, this problem message is also sometimes seen "</span>
                            <span class="string">"if empty square brackets are used, as in 'Understand "</span>
                            <span class="string">"\</span><span class="plain">"</span><span class="string">bless []\</span><span class="plain">"</span><span class="string"> as blessing.'"</span><span class="plain">);</span>
                        <span class="reserved">return</span><span class="plain">;</span>
                    <span class="plain">}</span>

            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">PL::Parsing::Tokens::is_literal</span><span class="plain">(</span><span class="identifier">to_pn</span><span class="plain">-&gt;</span><span class="identifier">down</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)</span>
                <span class="identifier">file_under</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">; </span>    <span class="comment">this will go into the no verb verb</span>
            <span class="reserved">else</span><span class="plain"> </span><span class="identifier">file_under</span><span class="plain"> = </span><span class="identifier">Wordings::first_word</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">to_pn</span><span class="plain">-&gt;</span><span class="identifier">down</span><span class="plain">));</span>
        <span class="plain">}</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR</span><span class="plain">, </span><span class="string">"GV is %d, an is $l, file under is %W\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">gv_is</span><span class="plain">, </span><span class="identifier">an</span><span class="plain">, </span><span class="identifier">file_under</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv_is</span><span class="plain"> != </span><span class="constant">GV_IS_COMMAND</span><span class="plain">) </span><span class="identifier">gl</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Lines::new</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">), </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">to_pn</span><span class="plain">, </span><span class="identifier">reversed</span><span class="plain">, </span><span class="identifier">pluralised</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">gl</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Lines::new</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">), </span><span class="identifier">an</span><span class="plain">, </span><span class="identifier">to_pn</span><span class="plain">, </span><span class="identifier">reversed</span><span class="plain">, </span><span class="identifier">pluralised</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">mistakenly</span><span class="plain">) </span><span class="functiontext">PL::Parsing::Lines::set_mistake</span><span class="plain">(</span><span class="identifier">gl</span><span class="plain">, </span><span class="identifier">mistake_text_at</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">WHENW</span><span class="plain">)) {</span>
            <span class="functiontext">PL::Parsing::Lines::set_understand_when</span><span class="plain">(</span><span class="identifier">gl</span><span class="plain">, </span><span class="identifier">WHENW</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_CONSULT</span><span class="plain">) {</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">), </span>    <span class="comment">at present, I7 syntax prevents this anyway</span>
                    <span class="string">"'when' cannot be used with this kind of 'Understand'"</span><span class="plain">,</span>
                    <span class="string">"for the time being at least."</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">WHENW</span><span class="plain">)) {</span>
            <span class="functiontext">PL::Parsing::Lines::set_understand_when</span><span class="plain">(</span><span class="identifier">gl</span><span class="plain">, </span><span class="identifier">WHENW</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_CONSULT</span><span class="plain">) {</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">), </span>    <span class="comment">at present, I7 syntax prevents this anyway</span>
                    <span class="string">"'when' cannot be used with this kind of 'Understand'"</span><span class="plain">,</span>
                    <span class="string">"for the time being at least."</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">u_prop</span><span class="plain">) {</span>
            <span class="functiontext">PL::Parsing::Lines::set_understand_prop</span><span class="plain">(</span><span class="identifier">gl</span><span class="plain">, </span><span class="identifier">u_prop</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_CONSULT</span><span class="plain">) {</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">), </span>    <span class="comment">at present, I7 syntax prevents this anyway</span>
                    <span class="string">"'when' cannot be used with this kind of 'Understand'"</span><span class="plain">,</span>
                    <span class="string">"for the time being at least."</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>

        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">gv_is</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_TOKEN</span><span class="plain">:</span>
                <span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">Feeds::feed_text_full</span><span class="plain">(</span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ur</span><span class="plain">-</span><span class="element">&gt;reference_text</span><span class="plain">)), </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="constant">GRAMMAR_PUNCTUATION_MARKS</span><span class="plain">);</span>
                <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR_CONSTRUCTION</span><span class="plain">, </span><span class="string">"GV_IS_TOKEN as words: %W\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">XW</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">PL::Parsing::valid_new_token_name</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                    <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnderstandAsCompoundText</span><span class="plain">),</span>
                        <span class="string">"if 'understand ... as ...' gives the meaning as text "</span>
                        <span class="string">"then it must describe a single new token"</span><span class="plain">,</span>
                        <span class="string">"so that 'Understand \</span><span class="plain">"</span><span class="string">group four/five/six\</span><span class="plain">"</span><span class="string"> as "</span>
                        <span class="string">"\</span><span class="plain">"</span><span class="string">[department]\</span><span class="plain">"</span><span class="string">' is legal (defining a new token "</span>
                        <span class="string">"\</span><span class="plain">"</span><span class="string">[department]\</span><span class="plain">"</span><span class="string">, or adding to its definition if it "</span>
                        <span class="string">"already existed) but 'Understand \</span><span class="plain">"</span><span class="string">take [thing]\</span><span class="plain">"</span><span class="string"> "</span>
                        <span class="string">"as \</span><span class="plain">"</span><span class="string">drop [thing]\</span><span class="plain">"</span><span class="string">' is not allowed, and would not "</span>
                        <span class="string">"make sense, because \</span><span class="plain">"</span><span class="string">drop [thing]\</span><span class="plain">"</span><span class="string"> is a combination "</span>
                        <span class="string">"of two existing tokens - not a single new one."</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="functiontext">PL::Parsing::Verbs::add_line</span><span class="plain">(</span><span class="functiontext">PL::Parsing::Verbs::named_token_new</span><span class="plain">(</span><span class="identifier">Wordings::trim_both_ends</span><span class="plain">(</span><span class="identifier">Wordings::trim_both_ends</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">))), </span><span class="identifier">gl</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_COMMAND</span><span class="plain">:</span>
                <span class="functiontext">PL::Parsing::Verbs::add_line</span><span class="plain">(</span><span class="functiontext">PL::Parsing::Verbs::find_or_create_command</span><span class="plain">(</span><span class="identifier">file_under</span><span class="plain">), </span><span class="identifier">gl</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_OBJECT</span><span class="plain">:</span>
                <span class="functiontext">PL::Parsing::Verbs::add_line</span><span class="plain">(</span><span class="functiontext">PL::Parsing::Verbs::for_subject</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">), </span><span class="identifier">gl</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_VALUE</span><span class="plain">:</span>
                <span class="functiontext">PL::Parsing::Lines::set_single_type</span><span class="plain">(</span><span class="identifier">gl</span><span class="plain">, </span><span class="identifier">gl_value</span><span class="plain">);</span>
                <span class="functiontext">PL::Parsing::Verbs::add_line</span><span class="plain">(</span><span class="functiontext">PL::Parsing::Verbs::for_kind</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">), </span><span class="identifier">gl</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_PROPERTY_NAME</span><span class="plain">:</span>
                <span class="functiontext">PL::Parsing::Verbs::add_line</span><span class="plain">(</span><span class="functiontext">PL::Parsing::Verbs::for_prn</span><span class="plain">(</span><span class="identifier">gv_prn</span><span class="plain">), </span><span class="identifier">gl</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_CONSULT</span><span class="plain">:</span>
                <span class="functiontext">PL::Parsing::Lines::set_single_type</span><span class="plain">(</span><span class="identifier">gl</span><span class="plain">, </span><span class="identifier">gl_value</span><span class="plain">);</span>
                <span class="functiontext">PL::Parsing::Verbs::add_line</span><span class="plain">(</span>
                    <span class="functiontext">PL::Parsing::Tokens::General::get_consultation_gv</span><span class="plain">(), </span><span class="identifier">gl</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::valid_new_token_name</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">cc</span><span class="plain">=0;</span>
        <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">compare_word</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">COMMA_V</span><span class="plain">)) </span><span class="identifier">cc</span><span class="plain">++;</span>
        <span class="identifier">Word::dequote</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (*(</span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))) != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">Word::dequote</span><span class="plain">(</span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (*(</span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))) != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">cc</span><span class="plain"> != 2) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::understand_block is used in <a href="#SP8">&#167;8</a>, <a href="#SP18_3">&#167;18.3</a>.</p>

<p class="endnote">The function PL::Parsing::valid_new_token_name appears nowhere else.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="5-itg.html">Back to 'Introduction to Grammar'</a></li><li><a href="5-gp.html">Continue with 'Grammar Properties'</a></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

