<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>5/tfg</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '5/gp' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">if</a></li><li><a href="index.html#5">Chapter 5: Command Grammar</a></li><li><b>Grammar Properties</b></li></ul><p class="purpose">A plugin for the I6 run-time properties needed to support parsing.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP5">&#167;5. Initialising</a></li><li><a href="#SP6">&#167;6. Plugin startup</a></li><li><a href="#SP11">&#167;11. Visible properties</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b></p>


<pre class="display">
    <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">P_name</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">P_parse_name</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">P_action_bitmap</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>

    <span class="identifier">nonlocal_variable</span><span class="plain"> *</span><span class="identifier">real_location_VAR</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">nonlocal_variable</span><span class="plain"> *</span><span class="identifier">actor_location_VAR</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>

    <span class="identifier">nonlocal_variable</span><span class="plain"> *</span><span class="identifier">I6_noun_VAR</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">nonlocal_variable</span><span class="plain"> *</span><span class="identifier">I6_second_VAR</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">nonlocal_variable</span><span class="plain"> *</span><span class="identifier">I6_actor_VAR</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>Every inference subject (in particular, every object and every kind of object)
contains a pointer to its own unique copy of the following structure:
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">parsing_data</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">understand_as_this_object</span><span class="plain">; </span>    <span class="comment">grammar for parsing the name at run-time</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">parsing_data</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure parsing_data is accessed in 5/gv, 5/gpr and here.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>And every property permission likewise:
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">parsing_pp_data</span><span class="plain"> {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">visibility_level_in_parser</span><span class="plain">; </span>    <span class="comment">if so, does the run-time I6 parser recognise it?</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">visibility_condition</span><span class="plain">; </span>    <span class="comment">(at least if...?)</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">visibility_sentence</span><span class="plain">; </span>    <span class="comment">where this is specified</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">parsing_pp_data</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure parsing_pp_data is private to this section.</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Initialising. </b></p>


<pre class="display">
    <span class="reserved">parsing_data</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Visibility::new_data</span><span class="plain">(</span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain">) {</span>
        <span class="reserved">parsing_data</span><span class="plain"> *</span><span class="identifier">pd</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">parsing_data</span><span class="plain">);</span>
        <span class="identifier">pd</span><span class="plain">-</span><span class="element">&gt;understand_as_this_object</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">pd</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">parsing_pp_data</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Visibility::new_pp_data</span><span class="plain">(</span><span class="identifier">property_permission</span><span class="plain"> *</span><span class="identifier">pp</span><span class="plain">) {</span>
        <span class="reserved">parsing_pp_data</span><span class="plain"> *</span><span class="identifier">pd</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">parsing_pp_data</span><span class="plain">);</span>
        <span class="identifier">pd</span><span class="plain">-</span><span class="element">&gt;visibility_level_in_parser</span><span class="plain"> = 0;</span>
        <span class="identifier">pd</span><span class="plain">-</span><span class="element">&gt;visibility_condition</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">pd</span><span class="plain">-</span><span class="element">&gt;visibility_sentence</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">pd</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Visibility::new_data is used in <a href="#SP6">&#167;6</a>.</p>

<p class="endnote">The function PL::Parsing::Visibility::new_pp_data is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Plugin startup. </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Visibility::start</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">PLUGIN_REGISTER</span><span class="plain">(</span><span class="identifier">PLUGIN_NEW_VARIABLE_NOTIFY</span><span class="plain">, </span><span class="functiontext">PL::Parsing::Visibility::parsing_new_variable_notify</span><span class="plain">);</span>
        <span class="identifier">PLUGIN_REGISTER</span><span class="plain">(</span><span class="identifier">PLUGIN_NEW_SUBJECT_NOTIFY</span><span class="plain">, </span><span class="functiontext">PL::Parsing::Visibility::parsing_new_subject_notify</span><span class="plain">);</span>
        <span class="identifier">PLUGIN_REGISTER</span><span class="plain">(</span><span class="identifier">PLUGIN_NEW_PERMISSION_NOTIFY</span><span class="plain">, </span><span class="functiontext">PL::Parsing::Visibility::parsing_new_permission_notify</span><span class="plain">);</span>
        <span class="identifier">PLUGIN_REGISTER</span><span class="plain">(</span><span class="identifier">PLUGIN_COMPLETE_MODEL</span><span class="plain">, </span><span class="functiontext">PL::Parsing::Visibility::parsing_complete_model</span><span class="plain">);</span>
        <span class="identifier">PLUGIN_REGISTER</span><span class="plain">(</span><span class="identifier">PLUGIN_ESTIMATE_PROPERTY_USAGE</span><span class="plain">, </span><span class="functiontext">PL::Parsing::Visibility::parsing_estimate_property_usage</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Visibility::parsing_new_subject_notify</span><span class="plain">(</span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain">) {</span>
        <span class="identifier">CREATE_PF_DATA</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">, </span><span class="functiontext">PL::Parsing::Visibility::new_data</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Visibility::parsing_new_permission_notify</span><span class="plain">(</span><span class="identifier">property_permission</span><span class="plain"> *</span><span class="identifier">new_pp</span><span class="plain">) {</span>
        <span class="identifier">CREATE_PLUGIN_PP_DATA</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">new_pp</span><span class="plain">, </span><span class="functiontext">PL::Parsing::Visibility::new_pp_data</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Visibility::start appears nowhere else.</p>

<p class="endnote">The function PL::Parsing::Visibility::parsing_new_subject_notify appears nowhere else.</p>

<p class="endnote">The function PL::Parsing::Visibility::parsing_new_permission_notify appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>These are variable names to do with "Understand..." which Inform provides
special support for; it recognises the English names when they are defined by
the Standard Rules or, in the case of "the X understood", by Inform itself.
(So there is no need to translate this to other languages.)
</p>

<p class="inwebparagraph"></p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">notable</span><span class="plain">-</span><span class="identifier">parsing</span><span class="plain">-</span><span class="identifier">variables</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">&gt; </span><span class="identifier">understood</span><span class="plain"> |			==&gt; 0; &lt;&lt;</span><span class="identifier">kind</span><span class="plain">:</span><span class="identifier">understood</span><span class="plain">&gt;&gt; = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="identifier">noun</span><span class="plain"> |							==&gt; 1</span>
        <span class="identifier">location</span><span class="plain"> |						==&gt; 2</span>
        <span class="identifier">actor</span><span class="plain">-</span><span class="identifier">location</span><span class="plain"> |				==&gt; 3</span>
        <span class="identifier">second</span><span class="plain"> </span><span class="identifier">noun</span><span class="plain"> |					==&gt; 4</span>
        <span class="identifier">person</span><span class="plain"> </span><span class="identifier">asked</span><span class="plain"> |					==&gt; 5</span>
        <span class="identifier">maximum</span><span class="plain"> </span><span class="identifier">score</span><span class="plain">					==&gt; 6</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Visibility::parsing_new_variable_notify</span><span class="plain">(</span><span class="identifier">nonlocal_variable</span><span class="plain"> *</span><span class="identifier">var</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">notable</span><span class="plain">-</span><span class="identifier">parsing</span><span class="plain">-</span><span class="identifier">variables</span><span class="plain">&gt;(</span><span class="identifier">var</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain">)) {</span>
            <span class="reserved">switch</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;) {</span>
                <span class="reserved">case</span><span class="plain"> 0:</span>
                    <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">kind</span><span class="plain">:</span><span class="identifier">understood</span><span class="plain">&gt;&gt; == </span><span class="identifier">NonlocalVariables::kind</span><span class="plain">(</span><span class="identifier">var</span><span class="plain">)) {</span>
                        <span class="identifier">NonlocalVariables::set_I6_identifier</span><span class="plain">(</span><span class="identifier">var</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">,</span>
                            <span class="identifier">NonlocalVariables::nve_from_iname</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSED_NUMBER_HL</span><span class="plain">)));</span>
                        <span class="identifier">NonlocalVariables::set_I6_identifier</span><span class="plain">(</span><span class="identifier">var</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">,</span>
                            <span class="identifier">NonlocalVariables::nve_from_iname</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSED_NUMBER_HL</span><span class="plain">)));</span>
                        <span class="identifier">NonlocalVariables::allow_to_be_zero</span><span class="plain">(</span><span class="identifier">var</span><span class="plain">);</span>
                    <span class="plain">}</span>
                    <span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> 1: </span><span class="identifier">I6_noun_VAR</span><span class="plain"> = </span><span class="identifier">var</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> 2: </span><span class="identifier">real_location_VAR</span><span class="plain"> = </span><span class="identifier">var</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> 3: </span><span class="identifier">actor_location_VAR</span><span class="plain"> = </span><span class="identifier">var</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> 4: </span><span class="identifier">I6_second_VAR</span><span class="plain"> = </span><span class="identifier">var</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> 5: </span><span class="identifier">I6_actor_VAR</span><span class="plain"> = </span><span class="identifier">var</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> 6: </span><span class="identifier">max_score_VAR</span><span class="plain"> = </span><span class="identifier">var</span><span class="plain">;</span>
                    <span class="identifier">NonlocalVariables::make_initalisable</span><span class="plain">(</span><span class="identifier">var</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Visibility::parsing_new_variable_notify is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>This is for <code class="display"><span class="extract">name</span></code> and <code class="display"><span class="extract">plural</span></code>.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Visibility::parsing_estimate_property_usage</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">k</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">words_used</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_name</span><span class="plain">(</span><span class="identifier">k</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="plain">*</span><span class="identifier">words_used</span><span class="plain"> += </span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_name</span><span class="plain">(</span><span class="identifier">k</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
        <span class="plain">*</span><span class="identifier">words_used</span><span class="plain"> += </span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">PW</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Visibility::parsing_estimate_property_usage is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>Once the traverse is done, we can infer values for the two key I6 properties
for parsing:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Visibility::parsing_complete_model</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">stage</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">stage</span><span class="plain"> == 5) {</span>
            <span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">;</span>
            <span class="identifier">P_name</span><span class="plain"> = </span><span class="identifier">Properties::Valued::new_nameless</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"name"</span><span class="plain">, </span><span class="identifier">K_text</span><span class="plain">);</span>
            <span class="identifier">Hierarchy::make_available</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="functiontext">PL::Parsing::Visibility::name_name</span><span class="plain">());</span>
            <span class="identifier">P_parse_name</span><span class="plain"> = </span><span class="identifier">Properties::Valued::new_nameless</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"parse_name"</span><span class="plain">, </span><span class="identifier">K_value</span><span class="plain">);</span>
            <span class="identifier">P_action_bitmap</span><span class="plain"> = </span><span class="identifier">Properties::Valued::new_nameless</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"action_bitmap"</span><span class="plain">, </span><span class="identifier">K_value</span><span class="plain">);</span>
            <span class="identifier">Hierarchy::make_available</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">P_action_bitmap</span><span class="plain">));</span>

            <span class="identifier">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">) {</span>
                <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain"> = </span><span class="identifier">Instances::as_subject</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
                &lt;<span class="cwebmacro">Assert the I6 name property</span> <span class="cwebmacronumber">10.1</span>&gt;<span class="plain">;</span>
                &lt;<span class="cwebmacro">Assert the I6 parse-name property</span> <span class="cwebmacronumber">10.2</span>&gt;<span class="plain">;</span>
                &lt;<span class="cwebmacro">Assert the I6 action-bitmap property</span> <span class="cwebmacronumber">10.3</span>&gt;<span class="plain">;</span>
            <span class="plain">}</span>

            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">;</span>
            <span class="identifier">LOOP_OVER_BASE_KINDS</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::lt</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)) {</span>
                    <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain"> = </span><span class="identifier">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
                    &lt;<span class="cwebmacro">Assert the I6 parse-name property</span> <span class="cwebmacronumber">10.2</span>&gt;<span class="plain">;</span>
                <span class="plain">}</span>

            <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain"> = </span><span class="identifier">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">K_thing</span><span class="plain">);</span>
            &lt;<span class="cwebmacro">Assert the I6 action-bitmap property</span> <span class="cwebmacronumber">10.3</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Visibility::name_name</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">P_name</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Visibility::parsing_complete_model is used in <a href="#SP6">&#167;6</a>.</p>

<p class="endnote">The function PL::Parsing::Visibility::name_name is used in 5/gpr (<a href="5-gpr.html#SP7">&#167;7</a>, <a href="5-gpr.html#SP9">&#167;9</a>).</p>

<p class="inwebparagraph"><a id="SP10_1"></a><b>&#167;10.1.  </b>The name property requires special care, partly over I6 eccentricities
such as the way that single-letter dictionary words can be misinterpreted
as characters (hence the double slash below), but also because something
called "your ..." in the source text &mdash; "your nose", say &mdash; needs to
be altered to "my ..." for purposes of parsing during play.
</p>

<p class="inwebparagraph">Note that <code class="display"><span class="extract">name</span></code> is additive in I6 terms, meaning that its values
accumulate from class down to instance: but we prevent this, by only
compiling <code class="display"><span class="extract">name</span></code> properties for instance objects directly. The practical
consequence is that we have to imitate this inheritance when it comes
to single-word grammar for things. Recall that a sentence like "Understand
"cube" as the block" formally creates a grammar line which ought to
be parsed as part of some elaborate <code class="display"><span class="extract">parse_name</span></code> property: but that for
efficiency's sake, we notice that "cube" is only one word and so put
it into the <code class="display"><span class="extract">name</span></code> property instead. And we need to perform the same trick
for the kinds we inherit from.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Assert the I6 name property</span> <span class="cwebmacronumber">10.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">PL::Naming::object_is_privately_named</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">from_kind</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="identifier">package_request</span><span class="plain"> *</span><span class="identifier">PR</span><span class="plain"> = </span><span class="identifier">Hierarchy::package_within</span><span class="plain">(</span><span class="identifier">INLINE_PROPERTIES_HAP</span><span class="plain">, </span><span class="identifier">Instances::package</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
            <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">name_array</span><span class="plain"> = </span><span class="identifier">Hierarchy::make_iname_in</span><span class="plain">(</span><span class="identifier">INLINE_PROPERTY_HL</span><span class="plain">, </span><span class="identifier">PR</span><span class="plain">);</span>
            <span class="identifier">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="identifier">Emit::named_array_begin</span><span class="plain">(</span><span class="identifier">name_array</span><span class="plain">, </span><span class="identifier">K_value</span><span class="plain">);</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Instances::get_name_in_play</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_name_in_play</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">Projects::get_language_of_play</span><span class="plain">(</span><span class="identifier">Task::project</span><span class="plain">()));</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">Instances::get_name_in_play</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">PW</span><span class="plain">)) {</span>
                <span class="identifier">from_kind</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_name_in_play</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">Projects::get_language_of_play</span><span class="plain">(</span><span class="identifier">Task::project</span><span class="plain">()));</span>
            <span class="plain">}</span>

            <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">j</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">) {</span>
                <span class="identifier">vocabulary_entry</span><span class="plain"> *</span><span class="identifier">ve</span><span class="plain"> = </span><span class="identifier">Lexer::word</span><span class="plain">(</span><span class="identifier">j</span><span class="plain">);</span>
                <span class="identifier">ve</span><span class="plain"> = </span><span class="identifier">Preform::Nonparsing::replace_word</span><span class="plain">(</span><span class="identifier">ve</span><span class="plain">,</span>
                    <span class="plain">&lt;</span><span class="identifier">possessive</span><span class="plain">-</span><span class="identifier">second</span><span class="plain">-</span><span class="identifier">person</span><span class="plain">&gt;,</span>
                    <span class="plain">&lt;</span><span class="identifier">possessive</span><span class="plain">-</span><span class="identifier">first</span><span class="plain">-</span><span class="identifier">person</span><span class="plain">&gt;);</span>
                <span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">Vocabulary::get_exemplar</span><span class="plain">(</span><span class="identifier">ve</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">content</span><span class="plain">);</span>
                <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">content</span><span class="plain">, </span><span class="string">"%w"</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">);</span>
                <span class="identifier">Emit::array_dword_entry</span><span class="plain">(</span><span class="identifier">content</span><span class="plain">);</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">content</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">from_kind</span><span class="plain">) </span>    <span class="comment">see test case PM_PluralsFromKind</span>
                <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">j</span><span class="plain">, </span><span class="identifier">PW</span><span class="plain">) {</span>
                    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">additional</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                    <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">k</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">compare_word</span><span class="plain">(</span><span class="identifier">j</span><span class="plain">, </span><span class="identifier">Lexer::word</span><span class="plain">(</span><span class="identifier">k</span><span class="plain">)))</span>
                            <span class="identifier">additional</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">additional</span><span class="plain">) {</span>
                        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">content</span><span class="plain">);</span>
                        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">content</span><span class="plain">, </span><span class="string">"%w"</span><span class="plain">, </span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">j</span><span class="plain">));</span>
                        <span class="identifier">Emit::array_plural_dword_entry</span><span class="plain">(</span><span class="identifier">content</span><span class="plain">);</span>
                        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">content</span><span class="plain">);</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>

            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">PF_I</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">I</span><span class="plain">)-</span><span class="element">&gt;understand_as_this_object</span><span class="plain">)</span>
                <span class="functiontext">PL::Parsing::Verbs::take_out_one_word_grammar</span><span class="plain">(</span>
                    <span class="identifier">PF_I</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">I</span><span class="plain">)-</span><span class="element">&gt;understand_as_this_object</span><span class="plain">);</span>

            <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">infs</span><span class="plain"> = </span><span class="identifier">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
                <span class="identifier">infs</span><span class="plain">; </span><span class="identifier">infs</span><span class="plain"> = </span><span class="identifier">InferenceSubjects::narrowest_broader_subject</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">PF_S</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">infs</span><span class="plain">)) {</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">PF_S</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">infs</span><span class="plain">)-</span><span class="element">&gt;understand_as_this_object</span><span class="plain">)</span>
                        <span class="functiontext">PL::Parsing::Verbs::take_out_one_word_grammar</span><span class="plain">(</span>
                            <span class="identifier">PF_S</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">infs</span><span class="plain">)-</span><span class="element">&gt;understand_as_this_object</span><span class="plain">);</span>
                <span class="plain">}</span>
            <span class="plain">}</span>

            <span class="identifier">Emit::array_end</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>
            <span class="identifier">Produce::annotate_i</span><span class="plain">(</span><span class="identifier">name_array</span><span class="plain">, </span><span class="identifier">INLINE_ARRAY_IANN</span><span class="plain">, 1);</span>
            <span class="identifier">Properties::Valued::assert</span><span class="plain">(</span><span class="identifier">P_name</span><span class="plain">, </span><span class="identifier">Instances::as_subject</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">),</span>
                <span class="identifier">Rvalues::from_iname</span><span class="plain">(</span><span class="identifier">name_array</span><span class="plain">), </span><span class="identifier">CERTAIN_CE</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP10">&#167;10</a>.</p>

<p class="inwebparagraph"><a id="SP10_2"></a><b>&#167;10.2.  </b>We attach numbered parse name routines as properties for any object
where grammar has specified a need. (By default, this will not happen.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Assert the I6 parse-name property</span> <span class="cwebmacronumber">10.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">S</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Tokens::General::compile_parse_name_property</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">)</span>
            <span class="identifier">Properties::Valued::assert</span><span class="plain">(</span><span class="identifier">P_parse_name</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">,</span>
                <span class="identifier">Rvalues::from_iname</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">), </span><span class="identifier">CERTAIN_CE</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP10">&#167;10</a> (twice).</p>

<p class="inwebparagraph"><a id="SP10_3"></a><b>&#167;10.3.  </b>The action bitmap is an array of bits attached to each object, one
for each action, which records whether that action has yet applied
successfully to that object. This is used at run-time to handle past
tense conditions such as "the jewels have been taken". Note that
we give the bitmap in the class definition associated with "thing"
to ensure that it will be inherited by all I6 objects of this class,
i.e., all I6 objects corresponding to I7 things.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Assert the I6 action-bitmap property</span> <span class="cwebmacronumber">10.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">InferenceSubjects::is_within</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">K_room</span><span class="plain">)) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain"> = </span><span class="identifier">InferenceSubjects::as_instance</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">);</span>
            <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">S</span><span class="plain"> = </span><span class="functiontext">PL::Actions::compile_action_bitmap_property</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
            <span class="identifier">Properties::Valued::assert</span><span class="plain">(</span><span class="identifier">P_action_bitmap</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">,</span>
                <span class="identifier">Rvalues::from_iname</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">), </span><span class="identifier">CERTAIN_CE</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP10">&#167;10</a> (twice).</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Visible properties. </b>A visible property is one which can be used to describe an object: for
instance, if colour is a visible property of a car, then it can be called
"green car" if and only if the current value of the colour of the car is
"green".
</p>

<p class="inwebparagraph">Properly speaking it is not the property which is visible, but the
combination of property and object (or kind): thus the following test
depends on a property permission and not a mere property.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Visibility::seek</span><span class="plain">(</span><span class="identifier">property</span><span class="plain"> *</span><span class="identifier">pr</span><span class="plain">, </span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain">,</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">level</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">WHENW</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">parity</span><span class="plain">, </span><span class="identifier">upto</span><span class="plain"> = 1;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Properties::is_either_or</span><span class="plain">(</span><span class="identifier">pr</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">upto</span><span class="plain"> = 0;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">parity</span><span class="plain"> = 0; </span><span class="identifier">parity</span><span class="plain"> &lt;= </span><span class="identifier">upto</span><span class="plain">; </span><span class="identifier">parity</span><span class="plain">++) {</span>
            <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">seek_prn</span><span class="plain"> = (</span><span class="identifier">parity</span><span class="plain"> == 0)?</span><span class="identifier">pr</span><span class="plain">:(</span><span class="identifier">Properties::EitherOr::get_negation</span><span class="plain">(</span><span class="identifier">pr</span><span class="plain">));</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">seek_prn</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">continue</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">World::Permissions::find</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">seek_prn</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">) == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">continue</span><span class="plain">;</span>
            <span class="identifier">property_permission</span><span class="plain"> *</span><span class="identifier">pp</span><span class="plain"> = </span><span class="identifier">World::Permissions::grant</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">seek_prn</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="identifier">PLUGIN_PP</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">pp</span><span class="plain">)-</span><span class="element">&gt;visibility_level_in_parser</span><span class="plain"> = </span><span class="identifier">level</span><span class="plain">;</span>
            <span class="identifier">PLUGIN_PP</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">pp</span><span class="plain">)-</span><span class="element">&gt;visibility_sentence</span><span class="plain"> = </span><span class="identifier">current_sentence</span><span class="plain">;</span>
            <span class="identifier">PLUGIN_PP</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">pp</span><span class="plain">)-</span><span class="element">&gt;visibility_condition</span><span class="plain"> = </span><span class="identifier">WHENW</span><span class="plain">;</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Visibility::any_property_visible_to_subject</span><span class="plain">(</span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">allow_inheritance</span><span class="plain">) {</span>
        <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">pr</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">pr</span><span class="plain">, </span><span class="identifier">property</span><span class="plain">) {</span>
            <span class="identifier">property_permission</span><span class="plain"> *</span><span class="identifier">pp</span><span class="plain"> =</span>
                <span class="identifier">World::Permissions::find</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">pr</span><span class="plain">, </span><span class="identifier">allow_inheritance</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">pp</span><span class="plain">) &amp;&amp; (</span><span class="identifier">PLUGIN_PP</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">pp</span><span class="plain">)-</span><span class="element">&gt;visibility_level_in_parser</span><span class="plain"> &gt; 0))</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Visibility::get_level</span><span class="plain">(</span><span class="identifier">property_permission</span><span class="plain"> *</span><span class="identifier">pp</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">PLUGIN_PP</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">pp</span><span class="plain">)-</span><span class="element">&gt;visibility_level_in_parser</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Visibility::get_condition</span><span class="plain">(</span><span class="identifier">property_permission</span><span class="plain"> *</span><span class="identifier">pp</span><span class="plain">) {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">PLUGIN_PP</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">pp</span><span class="plain">)-</span><span class="element">&gt;visibility_condition</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">condition</span><span class="plain">&gt;(</span><span class="identifier">PLUGIN_PP</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">pp</span><span class="plain">)-</span><span class="element">&gt;visibility_condition</span><span class="plain">)) </span><span class="identifier">spec</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">Specifications::new_UNKNOWN</span><span class="plain">(</span><span class="identifier">PLUGIN_PP</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">pp</span><span class="plain">)-</span><span class="element">&gt;visibility_condition</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Dash::validate_conditional_clause</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"$T"</span><span class="plain">, </span><span class="identifier">spec</span><span class="plain">);</span>
            <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">PLUGIN_PP</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">pp</span><span class="plain">)-</span><span class="element">&gt;visibility_sentence</span><span class="plain">;</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BadVisibilityWhen</span><span class="plain">),</span>
                <span class="string">"the condition after 'when' makes no sense to me"</span><span class="plain">,</span>
                <span class="string">"although otherwise this worked - it is only the part after 'when' "</span>
                <span class="string">"which I can't follow."</span><span class="plain">);</span>
            <span class="identifier">PLUGIN_PP</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">pp</span><span class="plain">)-</span><span class="element">&gt;visibility_condition</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">spec</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Visibility::log_parsing_visibility</span><span class="plain">(</span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">) {</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Permissions for $j:\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">infs</span><span class="plain">);</span>
        <span class="identifier">property_permission</span><span class="plain"> *</span><span class="identifier">pp</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_PERMISSIONS_FOR_INFS</span><span class="plain">(</span><span class="identifier">pp</span><span class="plain">, </span><span class="identifier">infs</span><span class="plain">) {</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"$Y: visibility %d, condition %W\</span><span class="plain">n</span><span class="string">"</span><span class="plain">,</span>
                <span class="identifier">World::Permissions::get_property</span><span class="plain">(</span><span class="identifier">pp</span><span class="plain">),</span>
                <span class="identifier">PLUGIN_PP</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">pp</span><span class="plain">)-</span><span class="element">&gt;visibility_level_in_parser</span><span class="plain">,</span>
                <span class="identifier">PLUGIN_PP</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">pp</span><span class="plain">)-</span><span class="element">&gt;visibility_condition</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">InferenceSubjects::narrowest_broader_subject</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">))</span>
            <span class="functiontext">PL::Parsing::Visibility::log_parsing_visibility</span><span class="plain">(</span><span class="identifier">InferenceSubjects::narrowest_broader_subject</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Visibility::seek is used in 5/tfg (<a href="5-tfg.html#SP19">&#167;19</a>).</p>

<p class="endnote">The function PL::Parsing::Visibility::any_property_visible_to_subject is used in 5/gpr (<a href="5-gpr.html#SP5">&#167;5</a>, <a href="5-gpr.html#SP6">&#167;6</a>).</p>

<p class="endnote">The function PL::Parsing::Visibility::get_level is used in 5/gpr (<a href="5-gpr.html#SP10">&#167;10</a>, <a href="5-gpr.html#SP11">&#167;11</a>).</p>

<p class="endnote">The function PL::Parsing::Visibility::get_condition is used in 5/gpr (<a href="5-gpr.html#SP11">&#167;11</a>).</p>

<p class="endnote">The function PL::Parsing::Visibility::log_parsing_visibility appears nowhere else.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="5-tfg.html">Back to 'Traverse for Grammar'</a></li><li><a href="5-gv.html">Continue with 'Grammar Verbs'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

