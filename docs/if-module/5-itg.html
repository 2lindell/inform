<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>4/ai</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../compiler.html"><b>compiler</b></a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul>
<h2>Compiler Webs</h2>
<ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul>
<h2>Inbuild Modules</h2>
<ul>
<li><a href="../inbuild-module/index.html">inbuild</a></li>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../html-module/index.html">html</a></li>
</ul>
<h2>Inform7 Modules</h2>
<ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul>
<h2>Inter Modules</h2>
<ul>
<li><a href="../inter-module/index.html">inter</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of '5/itg' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="../compiler.html">Compiler</a></li><li><a href="index.html">if</a></li><li><a href="index.html#5">Chapter 5: Command Grammar</a></li><li><b>Introduction to Grammar</b></li></ul><p class="purpose">An exposition of the data structures and basic method used to deal with the command-parsing grammar implied by Understand sentences in the source text.</p>

<ul class="toc"><li><a href="#SP2">&#167;2. Phase I: Slash Grammar</a></li><li><a href="#SP3">&#167;3. Phase II: Determining Grammar</a></li><li><a href="#SP4">&#167;4. Phase III: Sort Grammar</a></li><li><a href="#SP5">&#167;5. Phase IV: Compile Grammar</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1.  </b>This is grammar in the sense of the parsing structures used at run-time,
and it occupies a chapter of its own in the source code since it is to some
extent detached from the rest of NI: what we create in this chapter is
almost an independent compiler in its own right, but of a much simpler
language. Although we use many higher-level features of NI in the process,
none use this.
</p>

<p class="inwebparagraph">Grammar is organised in a three-level hierarchy:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(a) A grammar verb (GV) is a small independent grammar of alternative
formulations for some concept: for instance, the possible commands beginning
TAKE, or the possible verbal forms of numbers. Each GV is a list of GLs, and
an individual GL must belong to exactly one GV. There are five different
types of GV, differentiated mostly by the purpose to which the GV is put:
<ul class="items"><li>(1) <code class="display"><span class="extract">GV_IS_COMMAND</span></code>. An imperative verbal command at run-time.
</li><li>(2) <code class="display"><span class="extract">GV_IS_TOKEN</span></code>. A square-bracketed token in other grammar.
</li><li>(3) <code class="display"><span class="extract">GV_IS_OBJECT</span></code>. A noun phrase at run time: a name for an object.
</li><li>(4) <code class="display"><span class="extract">GV_IS_VALUE</span></code>. A noun phrase at run time: a name for a value.
</li><li>(5) <code class="display"><span class="extract">GV_IS_CONSULT</span></code>. A pattern to match in part of a command (such as "consult").
</li><li>(6) <code class="display"><span class="extract">GV_IS_PROPERTY_NAME</span></code>. A noun phrase at run time: a name for one
possibility for an either/or property, say "open" or "fixed in place".
</li></ul>
</li></ul>
<p class="inwebparagraph"></p>

<ul class="items"><li>(b) A grammar line (GL) is a single possibility within a GV: for
example, the line matching <code class="display"><span class="extract">"take [something]"</span></code> in the GV for the TAKE
command. Each GL is a list of tokens, and an individual token must belong
to exactly one GL.
</li></ul>
<ul class="items"><li>(c) A grammar token (GTOK) is a single particle of a GL: for
example, <code class="display"><span class="extract">'take'</span></code> and <code class="display"><span class="extract">something</span></code> are tokens.
</li></ul>
<p class="inwebparagraph">The picture is not quite so hierarchical as it looks, though, because
a GV naming a token can be used as a token inside other GVs. We need to
be careful that this does not lead to infinite regress: see below.
</p>

<p class="inwebparagraph">Much of what we do with grammar involves recursing down this hierarchy,
in some cases allowing results to percolate back upwards. What happens
takes place in four chronological phases. (This division into phases is
convenient because Inform 6 requires that all general parsing routines
and noun filter routines already exist when a <code class="display"><span class="extract">Verb</span></code> directive is reached
which uses them.)
</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Phase I: Slash Grammar. </b>Slashing is the process of dealing with slashes <code class="display"><span class="extract">/</span></code> used in grammar
to indicate alternatives.
</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Phase II: Determining Grammar. </b>We check that the grammar is well-founded and find the types of values
expressed by it, if any.
</p>

<p class="inwebparagraph">Determining well-foundedness means checking that no two grammar tokens
each require the use of the other, and that when a grammar token takes
several alternative forms, they have compatible results: so, for instance,
you can't have one version resulting in a number and another in a thing.
(This check is only meaningful for grammar verbs of type <code class="display"><span class="extract">GV_IS_TOKEN</span></code>.)
</p>

<p class="inwebparagraph">The result of a <code class="display"><span class="extract">GV_IS_TOKEN</span></code> is a single specification, which is the union of the
kinds resulting from its grammar lines. This is a more sophisticated approach
than we really need here, but might be useful for future expansion.
</p>

<p class="inwebparagraph">Of the determining traverse the following can be said:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(a) either errors are produced, or it is verified that no token's
definition depends directly or indirectly on already knowing itself;
</li></ul>
<ul class="items"><li>(b) also that no grammar line attached to a <code class="display"><span class="extract">GV_IS_COMMAND</span></code> produces
more than 2 values, and that no grammar line attached to anything else
produces more than one; and
</li></ul>
<ul class="items"><li>(c) also that the grammar lines attached to a <code class="display"><span class="extract">GV_IS_TOKEN</span></code> are
compatible in that there is a type to which they can all always be cast.
</li></ul>
<p class="inwebparagraph">We note of the determining routines that:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(a) <code class="display"><span class="extract">PL::Parsing::Verbs::determine</span></code> runs at least once for each GV;
</li></ul>
<ul class="items"><li>(b) <code class="display"><span class="extract">PL::Parsing::Lines::gl_determine</span></code> runs exactly once on each GL;
</li></ul>
<ul class="items"><li>(c) <code class="display"><span class="extract">PL::Parsing::Tokens::determine</span></code> runs exactly once on each token.
</li></ul>
<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Phase III: Sort Grammar. </b>We must ensure that if grammar line L1 is logically impossible once L2
has been parsed, then L1 must be checked before L2, regardless of the
ordering in the source code. Since the data sets are very small and
time is not of the essence, we simply insertion-sort the original
definition-order list into a second linked list.
</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Phase IV: Compile Grammar. </b>The final run-through, which uses the sorted order and not the original
declaration order, actually compiles the necessary I6 <code class="display"><span class="extract">Verb</span></code> and
<code class="display"><span class="extract">Extend</span></code> directives.
</p>

<hr class="tocbar">
<ul class="toc"><li><i>(This section begins Chapter 5: Command Grammar.)</i></li><li><a href="5-tfg.html">Continue with 'Traverse for Grammar'</a></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

