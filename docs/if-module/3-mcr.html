<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>3/tm</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '3/mcr' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">if</a></li><li><a href="index.html#3">Chapter 3: Space and Time</a></li><li><b>Map Connection Relations</b></li></ul><p class="purpose">To define one binary predicate for each map direction, such as "mapped north of".</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP3">&#167;3. The adjacency relation</a></li><li><a href="#SP5">&#167;5. Initial stock</a></li><li><a href="#SP6">&#167;6. Subsequent creations</a></li><li><a href="#SP8">&#167;8. Second stock</a></li><li><a href="#SP9">&#167;9. Typechecking</a></li><li><a href="#SP10">&#167;10. Assertion</a></li><li><a href="#SP11">&#167;11. Compilation</a></li><li><a href="#SP12">&#167;12. Problem message text</a></li><li><a href="#SP13">&#167;13. The correspondence with directions</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>This section creates a family of implicit relations (implemented as binary
predicates) corresponding to the different directions.
</p>

<p class="inwebparagraph">For every direction created, a predicate is created for the possibility of
a map connection. For instance, "if Versailles is mapped north of the
Metro" tests the "mapped-north" BP. There is also one general relation
built in:
</p>


<pre class="display">
    <span class="identifier">binary_predicate</span><span class="plain"> *</span><span class="identifier">R_adjacency</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. The adjacency relation. </b>We may as well do this here: creating the relation "X is adjacent to Y".
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::MapDirections::create_relations</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">R_adjacency</span><span class="plain"> =</span>
            <span class="identifier">BinaryPredicates::make_pair</span><span class="plain">(</span><span class="identifier">SPATIAL_KBP</span><span class="plain">,</span>
                <span class="identifier">BinaryPredicates::new_term</span><span class="plain">(</span><span class="identifier">infs_room</span><span class="plain">),</span>
                <span class="identifier">BinaryPredicates::new_term</span><span class="plain">(</span><span class="identifier">infs_room</span><span class="plain">),</span>
                <span class="identifier">I</span><span class="string">"adjacent-to"</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"adjacent-from"</span><span class="plain">,</span>
                <span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">Calculus::Schemas::new</span><span class="plain">(</span><span class="string">"TestAdjacency(*1,*2)"</span><span class="plain">),</span>
                <span class="identifier">Preform::Nonparsing::wording</span><span class="plain">(&lt;</span><span class="identifier">relation</span><span class="plain">-</span><span class="identifier">names</span><span class="plain">&gt;, </span><span class="identifier">ADJACENCY_RELATION_NAME</span><span class="plain">));</span>

    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::MapDirections::create_relations is used in 3/sr (<a href="3-sr.html#SP3">&#167;3</a>).</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>There is nothing special about asserting this, so we don't intervene:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::MapDirections::assert_relations</span><span class="plain">(</span><span class="identifier">binary_predicate</span><span class="plain"> *</span><span class="identifier">relation</span><span class="plain">, </span><span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">I0</span><span class="plain">, </span><span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">I1</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::MapDirections::assert_relations is used in 3/sr (<a href="3-sr.html#SP6_1">&#167;6.1</a>).</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Initial stock. </b>There is none, since at the start of Inform's run no direction objects exist
yet.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::MapDirections::REL_create_initial_stock</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::MapDirections::REL_create_initial_stock appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Subsequent creations. </b>Every direction created has a relation associated with it: for instance,
"north" has the relation "X is mapped north of Y". Now a direction is a
kind of object, but objects aren't created until after relations used to
parse sentences are needed. In fact, however, directions are "noticed"
at an earlier stage in Inform's run, so another two-step is needed:
</p>


<pre class="display">
    <span class="identifier">binary_predicate</span><span class="plain"> *</span><span class="functiontext">PL::MapDirections::create_sketchy_mapping_direction</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="identifier">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain">;</span>
        &lt;<span class="cwebmacro">Create the mapping BP for the new direction</span> <span class="cwebmacronumber">6.3</span>&gt;<span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">bp</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::MapDirections::create_sketchy_mapping_direction appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP6_1"></a><b>&#167;6.1.  </b>When each direction is created, so are corresponding relations and
prepositional uses: for example, "northeast" makes "mapping northeast"
as a relation, and "mapped northeast of" as a prepositional usage.
</p>

<p class="inwebparagraph">The rule is actually that production (a) in &lt;mapping-preposition-construction&gt;
is used for all directions except those named in &lt;notable-directions&gt;,
where (b) is used. As a result, we make "mapped inside" and "mapped
outside" instead of "mapped inside of" and "mapped outside of." This
is done to avoid ambiguities with the already-existing meanings of inside
and outside to do with spatial containment.
</p>

<p class="inwebparagraph">The use of the word "mapped" may seem itself off. Why define "to be mapped
east of" rather than "to be east of"? After all, that seems to be what is
used in assertions like:
</p>

<blockquote>
    <p>The Bakery is east of Pudding Lane.</p>

</blockquote>

<p class="inwebparagraph">In fact, the A-parser reads sentences like that by looking out specially for
direction names plus "of" &mdash; so this is parsed without using the mapping
predicate for "east". But it cannot read:
</p>

<blockquote>
    <p>The Flour Cellar is below the Bakery.</p>

</blockquote>

<p class="inwebparagraph">as a direction name plus "of", since "below" is not the name of the direction
"down", and anyway there is no "of".
</p>

<p class="inwebparagraph">We do not allow direction names with unexpected capital letters because we
want to allow room names to contain direction names on occasion:
</p>

<blockquote>
    <p>The fire hydrant is in West from 47th Street.</p>

</blockquote>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">mapping</span><span class="plain">-</span><span class="identifier">relation</span><span class="plain">-</span><span class="identifier">construction</span><span class="plain">&gt; ::=</span>
        <span class="identifier">mapping</span><span class="plain"> ...</span>

    <span class="plain">&lt;</span><span class="identifier">mapping</span><span class="plain">-</span><span class="identifier">preposition</span><span class="plain">-</span><span class="identifier">construction</span><span class="plain">&gt; ::=</span>
        <span class="identifier">mapped</span><span class="plain"> ... </span><span class="identifier">of</span><span class="plain"> |</span>
        <span class="identifier">mapped</span><span class="plain"> ... |</span>
        <span class="plain">... </span><span class="identifier">of</span><span class="plain"> |</span>
        <span class="plain">... </span><span class="identifier">from</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6_2"></a><b>&#167;6.2.  </b>Two of the directions are special to mapping, because they have to be parsed
slighly differently. (These are the English names; there is no need to translate
this to other languages.)
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">notable</span><span class="plain">-</span><span class="identifier">directions</span><span class="plain">&gt; ::=</span>
        <span class="identifier">inside</span><span class="plain"> |</span>
        <span class="identifier">outside</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6_3"></a><b>&#167;6.3.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">MAX_MAPPING_RELATION_NAME_LENGTH</span><span class="plain"> </span><span class="constant">MAX_WORDS_IN_DIRECTION</span><span class="plain">*</span><span class="identifier">MAX_WORD_LENGTH</span><span class="plain">+10</span>

    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Create the mapping BP for the new direction</span> <span class="cwebmacronumber">6.3</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">) &gt; </span><span class="constant">MAX_WORDS_IN_DIRECTION</span><span class="plain">)</span>
                <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Wordings::truncate</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="constant">MAX_WORDS_IN_DIRECTION</span><span class="plain">); </span>    <span class="comment">just truncate for now</span>

            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">relname</span><span class="plain">); </span>    <span class="comment">for debugging log, e.g., "north-map"</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">relname</span><span class="plain">, </span><span class="string">"%W-map"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
            <span class="identifier">LOOP_THROUGH_TEXT</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">, </span><span class="identifier">relname</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Str::get</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">) == </span><span class="character">' '</span><span class="plain">) </span><span class="identifier">Str::put</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">, </span><span class="character">'-'</span><span class="plain">);</span>

            <span class="identifier">bp_term_details</span><span class="plain"> </span><span class="identifier">room_term</span><span class="plain"> = </span><span class="identifier">BinaryPredicates::new_term</span><span class="plain">(</span><span class="identifier">NULL</span><span class="plain">);</span>
            <span class="identifier">bp</span><span class="plain"> = </span><span class="identifier">BinaryPredicates::make_pair</span><span class="plain">(</span><span class="identifier">MAP_CONNECTING_KBP</span><span class="plain">,</span>
                <span class="identifier">room_term</span><span class="plain">, </span><span class="identifier">room_term</span><span class="plain">, </span><span class="identifier">relname</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">,</span>
                <span class="identifier">Preform::Nonparsing::merge</span><span class="plain">(&lt;</span><span class="identifier">mapping</span><span class="plain">-</span><span class="identifier">relation</span><span class="plain">-</span><span class="identifier">construction</span><span class="plain">&gt;, 0,</span>
                    <span class="identifier">WordAssemblages::from_wording</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)));</span>

            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">mpc_form</span><span class="plain"> = 0;</span>
            <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">notable</span><span class="plain">-</span><span class="identifier">directions</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) </span><span class="identifier">mpc_form</span><span class="plain"> = 1;</span>

            <span class="identifier">preposition_identity</span><span class="plain"> *</span><span class="identifier">prep1</span><span class="plain"> = </span><span class="identifier">Prepositions::make</span><span class="plain">(</span>
                <span class="identifier">Preform::Nonparsing::merge</span><span class="plain">(&lt;</span><span class="identifier">mapping</span><span class="plain">-</span><span class="identifier">preposition</span><span class="plain">-</span><span class="identifier">construction</span><span class="plain">&gt;, </span><span class="identifier">mpc_form</span><span class="plain">,</span>
                    <span class="identifier">WordAssemblages::from_wording</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)),</span>
                <span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="identifier">preposition_identity</span><span class="plain"> *</span><span class="identifier">prep2</span><span class="plain"> = </span><span class="identifier">Prepositions::make</span><span class="plain">(</span>
                <span class="identifier">Preform::Nonparsing::merge</span><span class="plain">(&lt;</span><span class="identifier">mapping</span><span class="plain">-</span><span class="identifier">preposition</span><span class="plain">-</span><span class="identifier">construction</span><span class="plain">&gt;, 2,</span>
                    <span class="identifier">WordAssemblages::from_wording</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)),</span>
                <span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="identifier">preposition_identity</span><span class="plain"> *</span><span class="identifier">prep3</span><span class="plain"> = </span><span class="identifier">Prepositions::make</span><span class="plain">(</span>
                <span class="identifier">Preform::Nonparsing::merge</span><span class="plain">(&lt;</span><span class="identifier">mapping</span><span class="plain">-</span><span class="identifier">preposition</span><span class="plain">-</span><span class="identifier">construction</span><span class="plain">&gt;, 3,</span>
                    <span class="identifier">WordAssemblages::from_wording</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)),</span>
                <span class="identifier">FALSE</span><span class="plain">);</span>

            <span class="identifier">verb_meaning</span><span class="plain"> </span><span class="identifier">vm</span><span class="plain"> = </span><span class="identifier">VerbMeanings::new</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
            <span class="identifier">Verbs::add_form</span><span class="plain">(</span><span class="identifier">copular_verb</span><span class="plain">, </span><span class="identifier">prep1</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">vm</span><span class="plain">, </span><span class="identifier">SVO_FS_BIT</span><span class="plain">);</span>
            <span class="identifier">Verbs::add_form</span><span class="plain">(</span><span class="identifier">copular_verb</span><span class="plain">, </span><span class="identifier">prep2</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">vm</span><span class="plain">, </span><span class="identifier">SVO_FS_BIT</span><span class="plain">);</span>
            <span class="identifier">Verbs::add_form</span><span class="plain">(</span><span class="identifier">copular_verb</span><span class="plain">, </span><span class="identifier">prep3</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">vm</span><span class="plain">, </span><span class="identifier">SVO_FS_BIT</span><span class="plain">);</span>

            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">relname</span><span class="plain">);</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

    <p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>That was one step, and here's the second. At this point we have created the
    instance <code class="display"><span class="extract">I</span></code> for the direction, and given it the kind "direction". That
    makes it possible to complete the details of the BP.
    </p>

    <p class="inwebparagraph"><code class="display"><span class="extract">ident</span></code> can be any string of text which evaluates in I6 to the
    object number of the direction object. It seems redundant here because
    surely if we know <code class="display"><span class="extract">I</span></code>, we know its runtime representation; but that's not
    true &mdash; we need to call this routine at a time when the final identifier
    names for I6 objects have not yet been settled.
    </p>


    <pre class="display">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">mmp_call_counter</span><span class="plain"> = 0;</span>
        <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::MapDirections::make_mapped_predicate</span><span class="plain">(</span><span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">ident</span><span class="plain">) {</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Instances::get_name</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) || (</span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">) &gt; </span><span class="constant">MAX_WORDS_IN_DIRECTION</span><span class="plain">))</span>
                <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"bad direction name"</span><span class="plain">);</span>
            <span class="identifier">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain"> = </span><span class="identifier">Sentences::Rearrangement::relation_noticed</span><span class="plain">(</span><span class="identifier">mmp_call_counter</span><span class="plain">++);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
                <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Improper text: %W\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ImproperlyMadeDirection</span><span class="plain">),</span>
                    <span class="string">"directions must be created by only the simplest possible sentences"</span><span class="plain">,</span>
                    <span class="string">"in the form 'North-north-west is a direction' only. Using adjectives, "</span>
                    <span class="string">"'called', 'which', and so on is not allowed. (In practice this is not "</span>
                    <span class="string">"too much of a restriction. I won't allow 'Clockwise is a privately-named "</span>
                    <span class="string">"direction.', but I will allow 'Clockwise is a direction. Clockwise "</span>
                    <span class="string">"is privately-named.')"</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="identifier">bp</span><span class="plain">-&gt;</span><span class="identifier">term_details</span><span class="plain">[0] = </span><span class="identifier">BinaryPredicates::new_term</span><span class="plain">(</span><span class="identifier">NULL</span><span class="plain">);</span>
            <span class="identifier">bp</span><span class="plain">-&gt;</span><span class="identifier">term_details</span><span class="plain">[1] = </span><span class="identifier">BinaryPredicates::new_term</span><span class="plain">(</span><span class="identifier">NULL</span><span class="plain">);</span>
            <span class="identifier">BinaryPredicates::set_index_details</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">, </span><span class="string">"room/door"</span><span class="plain">, </span><span class="string">"room/door"</span><span class="plain">);</span>
            <span class="identifier">bp</span><span class="plain">-&gt;</span><span class="identifier">test_function</span><span class="plain"> = </span><span class="identifier">Calculus::Schemas::new</span><span class="plain">(</span><span class="string">"(MapConnection(*2,%n) == *1)"</span><span class="plain">, </span><span class="identifier">ident</span><span class="plain">);</span>
            <span class="identifier">bp</span><span class="plain">-&gt;</span><span class="identifier">make_true_function</span><span class="plain"> = </span><span class="identifier">Calculus::Schemas::new</span><span class="plain">(</span><span class="string">"AssertMapConnection(*2,%n,*1)"</span><span class="plain">, </span><span class="identifier">ident</span><span class="plain">);</span>
            <span class="identifier">bp</span><span class="plain">-&gt;</span><span class="identifier">make_false_function</span><span class="plain"> = </span><span class="identifier">Calculus::Schemas::new</span><span class="plain">(</span><span class="string">"AssertMapUnconnection(*2,%n,*1)"</span><span class="plain">, </span><span class="identifier">ident</span><span class="plain">);</span>
            <span class="identifier">PF_I</span><span class="plain">(</span><span class="identifier">map</span><span class="plain">, </span><span class="identifier">I</span><span class="plain">)-</span><span class="element">&gt;direction_relation</span><span class="plain"> = </span><span class="identifier">bp</span><span class="plain">;</span>
        <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">The function PL::MapDirections::make_mapped_predicate is used in 3/tm (<a href="3-tm.html#SP21_2">&#167;21.2</a>).</p>

    <p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Second stock. </b>By this time, they all exist; there is nothing to add.
    </p>


    <pre class="display">
        <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::MapDirections::REL_create_second_stock</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">The function PL::MapDirections::REL_create_second_stock appears nowhere else.</p>

    <p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Typechecking. </b>This won't catch everything, but it will do. Run-time checking will pick up
    remaining anomalies.
    </p>


    <pre class="display">
        <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::MapDirections::REL_typecheck</span><span class="plain">(</span><span class="identifier">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain">,</span>
                <span class="identifier">kind</span><span class="plain"> **</span><span class="identifier">kinds_of_terms</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> **</span><span class="identifier">kinds_required</span><span class="plain">, </span><span class="identifier">tc_problem_kit</span><span class="plain"> *</span><span class="identifier">tck</span><span class="plain">) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">t</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">t</span><span class="plain">=0; </span><span class="identifier">t</span><span class="plain">&lt;2; </span><span class="identifier">t</span><span class="plain">++)</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Kinds::Compare::compatible</span><span class="plain">(</span><span class="identifier">kinds_of_terms</span><span class="plain">[</span><span class="identifier">t</span><span class="plain">], </span><span class="identifier">K_room</span><span class="plain">) == </span><span class="identifier">NEVER_MATCH</span><span class="plain">) &amp;&amp;</span>
                    <span class="plain">(</span><span class="identifier">Kinds::Compare::compatible</span><span class="plain">(</span><span class="identifier">kinds_of_terms</span><span class="plain">[</span><span class="identifier">t</span><span class="plain">], </span><span class="identifier">K_door</span><span class="plain">) == </span><span class="identifier">NEVER_MATCH</span><span class="plain">)) {</span>
                <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Term %d is $u but should be a room or door\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">t</span><span class="plain">, </span><span class="identifier">kinds_of_terms</span><span class="plain">[</span><span class="identifier">t</span><span class="plain">]);</span>
                <span class="identifier">Calculus::Propositions::Checker::issue_bp_typecheck_error</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">, </span><span class="identifier">kinds_of_terms</span><span class="plain">[0], </span><span class="identifier">kinds_of_terms</span><span class="plain">[1], </span><span class="identifier">tck</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NEVER_MATCH</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">ALWAYS_MATCH</span><span class="plain">;</span>
        <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">The function PL::MapDirections::REL_typecheck appears nowhere else.</p>

    <p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Assertion. </b>Note that the following will infer <code class="display"><span class="extract">IS_ROOM_INF</span></code> for any source of a map
    connection &mdash; which will include doors. That doesn't matter, because the
    Spatial plugin uses these inferences only for objects whose kind is not
    explicitly given in the source text; and doors must always be specified as
    such.
    </p>


    <pre class="display">
        <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::MapDirections::REL_assert</span><span class="plain">(</span><span class="identifier">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain">,</span>
                <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">infs0</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec0</span><span class="plain">,</span>
                <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">infs1</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec1</span><span class="plain">) {</span>
            <span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">o_dir</span><span class="plain"> = </span><span class="functiontext">PL::MapDirections::get_mapping_direction</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">);</span>
            <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">infs_from</span><span class="plain"> = </span><span class="identifier">infs0</span><span class="plain">;</span>
            <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">infs_to</span><span class="plain"> = </span><span class="identifier">infs1</span><span class="plain">;</span>

            <span class="identifier">World::Inferences::draw</span><span class="plain">(</span><span class="constant">IS_ROOM_INF</span><span class="plain">, </span><span class="identifier">infs_from</span><span class="plain">, </span><span class="identifier">prevailing_mood</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prevailing_mood</span><span class="plain"> &gt;= 0) &amp;&amp; (</span><span class="identifier">infs_to</span><span class="plain">))</span>
                <span class="identifier">World::Inferences::draw</span><span class="plain">(</span><span class="constant">IS_ROOM_INF</span><span class="plain">, </span><span class="identifier">infs_to</span><span class="plain">, </span><span class="identifier">LIKELY_CE</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
            <span class="identifier">World::Inferences::draw</span><span class="plain">(</span><span class="constant">DIRECTION_INF</span><span class="plain">, </span><span class="identifier">infs_from</span><span class="plain">, </span><span class="identifier">prevailing_mood</span><span class="plain">,</span>
                <span class="identifier">infs_to</span><span class="plain">, </span><span class="identifier">o_dir</span><span class="plain">?(</span><span class="identifier">Instances::as_subject</span><span class="plain">(</span><span class="identifier">o_dir</span><span class="plain">)):</span><span class="identifier">NULL</span><span class="plain">);</span>

            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">The function PL::MapDirections::REL_assert appears nowhere else.</p>

    <p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Compilation. </b>We need do nothing special: these relations can be compiled from their schemas.
    </p>


    <pre class="display">
        <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::MapDirections::REL_compile</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain">, </span><span class="identifier">annotated_i6_schema</span><span class="plain"> *</span><span class="identifier">asch</span><span class="plain">) {</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">The function PL::MapDirections::REL_compile appears nowhere else.</p>

    <p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Problem message text. </b></p>


    <pre class="display">
        <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::MapDirections::REL_describe_for_problems</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="identifier">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain">) {</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">The function PL::MapDirections::REL_describe_for_problems appears nowhere else.</p>

    <p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. The correspondence with directions. </b>(Speed really does not matter here.)
    </p>


    <pre class="display">
        <span class="identifier">binary_predicate</span><span class="plain"> *</span><span class="functiontext">PL::MapDirections::get_mapping_relation</span><span class="plain">(</span><span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">dir</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">dir</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">PF_I</span><span class="plain">(</span><span class="identifier">map</span><span class="plain">, </span><span class="identifier">dir</span><span class="plain">)-</span><span class="element">&gt;direction_relation</span><span class="plain">;</span>
        <span class="plain">}</span>

        <span class="identifier">instance</span><span class="plain"> *</span><span class="functiontext">PL::MapDirections::get_mapping_direction</span><span class="plain">(</span><span class="identifier">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">;</span>
            <span class="identifier">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">PF_I</span><span class="plain">(</span><span class="identifier">map</span><span class="plain">, </span><span class="identifier">I</span><span class="plain">)-</span><span class="element">&gt;direction_relation</span><span class="plain"> == </span><span class="identifier">bp</span><span class="plain">)</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">I</span><span class="plain">;</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="plain">}</span>

    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">The function PL::MapDirections::get_mapping_relation is used in 3/tm (<a href="3-tm.html#SP36">&#167;36</a>).</p>

    <p class="endnote">The function PL::MapDirections::get_mapping_direction is used in <a href="#SP10">&#167;10</a>.</p>

    <hr class="tocbar">
    <ul class="toc"><li><a href="3-tm.html">Back to 'The Map'</a></li><li><a href="3-sg.html">Continue with 'Spatial Geometry'</a></li></ul><hr class="tocbar">
    <!--End of weave-->
    	</body>
    </html>

