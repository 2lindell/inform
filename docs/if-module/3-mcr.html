<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Map Connection Relations</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Preform-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../compiler.html">compiler tools</a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul><h2>Compiler Webs</h2><ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul><h2>Inbuild Modules</h2><ul>
<li><a href="../supervisor-module/index.html">supervisor</a></li>
</ul><h2>Inform7 Modules</h2><ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="index.html"><span class="selectedlink">if</span></a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul><h2>Inter Modules</h2><ul>
<li><a href="../bytecode-module/index.html">bytecode</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul><h2>Shared Modules</h2><ul>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../html-module/index.html">html</a></li>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Map Connection Relations' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../compiler.html">Inform7 Modules</a></li><li><a href="index.html">if</a></li><li><a href="index.html#3">Chapter 3: Space and Time</a></li><li><b>Map Connection Relations</b></li></ul></div>
<p class="purpose">To define one binary predicate for each map direction, such as "mapped north of".</p>

<ul class="toc"><li><a href="3-mcr.html#SP1">&#167;1. Definitions</a></li><li><a href="3-mcr.html#SP3">&#167;3. The adjacency relation</a></li><li><a href="3-mcr.html#SP5">&#167;5. Initial stock</a></li><li><a href="3-mcr.html#SP6">&#167;6. Subsequent creations</a></li><li><a href="3-mcr.html#SP8">&#167;8. Second stock</a></li><li><a href="3-mcr.html#SP9">&#167;9. Typechecking</a></li><li><a href="3-mcr.html#SP10">&#167;10. Assertion</a></li><li><a href="3-mcr.html#SP11">&#167;11. Compilation</a></li><li><a href="3-mcr.html#SP12">&#167;12. Problem message text</a></li><li><a href="3-mcr.html#SP13">&#167;13. The correspondence with directions</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="commentary firstcommentary"><a id="SP2"></a><b>&#167;2.  </b>This section creates a family of implicit relations (implemented as binary
predicates) corresponding to the different directions.
</p>

<p class="commentary">For every direction created, a predicate is created for the possibility of
a map connection. For instance, "if Versailles is mapped north of the
Metro" tests the "mapped-north" BP. There is also one general relation
built in:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">R_adjacency</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP3"></a><b>&#167;3. The adjacency relation. </b>We may as well do this here: creating the relation "X is adjacent to Y".
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">PL::MapDirections::create_relations</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">PL::MapDirections::create_relations</span></span>:<br/>Spatial Relations - <a href="3-sr.html#SP3">&#167;3</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">R_adjacency</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">BinaryPredicates::make_pair</span><span class="plain-syntax">(</span><span class="identifier-syntax">SPATIAL_KBP</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">BinaryPredicates::new_term</span><span class="plain-syntax">(</span><span class="identifier-syntax">infs_room</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">BinaryPredicates::new_term</span><span class="plain-syntax">(</span><span class="identifier-syntax">infs_room</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">I</span><span class="string-syntax">"adjacent-to"</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"adjacent-from"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">Calculus::Schemas::new</span><span class="plain-syntax">(</span><span class="string-syntax">"TestAdjacency(*1,*2)"</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Preform::Nonparsing::wording</span><span class="plain-syntax">(</span><span class="function-syntax">&lt;relation-names&gt;</span><span class="plain-syntax">, </span><span class="identifier-syntax">ADJACENCY_RELATION_NAME</span><span class="plain-syntax">));</span>

<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4"></a><b>&#167;4.  </b>There is nothing special about asserting this, so we don't intervene:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::MapDirections::assert_relations</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">PL::MapDirections::assert_relations</span></span>:<br/>Spatial Relations - <a href="3-sr.html#SP6_1">&#167;6.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">relation</span><span class="plain-syntax">, </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I0</span><span class="plain-syntax">, </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I1</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP5"></a><b>&#167;5. Initial stock. </b>There is none, since at the start of Inform's run no direction objects exist
yet.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">PL::MapDirections::REL_create_initial_stock</span><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP6"></a><b>&#167;6. Subsequent creations. </b>Every direction created has a relation associated with it: for instance,
"north" has the relation "X is mapped north of Y". Now a direction is a
kind of object, but objects aren't created until after relations used to
parse sentences are needed. In fact, however, directions are "noticed"
at an earlier stage in Inform's run, so another two-step is needed:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="function-syntax">PL::MapDirections::create_sketchy_mapping_direction</span><span class="plain-syntax">(</span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="3-mcr.html#SP6_3" class="named-paragraph-link"><span class="named-paragraph">Create the mapping BP for the new direction</span><span class="named-paragraph-number">6.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">bp</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP6_1"></a><b>&#167;6.1.  </b>When each direction is created, so are corresponding relations and
prepositional uses: for example, "northeast" makes "mapping northeast"
as a relation, and "mapped northeast of" as a prepositional usage.
</p>

<p class="commentary">The rule is actually that production (a) in &lt;mapping-preposition-construction&gt;
is used for all directions except those named in &lt;notable-directions&gt;,
where (b) is used. As a result, we make "mapped inside" and "mapped
outside" instead of "mapped inside of" and "mapped outside of." This
is done to avoid ambiguities with the already-existing meanings of inside
and outside to do with spatial containment.
</p>

<p class="commentary">The use of the word "mapped" may seem itself off. Why define "to be mapped
east of" rather than "to be east of"? After all, that seems to be what is
used in assertions like:
</p>

<blockquote>
    <p>The Bakery is east of Pudding Lane.</p>
</blockquote>

<p class="commentary">In fact, the A-parser reads sentences like that by looking out specially for
direction names plus "of" &mdash; so this is parsed without using the mapping
predicate for "east". But it cannot read:
</p>

<blockquote>
    <p>The Flour Cellar is below the Bakery.</p>
</blockquote>

<p class="commentary">as a direction name plus "of", since "below" is not the name of the direction
"down", and anyway there is no "of".
</p>

<p class="commentary">We do not allow direction names with unexpected capital letters because we
want to allow room names to contain direction names on occasion:
</p>

<blockquote>
    <p>The fire hydrant is in West from 47th Street.</p>
</blockquote>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;mapping-relation-construction&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">mapping</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">...</span>

<span class="Preform-function-syntax">&lt;mapping-preposition-construction&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">mapped</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">of</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">mapped</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">of</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">from</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-prf.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP6_2"></a><b>&#167;6.2.  </b>Two of the directions are special to mapping, because they have to be parsed
slighly differently. (These are the English names; there is no need to translate
this to other languages.)
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;notable-directions&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">inside</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">outside</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-prf.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP6_3"></a><b>&#167;6.3.  </b></p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="Preform-constant-syntax">MAX_MAPPING_RELATION_NAME_LENGTH</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">MAX_WORDS_IN_DIRECTION</span><span class="Preform-plain-syntax">*</span><span class="Preform-identifier-syntax">MAX_WORD_LENGTH</span><span class="Preform-plain-syntax">+10</span>
</pre>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Create the mapping BP for the new direction</span><span class="named-paragraph-number">6.3</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::length</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">MAX_WORDS_IN_DIRECTION</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Wordings::truncate</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="constant-syntax">MAX_WORDS_IN_DIRECTION</span><span class="plain-syntax">); </span><span class="comment-syntax"> just truncate for now</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">relname</span><span class="plain-syntax">); </span><span class="comment-syntax"> for debugging log, e.g., "north-map"</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">relname</span><span class="plain-syntax">, </span><span class="string-syntax">"%W-map"</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_THROUGH_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">pos</span><span class="plain-syntax">, </span><span class="identifier-syntax">relname</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::get</span><span class="plain-syntax">(</span><span class="identifier-syntax">pos</span><span class="plain-syntax">) == </span><span class="character-syntax">' '</span><span class="plain-syntax">) </span><span class="identifier-syntax">Str::put</span><span class="plain-syntax">(</span><span class="identifier-syntax">pos</span><span class="plain-syntax">, </span><span class="character-syntax">'-'</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">bp_term_details</span><span class="plain-syntax"> </span><span class="identifier-syntax">room_term</span><span class="plain-syntax"> = </span><span class="identifier-syntax">BinaryPredicates::new_term</span><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">bp</span><span class="plain-syntax"> = </span><span class="identifier-syntax">BinaryPredicates::make_pair</span><span class="plain-syntax">(</span><span class="identifier-syntax">MAP_CONNECTING_KBP</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">room_term</span><span class="plain-syntax">, </span><span class="identifier-syntax">room_term</span><span class="plain-syntax">, </span><span class="identifier-syntax">relname</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Preform::Nonparsing::merge</span><span class="plain-syntax">(</span><span class="function-syntax">&lt;mapping-relation-construction&gt;</span><span class="plain-syntax">, </span><span class="constant-syntax">0</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WordAssemblages::from_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)));</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">mpc_form</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;notable-directions&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) </span><span class="identifier-syntax">mpc_form</span><span class="plain-syntax"> = </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">preposition_identity</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prep1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Prepositions::make</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Preform::Nonparsing::merge</span><span class="plain-syntax">(</span><span class="function-syntax">&lt;mapping-preposition-construction&gt;</span><span class="plain-syntax">, </span><span class="identifier-syntax">mpc_form</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WordAssemblages::from_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">preposition_identity</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prep2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Prepositions::make</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Preform::Nonparsing::merge</span><span class="plain-syntax">(</span><span class="function-syntax">&lt;mapping-preposition-construction&gt;</span><span class="plain-syntax">, </span><span class="constant-syntax">2</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WordAssemblages::from_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">preposition_identity</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prep3</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Prepositions::make</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Preform::Nonparsing::merge</span><span class="plain-syntax">(</span><span class="function-syntax">&lt;mapping-preposition-construction&gt;</span><span class="plain-syntax">, </span><span class="constant-syntax">3</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WordAssemblages::from_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">verb_meaning</span><span class="plain-syntax"> </span><span class="identifier-syntax">vm</span><span class="plain-syntax"> = </span><span class="identifier-syntax">VerbMeanings::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">bp</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Verbs::add_form</span><span class="plain-syntax">(</span><span class="identifier-syntax">copular_verb</span><span class="plain-syntax">, </span><span class="identifier-syntax">prep1</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">vm</span><span class="plain-syntax">, </span><span class="identifier-syntax">SVO_FS_BIT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Verbs::add_form</span><span class="plain-syntax">(</span><span class="identifier-syntax">copular_verb</span><span class="plain-syntax">, </span><span class="identifier-syntax">prep2</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">vm</span><span class="plain-syntax">, </span><span class="identifier-syntax">SVO_FS_BIT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Verbs::add_form</span><span class="plain-syntax">(</span><span class="identifier-syntax">copular_verb</span><span class="plain-syntax">, </span><span class="identifier-syntax">prep3</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">vm</span><span class="plain-syntax">, </span><span class="identifier-syntax">SVO_FS_BIT</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">relname</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-mcr.html#SP6">&#167;6</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP7"></a><b>&#167;7.  </b>That was one step, and here's the second. At this point we have created the
instance <span class="extract"><span class="extract-syntax">I</span></span> for the direction, and given it the kind "direction". That
makes it possible to complete the details of the BP.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">ident</span></span> can be any string of text which evaluates in I6 to the
object number of the direction object. It seems redundant here because
surely if we know <span class="extract"><span class="extract-syntax">I</span></span>, we know its runtime representation; but that's not
true &mdash; we need to call this routine at a time when the final identifier
names for I6 objects have not yet been settled.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">mmp_call_counter</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">PL::MapDirections::make_mapped_predicate</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">PL::MapDirections::make_mapped_predicate</span></span>:<br/>The Map - <a href="3-tm.html#SP21_2">&#167;21.2</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">inter_name</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ident</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Instances::get_name</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Wordings::empty</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) || (</span><span class="identifier-syntax">Wordings::length</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">MAX_WORDS_IN_DIRECTION</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"bad direction name"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Sentences::Rearrangement::relation_noticed</span><span class="plain-syntax">(</span><span class="identifier-syntax">mmp_call_counter</span><span class="plain-syntax">++);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">bp</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"Improper text: %W\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Problems::Issue::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_ImproperlyMadeDirection</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"directions must be created by only the simplest possible sentences"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"in the form 'North-north-west is a direction' only. Using adjectives, "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"'called', 'which', and so on is not allowed. (In practice this is not "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"too much of a restriction. I won't allow 'Clockwise is a privately-named "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"direction.', but I will allow 'Clockwise is a direction. Clockwise "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"is privately-named.')"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">bp</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">term_details</span><span class="plain-syntax">[0] = </span><span class="identifier-syntax">BinaryPredicates::new_term</span><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">bp</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">term_details</span><span class="plain-syntax">[1] = </span><span class="identifier-syntax">BinaryPredicates::new_term</span><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">BinaryPredicates::set_index_details</span><span class="plain-syntax">(</span><span class="identifier-syntax">bp</span><span class="plain-syntax">, </span><span class="string-syntax">"room/door"</span><span class="plain-syntax">, </span><span class="string-syntax">"room/door"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">bp</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">test_function</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Calculus::Schemas::new</span><span class="plain-syntax">(</span><span class="string-syntax">"(MapConnection(*2,%n) == *1)"</span><span class="plain-syntax">, </span><span class="identifier-syntax">ident</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">bp</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">make_true_function</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Calculus::Schemas::new</span><span class="plain-syntax">(</span><span class="string-syntax">"AssertMapConnection(*2,%n,*1)"</span><span class="plain-syntax">, </span><span class="identifier-syntax">ident</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">bp</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">make_false_function</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Calculus::Schemas::new</span><span class="plain-syntax">(</span><span class="string-syntax">"AssertMapUnconnection(*2,%n,*1)"</span><span class="plain-syntax">, </span><span class="identifier-syntax">ident</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">direction_relation</span><span class="plain-syntax"> = </span><span class="identifier-syntax">bp</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP8"></a><b>&#167;8. Second stock. </b>By this time, they all exist; there is nothing to add.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">PL::MapDirections::REL_create_second_stock</span><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9"></a><b>&#167;9. Typechecking. </b>This won't catch everything, but it will do. Run-time checking will pick up
remaining anomalies.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::MapDirections::REL_typecheck</span><span class="plain-syntax">(</span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> **</span><span class="identifier-syntax">kinds_of_terms</span><span class="plain-syntax">, </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> **</span><span class="identifier-syntax">kinds_required</span><span class="plain-syntax">, </span><span class="identifier-syntax">tc_problem_kit</span><span class="plain-syntax"> *</span><span class="identifier-syntax">tck</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">t</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">t</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">t</span><span class="plain-syntax">&lt;2; </span><span class="identifier-syntax">t</span><span class="plain-syntax">++)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Kinds::Compare::compatible</span><span class="plain-syntax">(</span><span class="identifier-syntax">kinds_of_terms</span><span class="plain-syntax">[</span><span class="identifier-syntax">t</span><span class="plain-syntax">], </span><span class="identifier-syntax">K_room</span><span class="plain-syntax">) == </span><span class="identifier-syntax">NEVER_MATCH</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">Kinds::Compare::compatible</span><span class="plain-syntax">(</span><span class="identifier-syntax">kinds_of_terms</span><span class="plain-syntax">[</span><span class="identifier-syntax">t</span><span class="plain-syntax">], </span><span class="identifier-syntax">K_door</span><span class="plain-syntax">) == </span><span class="identifier-syntax">NEVER_MATCH</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"Term %d is $u but should be a room or door\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">t</span><span class="plain-syntax">, </span><span class="identifier-syntax">kinds_of_terms</span><span class="plain-syntax">[</span><span class="identifier-syntax">t</span><span class="plain-syntax">]);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Calculus::Propositions::Checker::issue_bp_typecheck_error</span><span class="plain-syntax">(</span><span class="identifier-syntax">bp</span><span class="plain-syntax">, </span><span class="identifier-syntax">kinds_of_terms</span><span class="plain-syntax">[0], </span><span class="identifier-syntax">kinds_of_terms</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">tck</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NEVER_MATCH</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">ALWAYS_MATCH</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10"></a><b>&#167;10. Assertion. </b>Note that the following will infer <span class="extract"><span class="extract-syntax">IS_ROOM_INF</span></span> for any source of a map
connection &mdash; which will include doors. That doesn't matter, because the
Spatial plugin uses these inferences only for objects whose kind is not
explicitly given in the source text; and doors must always be specified as
such.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::MapDirections::REL_assert</span><span class="plain-syntax">(</span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs0</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec0</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs1</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec1</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">o_dir</span><span class="plain-syntax"> = </span><a href="3-mcr.html#SP13" class="function-link"><span class="function-syntax">PL::MapDirections::get_mapping_direction</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">bp</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">infs0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs_to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">infs1</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">World::Inferences::draw</span><span class="plain-syntax">(</span><span class="constant-syntax">IS_ROOM_INF</span><span class="plain-syntax">, </span><span class="identifier-syntax">infs_from</span><span class="plain-syntax">, </span><span class="identifier-syntax">prevailing_mood</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">prevailing_mood</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">0</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">infs_to</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">World::Inferences::draw</span><span class="plain-syntax">(</span><span class="constant-syntax">IS_ROOM_INF</span><span class="plain-syntax">, </span><span class="identifier-syntax">infs_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">LIKELY_CE</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">World::Inferences::draw</span><span class="plain-syntax">(</span><span class="constant-syntax">DIRECTION_INF</span><span class="plain-syntax">, </span><span class="identifier-syntax">infs_from</span><span class="plain-syntax">, </span><span class="identifier-syntax">prevailing_mood</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">infs_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">o_dir</span><span class="plain-syntax">?(</span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">o_dir</span><span class="plain-syntax">)):</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP11"></a><b>&#167;11. Compilation. </b>We need do nothing special: these relations can be compiled from their schemas.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::MapDirections::REL_compile</span><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">task</span><span class="plain-syntax">, </span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax">, </span><span class="identifier-syntax">annotated_i6_schema</span><span class="plain-syntax"> *</span><span class="identifier-syntax">asch</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP12"></a><b>&#167;12. Problem message text. </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::MapDirections::REL_describe_for_problems</span><span class="plain-syntax">(</span><span class="identifier-syntax">OUTPUT_STREAM</span><span class="plain-syntax">, </span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP13"></a><b>&#167;13. The correspondence with directions. </b>(Speed really does not matter here.)
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="function-syntax">PL::MapDirections::get_mapping_relation</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">PL::MapDirections::get_mapping_relation</span></span>:<br/>The Map - <a href="3-tm.html#SP36">&#167;36</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">dir</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">dir</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">dir</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">direction_relation</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="function-syntax">PL::MapDirections::get_mapping_direction</span><button class="popup" onclick="togglePopup('usagePopup5')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup5">Usage of <span class="code-font"><span class="function-syntax">PL::MapDirections::get_mapping_direction</span></span>:<br/><a href="3-mcr.html#SP10">&#167;10</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">bp</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">direction_relation</span><span class="plain-syntax"> == </span><span class="identifier-syntax">bp</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="3-tm.html">&#10094;</a></li><li class="progresschapter"><a href="1-im.html">1</a></li><li class="progresschapter"><a href="2-ifi.html">2</a></li><li class="progresscurrentchapter">3</li><li class="progresssection"><a href="3-tnt.html">tnt</a></li><li class="progresssection"><a href="3-sm.html">sm</a></li><li class="progresssection"><a href="3-sr.html">sr</a></li><li class="progresssection"><a href="3-prs.html">prs</a></li><li class="progresssection"><a href="3-tp.html">tp</a></li><li class="progresssection"><a href="3-dvc.html">dvc</a></li><li class="progresssection"><a href="3-bck.html">bck</a></li><li class="progresssection"><a href="3-rgn.html">rgn</a></li><li class="progresssection"><a href="3-tm.html">tm</a></li><li class="progresscurrent">mcr</li><li class="progresssection"><a href="3-sg.html">sg</a></li><li class="progresssection"><a href="3-sm2.html">sm2</a></li><li class="progresssection"><a href="3-hm.html">hm</a></li><li class="progresssection"><a href="3-em.html">em</a></li><li class="progresssection"><a href="3-sc.html">sc</a></li><li class="progresssection"><a href="3-scn.html">scn</a></li><li class="progresssection"><a href="3-tm2.html">tm2</a></li><li class="progresssection"><a href="3-ts.html">ts</a></li><li class="progresschapter"><a href="4-act.html">4</a></li><li class="progresschapter"><a href="5-itg.html">5</a></li><li class="progressnext"><a href="3-sg.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

