<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>2/ri</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../compiler.html"><b>compiler</b></a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul>
<h2>Compiler Webs</h2>
<ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul>
<h2>Inbuild Modules</h2>
<ul>
<li><a href="../inbuild-module/index.html">inbuild</a></li>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../html-module/index.html">html</a></li>
</ul>
<h2>Inform7 Modules</h2>
<ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul>
<h2>Inter Modules</h2>
<ul>
<li><a href="../inter-module/index.html">inter</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of '3/tnt' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="../compiler.html">Compiler Modules</a></li><li><a href="index.html">if</a></li><li><a href="index.html#3">Chapter 3: Space and Time</a></li><li><b>The Naming Thicket</b></li></ul><p class="purpose">Inform has a thicket of properties to do with names: not just the name itself, but whether it is a plural, a proper name, and so on. Here we look after these properties, and give them their initial states.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP4">&#167;4. Plugin startup</a></li><li><a href="#SP5">&#167;5. Recognising significant properties</a></li><li><a href="#SP7">&#167;7. Proper named, plural named, definite article</a></li><li><a href="#SP9">&#167;9. Transferring name details</a></li><li><a href="#SP10">&#167;10. Private naming</a></li><li><a href="#SP11">&#167;11. Model completion</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>A few properties are treated specially by Inform, and need to have their
references stored in global variables. They are set as they are created,
during the parsing of assertions in the Standard Rules.
</p>


<pre class="display">
    <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">P_proper_named</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">an either/or property for names</span>
    <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">P_plural_named</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">an either/or property for names</span>
    <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">P_neuter</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">an either/or property for names</span>
    <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">P_female</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">an either/or property for names</span>
    <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">P_article</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">a value property for names</span>
    <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">P_privately_named</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">P_printed_name</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">P_printed_plural_name</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">P_cap_short_name</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">P_adaptive_text_viewpoint</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>We need to accumulate routines used for naming properties in a separate
stream, though there aren't very many of them.
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">short_name_notice</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">routine_iname</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">snn_iname</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">namee</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">after_subject</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">capped</span><span class="plain">;</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">short_name_notice</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure short_name_notice is private to this section.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Plugin startup. </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Naming::start</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">PLUGIN_REGISTER</span><span class="plain">(</span><span class="identifier">PLUGIN_NEW_PROPERTY_NOTIFY</span><span class="plain">, </span><span class="functiontext">PL::Naming::naming_new_property_notify</span><span class="plain">);</span>
        <span class="identifier">PLUGIN_REGISTER</span><span class="plain">(</span><span class="identifier">PLUGIN_COMPLETE_MODEL</span><span class="plain">, </span><span class="functiontext">PL::Naming::naming_complete_model</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Naming::start appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Recognising significant properties. </b>These are property names to do with naming which Inform provides special
support for; it recognises the English names when they are defined by the
Standard Rules. (So there is no need to translate this to other languages.)
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">notable</span><span class="plain">-</span><span class="identifier">naming</span><span class="plain">-</span><span class="identifier">properties</span><span class="plain">&gt; ::=</span>
        <span class="identifier">indefinite</span><span class="plain"> </span><span class="identifier">article</span><span class="plain"> |</span>
        <span class="identifier">plural</span><span class="plain">-</span><span class="identifier">named</span><span class="plain"> |</span>
        <span class="identifier">proper</span><span class="plain">-</span><span class="identifier">named</span><span class="plain"> |</span>
        <span class="identifier">printed</span><span class="plain"> </span><span class="identifier">name</span><span class="plain"> |</span>
        <span class="identifier">printed</span><span class="plain"> </span><span class="identifier">plural</span><span class="plain"> </span><span class="identifier">name</span><span class="plain"> |</span>
        <span class="identifier">publicly</span><span class="plain">-</span><span class="identifier">named</span><span class="plain"> |</span>
        <span class="identifier">privately</span><span class="plain">-</span><span class="identifier">named</span><span class="plain"> |</span>
        <span class="identifier">adaptive</span><span class="plain"> </span><span class="identifier">text</span><span class="plain"> </span><span class="identifier">viewpoint</span><span class="plain"> |</span>
        <span class="identifier">neuter</span><span class="plain"> |</span>
        <span class="identifier">female</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Naming::naming_new_property_notify</span><span class="plain">(</span><span class="identifier">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">notable</span><span class="plain">-</span><span class="identifier">naming</span><span class="plain">-</span><span class="identifier">properties</span><span class="plain">&gt;(</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain">)) {</span>
            <span class="reserved">switch</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;) {</span>
                <span class="reserved">case</span><span class="plain"> 0: </span><span class="identifier">P_article</span><span class="plain"> = </span><span class="identifier">prn</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> 1: </span><span class="identifier">P_plural_named</span><span class="plain"> = </span><span class="identifier">prn</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> 2: </span><span class="identifier">P_proper_named</span><span class="plain"> = </span><span class="identifier">prn</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> 3: </span><span class="identifier">P_printed_name</span><span class="plain"> = </span><span class="identifier">prn</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> 4: </span><span class="identifier">P_printed_plural_name</span><span class="plain"> = </span><span class="identifier">prn</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> 5: </span><span class="identifier">Properties::exclude_from_index</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> 6: </span><span class="identifier">P_privately_named</span><span class="plain"> = </span><span class="identifier">prn</span><span class="plain">; </span>    <span class="comment">this is the negation of "publicly named"</span>
                    <span class="identifier">Properties::exclude_from_index</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> 7: </span><span class="identifier">P_adaptive_text_viewpoint</span><span class="plain"> = </span><span class="identifier">prn</span><span class="plain">;</span>
                    <span class="identifier">Properties::exclude_from_index</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> 8: </span><span class="identifier">P_neuter</span><span class="plain"> = </span><span class="identifier">prn</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> 9: </span><span class="identifier">P_female</span><span class="plain"> = </span><span class="identifier">prn</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Naming::naming_new_property_notify is used in <a href="#SP4">&#167;4</a>.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Proper named, plural named, definite article. </b>Only objects can be proper-named or plural-named, so we do nothing if told by
the Creator to make something else have a proper name.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Naming::now_has_proper_name</span><span class="plain">(</span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">) {</span>
        <span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">wto</span><span class="plain"> = </span><span class="identifier">InferenceSubjects::as_object_instance</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wto</span><span class="plain">) </span><span class="functiontext">PL::Naming::object_now_has_proper_name</span><span class="plain">(</span><span class="identifier">wto</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Naming::object_now_has_proper_name</span><span class="plain">(</span><span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">P_proper_named</span><span class="plain">)</span>
            <span class="identifier">Properties::EitherOr::assert</span><span class="plain">(</span><span class="identifier">P_proper_named</span><span class="plain">,</span>
                <span class="identifier">Instances::as_subject</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">), </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">LIKELY_CE</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Naming::object_now_has_plural_name</span><span class="plain">(</span><span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">P_plural_named</span><span class="plain">)</span>
            <span class="identifier">Properties::EitherOr::assert</span><span class="plain">(</span><span class="identifier">P_plural_named</span><span class="plain">,</span>
                <span class="identifier">Instances::as_subject</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">), </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">LIKELY_CE</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Naming::now_has_proper_name is used in <a href="#SP9">&#167;9</a>.</p>

<p class="endnote">The function PL::Naming::object_now_has_proper_name appears nowhere else.</p>

<p class="endnote">The function PL::Naming::object_now_has_plural_name appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>It's a rather ugly fact of Inform 6 life that we indicate something is
unique, yet not proper-named, by giving it the indefinite article "the";
thus the following routine is called for creations of directions ("the north")
and where "called..." absolutely requires the definite article ("There is
a room called the Counting House").
</p>

<p class="inwebparagraph">We cache the text literal "the" rather than create it over and over.
</p>


<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">text_of_word_the</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Naming::object_takes_definite_article</span><span class="plain">(</span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">text_of_word_the</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)</span>
            <span class="identifier">text_of_word_the</span><span class="plain"> = </span><span class="identifier">Rvalues::from_wording</span><span class="plain">(</span><span class="identifier">Feeds::feed_text</span><span class="plain">(</span><span class="identifier">L</span><span class="string">"\</span><span class="plain">"</span><span class="string">the\</span><span class="plain">"</span><span class="string">"</span><span class="plain">));</span>
        <span class="identifier">Properties::Valued::assert</span><span class="plain">(</span><span class="identifier">P_article</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">text_of_word_the</span><span class="plain">, </span><span class="identifier">LIKELY_CE</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Naming::object_takes_definite_article is used in 3/tm (<a href="3-tm.html#SP21">&#167;21</a>).</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Transferring name details. </b>This is needed when assemblies name one new creation after another; for instance,
"Cleopatra's nose" must be proper-named because "Cleopatra" is.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Naming::transfer_details</span><span class="plain">(</span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">from</span><span class="plain">, </span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">to</span><span class="plain">) {</span>
        <span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">wto</span><span class="plain"> = </span><span class="identifier">InferenceSubjects::as_object_instance</span><span class="plain">(</span><span class="identifier">to</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wto</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">World::Inferences::get_EO_state</span><span class="plain">(</span><span class="identifier">from</span><span class="plain">, </span><span class="identifier">P_proper_named</span><span class="plain">) &gt; 0)</span>
                <span class="functiontext">PL::Naming::now_has_proper_name</span><span class="plain">(</span><span class="identifier">to</span><span class="plain">);</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">art</span><span class="plain"> = </span><span class="identifier">World::Inferences::get_prop_state</span><span class="plain">(</span><span class="identifier">from</span><span class="plain">, </span><span class="identifier">P_article</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">art</span><span class="plain">) </span><span class="identifier">Properties::Valued::assert</span><span class="plain">(</span><span class="identifier">P_article</span><span class="plain">, </span><span class="identifier">to</span><span class="plain">, </span><span class="identifier">art</span><span class="plain">, </span><span class="identifier">LIKELY_CE</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="identifier">instance</span><span class="plain"> *</span><span class="functiontext">PL::Naming::object_this_is_named_after</span><span class="plain">(</span><span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">InferenceSubjects::as_object_instance</span><span class="plain">(</span>
            <span class="identifier">Assertions::Assemblies::what_this_is_named_after</span><span class="plain">(</span>
                <span class="identifier">Instances::as_subject</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">)));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Naming::transfer_details appears nowhere else.</p>

<p class="endnote">The function PL::Naming::object_this_is_named_after is used in <a href="#SP11_1">&#167;11.1</a>, <a href="#SP14">&#167;14</a>.</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Private naming. </b>"Privately named" is a property which affects the parsing of commands; all
we do here is provide its state on request.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Naming::object_is_privately_named</span><span class="plain">(</span><span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">certainty</span><span class="plain"> = </span><span class="identifier">World::Inferences::get_EO_state</span><span class="plain">(</span><span class="identifier">Instances::as_subject</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">), </span><span class="identifier">P_privately_named</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">certainty</span><span class="plain"> &gt; 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">certainty</span><span class="plain"> &lt; 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NOT_APPLICABLE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Naming::object_is_privately_named is used in 5/gp (<a href="5-gp.html#SP10_1">&#167;10.1</a>).</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Model completion. </b>Quite a lot of work is entailed in producing all of the necessary I6 properties
to fill in the naming details for objects, so here goes.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Naming::naming_complete_model</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">stage</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">stage</span><span class="plain"> == 3) </span>&lt;<span class="cwebmacro">Add naming properties implicit from context</span> <span class="cwebmacronumber">11.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Naming::naming_complete_model is used in <a href="#SP4">&#167;4</a>.</p>

<p class="inwebparagraph"><a id="SP11_1"></a><b>&#167;11.1.  </b>Stage 3 of world model completion is adding properties not inferred directly
from sentences, and this can include I6 properties with no I7 analogue.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Add naming properties implicit from context</span> <span class="cwebmacronumber">11.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_BASE_KINDS</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::lt</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)) {</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_name_in_play</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">Projects::get_language_of_play</span><span class="plain">(</span><span class="identifier">Task::project</span><span class="plain">()));</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_name_in_play</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">Projects::get_language_of_play</span><span class="plain">(</span><span class="identifier">Task::project</span><span class="plain">()));</span>
                <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain"> = </span><span class="identifier">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
                &lt;<span class="cwebmacro">Issue problem message if the name contains a comma</span> <span class="cwebmacronumber">11.1.1</span>&gt;<span class="plain">;</span>
                &lt;<span class="cwebmacro">Assert the printed plural name property for kinds other than thing or kinds of room</span> <span class="cwebmacronumber">11.1.3</span>&gt;<span class="plain">;</span>
            <span class="plain">}</span>
        <span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">) {</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Instances::get_name_in_play</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain"> = </span><span class="identifier">Instances::as_subject</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">this_is_a_room</span><span class="plain"> = </span><span class="functiontext">PL::Spatial::object_is_a_room</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">this_has_a_printed_name</span><span class="plain"> = </span><span class="functiontext">PL::Naming::look_for_printed_name</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">);</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">this_is_named_for_something_with_a_printed_name</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">PL::Naming::object_this_is_named_after</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">))</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">PL::Naming::look_for_printed_name</span><span class="plain">(</span>
                    <span class="identifier">Instances::as_subject</span><span class="plain">(</span><span class="functiontext">PL::Naming::object_this_is_named_after</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">))))</span>
                    <span class="identifier">this_is_named_for_something_with_a_printed_name</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            &lt;<span class="cwebmacro">Issue problem message if the name contains a comma</span> <span class="cwebmacronumber">11.1.1</span>&gt;<span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">this_has_a_printed_name</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) </span>&lt;<span class="cwebmacro">Assert the printed name property</span> <span class="cwebmacronumber">11.1.2</span>&gt;<span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Projects::get_language_of_play</span><span class="plain">(</span><span class="identifier">Task::project</span><span class="plain">()) != </span><span class="identifier">English_language</span><span class="plain">)</span>
                &lt;<span class="cwebmacro">Assert male, female, neuter adjectives from grammatical gender</span> <span class="cwebmacronumber">11.1.4</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11">&#167;11</a>.</p>

<p class="inwebparagraph"><a id="SP11_1_1"></a><b>&#167;11.1.1.  </b>This was added in beta-testing when it turned out that mistakes in coding
sometimes created unlikely objects: for example, "In the Building is a
person called Wallace, Gromit Too." creates a single object. Its name contains
a comma, and that's caught here:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Issue problem message if the name contains a comma</span> <span class="cwebmacronumber">11.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">j</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Lexer::word</span><span class="plain">(</span><span class="identifier">j</span><span class="plain">) == </span><span class="identifier">COMMA_V</span><span class="plain">) {</span>
                <span class="identifier">Problems::Issue::subject_creation_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_CommaInName</span><span class="plain">),</span>
                    <span class="identifier">subj</span><span class="plain">,</span>
                    <span class="string">"has a comma in its name"</span><span class="plain">,</span>
                    <span class="string">"which is forbidden. Perhaps you used a comma in "</span>
                    <span class="string">"punctuating a sentence? Inform generally doesn't "</span>
                    <span class="string">"like this because it reserves commas for specific "</span>
                    <span class="string">"purposes such as dividing rules or 'if' phrases."</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Vocabulary::test_flags</span><span class="plain">(</span><span class="identifier">j</span><span class="plain">, </span><span class="identifier">TEXT_MC</span><span class="plain">+</span><span class="identifier">TEXTWITHSUBS_MC</span><span class="plain">)) {</span>
                <span class="identifier">Problems::Issue::subject_creation_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">),</span>
                    <span class="identifier">subj</span><span class="plain">,</span>
                    <span class="string">"has some double-quoted text in its name"</span><span class="plain">,</span>
                    <span class="string">"which is forbidden. Perhaps something odd happened "</span>
                    <span class="string">"to do with punctuation between sentences? Or perhaps "</span>
                    <span class="string">"you really do need the item to be described with "</span>
                    <span class="string">"literal quotation marks on screen when the player "</span>
                    <span class="string">"sees it. If so, try giving it a printed name: perhaps "</span>
                    <span class="string">"'The printed name of Moby Dick is \</span><span class="plain">"</span><span class="string">'Moby Dick'\</span><span class="plain">"</span><span class="string">.'"</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11_1">&#167;11.1</a> (twice).</p>

<p class="inwebparagraph"><a id="SP11_1_2"></a><b>&#167;11.1.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Assert the printed name property</span> <span class="cwebmacronumber">11.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">this_has_a_printed_name</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Instances::get_name_in_play</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
                <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">k</span><span class="plain"> = </span><span class="identifier">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
                <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_name_in_play</span><span class="plain">(</span><span class="identifier">k</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">Projects::get_language_of_play</span><span class="plain">(</span><span class="identifier">Task::project</span><span class="plain">()));</span>
            <span class="plain">}</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">begins_with_lower_case</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
                <span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">Lexer::word_raw_text</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Characters::islower</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">[0])) </span><span class="identifier">begins_with_lower_case</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">}</span>
            &lt;<span class="cwebmacro">Assert the I6 short-name property</span> <span class="cwebmacronumber">11.1.2.1</span>&gt;<span class="plain">;</span>
            &lt;<span class="cwebmacro">Assert the I6 cap-short-name property</span> <span class="cwebmacronumber">11.1.2.2</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11_1">&#167;11.1</a>.</p>

<p class="inwebparagraph"><a id="SP11_1_2_1"></a><b>&#167;11.1.2.1.  </b>The I7 property "printed name" translates to I6 <code class="display"><span class="extract">short_name</span></code>.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Assert the I6 short-name property</span> <span class="cwebmacronumber">11.1.2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">faux</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">PROP</span><span class="plain"> = </span><span class="identifier">Str::new</span><span class="plain">();</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">this_is_named_for_something_with_a_printed_name</span><span class="plain">)</span>
            &lt;<span class="cwebmacro">Compose the I6 short-name as a routine dynamically using its owner's short-name</span> <span class="cwebmacronumber">11.1.2.1.2</span>&gt;
        <span class="reserved">else</span><span class="plain"> </span>&lt;<span class="cwebmacro">Compose the I6 short-name as a piece of text</span> <span class="cwebmacronumber">11.1.2.1.1</span>&gt;<span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">faux</span><span class="plain">)</span>
            <span class="identifier">Properties::Valued::assert</span><span class="plain">(</span><span class="identifier">P_printed_name</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">,</span>
                <span class="identifier">Rvalues::from_iname</span><span class="plain">(</span><span class="identifier">faux</span><span class="plain">), </span><span class="identifier">CERTAIN_CE</span><span class="plain">);</span>
        <span class="reserved">else</span>
            <span class="identifier">Properties::Valued::assert</span><span class="plain">(</span><span class="identifier">P_printed_name</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">,</span>
                <span class="identifier">Rvalues::from_unescaped_wording</span><span class="plain">(</span><span class="identifier">Feeds::feed_stream</span><span class="plain">(</span><span class="identifier">PROP</span><span class="plain">)), </span><span class="identifier">CERTAIN_CE</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11_1_2">&#167;11.1.2</a>.</p>

<p class="inwebparagraph"><a id="SP11_1_2_2"></a><b>&#167;11.1.2.2.  </b>The I6 <code class="display"><span class="extract">cap_short_name</span></code> has no corresponding property in I7. Note that it's
only needed if the object is named after something else which might need it,
or if it's a proper-named object which begins with a lower-case letter. (This
actually means it's rarely needed.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Assert the I6 cap-short-name property</span> <span class="cwebmacronumber">11.1.2.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">faux</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">set_csn</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">PROP</span><span class="plain"> = </span><span class="identifier">Str::new</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">this_is_named_for_something_with_a_printed_name</span><span class="plain">) {</span>
            &lt;<span class="cwebmacro">Compose the I6 cap-short-name as a routine dynamically using its owner's cap-short-name</span> <span class="cwebmacronumber">11.1.2.2.2</span>&gt;
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">World::Inferences::get_EO_state</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">P_proper_named</span><span class="plain">) &gt; 0)</span>
                <span class="plain">&amp;&amp; (</span><span class="identifier">begins_with_lower_case</span><span class="plain">))</span>
                &lt;<span class="cwebmacro">Compose the I6 cap-short-name as a piece of text</span> <span class="cwebmacronumber">11.1.2.2.1</span>&gt;
            <span class="reserved">else</span><span class="plain"> </span><span class="identifier">set_csn</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">set_csn</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">P_cap_short_name</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
                <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">property_iname</span><span class="plain"> = </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">CAPSHORTNAME_HL</span><span class="plain">);</span>
                <span class="identifier">P_cap_short_name</span><span class="plain"> = </span><span class="identifier">Properties::Valued::new_nameless_using</span><span class="plain">(</span>
                    <span class="identifier">K_text</span><span class="plain">, </span><span class="identifier">Kinds::Behaviour::package</span><span class="plain">(</span><span class="identifier">K_object</span><span class="plain">), </span><span class="identifier">property_iname</span><span class="plain">);</span>
                <span class="identifier">Hierarchy::make_available</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">property_iname</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">faux</span><span class="plain">)</span>
                <span class="identifier">Properties::Valued::assert</span><span class="plain">(</span><span class="identifier">P_cap_short_name</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">,</span>
                    <span class="identifier">Rvalues::from_iname</span><span class="plain">(</span><span class="identifier">faux</span><span class="plain">), </span><span class="identifier">CERTAIN_CE</span><span class="plain">);</span>
            <span class="reserved">else</span>
                <span class="identifier">Properties::Valued::assert</span><span class="plain">(</span><span class="identifier">P_cap_short_name</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">,</span>
                    <span class="identifier">Rvalues::from_unescaped_wording</span><span class="plain">(</span><span class="identifier">Feeds::feed_stream</span><span class="plain">(</span><span class="identifier">PROP</span><span class="plain">)), </span><span class="identifier">CERTAIN_CE</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11_1_2">&#167;11.1.2</a>.</p>

<p class="inwebparagraph"><a id="SP11_1_2_1_1"></a><b>&#167;11.1.2.1.1.  </b>Note that it is important here to preserve the cases of the original
source text description, so that "Mr Beebe" will not be flattened to "mr
beebe"; but that we take care to reduce the case of "Your nose" (etc.)
to "your nose", unless it occurs in the name of a room, like "Your Bedroom".
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Compose the I6 short-name as a piece of text</span> <span class="cwebmacronumber">11.1.2.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="functiontext">PL::Naming::compose_words_to_I6_naming_text</span><span class="plain">(</span><span class="identifier">PROP</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, (</span><span class="identifier">this_is_a_room</span><span class="plain">)?</span><span class="identifier">FALSE</span><span class="plain">:</span><span class="identifier">TRUE</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11_1_2_1">&#167;11.1.2.1</a>.</p>

<p class="inwebparagraph"><a id="SP11_1_2_2_1"></a><b>&#167;11.1.2.2.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compose the I6 cap-short-name as a piece of text</span> <span class="cwebmacronumber">11.1.2.2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="functiontext">PL::Naming::compose_words_to_I6_naming_text</span><span class="plain">(</span><span class="identifier">PROP</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, (</span><span class="identifier">this_is_a_room</span><span class="plain">)?</span><span class="identifier">FALSE</span><span class="plain">:</span><span class="identifier">TRUE</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11_1_2_2">&#167;11.1.2.2</a>.</p>

<p class="inwebparagraph"><a id="SP11_1_2_1_2"></a><b>&#167;11.1.2.1.2.  </b>The following need to be routines so that the printed name will dynamically
change if the owner changes its own printed name during play: e.g. if the
"masked maiden" changes to "Cleopatra", then "masked maiden's nose"
must become "Cleopatra's nose", or at least several bug-reporters thought
so. These routines allow that to happen.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Compose the I6 short-name as a routine dynamically using its owner's short-name</span> <span class="cwebmacronumber">11.1.2.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">short_name_notice</span><span class="plain"> *</span><span class="identifier">notice</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">short_name_notice</span><span class="plain">);</span>
        <span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;routine_iname</span><span class="plain"> = </span><span class="identifier">Hierarchy::make_iname_in</span><span class="plain">(</span><span class="identifier">SHORT_NAME_FN_HL</span><span class="plain">, </span><span class="identifier">Instances::package</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
        <span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;namee</span><span class="plain"> = </span><span class="identifier">I</span><span class="plain">;</span>
        <span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;after_subject</span><span class="plain"> = </span><span class="identifier">subj</span><span class="plain">;</span>
        <span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;capped</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;snn_iname</span><span class="plain"> = </span><span class="identifier">Hierarchy::make_iname_in</span><span class="plain">(</span><span class="identifier">SHORT_NAME_PROPERTY_FN_HL</span><span class="plain">, </span><span class="identifier">Instances::package</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
        <span class="identifier">faux</span><span class="plain"> = </span><span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;snn_iname</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11_1_2_1">&#167;11.1.2.1</a>.</p>

<p class="inwebparagraph"><a id="SP11_1_2_2_2"></a><b>&#167;11.1.2.2.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compose the I6 cap-short-name as a routine dynamically using its owner's cap-short-name</span> <span class="cwebmacronumber">11.1.2.2.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">short_name_notice</span><span class="plain"> *</span><span class="identifier">notice</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">short_name_notice</span><span class="plain">);</span>
        <span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;routine_iname</span><span class="plain"> = </span><span class="identifier">Hierarchy::make_iname_in</span><span class="plain">(</span><span class="identifier">SHORT_NAME_FN_HL</span><span class="plain">, </span><span class="identifier">Instances::package</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
        <span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;namee</span><span class="plain"> = </span><span class="identifier">I</span><span class="plain">;</span>
        <span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;after_subject</span><span class="plain"> = </span><span class="identifier">subj</span><span class="plain">;</span>
        <span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;capped</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;snn_iname</span><span class="plain"> = </span><span class="identifier">Hierarchy::make_iname_in</span><span class="plain">(</span><span class="identifier">SHORT_NAME_PROPERTY_FN_HL</span><span class="plain">, </span><span class="identifier">Instances::package</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
        <span class="identifier">faux</span><span class="plain"> = </span><span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;snn_iname</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11_1_2_2">&#167;11.1.2.2</a>.</p>

<p class="inwebparagraph"><a id="SP11_1_3"></a><b>&#167;11.1.3.  </b>Lastly, then. We don't give this to kinds of room, because it's never necessary
to pluralise them at run-time in practice, so it would carry an unnecessary cost
in Z-machine memory. We don't give it to "thing" because this would be too
vague, and might cause Inform at run-time to spuriously group unrelated things
together in lists.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Assert the printed plural name property for kinds other than thing or kinds of room</span> <span class="cwebmacronumber">11.1.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_room</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">Kinds::Compare::eq</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_thing</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">World::Inferences::get_prop_state_without_inheritance</span><span class="plain">(</span>
                <span class="identifier">subj</span><span class="plain">, </span><span class="identifier">P_printed_plural_name</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">) == </span><span class="identifier">NULL</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">PW</span><span class="plain">)) {</span>
                <span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">PROP</span><span class="plain"> = </span><span class="identifier">Str::new</span><span class="plain">();</span>
                <span class="functiontext">PL::Naming::compose_words_to_I6_naming_text</span><span class="plain">(</span><span class="identifier">PROP</span><span class="plain">, </span><span class="identifier">PW</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
                <span class="identifier">Properties::Valued::assert</span><span class="plain">(</span><span class="identifier">P_printed_plural_name</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">,</span>
                    <span class="identifier">Rvalues::from_unescaped_wording</span><span class="plain">(</span><span class="identifier">Feeds::feed_stream</span><span class="plain">(</span><span class="identifier">PROP</span><span class="plain">)), </span><span class="identifier">CERTAIN_CE</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11_1">&#167;11.1</a>.</p>

<p class="inwebparagraph"><a id="SP11_1_4"></a><b>&#167;11.1.4.  </b>The following isn't done in English.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Assert male, female, neuter adjectives from grammatical gender</span> <span class="cwebmacronumber">11.1.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">World::Inferences::get_prop_state</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">P_grammatical_gender</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">spec</span><span class="plain">) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">g</span><span class="plain"> = </span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">constant_enumeration_ANNOT</span><span class="plain">);</span>
            <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">g</span><span class="plain">) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">NEUTER_GENDER</span><span class="plain">:</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">World::Permissions::grant</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">P_neuter</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">))</span>
                        <span class="identifier">Properties::EitherOr::assert</span><span class="plain">(</span><span class="identifier">P_neuter</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">LIKELY_CE</span><span class="plain">);</span>
                    <span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">MASCULINE_GENDER</span><span class="plain">:</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">World::Permissions::grant</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">P_female</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">))</span>
                        <span class="identifier">Properties::EitherOr::assert</span><span class="plain">(</span><span class="identifier">P_female</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">LIKELY_CE</span><span class="plain">);</span>
                    <span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">FEMININE_GENDER</span><span class="plain">:</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">World::Permissions::grant</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">P_female</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">))</span>
                        <span class="identifier">Properties::EitherOr::assert</span><span class="plain">(</span><span class="identifier">P_female</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">LIKELY_CE</span><span class="plain">);</span>
                    <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11_1">&#167;11.1</a>.</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b>We needed the following utility above. Note that only printed names
inferred from sentences count here &mdash; not printed names added in model
completion. (This is important because we might be working on these objects
in any order, and might have completed X but not Y where either X is named
after Y or vice versa.)
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Naming::look_for_printed_name</span><span class="plain">(</span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain">) {</span>
        <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">check</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">check</span><span class="plain"> = </span><span class="identifier">subj</span><span class="plain">; </span><span class="identifier">check</span><span class="plain">; </span><span class="identifier">check</span><span class="plain"> = </span><span class="identifier">InferenceSubjects::narrowest_broader_subject</span><span class="plain">(</span><span class="identifier">check</span><span class="plain">)) {</span>
            <span class="identifier">inference</span><span class="plain"> *</span><span class="identifier">inf</span><span class="plain">;</span>
            <span class="identifier">POSITIVE_KNOWLEDGE_LOOP</span><span class="plain">(</span><span class="identifier">inf</span><span class="plain">, </span><span class="identifier">check</span><span class="plain">, </span><span class="identifier">PROPERTY_INF</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">World::Inferences::added_in_construction</span><span class="plain">(</span><span class="identifier">inf</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">World::Inferences::get_property</span><span class="plain">(</span><span class="identifier">inf</span><span class="plain">) == </span><span class="identifier">P_printed_name</span><span class="plain">)</span>
                        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Naming::look_for_printed_name is used in <a href="#SP11_1">&#167;11.1</a>.</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b>And here we transcribe a word range to text suitable for an I6 property,
capitalising and fixing "your" as needed.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Naming::compose_words_to_I6_naming_text</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">cap</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">your_flag</span><span class="plain">) {</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"\</span><span class="plain">"</span><span class="string">"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">j</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">) {</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">your_here</span><span class="plain"> = &lt;</span><span class="identifier">possessive</span><span class="plain">-</span><span class="identifier">second</span><span class="plain">-</span><span class="identifier">person</span><span class="plain">&gt;(</span><span class="identifier">Wordings::one_word</span><span class="plain">(</span><span class="identifier">j</span><span class="plain">));</span>
                <span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">Lexer::word_raw_text</span><span class="plain">(</span><span class="identifier">j</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">cap</span><span class="plain">) {</span>
                    <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">j</span><span class="plain">==</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">your_here</span><span class="plain">) &amp;&amp; (</span><span class="identifier">your_flag</span><span class="plain">)) {</span>
                        <span class="identifier">PUT</span><span class="plain">(</span><span class="identifier">Characters::toupper</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">[0]));</span>
                        <span class="identifier">CompiledText::from_wide_string</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">+1, </span><span class="identifier">CT_RAW</span><span class="plain">);</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">j</span><span class="plain">==</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
                        <span class="identifier">CompiledText::from_wide_string</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">CT_RAW</span><span class="plain"> + </span><span class="identifier">CT_CAPITALISE</span><span class="plain">);</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                        <span class="identifier">CompiledText::from_wide_string</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">CT_RAW</span><span class="plain">);</span>
                    <span class="plain">}</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">j</span><span class="plain">==</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">your_here</span><span class="plain">) &amp;&amp; (</span><span class="identifier">your_flag</span><span class="plain">)) {</span>
                        <span class="identifier">PUT</span><span class="plain">(</span><span class="identifier">Characters::tolower</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">[0]));</span>
                        <span class="identifier">CompiledText::from_wide_string</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">+1, </span><span class="identifier">CT_RAW</span><span class="plain">);</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">CompiledText::from_wide_string</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">CT_RAW</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">j</span><span class="plain">&lt;</span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" "</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">cap</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"Object"</span><span class="plain">); </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"object"</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"\</span><span class="plain">"</span><span class="string">"</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Naming::compose_words_to_I6_naming_text is used in <a href="#SP11_1_2_1_1">&#167;11.1.2.1.1</a>, <a href="#SP11_1_2_2_1">&#167;11.1.2.2.1</a>, <a href="#SP11_1_3">&#167;11.1.3</a>.</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14.  </b>Finally:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Naming::compile_small_names</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">short_name_notice</span><span class="plain"> *</span><span class="identifier">notice</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">notice</span><span class="plain">, </span><span class="reserved">short_name_notice</span><span class="plain">) {</span>
            <span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">owner</span><span class="plain"> = </span><span class="functiontext">PL::Naming::object_this_is_named_after</span><span class="plain">(</span><span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;namee</span><span class="plain">);</span>
            <span class="identifier">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="identifier">Routines::begin</span><span class="plain">(</span><span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;routine_iname</span><span class="plain">);</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">NA</span><span class="plain"> = </span><span class="identifier">Assertions::Assemblies::get_named_after_text</span><span class="plain">(</span><span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;after_subject</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;capped</span><span class="plain">) {</span>
                <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">porname</span><span class="plain"> = </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PRINTORRUN_HL</span><span class="plain">);</span>

                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">IFELSE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">PROPERTYADDRESS_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Instances::iname</span><span class="plain">(</span><span class="identifier">owner</span><span class="plain">));</span>
                        <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">CAPSHORTNAME_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">porname</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Instances::iname</span><span class="plain">(</span><span class="identifier">owner</span><span class="plain">));</span>
                            <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">CAPSHORTNAME_HL</span><span class="plain">));</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">porname</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Instances::iname</span><span class="plain">(</span><span class="identifier">owner</span><span class="plain">));</span>
                            <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SHORT_NAME_HL</span><span class="plain">));</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINTNAME_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Instances::iname</span><span class="plain">(</span><span class="identifier">owner</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
            <span class="plain">}</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINT_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_text</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">I</span><span class="string">"'s "</span><span class="plain">);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">SNAMES</span><span class="plain">);</span>
            <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">j</span><span class="plain">, </span><span class="identifier">NA</span><span class="plain">) {</span>
                <span class="identifier">CompiledText::from_wide_string</span><span class="plain">(</span><span class="identifier">SNAMES</span><span class="plain">, </span><span class="identifier">Lexer::word_raw_text</span><span class="plain">(</span><span class="identifier">j</span><span class="plain">), 0);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">j</span><span class="plain">&lt;</span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">NA</span><span class="plain">)) </span><span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">SNAMES</span><span class="plain">, </span><span class="string">" "</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINT_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_text</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">SNAMES</span><span class="plain">);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">SNAMES</span><span class="plain">);</span>

            <span class="identifier">Produce::rtrue</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Routines::end</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>

            <span class="identifier">save</span><span class="plain"> = </span><span class="identifier">Emit::named_array_begin</span><span class="plain">(</span><span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;snn_iname</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
            <span class="identifier">Emit::array_iname_entry</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">CONSTANT_PACKED_TEXT_STORAGE_HL</span><span class="plain">));</span>
            <span class="identifier">Emit::array_iname_entry</span><span class="plain">(</span><span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;routine_iname</span><span class="plain">);</span>
            <span class="identifier">Emit::array_end</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Naming::compile_cap_short_name</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">P_cap_short_name</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">CAPSHORTNAME_HL</span><span class="plain">);</span>
            <span class="identifier">Emit::named_iname_constant</span><span class="plain">(</span><span class="identifier">iname</span><span class="plain">, </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SHORT_NAME_HL</span><span class="plain">));</span>
            <span class="identifier">Hierarchy::make_available</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">iname</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Naming::compile_small_names appears nowhere else.</p>

<p class="endnote">The function PL::Naming::compile_cap_short_name appears nowhere else.</p>

<hr class="tocbar">
<ul class="toc"><li><i>(This section begins Chapter 3: Space and Time.)</i></li><li><a href="3-sm.html">Continue with 'Spatial Model'</a></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

