<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>The Map</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
MathJax = {
	tex: {
		inlineMath: '$', '$'], ['\\(', '\\)'
	},
	svg: {
		fontCache: 'global'
	}
};
</script>
<script type="text/javascript" id="MathJax-script" async
	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Preform-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../compiler.html">compiler tools</a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul><h2>Compiler Webs</h2><ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul><h2>Inbuild Modules</h2><ul>
<li><a href="../supervisor-module/index.html">supervisor</a></li>
</ul><h2>Inform7 Modules</h2><ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="index.html"><span class="selectedlink">if</span></a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul><h2>Inter Modules</h2><ul>
<li><a href="../bytecode-module/index.html">bytecode</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul><h2>Services</h2><ul>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../html-module/index.html">html</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'The Map' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../compiler.html">Inform7 Modules</a></li><li><a href="index.html">if</a></li><li><a href="index.html#3">Chapter 3: Space and Time</a></li><li><b>The Map</b></li></ul></div>
<p class="purpose">A plugin to provide a geographical model, linking rooms and doors together in oppositely-paired directions.</p>

<ul class="toc"><li><a href="3-tm.html#SP7">&#167;7. Initialisation</a></li><li><a href="3-tm.html#SP9">&#167;9. Inferences</a></li><li><a href="3-tm.html#SP11">&#167;11. Kinds</a></li><li><a href="3-tm.html#SP17">&#167;17. Directions and their numbers</a></li><li><a href="3-tm.html#SP21">&#167;21. The exits array</a></li><li><a href="3-tm.html#SP23">&#167;23. Door connectivity</a></li><li><a href="3-tm.html#SP24">&#167;24. Properties</a></li><li><a href="3-tm.html#SP30">&#167;30. Linguistic extras</a></li><li><a href="3-tm.html#SP34">&#167;34. The map-connector</a></li><li><a href="3-tm.html#SP36">&#167;36. Model completion</a></li><li><a href="3-tm.html#SP37">&#167;37. Redeeming those notices</a></li><li><a href="3-tm.html#SP38">&#167;38. Indexing</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1"></a><b>&#167;1.  </b>The map is a complicated data structure, both because it amounts to a
ternary relation (though being implemented by many binary ones) and because
of an ambiguity: a map connection from a room R can lead to another room S,
to a door, or to nothing. Doors come in two sorts, one and two-sided, and
checking the physical realism of all this means we need to produce many
quite specific problem messages.
</p>

<p class="commentary">We will use quite a lot of temporary work-space to put all of this
together, but the details can be ignored. If we expected very large numbers
of objects then it would be worth economising here, but profiling suggests
that it really isn't.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">map_data</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="comment-syntax"> these are meaningful for doors only</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">map_connection_a</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">map_connection_b</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">map_direction_a</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">map_direction_b</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="comment-syntax"> these are meaningful for directions only</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">direction_index</span><span class="plain-syntax">; </span><span class="comment-syntax"> counts 0, 1, 2, ..., in order of creation</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">inter_name</span><span class="plain-syntax"> *</span><span class="identifier-syntax">direction_iname</span><span class="plain-syntax">; </span><span class="comment-syntax"> for the constant instance ref</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">direction_relation</span><span class="plain-syntax">; </span><span class="comment-syntax"> the corresponding "mapped D of" relation</span>

<span class="plain-syntax">    </span><span class="comment-syntax"> these are meaningful for rooms only, and are used in making the World index</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">exits</span><span class="plain-syntax">[</span><span class="constant-syntax">MAX_DIRECTIONS</span><span class="plain-syntax">];</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">exits_set_at</span><span class="plain-syntax">[</span><span class="constant-syntax">MAX_DIRECTIONS</span><span class="plain-syntax">];</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spatial_relationship</span><span class="plain-syntax">[12];</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">exit_lengths</span><span class="plain-syntax">[</span><span class="constant-syntax">MAX_DIRECTIONS</span><span class="plain-syntax">];</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lock_exits</span><span class="plain-syntax">[</span><span class="constant-syntax">MAX_DIRECTIONS</span><span class="plain-syntax">];</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">vector</span><span class="plain-syntax"> </span><span class="identifier-syntax">position</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">vector</span><span class="plain-syntax"> </span><span class="identifier-syntax">saved_gridpos</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">cooled</span><span class="plain-syntax">, </span><span class="identifier-syntax">shifted</span><span class="plain-syntax">, </span><span class="identifier-syntax">zone</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">connected_submap</span><span class="plain-syntax"> *</span><span class="identifier-syntax">submap</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">next_room_in_submap</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wchar_t</span><span class="plain-syntax"> *</span><span class="identifier-syntax">world_index_colour</span><span class="plain-syntax">; </span><span class="comment-syntax"> an HTML colour for the room square (rooms only)</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wchar_t</span><span class="plain-syntax"> *</span><span class="identifier-syntax">world_index_text_colour</span><span class="plain-syntax">; </span><span class="comment-syntax"> an HTML colour for the room text (rooms only)</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">map_parameter_scope</span><span class="plain-syntax"> </span><span class="identifier-syntax">local_map_parameters</span><span class="plain-syntax">; </span><span class="comment-syntax"> temporary: used in EPS mapping</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">eps_x</span><span class="plain-syntax">, </span><span class="identifier-syntax">eps_y</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">map_data</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>The structure map_data is accessed in 3/mcr, 3/sm2, 3/hm, 3/em and here.</li></ul>
<p class="commentary firstcommentary"><a id="SP2"></a><b>&#167;2.  </b>It's obvious why the kinds direction and door are special. It's not so
obvious why "up" and "down" are: the answer is that there are linguistic
features of these which aren't shared by lateral directions. "Above the
garden is the treehouse", for instance, does not directly refer to either
direction, but implies both.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K_direction</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K_door</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I_up</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I_down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP3"></a><b>&#167;3.  </b>Special properties. The I6 implementation of two-way doors and of what, in
I7, are called backdrops, is quite complicated. See the Inform Designer's Manual,
fourth edition (the "DM4") for explanations. We are essentially trying to
program all of that automatically, which is why these awkward multi-purpose
I6 properties (<span class="extract"><span class="extract-syntax">door_to</span></span>, <span class="extract"><span class="extract-syntax">found_in</span></span>, etc.) have no direct I7 equivalents.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">P_door</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="comment-syntax"> I6 only</span>
<span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">P_door_dir</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="comment-syntax"> I6 only</span>
<span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">P_door_to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="comment-syntax"> I6 only</span>
<span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">P_other_side</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="comment-syntax"> a value property for the other side of a door</span>
<span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">P_opposite</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="comment-syntax"> a value property for the reverse of a direction</span>
<span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">P_room_index</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="comment-syntax"> I6 only: workspace for path-finding through the map</span>
<span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">P_found_in</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="comment-syntax"> I6 only: needed for multiply-present objects</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4"></a><b>&#167;4.  </b>While we could probably represent map knowledge using relation inferences
in connection with the "mapped D of" relations, it's altogether easier and
makes for more legible code if we use a special inference type of our own:
</p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="constant-syntax">DIRECTION_INF</span><span class="plain-syntax"> </span><span class="constant-syntax">100</span><span class="plain-syntax"> </span><span class="comment-syntax"> where do map connections from O lead?</span>
</pre>
<p class="commentary firstcommentary"><a id="SP5"></a><b>&#167;5.  </b>One useful constant:
</p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="constant-syntax">MAX_WORDS_IN_DIRECTION</span><span class="plain-syntax"> (</span><span class="identifier-syntax">MAX_WORDS_IN_ASSEMBLAGE</span><span class="plain-syntax"> - </span><span class="constant-syntax">4</span><span class="plain-syntax">)</span>
</pre>
<p class="commentary firstcommentary"><a id="SP6"></a><b>&#167;6.  </b>These little structures are needed to remember routines to compile later:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">door_dir_notice</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">inter_name</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ddn_iname</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">door</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">R1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">D1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">D2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">door_dir_notice</span><span class="plain-syntax">;</span>

<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">door_to_notice</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">inter_name</span><span class="plain-syntax"> *</span><span class="identifier-syntax">dtn_iname</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">door</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">R1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">R2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">door_to_notice</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>The structure door_dir_notice is private to this section.</li><li>The structure door_to_notice is private to this section.</li></ul>
<p class="commentary firstcommentary"><a id="SP7"></a><b>&#167;7. Initialisation. </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::start</span><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PLUGIN_REGISTER</span><span class="plain-syntax">(</span><span class="identifier-syntax">PLUGIN_NEW_BASE_KIND_NOTIFY</span><span class="plain-syntax">, </span><a href="3-tm.html#SP12" class="function-link"><span class="function-syntax">PL::Map::map_new_base_kind_notify</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PLUGIN_REGISTER</span><span class="plain-syntax">(</span><span class="identifier-syntax">PLUGIN_NEW_SUBJECT_NOTIFY</span><span class="plain-syntax">, </span><a href="3-tm.html#SP14" class="function-link"><span class="function-syntax">PL::Map::map_new_subject_notify</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PLUGIN_REGISTER</span><span class="plain-syntax">(</span><span class="identifier-syntax">PLUGIN_SET_KIND_NOTIFY</span><span class="plain-syntax">, </span><a href="3-tm.html#SP20" class="function-link"><span class="function-syntax">PL::Map::map_set_kind_notify</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PLUGIN_REGISTER</span><span class="plain-syntax">(</span><span class="identifier-syntax">PLUGIN_SET_SUBKIND_NOTIFY</span><span class="plain-syntax">, </span><a href="3-tm.html#SP13" class="function-link"><span class="function-syntax">PL::Map::map_set_subkind_notify</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PLUGIN_REGISTER</span><span class="plain-syntax">(</span><span class="identifier-syntax">PLUGIN_ACT_ON_SPECIAL_NPS</span><span class="plain-syntax">, </span><a href="3-tm.html#SP31" class="function-link"><span class="function-syntax">PL::Map::map_act_on_special_NPs</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PLUGIN_REGISTER</span><span class="plain-syntax">(</span><span class="identifier-syntax">PLUGIN_CHECK_GOING</span><span class="plain-syntax">, </span><a href="3-tm.html#SP32" class="function-link"><span class="function-syntax">PL::Map::map_check_going</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PLUGIN_REGISTER</span><span class="plain-syntax">(</span><span class="identifier-syntax">PLUGIN_COMPILE_MODEL_TABLES</span><span class="plain-syntax">, </span><a href="3-tm.html#SP22" class="function-link"><span class="function-syntax">PL::Map::map_compile_model_tables</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PLUGIN_REGISTER</span><span class="plain-syntax">(</span><span class="identifier-syntax">PLUGIN_ESTIMATE_PROPERTY_USAGE</span><span class="plain-syntax">, </span><a href="3-tm.html#SP29" class="function-link"><span class="function-syntax">PL::Map::map_estimate_property_usage</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PLUGIN_REGISTER</span><span class="plain-syntax">(</span><span class="identifier-syntax">PLUGIN_LOG_INFERENCE_TYPE</span><span class="plain-syntax">, </span><a href="3-tm.html#SP9" class="function-link"><span class="function-syntax">PL::Map::map_log_inference_type</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PLUGIN_REGISTER</span><span class="plain-syntax">(</span><span class="identifier-syntax">PLUGIN_INFERENCES_CONTRADICT</span><span class="plain-syntax">, </span><a href="3-tm.html#SP10" class="function-link"><span class="function-syntax">PL::Map::map_inferences_contradict</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PLUGIN_REGISTER</span><span class="plain-syntax">(</span><span class="identifier-syntax">PLUGIN_COMPLETE_MODEL</span><span class="plain-syntax">, </span><a href="3-tm.html#SP36" class="function-link"><span class="function-syntax">PL::Map::map_complete_model</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PLUGIN_REGISTER</span><span class="plain-syntax">(</span><span class="identifier-syntax">PLUGIN_NEW_PROPERTY_NOTIFY</span><span class="plain-syntax">, </span><a href="3-tm.html#SP25" class="function-link"><span class="function-syntax">PL::Map::map_new_property_notify</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PLUGIN_REGISTER</span><span class="plain-syntax">(</span><span class="identifier-syntax">PLUGIN_PROPERTY_VALUE_NOTIFY</span><span class="plain-syntax">, </span><a href="3-tm.html#SP26" class="function-link"><span class="function-syntax">PL::Map::map_property_value_notify</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PLUGIN_REGISTER</span><span class="plain-syntax">(</span><span class="identifier-syntax">PLUGIN_INTERVENE_IN_ASSERTION</span><span class="plain-syntax">, </span><a href="3-tm.html#SP33" class="function-link"><span class="function-syntax">PL::Map::map_intervene_in_assertion</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PLUGIN_REGISTER</span><span class="plain-syntax">(</span><span class="identifier-syntax">PLUGIN_ADD_TO_WORLD_INDEX</span><span class="plain-syntax">, </span><a href="3-tm.html#SP38" class="function-link"><span class="function-syntax">PL::Map::map_add_to_World_index</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PLUGIN_REGISTER</span><span class="plain-syntax">(</span><span class="identifier-syntax">PLUGIN_ANNOTATE_IN_WORLD_INDEX</span><span class="plain-syntax">, </span><a href="3-tm.html#SP38" class="function-link"><span class="function-syntax">PL::Map::map_annotate_in_World_index</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP8"></a><b>&#167;8.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">map_data</span><span class="plain-syntax"> *</span><span class="function-syntax">PL::Map::new_data</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">PL::Map::new_data</span></span>:<br/><a href="3-tm.html#SP14">&#167;14</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">subj</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">map_data</span><span class="plain-syntax"> *</span><span class="identifier-syntax">md</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">map_data</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">md</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">direction_index</span><span class="plain-syntax"> = -1;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">md</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">direction_relation</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">i</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">i</span><span class="plain-syntax">&lt;</span><span class="constant-syntax">MAX_DIRECTIONS</span><span class="plain-syntax">; </span><span class="identifier-syntax">i</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">md</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">exits_set_at</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">] = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">md</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">exits</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">] = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">md</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">map_connection_a</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="identifier-syntax">md</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">map_connection_b</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">md</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">map_direction_a</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="identifier-syntax">md</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">map_direction_b</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><a href="3-sm2.html#SP7_1" class="function-link"><span class="function-syntax">PL::SpatialMap::initialise_mapping_data</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">md</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">md</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9"></a><b>&#167;9. Inferences. </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::map_log_inference_type</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">PL::Map::map_log_inference_type</span></span>:<br/><a href="3-tm.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">it</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">switch</span><span class="plain-syntax">(</span><span class="identifier-syntax">it</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">DIRECTION_INF:</span><span class="plain-syntax"> </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"DIRECTION_INF"</span><span class="plain-syntax">); </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10"></a><b>&#167;10.  </b>Two subjects are attached to a direction inference: 1, the destination;
2, the direction. So at the <span class="extract"><span class="extract-syntax">CI_DIFFER_IN_INFS1</span></span> level of similarity, two
different direction inferences disagree about the destination for a given
direction &mdash; this of course is a contradiction.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::map_inferences_contradict</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">PL::Map::map_inferences_contradict</span></span>:<br/><a href="3-tm.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">inference</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">inference</span><span class="plain-syntax"> *</span><span class="identifier-syntax">B</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">similarity</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="identifier-syntax">World::Inferences::get_inference_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">DIRECTION_INF:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">similarity</span><span class="plain-syntax"> == </span><span class="identifier-syntax">CI_DIFFER_IN_INFS1</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP11"></a><b>&#167;11. Kinds. </b>These are kind names to do with mapping which Inform provides special
support for; it recognises the English name when defined by the Standard
Rules. (So there is no need to translate this to other languages.)
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;notable-map-kinds&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">direction</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">door</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP12"></a><b>&#167;12.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::map_new_base_kind_notify</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">PL::Map::map_new_base_kind_notify</span></span>:<br/><a href="3-tm.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">new_base</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">name</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;notable-map-kinds&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;&lt;r&gt;&gt;</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="constant-syntax">0</span><span class="plain-syntax">: </span><span class="identifier-syntax">K_direction</span><span class="plain-syntax"> = </span><span class="identifier-syntax">new_base</span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">: </span><span class="identifier-syntax">K_door</span><span class="plain-syntax"> = </span><span class="identifier-syntax">new_base</span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP13"></a><b>&#167;13.  </b>Direction needs to be an abstract object, not a thing or a room, so:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::map_set_subkind_notify</span><button class="popup" onclick="togglePopup('usagePopup5')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup5">Usage of <span class="code-font"><span class="function-syntax">PL::Map::map_set_subkind_notify</span></span>:<br/><a href="3-tm.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sub</span><span class="plain-syntax">, </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">super</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">sub</span><span class="plain-syntax"> == </span><span class="identifier-syntax">K_direction</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">super</span><span class="plain-syntax"> != </span><span class="identifier-syntax">K_object</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">problem_count</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_DirectionAdrift</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                </span><span class="string-syntax">"'direction' is not allowed to be a kind of anything (other than "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"'object')"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="string-syntax">"because it's too fundamental to the way Inform maps out the "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"geography of the physical world."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">super</span><span class="plain-syntax"> == </span><span class="identifier-syntax">K_direction</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">problem_count</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_DirectionSubkinded</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                </span><span class="string-syntax">"'direction' is not allowed to have more specific kinds"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="string-syntax">"because it's too fundamental to the way Inform maps out the "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"geography of the physical world."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">K_backdrop</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">sub</span><span class="plain-syntax"> == </span><span class="identifier-syntax">K_door</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Kinds::Compare::le</span><span class="plain-syntax">(</span><span class="identifier-syntax">super</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_backdrop</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_DoorAdrift</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                </span><span class="string-syntax">"'door' is not allowed to be a kind of 'backdrop'"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="string-syntax">"because it's too fundamental to the way Inform maps out the "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"geography of the physical world."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">K_backdrop</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">sub</span><span class="plain-syntax"> == </span><span class="identifier-syntax">K_backdrop</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Kinds::Compare::le</span><span class="plain-syntax">(</span><span class="identifier-syntax">super</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_door</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_BackdropAdrift</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                </span><span class="string-syntax">"'backdrop' is not allowed to be a kind of 'door'"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="string-syntax">"because it's too fundamental to the way Inform maps out the "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"geography of the physical world."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP14"></a><b>&#167;14.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::map_new_subject_notify</span><button class="popup" onclick="togglePopup('usagePopup6')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup6">Usage of <span class="code-font"><span class="function-syntax">PL::Map::map_new_subject_notify</span></span>:<br/><a href="3-tm.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">subj</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CREATE_PF_DATA</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">subj</span><span class="plain-syntax">, </span><a href="3-tm.html#SP8" class="function-link"><span class="function-syntax">PL::Map::new_data</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP15"></a><b>&#167;15.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::object_is_a_direction</span><span class="plain-syntax">(</span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Plugins::Manage::plugged_in</span><span class="plain-syntax">(</span><span class="identifier-syntax">map_plugin</span><span class="plain-syntax">)) &amp;&amp; (</span><span class="identifier-syntax">K_direction</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">I</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Instances::of_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_direction</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP16"></a><b>&#167;16.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::object_is_a_door</span><button class="popup" onclick="togglePopup('usagePopup7')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup7">Usage of <span class="code-font"><span class="function-syntax">PL::Map::object_is_a_door</span></span>:<br/><a href="3-tm.html#SP36_2">&#167;36.2</a>, <a href="3-tm.html#SP36_3">&#167;36.3</a>, <a href="3-tm.html#SP36_4">&#167;36.4</a>, <a href="3-tm.html#SP36_5">&#167;36.5</a>, <a href="3-tm.html#SP36_6">&#167;36.6</a>, <a href="3-tm.html#SP36_7">&#167;36.7</a>, <a href="3-tm.html#SP36_8">&#167;36.8</a><br/>Spatial Model - <a href="3-sm.html#SP32_3_3">&#167;32.3.3</a>, <a href="3-sm.html#SP44">&#167;44</a><br/>Spatial Map - <a href="3-sm2.html#SP7_16">&#167;7.16</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Plugins::Manage::plugged_in</span><span class="plain-syntax">(</span><span class="identifier-syntax">map_plugin</span><span class="plain-syntax">)) &amp;&amp; (</span><span class="identifier-syntax">K_door</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">I</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Instances::of_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_door</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::subject_is_a_door</span><span class="plain-syntax">(</span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="3-tm.html#SP16" class="function-link"><span class="function-syntax">PL::Map::object_is_a_door</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">InferenceSubjects::as_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">infs</span><span class="plain-syntax">));</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP17"></a><b>&#167;17. Directions and their numbers. </b>Directions play a special role because sentences like "east of the treehouse
is the garden" are parsed differently from sentences like "the nearby place
property of the treehouse is the garden"; they're also one domain of what
amounts to the ternary map relation, though we actually implement it as a
sheaf of binary relations, one for each direction. Anyway:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::is_a_direction</span><button class="popup" onclick="togglePopup('usagePopup8')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup8">Usage of <span class="code-font"><span class="function-syntax">PL::Map::is_a_direction</span></span>:<br/><a href="3-tm.html#SP33">&#167;33</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">K_direction</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">; </span><span class="comment-syntax"> in particular, if we aren't using the IF model</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">InferenceSubjects::is_within</span><span class="plain-syntax">(</span><span class="identifier-syntax">infs</span><span class="plain-syntax">, </span><span class="identifier-syntax">Kinds::Knowledge::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_direction</span><span class="plain-syntax">));</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP18"></a><b>&#167;18.  </b>When a new direction comes into existence (i.e., not when the underlying
object <span class="extract"><span class="extract-syntax">I</span></span> is created, but when its kind is first realised to be "direction"),
we need to assign it a number:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">registered_directions</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">; </span><span class="comment-syntax"> next direction number to be free</span>
</pre>
<p class="commentary firstcommentary"><a id="SP19"></a><b>&#167;19.  </b>These are direction names which Inform provides special support for; it
recognises the English names when defined by the Standard Rules. (So there is
no need to translate this to other languages.)
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;notable-map-directions&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">up</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">down</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP20"></a><b>&#167;20.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::map_set_kind_notify</span><button class="popup" onclick="togglePopup('usagePopup9')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup9">Usage of <span class="code-font"><span class="function-syntax">PL::Map::map_set_kind_notify</span></span>:<br/><a href="3-tm.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">k</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">kw</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Instances::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((!(</span><span class="identifier-syntax">Kinds::Compare::le</span><span class="plain-syntax">(</span><span class="identifier-syntax">kw</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_direction</span><span class="plain-syntax">))) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Kinds::Compare::le</span><span class="plain-syntax">(</span><span class="identifier-syntax">k</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_direction</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">IW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Instances::get_name</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP20_1" class="named-paragraph-link"><span class="named-paragraph">Vet the direction name for acceptability</span><span class="named-paragraph-number">20.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;notable-map-directions&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">IW</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;&lt;r&gt;&gt;</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="constant-syntax">0</span><span class="plain-syntax">: </span><span class="identifier-syntax">I_up</span><span class="plain-syntax"> = </span><span class="identifier-syntax">I</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">: </span><span class="identifier-syntax">I_down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">I</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><a href="3-tnt.html#SP7" class="function-link"><span class="function-syntax">PL::Naming::object_takes_definite_article</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP20_2" class="named-paragraph-link"><span class="named-paragraph">Assign the object a direction number and a mapped-D-of relation</span><span class="named-paragraph-number">20.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP20_1"></a><b>&#167;20.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Vet the direction name for acceptability</span><span class="named-paragraph-number">20.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::empty</span><span class="plain-syntax">(</span><span class="identifier-syntax">IW</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_NamelessDirection</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"nameless directions are not allowed"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"so writing something like 'There is a direction.' is forbidden."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::length</span><span class="plain-syntax">(</span><span class="identifier-syntax">IW</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">MAX_WORDS_IN_DIRECTION</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_DirectionTooLong</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"although direction names can be really quite long in today's Inform"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"they can't be as long as that."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP20">&#167;20</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP20_2"></a><b>&#167;20.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Assign the object a direction number and a mapped-D-of relation</span><span class="named-paragraph-number">20.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">registered_directions</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">package_request</span><span class="plain-syntax"> *</span><span class="identifier-syntax">PR</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Hierarchy::synoptic_package</span><span class="plain-syntax">(</span><span class="identifier-syntax">DIRECTIONS_HAP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inter_name</span><span class="plain-syntax"> *</span><span class="identifier-syntax">dname</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Hierarchy::make_iname_in</span><span class="plain-syntax">(</span><span class="identifier-syntax">DIRECTION_HL</span><span class="plain-syntax">, </span><span class="identifier-syntax">PR</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">direction_iname</span><span class="plain-syntax"> = </span><span class="identifier-syntax">dname</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><a href="3-mcr.html#SP6" class="function-link"><span class="function-syntax">PL::MapDirections::make_mapped_predicate</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">dname</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP20">&#167;20</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP21"></a><b>&#167;21. The exits array. </b>The bulk of the map is stored in the arrays called <span class="extract"><span class="extract-syntax">exits</span></span>, which hold the
map connections fanning out from each room. The direction numbers carefully
noted above are keys into these arrays.
</p>

<p class="commentary">It might look a little wasteful of I7's memory to expand the direction
inferences, a nicely compact representation, into large and sparse arrays.
But it's convenient, and profiling suggests that the memory overhead is not
significant. It also means that the World Index mapping code, which contains
quite crunchy algorithms, has the fastest possible access to the layout.
</p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">MAP_EXIT</span><span class="plain-syntax">(</span><span class="identifier-syntax">X</span><span class="plain-syntax">, </span><span class="identifier-syntax">Y</span><span class="plain-syntax">) </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">X</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">exits</span><span class="plain-syntax">[</span><span class="identifier-syntax">Y</span><span class="plain-syntax">]</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::build_exits_array</span><button class="popup" onclick="togglePopup('usagePopup10')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup10">Usage of <span class="code-font"><span class="function-syntax">PL::Map::build_exits_array</span></span>:<br/><a href="3-tm.html#SP36">&#167;36</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">d</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Compare::le</span><span class="plain-syntax">(</span><span class="identifier-syntax">Instances::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="identifier-syntax">K_direction</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">direction_index</span><span class="plain-syntax"> = </span><span class="identifier-syntax">d</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inference</span><span class="plain-syntax"> *</span><span class="identifier-syntax">inf</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">POSITIVE_KNOWLEDGE_LOOP</span><span class="plain-syntax">(</span><span class="identifier-syntax">inf</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="constant-syntax">DIRECTION_INF</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs1</span><span class="plain-syntax">, *</span><span class="identifier-syntax">infs2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">World::Inferences::get_references</span><span class="plain-syntax">(</span><span class="identifier-syntax">inf</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">infs1</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">infs2</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, *</span><span class="identifier-syntax">dir</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">infs1</span><span class="plain-syntax">) </span><span class="identifier-syntax">to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">InferenceSubjects::as_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">infs1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">infs2</span><span class="plain-syntax">) </span><span class="identifier-syntax">dir</span><span class="plain-syntax"> = </span><span class="identifier-syntax">InferenceSubjects::as_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">infs2</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">to</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">dir</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">dn</span><span class="plain-syntax"> = </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">dir</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">direction_index</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">dn</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">0</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">dn</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">MAX_DIRECTIONS</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">MAP_EXIT</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">dn</span><span class="plain-syntax">) = </span><span class="identifier-syntax">to</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">exits_set_at</span><span class="plain-syntax">[</span><span class="identifier-syntax">dn</span><span class="plain-syntax">] = </span><span class="identifier-syntax">World::Inferences::where_inferred</span><span class="plain-syntax">(</span><span class="identifier-syntax">inf</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP22"></a><b>&#167;22.  </b>This is easy to translate into I6 (though that's partly because I7 doesn't
follow the traditional I6 library way to represent the map):
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::map_compile_model_tables</span><button class="popup" onclick="togglePopup('usagePopup11')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup11">Usage of <span class="code-font"><span class="function-syntax">PL::Map::map_compile_model_tables</span></span>:<br/><a href="3-tm.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP22_1" class="named-paragraph-link"><span class="named-paragraph">Declare I6 constants for the directions</span><span class="named-paragraph-number">22.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP22_2" class="named-paragraph-link"><span class="named-paragraph">Compile the I6 Map-Storage array</span><span class="named-paragraph-number">22.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP22_1"></a><b>&#167;22.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Declare I6 constants for the directions</span><span class="named-paragraph-number">22.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">inter_name</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ndi</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Hierarchy::find</span><span class="plain-syntax">(</span><span class="identifier-syntax">NO_DIRECTIONS_HL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Emit::named_numeric_constant</span><span class="plain-syntax">(</span><span class="identifier-syntax">ndi</span><span class="plain-syntax">, (</span><span class="identifier-syntax">inter_ti</span><span class="plain-syntax">) </span><span class="identifier-syntax">registered_directions</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Hierarchy::make_available</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">ndi</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_INSTANCES</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_direction</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Emit::named_iname_constant</span><span class="plain-syntax">(</span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">direction_iname</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_object</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::emitted_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP22">&#167;22</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP22_2"></a><b>&#167;22.2.  </b>The <span class="extract"><span class="extract-syntax">Map_Storage</span></span> array consists only of the <span class="extract"><span class="extract-syntax">exits</span></span> arrays written out
one after another. It looks wasteful of memory, since it is almost always
going to be filled mostly with <span class="extract"><span class="extract-syntax">0</span></span> entries (meaning: no exit that way). But
the memory needs to be there because map connections can be added dynamically
at run-time, so we can't know now how many we will need.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Compile the I6 Map-Storage array</span><span class="named-paragraph-number">22.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Instances::emitted_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inter_name</span><span class="plain-syntax"> *</span><span class="identifier-syntax">iname</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Hierarchy::find</span><span class="plain-syntax">(</span><span class="identifier-syntax">MAP_STORAGE_HL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">packaging_state</span><span class="plain-syntax"> </span><span class="identifier-syntax">save</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Emit::named_array_begin</span><span class="plain-syntax">(</span><span class="identifier-syntax">iname</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_object</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">words_used</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Task::wraps_existing_storyfile</span><span class="plain-syntax">()) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Emit::array_divider</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"minimal, as there are no rooms"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Emit::array_iname_entry</span><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Emit::array_iname_entry</span><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Emit::array_iname_entry</span><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Emit::array_iname_entry</span><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">words_used</span><span class="plain-syntax"> = </span><span class="constant-syntax">4</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Emit::array_divider</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"one row per room"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="3-sm.html#SP15" class="function-link"><span class="function-syntax">PL::Spatial::object_is_a_room</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">i</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">i</span><span class="plain-syntax">&lt;</span><span class="identifier-syntax">registered_directions</span><span class="plain-syntax">; </span><span class="identifier-syntax">i</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">MAP_EXIT</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">i</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">to</span><span class="plain-syntax">)</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Emit::array_iname_entry</span><span class="plain-syntax">(</span><span class="identifier-syntax">Instances::iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">to</span><span class="plain-syntax">));</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">else</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Emit::array_numeric_entry</span><span class="plain-syntax">(0);</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">words_used</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">divider</span><span class="plain-syntax">)</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">divider</span><span class="plain-syntax">, </span><span class="string-syntax">"Exits from: %~I"</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Emit::array_divider</span><span class="plain-syntax">(</span><span class="identifier-syntax">divider</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">divider</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Emit::array_end</span><span class="plain-syntax">(</span><span class="identifier-syntax">save</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Hierarchy::make_available</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">iname</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP22">&#167;22</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP23"></a><b>&#167;23. Door connectivity. </b>We've seen how most of the map is represented, in the <span class="extract"><span class="extract-syntax">exits</span></span> arrays. The
missing information has to do with doors. If east of the Carousel Room is
the oak door, then <span class="extract"><span class="extract-syntax">Map_Storage</span></span> reveals only that fact, and not what's on
the other side of the door. This will eventually be compiled into the
<span class="extract"><span class="extract-syntax">door_to</span></span> property for the oak door object. In the mean time, every door
object has four pieces of data attached:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::get_door_data</span><button class="popup" onclick="togglePopup('usagePopup12')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup12">Usage of <span class="code-font"><span class="function-syntax">PL::Map::get_door_data</span></span>:<br/><a href="3-tm.html#SP38">&#167;38</a><br/>Spatial Model - <a href="3-sm.html#SP44">&#167;44</a><br/>Spatial Map - <a href="3-sm2.html#SP7_16">&#167;7.16</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">door</span><span class="plain-syntax">, </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> **</span><span class="identifier-syntax">c1</span><span class="plain-syntax">, </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> **</span><span class="identifier-syntax">c2</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">c1</span><span class="plain-syntax">) *</span><span class="identifier-syntax">c1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">door</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_a</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">c2</span><span class="plain-syntax">) *</span><span class="identifier-syntax">c2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">door</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_b</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP24"></a><b>&#167;24. Properties. </b>These are property names to do with mapping which Inform provides special
support for; it recognises the English names when they are defined by the
Standard Rules. (So there is no need to translate this to other languages.)
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;notable-map-properties&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">opposite</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">other</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">side</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP25"></a><b>&#167;25.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::map_new_property_notify</span><button class="popup" onclick="togglePopup('usagePopup13')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup13">Usage of <span class="code-font"><span class="function-syntax">PL::Map::map_new_property_notify</span></span>:<br/><a href="3-tm.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prn</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;notable-map-properties&gt;(prn-&gt;</span><span class="element-syntax">name</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;&lt;r&gt;&gt;</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="constant-syntax">0</span><span class="plain-syntax">: </span><span class="identifier-syntax">P_opposite</span><span class="plain-syntax"> = </span><span class="identifier-syntax">prn</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">: </span><span class="identifier-syntax">P_other_side</span><span class="plain-syntax"> = </span><span class="identifier-syntax">prn</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP26"></a><b>&#167;26.  </b>We would like to deduce from a sentence like
</p>

<blockquote>
    <p>The other side of the iron door is the Black Holding Area.</p>
</blockquote>

<p class="commentary">that the "Black Holding Area" is a room; otherwise, if it has no map
connections, Inform may well think it's just an object. This is where that
deduction is made:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::map_property_value_notify</span><button class="popup" onclick="togglePopup('usagePopup14')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup14">Usage of <span class="code-font"><span class="function-syntax">PL::Map::map_property_value_notify</span></span>:<br/><a href="3-tm.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prn</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">val</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">prn</span><span class="plain-syntax"> == </span><span class="identifier-syntax">P_other_side</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Rvalues::to_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">val</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">I</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">World::Inferences::draw</span><span class="plain-syntax">(</span><span class="constant-syntax">IS_ROOM_INF</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="identifier-syntax">CERTAIN_CE</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP27"></a><b>&#167;27.  </b>The I6 <span class="extract"><span class="extract-syntax">found_in</span></span> property is a general mechanism for multiply-present
objects. This causes great complications, and I7 simplifies the model world
by hiding it from the author, and using it internally to implement backdrops
and two-sided doors. Two different plugins therefore need access to it (this
one and Backdrops), and this is where they set it.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::set_found_in</span><button class="popup" onclick="togglePopup('usagePopup15')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup15">Usage of <span class="code-font"><span class="function-syntax">PL::Map::set_found_in</span></span>:<br/><a href="3-tm.html#SP36_8_1">&#167;36.8.1</a><br/>Backdrops - <a href="3-bck.html#SP17">&#167;17</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">inter_name</span><span class="plain-syntax"> *</span><span class="identifier-syntax">S</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">P_found_in</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">P_found_in</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Properties::Valued::new_nameless</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"found_in"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">World::Inferences::get_prop_state</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="identifier-syntax">P_found_in</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"rival found_in interpretations"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Properties::Valued::assert</span><span class="plain-syntax">(</span><span class="identifier-syntax">P_found_in</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Rvalues::from_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">S</span><span class="plain-syntax">), </span><span class="identifier-syntax">CERTAIN_CE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP28"></a><b>&#167;28.  </b>This utility routine which looks for the "opposite"
property in the linked list of inferences belonging to an object.
(This is a property of directions.) Crude, but not time-sensitive,
and there seems little point in writing this any better.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="function-syntax">PL::Map::get_value_of_opposite_property</span><button class="popup" onclick="togglePopup('usagePopup16')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup16">Usage of <span class="code-font"><span class="function-syntax">PL::Map::get_value_of_opposite_property</span></span>:<br/><a href="3-tm.html#SP35">&#167;35</a>, <a href="3-tm.html#SP36_8_4">&#167;36.8.4</a>, <a href="3-tm.html#SP37">&#167;37</a><br/>Spatial Map - <a href="3-sm2.html#SP42_1">&#167;42.1</a>, <a href="3-sm2.html#SP42_3">&#167;42.3</a>, <a href="3-sm2.html#SP44">&#167;44</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">val</span><span class="plain-syntax"> = </span><span class="identifier-syntax">World::Inferences::get_prop_state</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="identifier-syntax">P_opposite</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">val</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">Rvalues::to_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">val</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP29"></a><b>&#167;29.  </b>This really is very approximate, but:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::map_estimate_property_usage</span><button class="popup" onclick="togglePopup('usagePopup17')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup17">Usage of <span class="code-font"><span class="function-syntax">PL::Map::map_estimate_property_usage</span></span>:<br/><a href="3-tm.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">k</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> *</span><span class="identifier-syntax">words_used</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Compare::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">k</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_door</span><span class="plain-syntax">)) *</span><span class="identifier-syntax">words_used</span><span class="plain-syntax"> += </span><span class="constant-syntax">14</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Compare::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">k</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_room</span><span class="plain-syntax">)) *</span><span class="identifier-syntax">words_used</span><span class="plain-syntax"> += </span><span class="constant-syntax">2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP30"></a><b>&#167;30. Linguistic extras. </b>These NPs allow us to refer to the special directions "up" and "down":
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;notable-map-noun-phrases&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">below</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">above</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP31"></a><b>&#167;31.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::map_act_on_special_NPs</span><button class="popup" onclick="togglePopup('usagePopup18')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup18">Usage of <span class="code-font"><span class="function-syntax">PL::Map::map_act_on_special_NPs</span></span>:<br/><a href="3-tm.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;notable-map-noun-phrases&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;&lt;r&gt;&gt;</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="constant-syntax">0</span><span class="plain-syntax">:</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">I_down</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">Refiner::give_subject_to_noun</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I_down</span><span class="plain-syntax">));</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">:</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">I_up</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">Refiner::give_subject_to_noun</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I_up</span><span class="plain-syntax">));</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP32"></a><b>&#167;32.  </b>We also add some optional clauses to the "going" action:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::map_check_going</span><button class="popup" onclick="togglePopup('usagePopup19')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup19">Usage of <span class="code-font"><span class="function-syntax">PL::Map::map_check_going</span></span>:<br/><a href="3-tm.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">from</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">to</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">by</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">through</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pushing</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="4-ap.html#SP5" class="function-link"><span class="function-syntax">PL::Actions::Patterns::check_going</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">from</span><span class="plain-syntax">, </span><span class="string-syntax">"from"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">K_room</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_region</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="4-ap.html#SP5" class="function-link"><span class="function-syntax">PL::Actions::Patterns::check_going</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">to</span><span class="plain-syntax">, </span><span class="string-syntax">"to"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">K_room</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_region</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="4-ap.html#SP5" class="function-link"><span class="function-syntax">PL::Actions::Patterns::check_going</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">by</span><span class="plain-syntax">, </span><span class="string-syntax">"by"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">K_thing</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="4-ap.html#SP5" class="function-link"><span class="function-syntax">PL::Actions::Patterns::check_going</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">through</span><span class="plain-syntax">, </span><span class="string-syntax">"through"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">K_door</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="4-ap.html#SP5" class="function-link"><span class="function-syntax">PL::Actions::Patterns::check_going</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">pushing</span><span class="plain-syntax">, </span><span class="string-syntax">"with"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">K_thing</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP33"></a><b>&#167;33.  </b>Consider the sentences:
</p>

<blockquote>
    <p>A dead end is a kind of room. The Pitch is a room. East is a dead end.</p>
</blockquote>

<p class="commentary">Inform would ordinarily read the third sentence as saying that the "east"
object (a direction) has kind "dead end", and would throw a problem message.
</p>

<p class="commentary">What was actually meant, of course, is that a new instance of "dead end"
exists to the east of the Pitch; in effect, we read it as:
</p>

<blockquote>
    <p>Z is a dead end. East is Z.</p>
</blockquote>

<p class="commentary">where Z is a newly created and nameless object.
</p>

<p class="commentary">But we must be careful not to catch "East is a direction" in the same net
because, of course, that does set its kind.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::map_intervene_in_assertion</span><button class="popup" onclick="togglePopup('usagePopup20')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup20">Usage of <span class="code-font"><span class="function-syntax">PL::Map::map_intervene_in_assertion</span></span>:<br/><a href="3-tm.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">px</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">py</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">px</span><span class="plain-syntax">) == </span><span class="identifier-syntax">PROPER_NOUN_NT</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">py</span><span class="plain-syntax">) == </span><span class="identifier-syntax">COMMON_NOUN_NT</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">left_object</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">px</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">right_kind</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">py</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><a href="3-tm.html#SP17" class="function-link"><span class="function-syntax">PL::Map::is_a_direction</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">left_object</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">            (</span><a href="3-tm.html#SP17" class="function-link"><span class="function-syntax">PL::Map::is_a_direction</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">right_kind</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Assertions::Creator::convert_instance_to_nounphrase</span><span class="plain-syntax">(</span><span class="identifier-syntax">py</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">px</span><span class="plain-syntax">, </span><span class="identifier-syntax">nowhere_ANNOT</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Problems::Using::assertion_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_NowhereDescribed</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                </span><span class="string-syntax">"'nowhere' cannot be made specific"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="string-syntax">"and so cannot have specific properties or be of any given kind."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP34"></a><b>&#167;34. The map-connector. </b>Now we come to the code which creates map connections. This needs special
treatment only so that asserting \(M(X, Y)\) also asserts \(M'(Y, X)\), where
\(M'\) is the predicate for the opposite direction to \(M\); but since this
is only a guess, it drops from <span class="extract"><span class="extract-syntax">CERTAIN_CE</span></span> to merely <span class="extract"><span class="extract-syntax">LIKELY_CE</span></span>.
</p>

<p class="commentary">However, the map-connector can also run in one-way mode, where it doesn't
make this guess; so we begin with switching in and out.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">oneway_map_connections_only</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::enter_one_way_mode</span><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) { </span><span class="identifier-syntax">oneway_map_connections_only</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">; }</span>
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::exit_one_way_mode</span><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) { </span><span class="identifier-syntax">oneway_map_connections_only</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">; }</span>
</pre>
<p class="commentary firstcommentary"><a id="SP35"></a><b>&#167;35.  </b>Note that, in order to make the conjectural reverse map direction, we need
to look up the "opposite" property of the forward one. This relies on all
directions having their opposites defined before any map is built, and is the
reason for Inform's insistence that directions are always created in matched
pairs.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::connect</span><span class="plain-syntax">(</span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">i_from</span><span class="plain-syntax">, </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">i_to</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">i_dir</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">go_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">InferenceSubjects::as_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">i_from</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">go_to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">InferenceSubjects::as_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">i_to</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">forwards_dir</span><span class="plain-syntax"> = </span><span class="identifier-syntax">InferenceSubjects::as_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">i_dir</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Instances::of_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">forwards_dir</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_direction</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"unknown direction"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">reverse_dir</span><span class="plain-syntax"> = </span><a href="3-tm.html#SP28" class="function-link"><span class="function-syntax">PL::Map::get_value_of_opposite_property</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">forwards_dir</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">go_from</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Problems::quote_source</span><span class="plain-syntax">(1, </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Problems::quote_object</span><span class="plain-syntax">(2, </span><span class="identifier-syntax">forwards_dir</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Problems::quote_object</span><span class="plain-syntax">(3, </span><span class="identifier-syntax">go_to</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::handmade_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_WayFromUnclear</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Problems::issue_problem_segment</span><span class="plain-syntax">(</span>
<span class="plain-syntax">            </span><span class="string-syntax">"On the basis of %1, I'm trying to make a map connection in the "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"%2 direction to %3, but I can't make sense of where it goes from."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Problems::issue_problem_end</span><span class="plain-syntax">();</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>

<span class="plain-syntax">    </span><a href="3-tm.html#SP35" class="function-link"><span class="function-syntax">PL::Map::oneway_map_connection</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">go_from</span><span class="plain-syntax">, </span><span class="identifier-syntax">go_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">forwards_dir</span><span class="plain-syntax">, </span><span class="identifier-syntax">CERTAIN_CE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">reverse_dir</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">go_to</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">oneway_map_connections_only</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Instances::of_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">reverse_dir</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_direction</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Problems::quote_object</span><span class="plain-syntax">(1, </span><span class="identifier-syntax">forwards_dir</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Problems::quote_object</span><span class="plain-syntax">(2, </span><span class="identifier-syntax">reverse_dir</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">StandardProblems::handmade_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_OppositeNotDirection</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Problems::issue_problem_segment</span><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="string-syntax">"I'm trying to make a map connection in the %1 direction, "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"which means there ought to be map connection back in the "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"opposite direction. But the opposite of %1 seems to be %2, "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"which doesn't make sense since %2 isn't a direction. (Maybe "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"you forgot to say that it was?)"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Problems::issue_problem_end</span><span class="plain-syntax">();</span>
<span class="plain-syntax">        } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><a href="3-tm.html#SP35" class="function-link"><span class="function-syntax">PL::Map::oneway_map_connection</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">go_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">go_from</span><span class="plain-syntax">, </span><span class="identifier-syntax">reverse_dir</span><span class="plain-syntax">, </span><span class="identifier-syntax">LIKELY_CE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::oneway_map_connection</span><span class="plain-syntax">(</span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">go_from</span><span class="plain-syntax">, </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">go_to</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">forwards_dir</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">certainty_level</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax"> = </span><a href="3-mcr.html#SP13" class="function-link"><span class="function-syntax">PL::MapDirections::get_mapping_relation</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">forwards_dir</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">bp</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"map connection in non-direction"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">x</span><span class="plain-syntax"> = </span><span class="identifier-syntax">prevailing_mood</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">prevailing_mood</span><span class="plain-syntax"> = </span><span class="identifier-syntax">certainty_level</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Calculus::Propositions::Assert::assert_true_about</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Calculus::Propositions::Abstract::to_set_simple_relation</span><span class="plain-syntax">(</span><span class="identifier-syntax">bp</span><span class="plain-syntax">, </span><span class="identifier-syntax">go_to</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">go_from</span><span class="plain-syntax">), </span><span class="identifier-syntax">certainty_level</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">prevailing_mood</span><span class="plain-syntax"> = </span><span class="identifier-syntax">x</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP36"></a><b>&#167;36. Model completion. </b>And here begins the fun. It's not as easy to write down the requirements for
the map as might be thought.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::map_complete_model</span><button class="popup" onclick="togglePopup('usagePopup21')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup21">Usage of <span class="code-font"><span class="function-syntax">PL::Map::map_complete_model</span></span>:<br/><a href="3-tm.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">stage</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="identifier-syntax">stage</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="constant-syntax">2</span><span class="plain-syntax">:</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP36_1" class="named-paragraph-link"><span class="named-paragraph">Give each room a room-index property as workspace for route finding</span><span class="named-paragraph-number">36.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP36_2" class="named-paragraph-link"><span class="named-paragraph">Ensure that map connections are room-to-room, room-to-door or door-to-room</span><span class="named-paragraph-number">36.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">problem_count</span><span class="plain-syntax"> &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP36_3" class="named-paragraph-link"><span class="named-paragraph">Ensure that every door has either one or two connections from it</span><span class="named-paragraph-number">36.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">problem_count</span><span class="plain-syntax"> &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP36_4" class="named-paragraph-link"><span class="named-paragraph">Ensure that no door has spurious other connections to it</span><span class="named-paragraph-number">36.4</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">problem_count</span><span class="plain-syntax"> &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP36_5" class="named-paragraph-link"><span class="named-paragraph">Ensure that no door uses both map connections and other side</span><span class="named-paragraph-number">36.5</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">problem_count</span><span class="plain-syntax"> &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP36_6" class="named-paragraph-link"><span class="named-paragraph">Ensure that no door is present in a room to which it does not connect</span><span class="named-paragraph-number">36.6</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">problem_count</span><span class="plain-syntax"> &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP36_7" class="named-paragraph-link"><span class="named-paragraph">Place any one-sided door inside the room which connects to it</span><span class="named-paragraph-number">36.7</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP36_8" class="named-paragraph-link"><span class="named-paragraph">Assert found-in, door-to and door-dir properties for doors</span><span class="named-paragraph-number">36.8</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="constant-syntax">4</span><span class="plain-syntax">: </span><a href="3-tm.html#SP21" class="function-link"><span class="function-syntax">PL::Map::build_exits_array</span></a><span class="plain-syntax">(); </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP36_1"></a><b>&#167;36.1.  </b>Every room has a <span class="extract"><span class="extract-syntax">room_index</span></span> property. It has no meaningful contents at
the start of play, and we initialise to \(-1\) since this marks the route-finding
cache as being broken. (Route-finding is one of the few really time-critical
tasks at run-time, which is why we keep complicating the I7 code to
accommodate it.)
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Give each room a room-index property as workspace for route finding</span><span class="named-paragraph-number">36.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">P_room_index</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Properties::Valued::new_nameless</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"room_index"</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_number</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">minus_one</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Rvalues::from_int</span><span class="plain-syntax">(-1, </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="3-sm.html#SP15" class="function-link"><span class="function-syntax">PL::Spatial::object_is_a_room</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Properties::Valued::assert</span><span class="plain-syntax">(</span><span class="identifier-syntax">P_room_index</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="identifier-syntax">minus_one</span><span class="plain-syntax">, </span><span class="identifier-syntax">CERTAIN_CE</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP36">&#167;36</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP36_2"></a><b>&#167;36.2.  </b>The following code does little if the source is correct: it mostly
checks that various mapping impossibilities do not occur.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Ensure that map connections are room-to-room, room-to-door or door-to-room</span><span class="named-paragraph-number">36.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inference</span><span class="plain-syntax"> *</span><span class="identifier-syntax">inf</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">POSITIVE_KNOWLEDGE_LOOP</span><span class="plain-syntax">(</span><span class="identifier-syntax">inf</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="constant-syntax">DIRECTION_INF</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">World::Inferences::get_references</span><span class="plain-syntax">(</span><span class="identifier-syntax">inf</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">infs1</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">InferenceSubjects::as_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">infs1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><a href="3-sm.html#SP15" class="function-link"><span class="function-syntax">PL::Spatial::object_is_a_room</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)) &amp;&amp; (</span><span class="identifier-syntax">to</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">                (</span><a href="3-tm.html#SP16" class="function-link"><span class="function-syntax">PL::Map::object_is_a_door</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">to</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">                (</span><a href="3-sm.html#SP15" class="function-link"><span class="function-syntax">PL::Spatial::object_is_a_room</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">to</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">))</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">StandardProblems::contradiction_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_BadMapCell</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">Instances::get_creating_sentence</span><span class="plain-syntax">(</span><span class="identifier-syntax">to</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">World::Inferences::where_inferred</span><span class="plain-syntax">(</span><span class="identifier-syntax">inf</span><span class="plain-syntax">), </span><span class="identifier-syntax">to</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                    </span><span class="string-syntax">"appears to be something which can be reached via a map "</span>
<span class="plain-syntax">                    </span><span class="string-syntax">"connection, but it seems to be neither a room nor a door"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                    </span><span class="string-syntax">"and these are the only possibilities allowed by Inform."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><a href="3-tm.html#SP16" class="function-link"><span class="function-syntax">PL::Map::object_is_a_door</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">                (</span><a href="3-sm.html#SP15" class="function-link"><span class="function-syntax">PL::Spatial::object_is_a_room</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">to</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">))</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">StandardProblems::object_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_DoorToNonRoom</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">I</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                    </span><span class="string-syntax">"seems to be a door opening on something not a room"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                    </span><span class="string-syntax">"but a door must connect one or two rooms (and in particular is "</span>
<span class="plain-syntax">                    </span><span class="string-syntax">"not allowed to connect to another door)."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP36">&#167;36</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP36_3"></a><b>&#167;36.3.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Ensure that every door has either one or two connections from it</span><span class="named-paragraph-number">36.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="3-tm.html#SP16" class="function-link"><span class="function-syntax">PL::Map::object_is_a_door</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">connections_in</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">inference</span><span class="plain-syntax"> *</span><span class="identifier-syntax">inf</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">where</span><span class="plain-syntax">[3];</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">where</span><span class="plain-syntax">[0] = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="identifier-syntax">where</span><span class="plain-syntax">[1] = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="identifier-syntax">where</span><span class="plain-syntax">[2] = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="comment-syntax"> to placate </span><span class="extract"><span class="extract-syntax">gcc</span></span>
<span class="plain-syntax">            </span><span class="identifier-syntax">inference</span><span class="plain-syntax"> *</span><span class="identifier-syntax">front_side_inf</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, *</span><span class="identifier-syntax">back_side_inf</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">POSITIVE_KNOWLEDGE_LOOP</span><span class="plain-syntax">(</span><span class="identifier-syntax">inf</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="constant-syntax">DIRECTION_INF</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs1</span><span class="plain-syntax">, *</span><span class="identifier-syntax">infs2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">World::Inferences::get_references</span><span class="plain-syntax">(</span><span class="identifier-syntax">inf</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">infs1</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">infs2</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">InferenceSubjects::as_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">infs1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">dir</span><span class="plain-syntax"> = </span><span class="identifier-syntax">InferenceSubjects::as_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">infs2</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">to</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">connections_in</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_a</span><span class="plain-syntax"> = </span><span class="identifier-syntax">to</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_direction_a</span><span class="plain-syntax"> = </span><span class="identifier-syntax">dir</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">where</span><span class="plain-syntax">[0] = </span><span class="identifier-syntax">World::Inferences::where_inferred</span><span class="plain-syntax">(</span><span class="identifier-syntax">inf</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">front_side_inf</span><span class="plain-syntax"> = </span><span class="identifier-syntax">inf</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    }</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">connections_in</span><span class="plain-syntax"> == </span><span class="constant-syntax">1</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_b</span><span class="plain-syntax"> = </span><span class="identifier-syntax">to</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_direction_b</span><span class="plain-syntax"> = </span><span class="identifier-syntax">dir</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">where</span><span class="plain-syntax">[1] = </span><span class="identifier-syntax">World::Inferences::where_inferred</span><span class="plain-syntax">(</span><span class="identifier-syntax">inf</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">back_side_inf</span><span class="plain-syntax"> = </span><span class="identifier-syntax">inf</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    }</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">connections_in</span><span class="plain-syntax"> == </span><span class="constant-syntax">2</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">where</span><span class="plain-syntax">[2] = </span><span class="identifier-syntax">World::Inferences::where_inferred</span><span class="plain-syntax">(</span><span class="identifier-syntax">inf</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    }</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">connections_in</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">front_side_inf</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">back_side_inf</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">World::Inferences::get_timestamp</span><span class="plain-syntax">(</span><span class="identifier-syntax">front_side_inf</span><span class="plain-syntax">) &gt;</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">World::Inferences::get_timestamp</span><span class="plain-syntax">(</span><span class="identifier-syntax">back_side_inf</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">X</span><span class="plain-syntax"> = </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_a</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_a</span><span class="plain-syntax"> = </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_b</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_b</span><span class="plain-syntax"> = </span><span class="identifier-syntax">X</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">X</span><span class="plain-syntax"> = </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_direction_a</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_direction_a</span><span class="plain-syntax"> = </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_direction_b</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_direction_b</span><span class="plain-syntax"> = </span><span class="identifier-syntax">X</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">PX</span><span class="plain-syntax"> = </span><span class="identifier-syntax">where</span><span class="plain-syntax">[0]; </span><span class="identifier-syntax">where</span><span class="plain-syntax">[0] = </span><span class="identifier-syntax">where</span><span class="plain-syntax">[1]; </span><span class="identifier-syntax">where</span><span class="plain-syntax">[1] = </span><span class="identifier-syntax">PX</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">connections_in</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP36_3_1" class="named-paragraph-link"><span class="named-paragraph">Issue a problem message for a stranded door</span><span class="named-paragraph-number">36.3.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">connections_in</span><span class="plain-syntax"> &gt; </span><span class="constant-syntax">2</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP36_3_2" class="named-paragraph-link"><span class="named-paragraph">Issue a problem message for an overactive door</span><span class="named-paragraph-number">36.3.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP36">&#167;36</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP36_3_1"></a><b>&#167;36.3.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue a problem message for a stranded door</span><span class="named-paragraph-number">36.3.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::object_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_DoorUnconnected</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">I</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"seems to be a door with no way in or out"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"so either you didn't mean it to be a door or you haven't specified what's "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"on each side. You could do this by writing something like 'The blue door is "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"east of the Library and west of the Conservatory'."</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP36_3">&#167;36.3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP36_3_2"></a><b>&#167;36.3.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue a problem message for an overactive door</span><span class="named-paragraph-number">36.3.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::quote_object</span><span class="plain-syntax">(1, </span><span class="identifier-syntax">I</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::quote_source</span><span class="plain-syntax">(2, </span><span class="identifier-syntax">where</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::quote_source</span><span class="plain-syntax">(3, </span><span class="identifier-syntax">where</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::quote_source</span><span class="plain-syntax">(4, </span><span class="identifier-syntax">where</span><span class="plain-syntax">[2]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::handmade_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_DoorOverconnected</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::issue_problem_segment</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="string-syntax">"%1 seems to be a door with three ways out (specified %2, %3 and %4), but "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"you can only have one or two sides to a door in Inform: a one-sided "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"door means a door which is only touchable and usable from one side, and an "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"example might be a window through which one falls to the ground below. If "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"you really need a three-sided cavity, best to make it a room in its own right."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::issue_problem_end</span><span class="plain-syntax">();</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP36_3">&#167;36.3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP36_4"></a><b>&#167;36.4.  </b>Since map connections are not always reversible (only most of the time), we
can't assume that having at most two ways out means there are at most two ways
in. So we check here that any way in to a door corresponds to one of its ways
out. (The reverse need not be true: it's possible for a door to lead to a room
from which there's no way back.)
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Ensure that no door has spurious other connections to it</span><span class="named-paragraph-number">36.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="3-sm.html#SP15" class="function-link"><span class="function-syntax">PL::Spatial::object_is_a_room</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">inference</span><span class="plain-syntax"> *</span><span class="identifier-syntax">inf</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">POSITIVE_KNOWLEDGE_LOOP</span><span class="plain-syntax">(</span><span class="identifier-syntax">inf</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="constant-syntax">DIRECTION_INF</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">World::Inferences::get_references</span><span class="plain-syntax">(</span><span class="identifier-syntax">inf</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">infs1</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">InferenceSubjects::as_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">infs1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="3-tm.html#SP16" class="function-link"><span class="function-syntax">PL::Map::object_is_a_door</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">to</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">exit1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">to</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_a</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">exit2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">to</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_b</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">I</span><span class="plain-syntax"> != </span><span class="identifier-syntax">exit1</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">exit2</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Problems::quote_object</span><span class="plain-syntax">(1, </span><span class="identifier-syntax">I</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Problems::quote_object</span><span class="plain-syntax">(2, </span><span class="identifier-syntax">to</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Problems::quote_object</span><span class="plain-syntax">(3, </span><span class="identifier-syntax">exit1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">StandardProblems::handmade_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_RoomTwistyDoor</span><span class="plain-syntax">));</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Problems::issue_problem_segment</span><span class="plain-syntax">(</span>
<span class="plain-syntax">                            </span><span class="string-syntax">"%1, a room, seems to have a map connection which goes "</span>
<span class="plain-syntax">                            </span><span class="string-syntax">"through %2, a door: but that doesn't seem physically "</span>
<span class="plain-syntax">                            </span><span class="string-syntax">"possible, since %2 seems to connect to %3 in the same "</span>
<span class="plain-syntax">                            </span><span class="string-syntax">"direction. Something's twisty here."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Problems::issue_problem_end</span><span class="plain-syntax">();</span>
<span class="plain-syntax">                    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">I</span><span class="plain-syntax"> != </span><span class="identifier-syntax">exit1</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">I</span><span class="plain-syntax"> != </span><span class="identifier-syntax">exit2</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Problems::quote_object</span><span class="plain-syntax">(1, </span><span class="identifier-syntax">I</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Problems::quote_object</span><span class="plain-syntax">(2, </span><span class="identifier-syntax">to</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Problems::quote_object</span><span class="plain-syntax">(3, </span><span class="identifier-syntax">exit1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Problems::quote_object</span><span class="plain-syntax">(4, </span><span class="identifier-syntax">exit2</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">StandardProblems::handmade_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_RoomMissingDoor</span><span class="plain-syntax">));</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Problems::issue_problem_segment</span><span class="plain-syntax">(</span>
<span class="plain-syntax">                            </span><span class="string-syntax">"%1, a room, seems to have a map connection which goes "</span>
<span class="plain-syntax">                            </span><span class="string-syntax">"through %2, a door: but that doesn't seem physically "</span>
<span class="plain-syntax">                            </span><span class="string-syntax">"possible, since the rooms on each side of %2 have "</span>
<span class="plain-syntax">                            </span><span class="string-syntax">"been established as %3 and %4."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Problems::issue_problem_end</span><span class="plain-syntax">();</span>
<span class="plain-syntax">                    }</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP36">&#167;36</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP36_5"></a><b>&#167;36.5.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Ensure that no door uses both map connections and other side</span><span class="named-paragraph-number">36.5</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><a href="3-tm.html#SP16" class="function-link"><span class="function-syntax">PL::Map::object_is_a_door</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_a</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_b</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">World::Inferences::get_prop_state</span><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="identifier-syntax">P_other_side</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">StandardProblems::object_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_BothWaysDoor</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="string-syntax">"seems to be a door whose connections have been given in both "</span>
<span class="plain-syntax">                    </span><span class="string-syntax">"of the alternative ways at once"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                    </span><span class="string-syntax">"by directly giving its map connections (the normal way to set up "</span>
<span class="plain-syntax">                    </span><span class="string-syntax">"a two-sided door) and also by saying what is through it (the normal "</span>
<span class="plain-syntax">                    </span><span class="string-syntax">"way to set up a one-sided door). As a door can't be both one- and "</span>
<span class="plain-syntax">                    </span><span class="string-syntax">"two-sided at once, I'm going to object to this."</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP36">&#167;36</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP36_6"></a><b>&#167;36.6.  </b>The Spatial model requires that rooms are free-standing, that is, not in, on
or part of anything else; but it knows nothing of doors. So if we are not
careful, the source text could put a door on a shelf, or make it part of a
robot, or something like that. (Testing showed, in fact, that some authors
actually wanted to do this, though the result was a horribly inconsistent
model at run-time.) This is where we apply the kill-joy rule in question:
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Ensure that no door is present in a room to which it does not connect</span><span class="named-paragraph-number">36.6</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><a href="3-tm.html#SP16" class="function-link"><span class="function-syntax">PL::Map::object_is_a_door</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">            (</span><a href="3-sm.html#SP30" class="function-link"><span class="function-syntax">PL::Spatial::progenitor</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">            (</span><a href="3-sm.html#SP30" class="function-link"><span class="function-syntax">PL::Spatial::progenitor</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">) != </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_a</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            (</span><a href="3-sm.html#SP30" class="function-link"><span class="function-syntax">PL::Spatial::progenitor</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">) != </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_b</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">StandardProblems::object_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_DoorInThirdRoom</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="string-syntax">"seems to be a door which is present in a room to which it is not connected"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="string-syntax">"but this is not allowed. A door must be in one or both of the rooms it is "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"between, but not in a third place altogether."</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP36">&#167;36</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP36_7"></a><b>&#167;36.7.  </b>We don't need to do the following for two-sided doors since they will bypass
the object tree and use I6's <span class="extract"><span class="extract-syntax">found_in</span></span> to be present in both rooms connecting
to them.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Place any one-sided door inside the room which connects to it</span><span class="named-paragraph-number">36.7</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><a href="3-tm.html#SP16" class="function-link"><span class="function-syntax">PL::Map::object_is_a_door</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_b</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            (</span><a href="3-sm.html#SP30" class="function-link"><span class="function-syntax">PL::Spatial::progenitor</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">) == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><a href="3-sm.html#SP30" class="function-link"><span class="function-syntax">PL::Spatial::set_progenitor</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_a</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP36">&#167;36</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP36_8"></a><b>&#167;36.8.  </b>At this point we know that the doors are correctly plumbed in, and all we
need to do is compile properties to implement them. See the DM4 for details
of how to compile one and two-sided doors in I6. Alternatively, take it on
trust that there is nothing surprising here.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Assert found-in, door-to and door-dir properties for doors</span><span class="named-paragraph-number">36.8</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">P_door</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Properties::EitherOr::new_nameless</span><span class="plain-syntax">(</span><span class="identifier-syntax">L</span><span class="string-syntax">"door"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Properties::EitherOr::implement_as_attribute</span><span class="plain-syntax">(</span><span class="identifier-syntax">P_door</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">P_door_dir</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Properties::Valued::new_nameless</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"door_dir"</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">P_door_to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Properties::Valued::new_nameless</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"door_to"</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="3-tm.html#SP16" class="function-link"><span class="function-syntax">PL::Map::object_is_a_door</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Properties::EitherOr::assert</span><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">P_door</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">CERTAIN_CE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">R1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_a</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">R2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_connection_b</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">D1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_direction_a</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">D2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">PF_I</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">map_direction_b</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">R1</span><span class="plain-syntax"> &amp;&amp; </span><span class="identifier-syntax">R2</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP36_8_1" class="named-paragraph-link"><span class="named-paragraph">Assert found-in for a two-sided door</span><span class="named-paragraph-number">36.8.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP36_8_2" class="named-paragraph-link"><span class="named-paragraph">Assert door-dir for a two-sided door</span><span class="named-paragraph-number">36.8.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP36_8_3" class="named-paragraph-link"><span class="named-paragraph">Assert door-to for a two-sided door</span><span class="named-paragraph-number">36.8.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">R1</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="named-paragraph-container code-font"><a href="3-tm.html#SP36_8_4" class="named-paragraph-link"><span class="named-paragraph">Assert door-dir for a one-sided door</span><span class="named-paragraph-number">36.8.4</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP36">&#167;36</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP36_8_1"></a><b>&#167;36.8.1.  </b>Here <span class="extract"><span class="extract-syntax">found_in</span></span> is a two-entry list.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Assert found-in for a two-sided door</span><span class="named-paragraph-number">36.8.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">package_request</span><span class="plain-syntax"> *</span><span class="identifier-syntax">PR</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Hierarchy::package_within</span><span class="plain-syntax">(</span><span class="identifier-syntax">INLINE_PROPERTIES_HAP</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::package</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inter_name</span><span class="plain-syntax"> *</span><span class="identifier-syntax">S</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Hierarchy::make_iname_in</span><span class="plain-syntax">(</span><span class="identifier-syntax">INLINE_PROPERTY_HL</span><span class="plain-syntax">, </span><span class="identifier-syntax">PR</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">packaging_state</span><span class="plain-syntax"> </span><span class="identifier-syntax">save</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Emit::named_array_begin</span><span class="plain-syntax">(</span><span class="identifier-syntax">S</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Emit::array_iname_entry</span><span class="plain-syntax">(</span><span class="identifier-syntax">Instances::iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">R1</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Emit::array_iname_entry</span><span class="plain-syntax">(</span><span class="identifier-syntax">Instances::iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">R2</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Emit::array_end</span><span class="plain-syntax">(</span><span class="identifier-syntax">save</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Produce::annotate_i</span><span class="plain-syntax">(</span><span class="identifier-syntax">S</span><span class="plain-syntax">, </span><span class="identifier-syntax">INLINE_ARRAY_IANN</span><span class="plain-syntax">, </span><span class="constant-syntax">1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="3-tm.html#SP27" class="function-link"><span class="function-syntax">PL::Map::set_found_in</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">S</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP36_8">&#167;36.8</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP36_8_2"></a><b>&#167;36.8.2.  </b>Here <span class="extract"><span class="extract-syntax">door_dir</span></span> is a routine looking at the current location and returning
always the way to the other room &mdash; the one we are not in.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Assert door-dir for a two-sided door</span><span class="named-paragraph-number">36.8.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">door_dir_notice</span><span class="plain-syntax"> *</span><span class="identifier-syntax">notice</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">door_dir_notice</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ddn_iname</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Hierarchy::make_iname_in</span><span class="plain-syntax">(</span><span class="identifier-syntax">TSD_DOOR_DIR_FN_HL</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::package</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">door</span><span class="plain-syntax"> = </span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">R1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">R1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">D1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">D1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">D2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">D2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Properties::Valued::assert</span><span class="plain-syntax">(</span><span class="identifier-syntax">P_door_dir</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Rvalues::from_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ddn_iname</span><span class="plain-syntax">), </span><span class="identifier-syntax">CERTAIN_CE</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP36_8">&#167;36.8</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP36_8_3"></a><b>&#167;36.8.3.  </b>Here <span class="extract"><span class="extract-syntax">door_to</span></span> is a routine looking at the current location and returning
always the other room &mdash; the one we are not in.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Assert door-to for a two-sided door</span><span class="named-paragraph-number">36.8.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">door_to_notice</span><span class="plain-syntax"> *</span><span class="identifier-syntax">notice</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">door_to_notice</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">dtn_iname</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Hierarchy::make_iname_in</span><span class="plain-syntax">(</span><span class="identifier-syntax">TSD_DOOR_TO_FN_HL</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::package</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">door</span><span class="plain-syntax"> = </span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">R1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">R1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">R2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">R2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Properties::Valued::assert</span><span class="plain-syntax">(</span><span class="identifier-syntax">P_door_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Rvalues::from_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">dtn_iname</span><span class="plain-syntax">), </span><span class="identifier-syntax">CERTAIN_CE</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP36_8">&#167;36.8</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP36_8_4"></a><b>&#167;36.8.4.  </b>The reversal of direction here looks peculiar, but is correct. Suppose
the Drainage Room contains a one-sided door called the iron grating, and
the iron grating is east of the Drainage Room. To get through, the player
will type EAST. But that means the iron grating has one exit, west to the
Drainage Room; so Inform looks at this exit, reverses west to east, and
compiles east into the <span class="extract"><span class="extract-syntax">door_dir</span></span> property.
</p>

<p class="commentary">As for what lies beyond the iron grating, that's stored in the "other side"
property for the door; "other side" is an alias for <span class="extract"><span class="extract-syntax">door_to</span></span>, which is
why we don't need to compile <span class="extract"><span class="extract-syntax">door_to</span></span> here.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Assert door-dir for a one-sided door</span><span class="named-paragraph-number">36.8.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">backwards</span><span class="plain-syntax"> = </span><a href="3-tm.html#SP28" class="function-link"><span class="function-syntax">PL::Map::get_value_of_opposite_property</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">D1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">backwards</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Properties::Valued::assert</span><span class="plain-syntax">(</span><span class="identifier-syntax">P_door_dir</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Rvalues::from_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">Instances::emitted_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">backwards</span><span class="plain-syntax">)), </span><span class="identifier-syntax">CERTAIN_CE</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-tm.html#SP36_8">&#167;36.8</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP37"></a><b>&#167;37. Redeeming those notices. </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::write_door_dir_routines</span><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">door_dir_notice</span><span class="plain-syntax"> *</span><span class="identifier-syntax">notice</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">notice</span><span class="plain-syntax">, </span><span class="reserved-syntax">door_dir_notice</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">packaging_state</span><span class="plain-syntax"> </span><span class="identifier-syntax">save</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Routines::begin</span><span class="plain-syntax">(</span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ddn_iname</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">local_variable</span><span class="plain-syntax"> *</span><span class="identifier-syntax">loc</span><span class="plain-syntax"> = </span><span class="identifier-syntax">LocalVariables::add_internal_local_c</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"loc"</span><span class="plain-syntax">, </span><span class="string-syntax">"room of actor"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inter_symbol</span><span class="plain-syntax"> *</span><span class="identifier-syntax">loc_s</span><span class="plain-syntax"> = </span><span class="identifier-syntax">LocalVariables::declare_this</span><span class="plain-syntax">(</span><span class="identifier-syntax">loc</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">8</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">STORE_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::ref_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">loc_s</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::val_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">Hierarchy::find</span><span class="plain-syntax">(</span><span class="identifier-syntax">LOCATION_HL</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>

<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">IF_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">EQ_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">loc_s</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::val_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">Hierarchy::find</span><span class="plain-syntax">(</span><span class="identifier-syntax">THEDARK_HL</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::code</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">STORE_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">Produce::ref_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">loc_s</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">Produce::val_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">Hierarchy::find</span><span class="plain-syntax">(</span><span class="identifier-syntax">REAL_LOCATION_HL</span><span class="plain-syntax">));</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>

<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">IF_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">EQ_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">loc_s</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::val_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">R1</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::code</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">RETURN_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">Produce::val_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Instances::iname</span><span class="plain-syntax">(</span><a href="3-tm.html#SP28" class="function-link"><span class="function-syntax">PL::Map::get_value_of_opposite_property</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">D1</span><span class="plain-syntax">)));</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>

<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">RETURN_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::val_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Instances::iname</span><span class="plain-syntax">(</span><a href="3-tm.html#SP28" class="function-link"><span class="function-syntax">PL::Map::get_value_of_opposite_property</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">D2</span><span class="plain-syntax">)));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>

<span class="plain-syntax">        </span><span class="identifier-syntax">Routines::end</span><span class="plain-syntax">(</span><span class="identifier-syntax">save</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::write_door_to_routines</span><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">door_to_notice</span><span class="plain-syntax"> *</span><span class="identifier-syntax">notice</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">notice</span><span class="plain-syntax">, </span><span class="reserved-syntax">door_to_notice</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">packaging_state</span><span class="plain-syntax"> </span><span class="identifier-syntax">save</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Routines::begin</span><span class="plain-syntax">(</span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">dtn_iname</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">local_variable</span><span class="plain-syntax"> *</span><span class="identifier-syntax">loc</span><span class="plain-syntax"> = </span><span class="identifier-syntax">LocalVariables::add_internal_local_c</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"loc"</span><span class="plain-syntax">, </span><span class="string-syntax">"room of actor"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inter_symbol</span><span class="plain-syntax"> *</span><span class="identifier-syntax">loc_s</span><span class="plain-syntax"> = </span><span class="identifier-syntax">LocalVariables::declare_this</span><span class="plain-syntax">(</span><span class="identifier-syntax">loc</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">8</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">STORE_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::ref_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">loc_s</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::val_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">Hierarchy::find</span><span class="plain-syntax">(</span><span class="identifier-syntax">LOCATION_HL</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>

<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">IF_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">EQ_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">loc_s</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::val_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">Hierarchy::find</span><span class="plain-syntax">(</span><span class="identifier-syntax">THEDARK_HL</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::code</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">STORE_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">Produce::ref_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">loc_s</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">Produce::val_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">Hierarchy::find</span><span class="plain-syntax">(</span><span class="identifier-syntax">REAL_LOCATION_HL</span><span class="plain-syntax">));</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>

<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">IF_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">EQ_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">loc_s</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::val_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">R1</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::code</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">RETURN_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">Produce::val_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">R2</span><span class="plain-syntax">));</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>

<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::inv_primitive</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">RETURN_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::down</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Produce::val_iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">notice</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">R1</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">());</span>

<span class="plain-syntax">        </span><span class="identifier-syntax">Routines::end</span><span class="plain-syntax">(</span><span class="identifier-syntax">save</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP38"></a><b>&#167;38. Indexing. </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::map_add_to_World_index</span><button class="popup" onclick="togglePopup('usagePopup22')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup22">Usage of <span class="code-font"><span class="function-syntax">PL::Map::map_add_to_World_index</span></span>:<br/><a href="3-tm.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">OUTPUT_STREAM</span><span class="plain-syntax">, </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">O</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">O</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Instances::of_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">O</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_room</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><a href="3-sm2.html#SP44" class="function-link"><span class="function-syntax">PL::SpatialMap::index_room_connections</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">O</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">PL::Map::map_annotate_in_World_index</span><button class="popup" onclick="togglePopup('usagePopup23')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup23">Usage of <span class="code-font"><span class="function-syntax">PL::Map::map_annotate_in_World_index</span></span>:<br/><a href="3-tm.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">OUTPUT_STREAM</span><span class="plain-syntax">, </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">O</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">O</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Instances::of_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">O</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_door</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, *</span><span class="identifier-syntax">B</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><a href="3-tm.html#SP23" class="function-link"><span class="function-syntax">PL::Map::get_door_data</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">O</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">A</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">B</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">A</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">B</span><span class="plain-syntax">)) </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">" - &lt;i&gt;door to "</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">" - &lt;i&gt;one-sided door to "</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">X</span><span class="plain-syntax"> = </span><span class="identifier-syntax">A</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">A</span><span class="plain-syntax"> == </span><span class="identifier-syntax">indexing_room</span><span class="plain-syntax">) </span><span class="identifier-syntax">X</span><span class="plain-syntax"> = </span><span class="identifier-syntax">B</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">X</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">S</span><span class="plain-syntax"> = </span><span class="identifier-syntax">World::Inferences::get_prop_state</span><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">O</span><span class="plain-syntax">), </span><span class="identifier-syntax">P_other_side</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">X</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Rvalues::to_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">S</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">X</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"nowhere"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">Instances::index_name</span><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">X</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"&lt;/i&gt;"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="3-rgn.html">&#10094;</a></li><li class="progresschapter"><a href="1-im.html">1</a></li><li class="progresschapter"><a href="2-ifi.html">2</a></li><li class="progresscurrentchapter">3</li><li class="progresssection"><a href="3-tnt.html">tnt</a></li><li class="progresssection"><a href="3-sm.html">sm</a></li><li class="progresssection"><a href="3-sr.html">sr</a></li><li class="progresssection"><a href="3-prs.html">prs</a></li><li class="progresssection"><a href="3-tp.html">tp</a></li><li class="progresssection"><a href="3-dvc.html">dvc</a></li><li class="progresssection"><a href="3-bck.html">bck</a></li><li class="progresssection"><a href="3-rgn.html">rgn</a></li><li class="progresscurrent">tm</li><li class="progresssection"><a href="3-mcr.html">mcr</a></li><li class="progresssection"><a href="3-sg.html">sg</a></li><li class="progresssection"><a href="3-sm2.html">sm2</a></li><li class="progresssection"><a href="3-hm.html">hm</a></li><li class="progresssection"><a href="3-em.html">em</a></li><li class="progresssection"><a href="3-sc.html">sc</a></li><li class="progresssection"><a href="3-scn.html">scn</a></li><li class="progresssection"><a href="3-tm2.html">tm2</a></li><li class="progresssection"><a href="3-ts.html">ts</a></li><li class="progresschapter"><a href="4-act.html">4</a></li><li class="progresschapter"><a href="5-itg.html">5</a></li><li class="progressnext"><a href="3-mcr.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

