<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>5/tpv</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '5/gpr' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">if</a></li><li><a href="index.html#5">Chapter 5: Command Grammar</a></li><li><b>General Parsing Routines</b></li></ul><p class="purpose">To compile I6 general parsing routines (GPRs) and/or |parse_name| properties as required by the I7 grammar.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP3">&#167;3. Consult routines</a></li><li><a href="#SP5">&#167;5. Parse name properties</a></li><li><a href="#SP11">&#167;11. Common handling for distinguishing and parsing</a></li><li><a href="#SP12">&#167;12. Distinguishing visible properties</a></li><li><a href="#SP14">&#167;14. Parsing visible properties</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">parse_name_notice</span><span class="plain"> {</span>
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">pnn_iname</span><span class="plain">;</span>
        <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">parse_subject</span><span class="plain">;</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">parse_name_notice</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure parse_name_notice is private to this section.</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>In this section we compile GPRs, routines to handle <code class="display"><span class="extract">Consult</span></code>-like text,
and also <code class="display"><span class="extract">parse_name</span></code> routines, which as we shall see come in two different
forms. These routines share a basic protocol for dealing with the I6
library, which makes things considerably easier. In each case, the
routine is compiled as a head and then, subsequently, a tail: the user
of the routines is expected to compile the actual grammar in between
the two. Every head must be followed by exactly one tail of the same
sort; every tail must be preceded by exactly one head of the same sort;
but code to parse at <code class="display"><span class="extract">wn</span></code> may be placed in between.
</p>

<p class="inwebparagraph">The GPRs compiled to parse literal values of given kinds of values
(for instance, exotic verbal forms of numbers, or verbal names of
the constants for new kinds of value, or literal patterns) are not
compiled here: they are in Tokens Parsing Values.
</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Consult routines. </b>These are used to parse an explicit range of words (such as traditionally
found in the CONSULT command) at run time, and they are not I6 grammar
tokens, and do not appear in <code class="display"><span class="extract">Verb</span></code> declarations: otherwise, such
routines are very similar to GPRs.
</p>

<p class="inwebparagraph">First, we need to look after a pointer to the GV used to hold the grammar
being matched against the snippet of words.
</p>


<pre class="display">
    <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">consultation_gv</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">used only in routines below</span>

    <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Tokens::General::get_consultation_gv</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">consultation_gv</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">consultation_gv</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::consultation_new</span><span class="plain">();</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">consultation_gv</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::prepare_consultation_gv</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">consultation_gv</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Tokens::General::print_consultation_gv_name</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">consultation_gv</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::consult_iname</span><span class="plain">(</span><span class="identifier">consultation_gv</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Tokens::General::consult_iname</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_consult_iname</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">package_request</span><span class="plain"> *</span><span class="identifier">PR</span><span class="plain"> = </span><span class="identifier">Hierarchy::local_package</span><span class="plain">(</span><span class="identifier">CONSULT_TOKENS_HAP</span><span class="plain">);</span>
            <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_consult_iname</span><span class="plain"> = </span><span class="identifier">Hierarchy::make_iname_in</span><span class="plain">(</span><span class="identifier">CONSULT_FN_HL</span><span class="plain">, </span><span class="identifier">PR</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_consult_iname</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::General::get_consultation_gv is used in 5/tfg (<a href="5-tfg.html#SP21">&#167;21</a>).</p>

<p class="endnote">The function PL::Parsing::Tokens::General::prepare_consultation_gv is used in 5/tfg (<a href="5-tfg.html#SP8">&#167;8</a>).</p>

<p class="endnote">The function PL::Parsing::Tokens::General::print_consultation_gv_name is used in 5/tfg (<a href="5-tfg.html#SP8">&#167;8</a>).</p>

<p class="endnote">The function PL::Parsing::Tokens::General::consult_iname is used in 5/gv (<a href="5-gv.html#SP27">&#167;27</a>).</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>We also, at another time, need to compile the routine being named. There
are no timing difficulties here: the routine's name is used in the context of
an I6 constant rather than in a <code class="display"><span class="extract">Verb</span></code> declaration, so no predeclaration is
needed.
</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Parse name properties. </b>One of the major services provided by I7, as compared with I6, is that it
automatically compiles what would otherwise be laborious <code class="display"><span class="extract">parse_name</span></code>
routines for its objects. This is messy, because the underlying I6 syntax
is messy. The significant complication is that the I6 parser makes two
quite different uses of <code class="display"><span class="extract">parse_name</span></code>: not just for parsing names, but
also for determining whether two objects are visually distinguishable,
something it needs to know in order to make plural objects work properly.
</p>

<p class="inwebparagraph">If an object has any actual grammar attached, say a collection of grammar
lines belonging to GV3, we will compile the <code class="display"><span class="extract">parse_name</span></code> as an independent
I6 routine with a name like <code class="display"><span class="extract">Parse_Name_GV3</span></code>. If not, a <code class="display"><span class="extract">parse_name</span></code> may
still be needed, because of the distinguishability problem: if so then we
will simply compile a <code class="display"><span class="extract">parse_name</span></code> routine inline, in the usual I6 way.
</p>


<pre class="display">
    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Tokens::General::get_gv_parse_name</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_parse_name_iname</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">compilation_module</span><span class="plain"> *</span><span class="identifier">C</span><span class="plain"> = </span><span class="identifier">Modules::find</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;where_gv_created</span><span class="plain">);</span>
            <span class="identifier">package_request</span><span class="plain"> *</span><span class="identifier">PR</span><span class="plain"> = </span><span class="identifier">Hierarchy::package</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="identifier">PARSE_NAMES_HAP</span><span class="plain">);</span>
            <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_parse_name_iname</span><span class="plain"> = </span><span class="identifier">Hierarchy::make_iname_in</span><span class="plain">(</span><span class="identifier">PARSE_NAME_FN_HL</span><span class="plain">, </span><span class="identifier">PR</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_parse_name_iname</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Tokens::General::compile_parse_name_property</span><span class="plain">(</span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain">) {</span>
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">symb</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain"> = </span><span class="identifier">PF_S</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">)-</span><span class="element">&gt;understand_as_this_object</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">PL::Parsing::Verbs::is_empty</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="identifier">symb</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Tokens::General::get_gv_parse_name</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">PL::Parsing::Visibility::any_property_visible_to_subject</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
                <span class="reserved">parse_name_notice</span><span class="plain"> *</span><span class="identifier">notice</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">parse_name_notice</span><span class="plain">);</span>
                <span class="identifier">compilation_module</span><span class="plain"> *</span><span class="identifier">C</span><span class="plain"> = </span><span class="identifier">Modules::find</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">-&gt;</span><span class="identifier">infs_created_at</span><span class="plain">);</span>
                <span class="identifier">package_request</span><span class="plain"> *</span><span class="identifier">PR</span><span class="plain"> = </span><span class="identifier">Hierarchy::package</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="identifier">PARSE_NAMES_HAP</span><span class="plain">);</span>
                <span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;pnn_iname</span><span class="plain"> = </span><span class="identifier">Hierarchy::make_iname_in</span><span class="plain">(</span><span class="identifier">PARSE_NAME_DASH_FN_HL</span><span class="plain">, </span><span class="identifier">PR</span><span class="plain">);</span>
                <span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;parse_subject</span><span class="plain"> = </span><span class="identifier">subj</span><span class="plain">;</span>
                <span class="identifier">symb</span><span class="plain"> = </span><span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;pnn_iname</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">symb</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::write_parse_name_routines</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">parse_name_notice</span><span class="plain"> *</span><span class="identifier">notice</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">notice</span><span class="plain">, </span><span class="reserved">parse_name_notice</span><span class="plain">) {</span>
            <span class="reserved">gpr_kit</span><span class="plain"> </span><span class="identifier">gprk</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Tokens::Values::new_kit</span><span class="plain">();</span>
            <span class="identifier">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="identifier">Emit::unused_packaging_state</span><span class="plain">();</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">PL::Parsing::Tokens::General::compile_parse_name_head</span><span class="plain">(&amp;</span><span class="identifier">save</span><span class="plain">, &amp;</span><span class="identifier">gprk</span><span class="plain">,</span>
                <span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;parse_subject</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">notice</span><span class="plain">-</span><span class="element">&gt;pnn_iname</span><span class="plain">)) {</span>
                <span class="functiontext">PL::Parsing::Tokens::General::compile_parse_name_tail</span><span class="plain">(&amp;</span><span class="identifier">gprk</span><span class="plain">);</span>
                <span class="identifier">Routines::end</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::General::get_gv_parse_name is used in <a href="#SP6">&#167;6</a>, 5/gv (<a href="5-gv.html#SP27">&#167;27</a>).</p>

<p class="endnote">The function PL::Parsing::Tokens::General::compile_parse_name_property is used in 5/gp (<a href="5-gp.html#SP10_2">&#167;10.2</a>).</p>

<p class="endnote">The function PL::Parsing::Tokens::General::write_parse_name_routines appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>The following routine produces one of three outcomes: either (i) the
head of an I6 declaration of a free-standing routine to be used as a
<code class="display"><span class="extract">parse_name</span></code> property, or (ii) the head of an I6 inline declaration of a
<code class="display"><span class="extract">parse_name</span></code> property as a <code class="display"><span class="extract">with</span></code> clause for an <code class="display"><span class="extract">Object</span></code> directive, or
</p>

<ul class="items"><li>(iii) the empty output, in happy cases where neither parsing nor
distinguishability need to be investigated. The routine returns a flag
indicating if a tail need be compiled (i.e., in cases (i) or (ii) but not
(iii)).
</li></ul>
<p class="inwebparagraph">In cases (i) and (ii), the head is immediately followed by code which
looks at the names of visible properties. Recall that a visible property
is one which can be used to describe an object: for instance, if colour
is a visible property of a car, then it can be called "green car" if
and only if the current value of the colour of the car is "green", and
so forth. In all such cases, we need to parse the text to look for the
name of the current value.
</p>

<p class="inwebparagraph">But if a property can be used as part of the name, then it follows that
two objects with the same grammar (and name words) cease to be
indistinguishable when their values for this property differ. For instance,
given two otherwise identical cars which can only be called "car", we
can distinguish them with the names "red car" and "green car" if one
is red and the other green. The parser needs to know this. It calls the
<code class="display"><span class="extract">parse_name</span></code> routine with an I6 global called <code class="display"><span class="extract">parser_action</span></code> set to
<code class="display"><span class="extract">##TheSame</span></code> in such a case, and we can return 0 to make no decision or
<code class="display"><span class="extract">-2</span></code> to say that they are different.
</p>

<p class="inwebparagraph">Note that the parser checks this only if two or more objects share the same
<code class="display"><span class="extract">parse_name</span></code> routine: which will in I7 happen only if they each inherit it
from the I6 class of a common kind. Because <code class="display"><span class="extract">parse_name</span></code> is not additive in
I6, this can only occur if the objects, and any intervening classes for
intervening kinds, define no <code class="display"><span class="extract">parse_name</span></code> of their own.
</p>

<p class="inwebparagraph">We will test distinguishability only for kinds which have permissions for
visible properties: kinds because no other <code class="display"><span class="extract">parse_name</span></code> values can ever
be duplicated in instance objects, and visible properties because these
are the only ways to tell apart instances which have no grammar of their
own. (If either had grammar of its own, it would also have its own
<code class="display"><span class="extract">parse_name</span></code> routine.) For all other kinds, we return a make-no-decision
value in response to a <code class="display"><span class="extract">##TheSame</span></code> request: this ensures that the I6
parser looks at the <code class="display"><span class="extract">name</span></code> properties of the objects instead, and in
the absence of either I7-level grammar lines or visible properties, that
will be the correct decision.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::compile_parse_name_head</span><span class="plain">(</span><span class="identifier">packaging_state</span><span class="plain"> *</span><span class="identifier">save</span><span class="plain">,</span>
        <span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain">,</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">, </span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">rname</span><span class="plain">) {</span>
    <span class="identifier">STREAM_FLUSH</span><span class="plain">(</span><span class="identifier">DL</span><span class="plain">);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">test_distinguishability</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">sometimes_has_visible_properties</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">N</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">subj</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"compiling parse_name head for null subj"</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">) {</span>
            <span class="identifier">sometimes_has_visible_properties</span><span class="plain"> =</span>
                <span class="functiontext">PL::Parsing::Visibility::any_property_visible_to_subject</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
            <span class="identifier">N</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Tokens::General::get_gv_parse_name</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">PL::Parsing::Visibility::any_property_visible_to_subject</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">)</span>
                <span class="plain">== </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">}</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">InferenceSubjects::domain</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">)) </span><span class="identifier">test_distinguishability</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>

        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">compile_to</span><span class="plain"> = </span><span class="identifier">rname</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">compile_to</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">compile_to</span><span class="plain"> = </span><span class="identifier">N</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">compile_to</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"no parse name routine name given"</span><span class="plain">);</span>

    <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"\</span><span class="plain">n</span><span class="string">\</span><span class="plain">n</span><span class="string">AND %n\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">compile_to</span><span class="plain">);</span>
    <span class="identifier">STREAM_FLUSH</span><span class="plain">(</span><span class="identifier">DL</span><span class="plain">);</span>

        <span class="plain">*</span><span class="identifier">save</span><span class="plain"> = </span><span class="identifier">Routines::begin</span><span class="plain">(</span><span class="identifier">compile_to</span><span class="plain">);</span>

        <span class="functiontext">PL::Parsing::Tokens::Values::add_parse_name_vars</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">);</span>

        <span class="functiontext">PL::Parsing::Tokens::General::top_of_head</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">N</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">,</span>
            <span class="identifier">test_distinguishability</span><span class="plain">, </span><span class="identifier">sometimes_has_visible_properties</span><span class="plain">, </span><span class="identifier">rname</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::General::compile_parse_name_head is used in <a href="#SP5">&#167;5</a>, 5/gv (<a href="5-gv.html#SP27">&#167;27</a>).</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>The following multi-pass approach checks the possible patterns:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(1) (words in <code class="display"><span class="extract">name</span></code> property) (visible property names) (words in <code class="display"><span class="extract">name</span></code> property) (longer grammar) (words in <code class="display"><span class="extract">name</span></code> property)
</li></ul>
<ul class="items"><li>(2) (visible property names) (longer grammar) (words in <code class="display"><span class="extract">name</span></code> property)
</li></ul>
<ul class="items"><li>(3) (longer grammar) (words in <code class="display"><span class="extract">name</span></code> property)
</li></ul>
<p class="inwebparagraph">The longer match is taken: but note that a match of visible property names
alone is rejected unless at least one property has been declared sufficient
to identify the object all by itself. Longer grammar means grammar lines
containing 2 or more words, since all single-fixed-word grammar lines for
GVs destined to be <code class="display"><span class="extract">parse_name</span></code>s is stripped out and converted into the
<code class="display"><span class="extract">name</span></code> property.
</p>

<p class="inwebparagraph">There are clearly other possibilities and the above system is something of
a pragmatic compromise (in that to check other cases would be slower and
more complex). I suspect we will return to this.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::top_of_head</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">gv_iname</span><span class="plain">, </span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain">,</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">test_distinguishability</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">sometimes_has_visible_properties</span><span class="plain">, </span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">given_name</span><span class="plain">) {</span>

        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">ifdebug_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::code</span><span class="plain">();</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">ge_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_TRACE_HL</span><span class="plain">));</span>
                        <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 3);</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::code</span><span class="plain">();</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">print_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_text</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"Parse_name called\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>

        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">gv_iname</span><span class="plain">) &amp;&amp; (</span><span class="identifier">sometimes_has_visible_properties</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_ACTION_HL</span><span class="plain">));</span>
                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">THESAME_HL</span><span class="plain">));</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::code</span><span class="plain">();</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">return_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="plain">}</span>
        &lt;<span class="cwebmacro">Save word number</span> <span class="cwebmacronumber">7.1</span>&gt;<span class="plain">;</span>

        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass_s</span><span class="plain">);</span>
            <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">while_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">le_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass_s</span><span class="plain">);</span>
                <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 3);</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::code</span><span class="plain">();</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                &lt;<span class="cwebmacro">Reset word number</span> <span class="cwebmacronumber">7.2</span>&gt;<span class="plain">;</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;try_from_wn_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;f_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;n_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">while_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                    <span class="identifier">Emit::code</span><span class="plain">();</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>

                        <span class="comment">On pass 1 only, advance <code class="display"><span class="extract">wn</span></code> past name property words</span>
                        <span class="comment">(but do not do this for <code class="display"><span class="extract">##TheSame</span></code>, when <code class="display"><span class="extract">wn</span></code> is undefined)</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">and_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">ne_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_ACTION_HL</span><span class="plain">));</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">THESAME_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::code</span><span class="plain">();</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">while_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::inv_call_iname</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WORDINPROPERTY_HL</span><span class="plain">));</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::inv_call_iname</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">NEXTWORDSTOPPED_HL</span><span class="plain">));</span>
                                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">PL::Parsing::Visibility::name_name</span><span class="plain">());</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                    <span class="identifier">Emit::code</span><span class="plain">();</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                                            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;f_s</span><span class="plain">);</span>
                                            <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>

                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">postdecrement_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;try_from_wn_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>

                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">or_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 2);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::code</span><span class="plain">();</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="functiontext">PL::Parsing::Tokens::General::consider_visible_properties</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">test_distinguishability</span><span class="plain">);</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>

                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">and_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">ne_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_ACTION_HL</span><span class="plain">));</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">THESAME_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::code</span><span class="plain">();</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">while_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::inv_call_iname</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WORDINPROPERTY_HL</span><span class="plain">));</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::inv_call_iname</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">NEXTWORDSTOPPED_HL</span><span class="plain">));</span>
                                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">PL::Parsing::Visibility::name_name</span><span class="plain">());</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                    <span class="identifier">Emit::code</span><span class="plain">();</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                                            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;f_s</span><span class="plain">);</span>
                                            <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>

                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">postdecrement_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;try_from_wn_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::General::top_of_head is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP7_1"></a><b>&#167;7.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Save word number</span> <span class="cwebmacronumber">7.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;original_wn_s</span><span class="plain">);</span>
            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7">&#167;7</a>.</p>

<p class="inwebparagraph"><a id="SP7_2"></a><b>&#167;7.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Reset word number</span> <span class="cwebmacronumber">7.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;original_wn_s</span><span class="plain">);</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7">&#167;7</a>.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>The head and tail routines can only be understood by knowing that the
following code is used to reset the grammar-line parser after each failure
of a GL to parse.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::after_gl_failed</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">label</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">pluralised</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pluralised</span><span class="plain">) {</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_ACTION_HL</span><span class="plain">));</span>
                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PLURALFOUND_HL</span><span class="plain">));</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="plain">}</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;try_from_wn_s</span><span class="plain">);</span>
            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;f_s</span><span class="plain">);</span>
            <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">continue_interp</span><span class="plain">);</span>

        <span class="identifier">Emit::place_label</span><span class="plain">(</span><span class="identifier">label</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;try_from_wn_s</span><span class="plain">);</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::General::after_gl_failed is used in 5/gl (<a href="5-gl.html#SP20">&#167;20</a>).</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>The interesting point about the tail of the <code class="display"><span class="extract">parse_name</span></code> routine is that
it ends on the <code class="display"><span class="extract">]</span></code> "close routine" character, in mid-source line. This is
because the routine may be being used inside an <code class="display"><span class="extract">Object</span></code> directive, and
would therefore need to be followed by a comma, or in free-standing I6 code,
in which case it would need to be followed by a semi-colon.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::compile_parse_name_tail</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">) {</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">break_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>

                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">while_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_call_iname</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WORDINPROPERTY_HL</span><span class="plain">));</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_call_iname</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">NEXTWORDSTOPPED_HL</span><span class="plain">));</span>
                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">PL::Parsing::Visibility::name_name</span><span class="plain">());</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::code</span><span class="plain">();</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">postincrement_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;n_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>

                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">or_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;f_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">gt_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;n_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::code</span><span class="plain">();</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;n_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">minus_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">plus_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;n_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;try_from_wn_s</span><span class="plain">);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;original_wn_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>

                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::code</span><span class="plain">();</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass1_n_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;n_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 2);</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::code</span><span class="plain">();</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass2_n_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;n_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">postincrement_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass_s</span><span class="plain">);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>

        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">ifdebug_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::code</span><span class="plain">();</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">ge_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_TRACE_HL</span><span class="plain">));</span>
                        <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 3);</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::code</span><span class="plain">();</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">print_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_text</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"Pass 1: "</span><span class="plain">);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">printnumber_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass1_n_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">print_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_text</span><span class="plain">(</span><span class="identifier">I</span><span class="string">" Pass 2: "</span><span class="plain">);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">printnumber_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass2_n_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">print_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_text</span><span class="plain">(</span><span class="identifier">I</span><span class="string">" Pass 3: "</span><span class="plain">);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">printnumber_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;n_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">print_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_text</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>

        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">gt_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass1_n_s</span><span class="plain">);</span>
                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;n_s</span><span class="plain">);</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::code</span><span class="plain">();</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;n_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass1_n_s</span><span class="plain">);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">gt_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass2_n_s</span><span class="plain">);</span>
                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;n_s</span><span class="plain">);</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::code</span><span class="plain">();</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;n_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;pass2_n_s</span><span class="plain">);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">plus_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;original_wn_s</span><span class="plain">);</span>
                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;n_s</span><span class="plain">);</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;n_s</span><span class="plain">);</span>
                <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::code</span><span class="plain">();</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">return_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) -1);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::inv_call_iname</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">DETECTPLURALWORD_HL</span><span class="plain">));</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;original_wn_s</span><span class="plain">);</span>
            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;n_s</span><span class="plain">);</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">return_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;n_s</span><span class="plain">);</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::General::compile_parse_name_tail is used in <a href="#SP5">&#167;5</a>, 5/gv (<a href="5-gv.html#SP27">&#167;27</a>).</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>We generate code suitable for inclusion in a <code class="display"><span class="extract">parse_name</span></code> routine which
either tests distinguishability then parses, or else just parses, the
visible properties of a given subject (which may be a kind or instance).
Sometimes we allow visibility to be inherited from a permission given
to a kind, sometimes we require that the permission be given to this
specific object.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::consider_visible_properties</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain">,</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">test_distinguishability</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">phase</span><span class="plain"> = 2;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">test_distinguishability</span><span class="plain">) </span><span class="identifier">phase</span><span class="plain"> = 1;</span>
        <span class="reserved">for</span><span class="plain"> (; </span><span class="identifier">phase</span><span class="plain">&lt;=2; </span><span class="identifier">phase</span><span class="plain">++) {</span>
            <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">pr</span><span class="plain">;</span>
            <span class="functiontext">PL::Parsing::Tokens::General::start_considering_visible_properties</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">phase</span><span class="plain">);</span>
            <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">pr</span><span class="plain">, </span><span class="identifier">property</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Properties::is_either_or</span><span class="plain">(</span><span class="identifier">pr</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">Properties::EitherOr::stored_in_negation</span><span class="plain">(</span><span class="identifier">pr</span><span class="plain">))) </span><span class="reserved">continue</span><span class="plain">;</span>
                <span class="identifier">property_permission</span><span class="plain"> *</span><span class="identifier">pp</span><span class="plain"> =</span>
                    <span class="identifier">World::Permissions::find</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">pr</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">pp</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">PL::Parsing::Visibility::get_level</span><span class="plain">(</span><span class="identifier">pp</span><span class="plain">) &gt; 0))</span>
                    <span class="functiontext">PL::Parsing::Tokens::General::consider_visible_property</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">pr</span><span class="plain">, </span><span class="identifier">pp</span><span class="plain">, </span><span class="identifier">phase</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="functiontext">PL::Parsing::Tokens::General::finish_considering_visible_properties</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">phase</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::General::consider_visible_properties is used in <a href="#SP7">&#167;7</a>.</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Common handling for distinguishing and parsing. </b>The top-level considering routines parcel up work and hand it over to
the distinguishing routines if <code class="display"><span class="extract">phase</span></code> is 1, and the parsing routines
if <code class="display"><span class="extract">phase</span></code> is 2. Note that if there are no sometimes-visible-properties
then the correct behaviour is to call none of the routines below this
level, and to compile nothing to the file.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">visible_properties_code_written</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">; </span>    <span class="comment">persistent state used only here</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::start_considering_visible_properties</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">phase</span><span class="plain">) {</span>
        <span class="identifier">visible_properties_code_written</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::consider_visible_property</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain">,</span>
        <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">pr</span><span class="plain">, </span><span class="identifier">property_permission</span><span class="plain"> *</span><span class="identifier">pp</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">phase</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">conditional_vis</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">visible_properties_code_written</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="identifier">visible_properties_code_written</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phase</span><span class="plain"> == 1)</span>
                <span class="functiontext">PL::Parsing::Tokens::General::begin_distinguishing_visible_properties</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">);</span>
            <span class="reserved">else</span>
                <span class="functiontext">PL::Parsing::Tokens::General::begin_parsing_visible_properties</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">);</span>
        <span class="plain">}</span>

        <span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Visibility::get_condition</span><span class="plain">(</span><span class="identifier">pp</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">spec</span><span class="plain">) {</span>
            <span class="identifier">conditional_vis</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phase</span><span class="plain"> == 1)</span>
                <span class="functiontext">PL::Parsing::Tokens::General::test_distinguish_visible_property</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">spec</span><span class="plain">);</span>
            <span class="reserved">else</span>
                <span class="functiontext">PL::Parsing::Tokens::General::test_parse_visible_property</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="plain">}</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phase</span><span class="plain"> == 1)</span>
            <span class="functiontext">PL::Parsing::Tokens::General::distinguish_visible_property</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">pr</span><span class="plain">);</span>
        <span class="reserved">else</span>
            <span class="functiontext">PL::Parsing::Tokens::General::parse_visible_property</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">pr</span><span class="plain">, </span><span class="functiontext">PL::Parsing::Visibility::get_level</span><span class="plain">(</span><span class="identifier">pp</span><span class="plain">));</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">conditional_vis</span><span class="plain">) { </span><span class="identifier">Emit::up</span><span class="plain">(); </span><span class="identifier">Emit::up</span><span class="plain">(); }</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::finish_considering_visible_properties</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">phase</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">visible_properties_code_written</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phase</span><span class="plain"> == 1)</span>
                <span class="functiontext">PL::Parsing::Tokens::General::finish_distinguishing_visible_properties</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">);</span>
            <span class="reserved">else</span>
                <span class="functiontext">PL::Parsing::Tokens::General::finish_parsing_visible_properties</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::General::start_considering_visible_properties is used in <a href="#SP10">&#167;10</a>.</p>

<p class="endnote">The function PL::Parsing::Tokens::General::consider_visible_property is used in <a href="#SP10">&#167;10</a>.</p>

<p class="endnote">The function PL::Parsing::Tokens::General::finish_considering_visible_properties is used in <a href="#SP10">&#167;10</a>.</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Distinguishing visible properties. </b>We distinguish two objects P1 and P2 based on the following criteria:
</p>

<ul class="items"><li>(i) if any property is currently visible for P1 but not P2 or vice versa,
then they are distinguishable; (ii) if any value property is visible
but P1 and P2 have different values for it, then they are distinguishable;
</li><li>(iii) if any either/or property is visible but P1 has it and P2 hasn't,
or vice versa, then they are distinguishable; and otherwise we revert to
the I6 parser's standard algorithm, which looks at the <code class="display"><span class="extract">name</span></code> property.
</li></ul>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::begin_distinguishing_visible_properties</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">) {</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_ACTION_HL</span><span class="plain">));</span>
                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">THESAME_HL</span><span class="plain">));</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::code</span><span class="plain">();</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">ifdebug_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::code</span><span class="plain">();</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">ge_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_TRACE_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 4);</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::code</span><span class="plain">();</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">print_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_text</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"p1, p2 = "</span><span class="plain">);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">printnumber_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_ONE_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">print_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_text</span><span class="plain">(</span><span class="identifier">I</span><span class="string">", "</span><span class="plain">);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">printnumber_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_TWO_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">print_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_text</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;ss_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::test_distinguish_visible_property</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_ONE_HL</span><span class="plain">));</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;f_s</span><span class="plain">);</span>
            <span class="identifier">Specifications::Compiler::emit_as_val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>

        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_TWO_HL</span><span class="plain">));</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;g_s</span><span class="plain">);</span>
            <span class="identifier">Specifications::Compiler::emit_as_val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>

        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">ne_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;f_s</span><span class="plain">);</span>
                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;g_s</span><span class="plain">);</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::code</span><span class="plain">();</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                &lt;<span class="cwebmacro">Return minus two</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>

        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;f_s</span><span class="plain">);</span>
            <span class="identifier">Emit::code</span><span class="plain">();</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::distinguish_visible_property</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="string">"Distinguishing property %n"</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
        <span class="identifier">Emit::code_comment</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Properties::is_either_or</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">)) {</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">and_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Properties::Emit::emit_iname_has_property</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_ONE_HL</span><span class="plain">), </span><span class="identifier">prn</span><span class="plain">);</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">not_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Properties::Emit::emit_iname_has_property</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_TWO_HL</span><span class="plain">), </span><span class="identifier">prn</span><span class="plain">);</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::code</span><span class="plain">();</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    &lt;<span class="cwebmacro">Return minus two</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>

            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">and_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Properties::Emit::emit_iname_has_property</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_TWO_HL</span><span class="plain">), </span><span class="identifier">prn</span><span class="plain">);</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">not_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Properties::Emit::emit_iname_has_property</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_ONE_HL</span><span class="plain">), </span><span class="identifier">prn</span><span class="plain">);</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::code</span><span class="plain">();</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    &lt;<span class="cwebmacro">Return minus two</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">Properties::Valued::kind</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">);</span>
            <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">distinguisher</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_distinguisher_as_iname</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">distinguisher</span><span class="plain">) {</span>
                    <span class="identifier">Emit::inv_call_iname</span><span class="plain">(</span><span class="identifier">distinguisher</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">propertyvalue_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_ONE_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">propertyvalue_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_TWO_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">ne_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">propertyvalue_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_ONE_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">propertyvalue_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSER_TWO_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="plain">}</span>
                <span class="identifier">Emit::code</span><span class="plain">();</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    &lt;<span class="cwebmacro">Return minus two</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::General::begin_distinguishing_visible_properties is used in <a href="#SP11">&#167;11</a>.</p>

<p class="endnote">The function PL::Parsing::Tokens::General::test_distinguish_visible_property is used in <a href="#SP11">&#167;11</a>.</p>

<p class="endnote">The function PL::Parsing::Tokens::General::distinguish_visible_property is used in <a href="#SP11">&#167;11</a>.</p>

<p class="inwebparagraph"><a id="SP12_1"></a><b>&#167;12.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Return minus two</span> <span class="cwebmacronumber">12.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">return_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) -2);</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a> (four times).</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::finish_distinguishing_visible_properties</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">) {</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;ss_s</span><span class="plain">);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">return_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::General::finish_distinguishing_visible_properties is used in <a href="#SP11">&#167;11</a>.</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Parsing visible properties. </b>Here, unlike in distinguishing visible properties, it is unambiguous that
<code class="display"><span class="extract">self</span></code> refers to the object being parsed: there is therefore no need to
alter the value of <code class="display"><span class="extract">self</span></code> to make any visibility condition work correctly.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::begin_parsing_visible_properties</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">) {</span>
        <span class="identifier">Emit::code_comment</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"Match any number of visible property values"</span><span class="plain">);</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;try_from_wn_s</span><span class="plain">);</span>
            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;g_s</span><span class="plain">);</span>
            <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">while_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;g_s</span><span class="plain">);</span>
            <span class="identifier">Emit::code</span><span class="plain">();</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;g_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::test_parse_visible_property</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Specifications::Compiler::emit_as_val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">spec</span><span class="plain">);</span>
            <span class="identifier">Emit::code</span><span class="plain">();</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">unique_pvp_counter</span><span class="plain"> = 0;</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::parse_visible_property</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">,</span>
        <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">visibility_level</span><span class="plain">) {</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="string">"Parsing property %n"</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
        <span class="identifier">Emit::code_comment</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Properties::is_either_or</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">)) {</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">);</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">, </span><span class="string">".pvp_pass_L_%d"</span><span class="plain">, </span><span class="identifier">unique_pvp_counter</span><span class="plain">++);</span>
            <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">pass_label</span><span class="plain"> = </span><span class="identifier">Emit::reserve_label</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">);</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">);</span>

            <span class="functiontext">PL::Parsing::Tokens::General::parse_visible_either_or</span><span class="plain">(</span>
                <span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">visibility_level</span><span class="plain">, </span><span class="identifier">pass_label</span><span class="plain">);</span>
            <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">prnbar</span><span class="plain"> = </span><span class="identifier">Properties::EitherOr::get_negation</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prnbar</span><span class="plain">)</span>
                <span class="functiontext">PL::Parsing::Tokens::General::parse_visible_either_or</span><span class="plain">(</span>
                    <span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">prnbar</span><span class="plain">, </span><span class="identifier">visibility_level</span><span class="plain">, </span><span class="identifier">pass_label</span><span class="plain">);</span>

            <span class="identifier">Emit::place_label</span><span class="plain">(</span><span class="identifier">pass_label</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;try_from_wn_s</span><span class="plain">);</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>

            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;spn_s</span><span class="plain">);</span>
                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSED_NUMBER_HL</span><span class="plain">));</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;ss_s</span><span class="plain">);</span>
                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">ETYPE_HL</span><span class="plain">));</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>

            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">Properties::Valued::kind</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">);</span>
                <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">recog_gpr</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_recognition_only_GPR_as_iname</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">recog_gpr</span><span class="plain">) {</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_call_iname</span><span class="plain">(</span><span class="identifier">recog_gpr</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">propertyvalue_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_PREPOSITION_HL</span><span class="plain">));</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Behaviour::offers_I6_GPR</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">)) {</span>
                    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">i6_gpr_name</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_explicit_I6_GPR_iname</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i6_gpr_name</span><span class="plain">) {</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">and_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_call_iname</span><span class="plain">(</span><span class="identifier">i6_gpr_name</span><span class="plain">);</span>
                                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_NUMBER_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">propertyvalue_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSED_NUMBER_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Behaviour::is_an_enumeration</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">)) {</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_call_iname</span><span class="plain">(</span><span class="identifier">Kinds::RunTime::get_instance_GPR_iname</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">));</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">propertyvalue_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_NUMBER_HL</span><span class="plain">));</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">and_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_call_iname</span><span class="plain">(</span><span class="identifier">Kinds::RunTime::get_kind_GPR_iname</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">));</span>
                                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_NUMBER_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">propertyvalue_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSED_NUMBER_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="plain">}</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"Unable to recognise kind of value in parsing"</span><span class="plain">);</span>
                <span class="identifier">Emit::code</span><span class="plain">();</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;try_from_wn_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;g_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">visibility_level</span><span class="plain"> == 2) {</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;f_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="plain">}</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>

            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSED_NUMBER_HL</span><span class="plain">));</span>
                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;spn_s</span><span class="plain">);</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">ETYPE_HL</span><span class="plain">));</span>
                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;ss_s</span><span class="plain">);</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::parse_visible_either_or</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">visibility_level</span><span class="plain">,</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">pass_l</span><span class="plain">) {</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain"> = </span><span class="identifier">Properties::EitherOr::get_parsing_grammar</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Tokens::General::pvp_test_begins_dash</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">);</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain">;</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">j</span><span class="plain"> = 0; </span><span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">) </span><span class="identifier">j</span><span class="plain">++;</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">ands</span><span class="plain"> = 0;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">j</span><span class="plain"> &gt; 0) { </span><span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">and_interp</span><span class="plain">); </span><span class="identifier">Emit::down</span><span class="plain">(); </span><span class="identifier">ands</span><span class="plain">++; }</span>
            <span class="identifier">Properties::Emit::emit_iname_has_property</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">), </span><span class="identifier">prn</span><span class="plain">);</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">k</span><span class="plain"> = 0;</span>
            <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">k</span><span class="plain"> &lt; </span><span class="identifier">j</span><span class="plain">-1) { </span><span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">and_interp</span><span class="plain">); </span><span class="identifier">Emit::down</span><span class="plain">(); </span><span class="identifier">ands</span><span class="plain">++; }</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_call_iname</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">NEXTWORDSTOPPED_HL</span><span class="plain">));</span>
                    <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">N</span><span class="plain">);</span>
                    <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">N</span><span class="plain">, </span><span class="string">"%N"</span><span class="plain">, </span><span class="identifier">i</span><span class="plain">);</span>
                    <span class="identifier">Emit::val_dword</span><span class="plain">(</span><span class="identifier">N</span><span class="plain">);</span>
                    <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">N</span><span class="plain">);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">k</span><span class="plain">++;</span>
            <span class="plain">}</span>

            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">a</span><span class="plain">=0; </span><span class="identifier">a</span><span class="plain">&lt;</span><span class="identifier">ands</span><span class="plain">; </span><span class="identifier">a</span><span class="plain">++) </span><span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::code</span><span class="plain">();</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="functiontext">PL::Parsing::Tokens::General::pvp_test_passes_dash</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">visibility_level</span><span class="plain">, </span><span class="identifier">pass_l</span><span class="plain">);</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_prn_iname</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"no PRN iname"</span><span class="plain">);</span>
            <span class="functiontext">PL::Parsing::Tokens::General::pvp_test_begins_dash</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">);</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">and_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Properties::Emit::emit_iname_has_property</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">), </span><span class="identifier">prn</span><span class="plain">);</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_call_iname</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_prn_iname</span><span class="plain">);</span>
                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_PREPOSITION_HL</span><span class="plain">));</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::code</span><span class="plain">();</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="functiontext">PL::Parsing::Tokens::General::pvp_test_passes_dash</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">visibility_level</span><span class="plain">, </span><span class="identifier">pass_l</span><span class="plain">);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::pvp_test_begins_dash</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">) {</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;try_from_wn_s</span><span class="plain">);</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::pvp_test_passes_dash</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">visibility_level</span><span class="plain">, </span><span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">pass_l</span><span class="plain">) {</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;try_from_wn_s</span><span class="plain">);</span>
            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;g_s</span><span class="plain">);</span>
            <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">visibility_level</span><span class="plain"> == 2) {</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;f_s</span><span class="plain">);</span>
                <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pass_l</span><span class="plain">) {</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">jump_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::lab</span><span class="plain">(</span><span class="identifier">pass_l</span><span class="plain">);</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::General::finish_parsing_visible_properties</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">) {</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
        <span class="identifier">Emit::code_comment</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"try_from_wn is now advanced past any visible property values"</span><span class="plain">);</span>
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;try_from_wn_s</span><span class="plain">);</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::General::begin_parsing_visible_properties is used in <a href="#SP11">&#167;11</a>.</p>

<p class="endnote">The function PL::Parsing::Tokens::General::test_parse_visible_property is used in <a href="#SP11">&#167;11</a>.</p>

<p class="endnote">The function PL::Parsing::Tokens::General::parse_visible_property is used in <a href="#SP11">&#167;11</a>.</p>

<p class="endnote">The function PL::Parsing::Tokens::General::parse_visible_either_or appears nowhere else.</p>

<p class="endnote">The function PL::Parsing::Tokens::General::pvp_test_begins_dash appears nowhere else.</p>

<p class="endnote">The function PL::Parsing::Tokens::General::pvp_test_passes_dash appears nowhere else.</p>

<p class="endnote">The function PL::Parsing::Tokens::General::finish_parsing_visible_properties is used in <a href="#SP11">&#167;11</a>.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="5-tpv.html">Back to 'Tokens Parsing Values'</a></li><li><i>(This section ends Chapter 5: Command Grammar.)</i></li></ul><hr class="tocbar">
<!--End of weave: 1253 lines from a web of 25583-->
	</body>
</html>

