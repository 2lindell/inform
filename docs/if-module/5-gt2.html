<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>5/gt</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '5/gt2' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">if</a></li><li><a href="index.html#5">Chapter 5: Command Grammar</a></li><li><b>Grammar Tokens</b></li></ul><p class="purpose">To handle grammar at the level of individual tokens. I7 grammar tokens correspond in a 1-to-1 way with I6 tokens: here we determine the I7 type a token represents (if any) and compile it to its I6 grammar token equivalent as needed.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP5">&#167;5. Multiple tokens</a></li><li><a href="#SP6">&#167;6. Text</a></li><li><a href="#SP7">&#167;7. The special tokens</a></li><li><a href="#SP11">&#167;11. Phase II: Determining Grammar</a></li><li><a href="#SP12">&#167;12. Phase IV: Compiling Grammar</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>I7 tokens are (at present) stored simply as parse tree nodes of type
<code class="display"><span class="extract">TOKEN_NT</span></code>, with meaningful information hidden in annotations. At one
time I thought this was a simple arrangement, but it now seems obfuscatory,
so at some point I plan to create a "grammar token" structure to avoid
these arcane annotations of the parse tree.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">grammar_token_nonliteral_ANNOT</span></code> is clear for literal words such as <code class="display"><span class="extract">"into"</span></code>
and set for square-bracketed tokens such as <code class="display"><span class="extract">"[something]"</span></code>.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">index</span></code> stores the GSB scoring contribution made by the token to the
GL sorting algorithm.
</p>

<p class="inwebparagraph">The <code class="display"><span class="extract">grammar_token_code_ANNOT</span></code> annotation is meaningful only for parse nodes
with an evaluation of type <code class="display"><span class="extract">DESCRIPTION</span></code>. These are tokens which describe a
range of objects. Examples include "[open container]", which compiles to an
I6 noun filter, "[any container]", which compiles to an I6 scope filter, or
"[things]", one of a small number of special cases compiling to primitive I6
parser tokens. The annotation holds the allocation ID for the noun/scope
filter structure built for the occasion in the former cases, and one of the
following constants in the latter case. (These must all have negative values
in order not to clash with allocation IDs 0, 1, 2, ..., and clearly must all
be different, but otherwise the values are not significant and there is no
preferred order.)
</p>

<p class="inwebparagraph">For tokens with any other evaluation, <code class="display"><span class="extract">general_purpose</span></code> is always 0, so
that the special values below cannot arise.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">NAMED_TOKEN_GTC</span><span class="plain"> 1 </span>    <span class="comment">these positive values are used only in parsing</span>
    <span class="definitionkeyword">define</span> <span class="constant">RELATED_GTC</span><span class="plain"> 2</span>
    <span class="definitionkeyword">define</span> <span class="constant">STUFF_GTC</span><span class="plain"> 3</span>
    <span class="definitionkeyword">define</span> <span class="constant">ANY_STUFF_GTC</span><span class="plain"> 4</span>
    <span class="definitionkeyword">define</span> <span class="constant">ANY_THINGS_GTC</span><span class="plain"> 5</span>
    <span class="definitionkeyword">define</span> <span class="constant">NOUN_TOKEN_GTC</span><span class="plain"> -1 </span>    <span class="comment">I6 <code class="display"><span class="extract">noun</span></code></span>
    <span class="definitionkeyword">define</span> <span class="constant">MULTI_TOKEN_GTC</span><span class="plain"> -2 </span>    <span class="comment">I6 <code class="display"><span class="extract">multi</span></code></span>
    <span class="definitionkeyword">define</span> <span class="constant">MULTIINSIDE_TOKEN_GTC</span><span class="plain"> -3 </span>    <span class="comment">I6 <code class="display"><span class="extract">multiinside</span></code></span>
    <span class="definitionkeyword">define</span> <span class="constant">MULTIHELD_TOKEN_GTC</span><span class="plain"> -4 </span>    <span class="comment">I6 <code class="display"><span class="extract">multiheld</span></code></span>
    <span class="definitionkeyword">define</span> <span class="constant">HELD_TOKEN_GTC</span><span class="plain"> -5 </span>    <span class="comment">I6 <code class="display"><span class="extract">held</span></code></span>
    <span class="definitionkeyword">define</span> <span class="constant">CREATURE_TOKEN_GTC</span><span class="plain"> -6 </span>    <span class="comment">I6 <code class="display"><span class="extract">creature</span></code></span>
    <span class="definitionkeyword">define</span> <span class="constant">TOPIC_TOKEN_GTC</span><span class="plain"> -7 </span>    <span class="comment">I6 <code class="display"><span class="extract">topic</span></code></span>
    <span class="definitionkeyword">define</span> <span class="constant">MULTIEXCEPT_TOKEN_GTC</span><span class="plain"> -8 </span>    <span class="comment">I6 <code class="display"><span class="extract">multiexcept</span></code></span>
</pre>
<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>Tokens are created when text such as "drill [something] with [something]"
is parsed, from an Understand sentence or elsewhere. What happens is much
the same as when text with substitutions is read: that produces
</p>

<blockquote>
    <p>"drill", something, "with", something</p>

</blockquote>

<p class="inwebparagraph">and the following little grammar is used to divide this text up into its
four constituent tokens.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">grammar</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">breaking</span><span class="plain">&gt; ::=</span>
        <span class="plain">... , ... |				==&gt; </span><span class="identifier">NOT_APPLICABLE</span>
        <span class="plain">&lt;</span><span class="identifier">quoted</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">&gt; |			==&gt; </span><span class="identifier">TRUE</span>
        <span class="plain">...						==&gt; </span><span class="identifier">FALSE</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>We use a different punctuation set, in which forward slashes break words,
to handle such as:
</p>

<blockquote>
    <p>Understand "get away/off/out" as exiting.</p>

</blockquote>

<p class="inwebparagraph">Inform would ordinarily lex the text away/off/out as one single word &mdash; so that
something like "on/off switch" would be regarded as two words not four &mdash;
but with slash treated as a punctuation mark, we instead read "away / off /
out", a sequence of five lexical words.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">GRAMMAR_PUNCTUATION_MARKS</span><span class="plain"> </span><span class="identifier">L</span><span class="string">".,:;?!(){}[]/"</span><span class="plain"> </span>    <span class="comment">note the slash...</span>
</pre>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::break_into_tokens</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="plain">&lt;</span><span class="identifier">grammar</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">breaking</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">switch</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">NOT_APPLICABLE</span><span class="plain">: {</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">LW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">grammar</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">breaking</span><span class="plain">&gt;, 1);</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">RW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">grammar</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">breaking</span><span class="plain">&gt;, 2);</span>
                <span class="functiontext">PL::Parsing::Tokens::break_into_tokens</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">LW</span><span class="plain">);</span>
                <span class="functiontext">PL::Parsing::Tokens::break_into_tokens</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">RW</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">:</span>
                <span class="identifier">Word::dequote</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
                <span class="reserved">if</span><span class="plain"> (*(</span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))) == 0) </span><span class="reserved">return</span><span class="plain">;</span>
                <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Feeds::feed_text_full</span><span class="plain">(</span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)), </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="constant">GRAMMAR_PUNCTUATION_MARKS</span><span class="plain">);</span>
                <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">) {</span>
                    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">newpn</span><span class="plain"> = </span><span class="identifier">NounPhrases::new_raw</span><span class="plain">(</span><span class="identifier">Wordings::one_word</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">));</span>
                    <span class="identifier">ParseTree::set_type</span><span class="plain">(</span><span class="identifier">newpn</span><span class="plain">, </span><span class="identifier">TOKEN_NT</span><span class="plain">);</span>
                    <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">newpn</span><span class="plain">, </span><span class="identifier">grammar_token_literal_ANNOT</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
                    <span class="identifier">ParseTree::graft</span><span class="plain">(</span><span class="identifier">newpn</span><span class="plain">, </span><span class="identifier">pn</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">: {</span>
                <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">newpn</span><span class="plain"> = </span><span class="identifier">NounPhrases::new_raw</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
                <span class="identifier">ParseTree::set_type</span><span class="plain">(</span><span class="identifier">newpn</span><span class="plain">, </span><span class="identifier">TOKEN_NT</span><span class="plain">);</span>
                <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">newpn</span><span class="plain">, </span><span class="identifier">grammar_token_literal_ANNOT</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
                <span class="identifier">ParseTree::graft</span><span class="plain">(</span><span class="identifier">newpn</span><span class="plain">, </span><span class="identifier">pn</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::is_literal</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">grammar_token_literal_ANNOT</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::break_into_tokens is used in 5/tfg (<a href="5-tfg.html#SP21">&#167;21</a>).</p>

<p class="endnote">The function PL::Parsing::Tokens::is_literal is used in 5/tfg (<a href="5-tfg.html#SP21">&#167;21</a>), 5/gl (<a href="5-gl.html#SP20">&#167;20</a>).</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Multiple tokens. </b>A multiple token is one which permits multiple matches in the I6 parser: for
instance, permits the use of "all".
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::is_multiple</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">) {</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">grammar_token_code_ANNOT</span><span class="plain">)) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTI_TOKEN_GTC</span><span class="plain">:</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTIINSIDE_TOKEN_GTC</span><span class="plain">:</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTIHELD_TOKEN_GTC</span><span class="plain">:</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTIEXCEPT_TOKEN_GTC</span><span class="plain">:</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::is_multiple is used in 5/gl (<a href="5-gl.html#SP15">&#167;15</a>).</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Text. </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::is_text</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">) {</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">grammar_token_code_ANNOT</span><span class="plain">)) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TOPIC_TOKEN_GTC</span><span class="plain">:</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::is_text is used in 5/gl (<a href="5-gl.html#SP20">&#167;20</a>).</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. The special tokens. </b>Do not change any of these GTC numbers without first checking and updating
the discussion of GL sorting in Grammar Lines:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::gsb_for_special_token</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">gtc</span><span class="plain">) {</span>
        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">gtc</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOUN_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> 0;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTI_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> 0;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTIINSIDE_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> 1;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTIHELD_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> 2;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">HELD_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> 3;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">CREATURE_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> 0;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TOPIC_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> -1;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTIEXCEPT_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> 2;</span>
            <span class="reserved">default</span><span class="plain">: </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to find GSB for invalid GTC"</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> 0; </span>    <span class="comment">to prevent a gcc error: never reached</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::gsb_for_special_token is used in <a href="#SP11_5">&#167;11.5</a>.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>These translate into I6 as follows:
</p>


<pre class="display">
    <span class="reserved">char</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Tokens::i6_token_for_special_token</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">gtc</span><span class="plain">) {</span>
        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">gtc</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOUN_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"noun"</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTI_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"multi"</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTIINSIDE_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"multiinside"</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTIHELD_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"multiheld"</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">HELD_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"held"</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">CREATURE_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"creature"</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TOPIC_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"topic"</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTIEXCEPT_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"multiexcept"</span><span class="plain">;</span>
            <span class="reserved">default</span><span class="plain">: </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to find I6 token for invalid GTC"</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="string">""</span><span class="plain">; </span>    <span class="comment">to prevent a gcc error: never reached</span>
    <span class="plain">}</span>

    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Tokens::iname_for_special_token</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">gtc</span><span class="plain">) {</span>
        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">gtc</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOUN_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">VERB_DIRECTIVE_NOUN_iname</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTI_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">VERB_DIRECTIVE_MULTI_iname</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTIINSIDE_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">VERB_DIRECTIVE_MULTIINSIDE_iname</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTIHELD_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">VERB_DIRECTIVE_MULTIHELD_iname</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">HELD_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">VERB_DIRECTIVE_HELD_iname</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">CREATURE_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">VERB_DIRECTIVE_CREATURE_iname</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TOPIC_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">VERB_DIRECTIVE_TOPIC_iname</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTIEXCEPT_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">VERB_DIRECTIVE_MULTIEXCEPT_iname</span><span class="plain">;</span>
            <span class="reserved">default</span><span class="plain">: </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to find inter name for invalid GTC"</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">to prevent a gcc error: never reached</span>
    <span class="plain">}</span>

    <span class="reserved">char</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Tokens::i6_constant_for_special_token</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">gtc</span><span class="plain">) {</span>
        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">gtc</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOUN_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"NOUN_TOKEN"</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTI_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"MULTI_TOKEN"</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTIINSIDE_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"MULTIINSIDE_TOKEN"</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTIHELD_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"MULTIHELD_TOKEN"</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">HELD_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"HELD_TOKEN"</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">CREATURE_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"CREATURE_TOKEN"</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TOPIC_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"TOPIC_TOKEN"</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MULTIEXCEPT_TOKEN_GTC</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"MULTIEXCEPT_TOKEN"</span><span class="plain">;</span>
            <span class="reserved">default</span><span class="plain">: </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to find I6 constant for invalid GTC"</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="string">""</span><span class="plain">; </span>    <span class="comment">to prevent a gcc error: never reached</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::i6_token_for_special_token appears nowhere else.</p>

<p class="endnote">The function PL::Parsing::Tokens::iname_for_special_token is used in <a href="#SP12">&#167;12</a>.</p>

<p class="endnote">The function PL::Parsing::Tokens::i6_constant_for_special_token appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>The special tokens all return a value in I6 which needs a kind
to be used in I7: these are defined by the following routine.
</p>


<pre class="display">
    <span class="identifier">kind</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Tokens::kind_for_special_token</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">gtc</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gtc</span><span class="plain"> == </span><span class="constant">TOPIC_TOKEN_GTC</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">K_understanding</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">K_object</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::kind_for_special_token is used in <a href="#SP11_5">&#167;11.5</a>, <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>The tokens which aren't literal words in double-quotes are parsed as follows:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">grammar</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">named</span><span class="plain">-</span><span class="identifier">grammar</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">&gt; |				==&gt; </span><span class="constant">NAMED_TOKEN_GTC</span><span class="plain">; &lt;&lt;</span><span class="reserved">grammar_verb</span><span class="plain">:</span><span class="identifier">named</span><span class="plain">&gt;&gt; = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="identifier">any</span><span class="plain"> </span><span class="identifier">things</span><span class="plain"> |						==&gt; </span><span class="constant">ANY_THINGS_GTC</span><span class="plain">; &lt;&lt;</span><span class="identifier">parse_node</span><span class="plain">:</span><span class="identifier">s</span><span class="plain">&gt;&gt; = </span><span class="identifier">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">K_thing</span><span class="plain">);</span>
        <span class="identifier">any</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">description</span><span class="plain">&gt; |				==&gt; </span><span class="constant">ANY_STUFF_GTC</span><span class="plain">; &lt;&lt;</span><span class="identifier">parse_node</span><span class="plain">:</span><span class="identifier">s</span><span class="plain">&gt;&gt; = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="identifier">anything</span><span class="plain"> |							==&gt; </span><span class="constant">ANY_STUFF_GTC</span><span class="plain">; &lt;&lt;</span><span class="identifier">parse_node</span><span class="plain">:</span><span class="identifier">s</span><span class="plain">&gt;&gt; = </span><span class="identifier">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">K_thing</span><span class="plain">);</span>
        <span class="identifier">anybody</span><span class="plain"> |							==&gt; </span><span class="constant">ANY_STUFF_GTC</span><span class="plain">; &lt;&lt;</span><span class="identifier">parse_node</span><span class="plain">:</span><span class="identifier">s</span><span class="plain">&gt;&gt; = </span><span class="identifier">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">K_person</span><span class="plain">);</span>
        <span class="identifier">anyone</span><span class="plain"> |							==&gt; </span><span class="constant">ANY_STUFF_GTC</span><span class="plain">; &lt;&lt;</span><span class="identifier">parse_node</span><span class="plain">:</span><span class="identifier">s</span><span class="plain">&gt;&gt; = </span><span class="identifier">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">K_person</span><span class="plain">);</span>
        <span class="identifier">anywhere</span><span class="plain"> |							==&gt; </span><span class="constant">ANY_STUFF_GTC</span><span class="plain">; &lt;&lt;</span><span class="identifier">parse_node</span><span class="plain">:</span><span class="identifier">s</span><span class="plain">&gt;&gt; = </span><span class="identifier">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">K_room</span><span class="plain">);</span>
        <span class="identifier">something</span><span class="plain"> </span><span class="identifier">related</span><span class="plain"> </span><span class="identifier">by</span><span class="plain"> </span><span class="identifier">reversed</span><span class="plain"> &lt;</span><span class="identifier">relation</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |	==&gt; </span><span class="constant">RELATED_GTC</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">BinaryPredicates::get_reversal</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1])</span>
        <span class="identifier">something</span><span class="plain"> </span><span class="identifier">related</span><span class="plain"> </span><span class="identifier">by</span><span class="plain"> &lt;</span><span class="identifier">relation</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |			==&gt; </span><span class="constant">RELATED_GTC</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="identifier">something</span><span class="plain"> </span><span class="identifier">related</span><span class="plain"> </span><span class="identifier">by</span><span class="plain"> ... |			==&gt; </span>&lt;<span class="cwebmacro">Issue PM_GrammarBadRelation problem</span> <span class="cwebmacronumber">10.1</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">standard</span><span class="plain">-</span><span class="identifier">grammar</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">&gt; |			==&gt; </span><span class="identifier">R</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">definite</span><span class="plain">-</span><span class="identifier">article</span><span class="plain">&gt; &lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">&gt; |		==&gt; </span><span class="constant">STUFF_GTC</span><span class="plain">; &lt;&lt;</span><span class="identifier">parse_node</span><span class="plain">:</span><span class="identifier">s</span><span class="plain">&gt;&gt; = </span><span class="identifier">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[2])</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">description</span><span class="plain">&gt; |					==&gt; </span><span class="constant">STUFF_GTC</span><span class="plain">; &lt;&lt;</span><span class="identifier">parse_node</span><span class="plain">:</span><span class="identifier">s</span><span class="plain">&gt;&gt; = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">&gt;	|				==&gt; </span>&lt;<span class="cwebmacro">Issue PM_BizarreToken problem</span> <span class="cwebmacronumber">10.7</span>&gt;
        <span class="plain">...									==&gt; </span>&lt;<span class="cwebmacro">Issue PM_UnknownToken problem</span> <span class="cwebmacronumber">10.8</span>&gt;

    <span class="plain">&lt;</span><span class="identifier">standard</span><span class="plain">-</span><span class="identifier">grammar</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">&gt; ::=</span>
        <span class="identifier">something</span><span class="plain"> |							==&gt; </span><span class="constant">NOUN_TOKEN_GTC</span>
        <span class="identifier">things</span><span class="plain"> |							==&gt; </span><span class="constant">MULTI_TOKEN_GTC</span>
        <span class="identifier">things</span><span class="plain"> </span><span class="identifier">inside</span><span class="plain"> |						==&gt; </span><span class="constant">MULTIINSIDE_TOKEN_GTC</span>
        <span class="identifier">things</span><span class="plain"> </span><span class="identifier">preferably</span><span class="plain"> </span><span class="identifier">held</span><span class="plain"> |			==&gt; </span><span class="constant">MULTIHELD_TOKEN_GTC</span>
        <span class="identifier">something</span><span class="plain"> </span><span class="identifier">preferably</span><span class="plain"> </span><span class="identifier">held</span><span class="plain"> |			==&gt; </span><span class="constant">HELD_TOKEN_GTC</span>
        <span class="identifier">other</span><span class="plain"> </span><span class="identifier">things</span><span class="plain"> |						==&gt; </span><span class="constant">MULTIEXCEPT_TOKEN_GTC</span>
        <span class="identifier">someone</span><span class="plain">	|							==&gt; </span><span class="constant">CREATURE_TOKEN_GTC</span>
        <span class="identifier">somebody</span><span class="plain"> |							==&gt; </span><span class="constant">CREATURE_TOKEN_GTC</span>
        <span class="identifier">text</span><span class="plain"> |								==&gt; </span><span class="constant">TOPIC_TOKEN_GTC</span>
        <span class="identifier">topic</span><span class="plain"> |								==&gt; </span>&lt;<span class="cwebmacro">Issue PM_UseTextNotTopic problem</span> <span class="cwebmacronumber">10.2</span>&gt;
        <span class="identifier">a</span><span class="plain"> </span><span class="identifier">topic</span><span class="plain"> |							==&gt; </span>&lt;<span class="cwebmacro">Issue PM_UseTextNotTopic problem</span> <span class="cwebmacronumber">10.2</span>&gt;
        <span class="identifier">object</span><span class="plain"> |							==&gt; </span>&lt;<span class="cwebmacro">Issue PM_UseThingNotObject problem</span> <span class="cwebmacronumber">10.3</span>&gt;
        <span class="identifier">an</span><span class="plain"> </span><span class="identifier">object</span><span class="plain"> |							==&gt; </span>&lt;<span class="cwebmacro">Issue PM_UseThingNotObject problem</span> <span class="cwebmacronumber">10.3</span>&gt;
        <span class="identifier">something</span><span class="plain"> </span><span class="identifier">held</span><span class="plain"> |					==&gt; </span>&lt;<span class="cwebmacro">Issue something held problem message</span> <span class="cwebmacronumber">10.4</span>&gt;
        <span class="identifier">things</span><span class="plain"> </span><span class="identifier">held</span><span class="plain">							==&gt; </span>&lt;<span class="cwebmacro">Issue things held problem message</span> <span class="cwebmacronumber">10.5</span>&gt;

    <span class="plain">&lt;</span><span class="identifier">named</span><span class="plain">-</span><span class="identifier">grammar</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::named_token_by_name</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">) { *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">gv</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">; }</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP10_1"></a><b>&#167;10.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_GrammarBadRelation problem</span> <span class="cwebmacronumber">10.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">RELATED_GTC</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_GrammarBadRelation</span><span class="plain">));</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"The grammar token '%2' in the sentence %1 "</span>
            <span class="string">"invites me to understand names of related things, "</span>
            <span class="string">"but the relation is not one that I know."</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP10">&#167;10</a>.</p>

<p class="inwebparagraph"><a id="SP10_2"></a><b>&#167;10.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_UseTextNotTopic problem</span> <span class="cwebmacronumber">10.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">TOPIC_TOKEN_GTC</span><span class="plain">;</span>
        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UseTextNotTopic</span><span class="plain">));</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"The grammar token '%2' in the sentence %1 would in some "</span>
            <span class="string">"ways be the right logical way to suggest 'any words at "</span>
            <span class="string">"all here', but Inform in actually uses the special syntax "</span>
            <span class="string">"'[text]' for that. %P"</span>
            <span class="string">"This is partly for historical reasons, but also because "</span>
            <span class="string">"'[text]' is a token which can't be used in every sort of "</span>
            <span class="string">"Understand grammar - for example, it can't be used with 'matches' "</span>
            <span class="string">"or in descriptions of actions or in table columns; it's really "</span>
            <span class="string">"intended only for defining new commands."</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP10">&#167;10</a> (twice).</p>

<p class="inwebparagraph"><a id="SP10_3"></a><b>&#167;10.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_UseThingNotObject problem</span> <span class="cwebmacronumber">10.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">MULTI_TOKEN_GTC</span><span class="plain">;</span>
        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UseThingNotObject</span><span class="plain">));</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"The grammar token '%2' in the sentence %1 would in some "</span>
            <span class="string">"ways be the right logical way to suggest 'any object at "</span>
            <span class="string">"all here', but Inform uses the special syntax '[thing]' "</span>
            <span class="string">"for that. (Or '[things]' if multiple objects are allowed.)"</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP10">&#167;10</a> (twice).</p>

<p class="inwebparagraph"><a id="SP10_4"></a><b>&#167;10.4.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue something held problem message</span> <span class="cwebmacronumber">10.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">HELD_TOKEN_GTC</span><span class="plain">;</span>
        <span class="functiontext">PL::Parsing::Tokens::incompatible_change_problem</span><span class="plain">(</span>
            <span class="string">"something held"</span><span class="plain">, </span><span class="string">"something"</span><span class="plain">, </span><span class="string">"something preferably held"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP10">&#167;10</a>.</p>

<p class="inwebparagraph"><a id="SP10_5"></a><b>&#167;10.5.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue things held problem message</span> <span class="cwebmacronumber">10.5</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">MULTIHELD_TOKEN_GTC</span><span class="plain">;</span>
        <span class="functiontext">PL::Parsing::Tokens::incompatible_change_problem</span><span class="plain">(</span>
                <span class="string">"things held"</span><span class="plain">, </span><span class="string">"things"</span><span class="plain">, </span><span class="string">"things preferably held"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP10">&#167;10</a>.</p>

<p class="inwebparagraph"><a id="SP10_6"></a><b>&#167;10.6.  </b>Something of an extended mea culpa: but it had the desired effect, in
that nobody complained about what might have been a controversial change.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::incompatible_change_problem</span><span class="plain">(</span><span class="reserved">char</span><span class="plain"> *</span><span class="identifier">token_tried</span><span class="plain">, </span><span class="reserved">char</span><span class="plain"> *</span><span class="identifier">token_instead</span><span class="plain">,</span>
        <span class="reserved">char</span><span class="plain"> *</span><span class="identifier">token_better</span><span class="plain">) {</span>
        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_text</span><span class="plain">(2, </span><span class="identifier">token_tried</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_text</span><span class="plain">(3, </span><span class="identifier">token_instead</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_text</span><span class="plain">(4, </span><span class="identifier">token_better</span><span class="plain">);</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ObsoleteHeldTokens</span><span class="plain">));</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"In the sentence %1, you used the '[%2]' as a token, which was "</span>
            <span class="string">"allowed in the early Public Beta versions of Inform 7, but became "</span>
            <span class="string">"out of date in August 2006%|. A change was then made so that if an "</span>
            <span class="string">"action needed to apply to something which was carried, this would "</span>
            <span class="string">"now be specified when the action is created - not in the Understand "</span>
            <span class="string">"line for it. For instance, one might say 'Dismantling is an action "</span>
            <span class="string">"which applies to one carried thing', instead of '...which applies "</span>
            <span class="string">"to one thing', and then write grammar such as 'Understand \</span><span class="plain">"</span><span class="string">dismantle "</span>
            <span class="string">"[something] as dismantling' instead of '...[something held]...'. "</span>
            <span class="string">"So you probably need to change your '[%2]' token to '[%3]', and "</span>
            <span class="string">"change the action's definition (unless it is a built-in action "</span>
            <span class="string">"such as 'dropping'). An alternative, though, for fine-tuning is to "</span>
            <span class="string">"change it to '[%4]', which allows anything to be Understood, but "</span>
            <span class="string">"in cases of ambiguity tends to guess that something held is more "</span>
            <span class="string">"likely to be what the player means than something not held."</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::incompatible_change_problem is used in <a href="#SP10_4">&#167;10.4</a>, <a href="#SP10_5">&#167;10.5</a>.</p>

<p class="inwebparagraph"><a id="SP10_7"></a><b>&#167;10.7.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_BizarreToken problem</span> <span class="cwebmacronumber">10.7</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">STUFF_GTC</span><span class="plain">;</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"$T"</span><span class="plain">, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_kind_of</span><span class="plain">(3, </span><span class="identifier">RP</span><span class="plain">[1]);</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BizarreToken</span><span class="plain">));</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"The grammar token '%2' in the sentence %1 looked to me as "</span>
            <span class="string">"if it might be %3, but this isn't something allowed in "</span>
            <span class="string">"parsing grammar."</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP10">&#167;10</a>.</p>

<p class="inwebparagraph"><a id="SP10_8"></a><b>&#167;10.8.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_UnknownToken problem</span> <span class="cwebmacronumber">10.8</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">STUFF_GTC</span><span class="plain">;</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"$T"</span><span class="plain">, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnknownToken</span><span class="plain">));</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"I was unable to understand what you meant by the grammar token '%2' "</span>
            <span class="string">"in the sentence %1."</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP10">&#167;10</a>.</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Phase II: Determining Grammar. </b>Slashing does not recurse down to individual tokens, so the first time we
look seriously at tokens is in Phase II.
</p>


<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Tokens::determine</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">depth</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">score</span><span class="plain">) {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">grammar_token_literal_ANNOT</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>

        <span class="plain">&lt;&lt;</span><span class="reserved">grammar_verb</span><span class="plain">:</span><span class="identifier">named</span><span class="plain">&gt;&gt; = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="plain">&lt;</span><span class="identifier">grammar</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">));</span>
        <span class="reserved">switch</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NAMED_TOKEN_GTC</span><span class="plain">: </span>&lt;<span class="cwebmacro">Determine a named grammar token</span> <span class="cwebmacronumber">11.1</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">ANY_STUFF_GTC</span><span class="plain">: </span>&lt;<span class="cwebmacro">Determine an any grammar token</span> <span class="cwebmacronumber">11.2</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">ANY_THINGS_GTC</span><span class="plain">: </span>&lt;<span class="cwebmacro">Determine an any grammar token</span> <span class="cwebmacronumber">11.2</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">RELATED_GTC</span><span class="plain">: </span>&lt;<span class="cwebmacro">Determine a related grammar token</span> <span class="cwebmacronumber">11.3</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">STUFF_GTC</span><span class="plain">: </span>&lt;<span class="cwebmacro">Determine a kind grammar token</span> <span class="cwebmacronumber">11.4</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">default</span><span class="plain">: </span>&lt;<span class="cwebmacro">Determine a special grammar token</span> <span class="cwebmacronumber">11.5</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">spec</span><span class="plain">) </span>&lt;<span class="cwebmacro">Vet the grammar token determination for parseability at run-time</span> <span class="cwebmacronumber">11.6</span>&gt;<span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">spec</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::determine is used in <a href="#SP12">&#167;12</a>, 5/gl (<a href="5-gl.html#SP15">&#167;15</a>).</p>

<p class="inwebparagraph"><a id="SP11_1"></a><b>&#167;11.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Determine a named grammar token</span> <span class="cwebmacronumber">11.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">val</span><span class="plain"> = </span><span class="identifier">Rvalues::from_grammar_verb</span><span class="plain">(&lt;&lt;</span><span class="reserved">grammar_verb</span><span class="plain">:</span><span class="identifier">named</span><span class="plain">&gt;&gt;);</span>
        <span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::determine</span><span class="plain">(&lt;&lt;</span><span class="reserved">grammar_verb</span><span class="plain">:</span><span class="identifier">named</span><span class="plain">&gt;&gt;, </span><span class="identifier">depth</span><span class="plain">+1); </span>    <span class="comment">this is where Phase II recurses</span>
        <span class="identifier">ParseTree::set_grammar_value</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">val</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11">&#167;11</a>.</p>

<p class="inwebparagraph"><a id="SP11_2"></a><b>&#167;11.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Determine an any grammar token</span> <span class="cwebmacronumber">11.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">spec</span><span class="plain"> = &lt;&lt;</span><span class="identifier">parse_node</span><span class="plain">:</span><span class="identifier">s</span><span class="plain">&gt;&gt;;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">any_things</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt; == </span><span class="constant">ANY_THINGS_GTC</span><span class="plain">) </span><span class="identifier">any_things</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">grammar_token_code_ANNOT</span><span class="plain">,</span>
                <span class="functiontext">PL::Parsing::Tokens::Filters::new_id</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">any_things</span><span class="plain">));</span>
            <span class="identifier">ParseTree::set_grammar_value</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11">&#167;11</a> (twice).</p>

<p class="inwebparagraph"><a id="SP11_3"></a><b>&#167;11.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Determine a related grammar token</span> <span class="cwebmacronumber">11.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain">) </span><span class="identifier">ParseTree::set_grammar_token_relation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">bp</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11">&#167;11</a>.</p>

<p class="inwebparagraph"><a id="SP11_4"></a><b>&#167;11.4.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Determine a kind grammar token</span> <span class="cwebmacronumber">11.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">spec</span><span class="plain"> = &lt;&lt;</span><span class="identifier">parse_node</span><span class="plain">:</span><span class="identifier">s</span><span class="plain">&gt;&gt;;</span>
        <span class="identifier">ParseTree::set_grammar_value</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Specifications::is_description_like</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) {</span>
            <span class="plain">*</span><span class="identifier">score</span><span class="plain"> = 5;</span>
            <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">grammar_token_code_ANNOT</span><span class="plain">,</span>
                <span class="functiontext">PL::Parsing::Tokens::Filters::new_id</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">));</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11">&#167;11</a>.</p>

<p class="inwebparagraph"><a id="SP11_5"></a><b>&#167;11.5.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Determine a special grammar token</span> <span class="cwebmacronumber">11.5</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">p</span><span class="plain"> = &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;;</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Tokens::kind_for_special_token</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
        <span class="identifier">ParseTree::set_text</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">));</span>
        <span class="plain">*</span><span class="identifier">score</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Tokens::gsb_for_special_token</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="identifier">ParseTree::set_grammar_value</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">grammar_token_code_ANNOT</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11">&#167;11</a>.</p>

<p class="inwebparagraph"><a id="SP11_6"></a><b>&#167;11.6.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Vet the grammar token determination for parseability at run-time</span> <span class="cwebmacronumber">11.6</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) {</span>
            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">Specifications::to_kind</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp;</span>
                <span class="plain">(</span><span class="identifier">Kinds::Compare::eq</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_understanding</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp;</span>
                <span class="plain">(</span><span class="identifier">Kinds::Behaviour::request_I6_GPR</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">));</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnparsableKind</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"The grammar token '%2' in the sentence %1 "</span>
                    <span class="string">"invites me to understand values typed by the player during "</span>
                    <span class="string">"play but for a kind of value which is beyond my ability. "</span>
                    <span class="string">"Generally speaking, the allowable kinds of value are "</span>
                    <span class="string">"number, time, text and any new kind of value you may "</span>
                    <span class="string">"have created - but not, for instance, scene or rule."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11">&#167;11</a>.</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Phase IV: Compiling Grammar. </b>Tokens play no direct part in Phase III either, having made their contribution
earlier by recording their GSB scores instead. So we next see them at
compilation time.
</p>

<p class="inwebparagraph">In code mode, we compile a test that the token matches, jumping to the
failure label if it doesn't, and setting the I6 local variable <code class="display"><span class="extract">rv</span></code> to a
suitable GPR return value if it does match and produces an outcome.
We are allowed to use the I6 local <code class="display"><span class="extract">w</span></code> for temporary storage, but
nothing else.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">ol_loop_counter</span><span class="plain"> = 0;</span>
    <span class="identifier">kind</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Tokens::compile</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">code_mode</span><span class="plain">,</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">failure_label</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">consult_mode</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">wn</span><span class="plain"> = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">));</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">;</span>
        <span class="identifier">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain">;</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">grammar_token_literal_ANNOT</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">code_mode</span><span class="plain">) {</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">ne_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_call</span><span class="plain">(</span><span class="identifier">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">NEXTWORDSTOPPED_HL</span><span class="plain">)));</span>
                        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">N</span><span class="plain">);</span>
                        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">N</span><span class="plain">, </span><span class="string">"%N"</span><span class="plain">, </span><span class="identifier">wn</span><span class="plain">);</span>
                        <span class="identifier">Emit::val_dword</span><span class="plain">(</span><span class="identifier">N</span><span class="plain">);</span>
                        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">N</span><span class="plain">);</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    &lt;<span class="cwebmacro">Then jump to our doom</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">WT</span><span class="plain">);</span>
                <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">WT</span><span class="plain">, </span><span class="string">"%N"</span><span class="plain">, </span><span class="identifier">wn</span><span class="plain">);</span>
                <span class="identifier">Emit::array_dword_entry</span><span class="plain">(</span><span class="identifier">WT</span><span class="plain">);</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">WT</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="plain">}</span>

        <span class="identifier">bp</span><span class="plain"> = </span><span class="identifier">ParseTree::get_grammar_token_relation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain">) {</span>
            <span class="identifier">Emit::inv_call</span><span class="plain">(</span><span class="identifier">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">ARTICLEDESCRIPTORS_HL</span><span class="plain">)));</span>
            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
            <span class="identifier">Emit::down</span><span class="plain">();</span>
                <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
            <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">R_containment</span><span class="plain">) {</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">not_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">has_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">CONTAINER_HL</span><span class="plain">));</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    &lt;<span class="cwebmacro">Then jump to our doom</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">R_support</span><span class="plain">) {</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">not_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">has_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SUPPORTER_HL</span><span class="plain">));</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    &lt;<span class="cwebmacro">Then jump to our doom</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">a_has_b_predicate</span><span class="plain">) || (</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">R_wearing</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">R_carrying</span><span class="plain">)) {</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">not_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">has_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">ANIMATE_HL</span><span class="plain">));</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    &lt;<span class="cwebmacro">Then jump to our doom</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">R_containment</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">R_support</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">a_has_b_predicate</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">R_wearing</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">R_carrying</span><span class="plain">)) {</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">);</span>
                <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">, </span><span class="string">".ol_mm_%d"</span><span class="plain">, </span><span class="identifier">ol_loop_counter</span><span class="plain">++);</span>
                <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">exit_label</span><span class="plain"> = </span><span class="identifier">Emit::reserve_label</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">);</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">);</span>

                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">objectloop_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Kinds::RunTime::I6_classname</span><span class="plain">(</span><span class="identifier">K_object</span><span class="plain">));</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">in_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::code</span><span class="plain">();</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">R_carrying</span><span class="plain">) {</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">has_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">P_worn</span><span class="plain">));</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::code</span><span class="plain">();</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">continue_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="plain">}</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">R_wearing</span><span class="plain">) {</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">not_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">has_interp</span><span class="plain">);</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">P_worn</span><span class="plain">));</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::code</span><span class="plain">();</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">continue_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="plain">}</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">plus_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                <span class="identifier">Emit::inv_call</span><span class="plain">(</span><span class="identifier">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">TRYGIVENOBJECT_HL</span><span class="plain">)));</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">gt_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::code</span><span class="plain">();</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">jump_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::lab</span><span class="plain">(</span><span class="identifier">exit_label</span><span class="plain">);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                &lt;<span class="cwebmacro">Jump to our doom</span> <span class="cwebmacronumber">12.2</span>&gt;<span class="plain">;</span>
                <span class="identifier">Emit::place_label</span><span class="plain">(</span><span class="identifier">exit_label</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">R_incorporation</span><span class="plain">) {</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">);</span>
                <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">, </span><span class="string">".ol_mm_%d"</span><span class="plain">, </span><span class="identifier">ol_loop_counter</span><span class="plain">++);</span>
                <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">exit_label</span><span class="plain"> = </span><span class="identifier">Emit::reserve_label</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">);</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">);</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">propertyvalue_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">COMPONENT_CHILD_HL</span><span class="plain">));</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">while_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::code</span><span class="plain">();</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">plus_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                <span class="identifier">Emit::inv_call</span><span class="plain">(</span><span class="identifier">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">TRYGIVENOBJECT_HL</span><span class="plain">)));</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">gt_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::code</span><span class="plain">();</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">jump_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::lab</span><span class="plain">(</span><span class="identifier">exit_label</span><span class="plain">);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">propertyvalue_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">COMPONENT_SIBLING_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                &lt;<span class="cwebmacro">Jump to our doom</span> <span class="cwebmacronumber">12.2</span>&gt;<span class="plain">;</span>
                <span class="identifier">Emit::place_label</span><span class="plain">(</span><span class="identifier">exit_label</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">R_equality</span><span class="plain">) {</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(2, </span><span class="identifier">pn</span><span class="plain">);</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_RelatedByEquality</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"The grammar you give in %1 contains a token %2 which would "</span>
                    <span class="string">"create a circularity. To follow this, I'd have to compute "</span>
                    <span class="string">"forever."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">K_object</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">BinaryPredicates::get_reversal</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">) == </span><span class="identifier">R_containment</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">BinaryPredicates::get_reversal</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">) == </span><span class="identifier">R_support</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">BinaryPredicates::get_reversal</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">) == </span><span class="identifier">a_has_b_predicate</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">BinaryPredicates::get_reversal</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">) == </span><span class="identifier">R_wearing</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">BinaryPredicates::get_reversal</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">) == </span><span class="identifier">R_carrying</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">BinaryPredicates::get_reversal</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">) == </span><span class="identifier">R_carrying</span><span class="plain">) {</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">has_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">P_worn</span><span class="plain">));</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        &lt;<span class="cwebmacro">Then jump to our doom</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="plain">}</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">BinaryPredicates::get_reversal</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">) == </span><span class="identifier">R_wearing</span><span class="plain">) {</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">not_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">has_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">P_worn</span><span class="plain">));</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        &lt;<span class="cwebmacro">Then jump to our doom</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="plain">}</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::inv_call</span><span class="plain">(</span><span class="identifier">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARENT_HL</span><span class="plain">)));</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>

                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">plus_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::inv_call</span><span class="plain">(</span><span class="identifier">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">TRYGIVENOBJECT_HL</span><span class="plain">)));</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    &lt;<span class="cwebmacro">Then jump to our doom</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">BinaryPredicates::get_reversal</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">) == </span><span class="identifier">R_incorporation</span><span class="plain">) {</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">propertyvalue_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">COMPONENT_PARENT_HL</span><span class="plain">));</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">plus_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::inv_call</span><span class="plain">(</span><span class="identifier">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">TRYGIVENOBJECT_HL</span><span class="plain">)));</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                <span class="identifier">Emit::down</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    &lt;<span class="cwebmacro">Then jump to our doom</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                <span class="identifier">Emit::up</span><span class="plain">();</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="identifier">i6_schema</span><span class="plain"> *</span><span class="identifier">i6s</span><span class="plain">;</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">reverse</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">continue_loop_on_fail</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>

                <span class="identifier">i6s</span><span class="plain"> = </span><span class="identifier">BinaryPredicates::get_test_function</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">);</span>
                <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR_CONSTRUCTION</span><span class="plain">, </span><span class="string">"Read I6s $i from $2\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">i6s</span><span class="plain">, </span><span class="identifier">bp</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">i6s</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) &amp;&amp; (</span><span class="identifier">BinaryPredicates::get_test_function</span><span class="plain">(</span><span class="identifier">BinaryPredicates::get_reversal</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">)))) {</span>
                    <span class="identifier">reverse</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                    <span class="identifier">i6s</span><span class="plain"> = </span><span class="identifier">BinaryPredicates::get_test_function</span><span class="plain">(</span><span class="identifier">BinaryPredicates::get_reversal</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">));</span>
                    <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR_CONSTRUCTION</span><span class="plain">, </span><span class="string">"But read I6s $i from reversal\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">i6s</span><span class="plain">);</span>
                <span class="plain">}</span>

                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i6s</span><span class="plain">) {</span>
                    <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">BinaryPredicates::term_kind</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">, 1);</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::lt</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)) {</span>
                        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR_CONSTRUCTION</span><span class="plain">, </span><span class="string">"Term 1 of BP is $u\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">);</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">objectloopx_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Kinds::RunTime::I6_classname</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">));</span>
                            <span class="identifier">Emit::code</span><span class="plain">();</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">pcalc_term</span><span class="plain"> </span><span class="identifier">rv_term</span><span class="plain"> = </span><span class="identifier">Calculus::Terms::new_constant</span><span class="plain">(</span>
                                            <span class="identifier">Lvalues::new_LOCAL_VARIABLE</span><span class="plain">(</span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_lv</span><span class="plain">));</span>
                                        <span class="identifier">pcalc_term</span><span class="plain"> </span><span class="identifier">self_term</span><span class="plain"> = </span><span class="identifier">Calculus::Terms::new_constant</span><span class="plain">(</span>
                                            <span class="identifier">Rvalues::new_self_object_constant</span><span class="plain">());</span>
                                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">reverse</span><span class="plain">)</span>
                                            <span class="identifier">Calculus::Schemas::emit_val_expand_from_terms</span><span class="plain">(</span><span class="identifier">i6s</span><span class="plain">, &amp;</span><span class="identifier">rv_term</span><span class="plain">, &amp;</span><span class="identifier">self_term</span><span class="plain">);</span>
                                        <span class="reserved">else</span>
                                            <span class="identifier">Calculus::Schemas::emit_val_expand_from_terms</span><span class="plain">(</span><span class="identifier">i6s</span><span class="plain">, &amp;</span><span class="identifier">self_term</span><span class="plain">, &amp;</span><span class="identifier">rv_term</span><span class="plain">);</span>
                        <span class="identifier">continue_loop_on_fail</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                        <span class="identifier">Problems::quote_source</span><span class="plain">(2, </span><span class="identifier">pn</span><span class="plain">);</span>
                        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_GrammarValueRelation</span><span class="plain">));</span>
                        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                            <span class="string">"The grammar you give in %1 contains a token "</span>
                            <span class="string">"which relates things to values - %2. At present, "</span>
                            <span class="string">"this is not allowed: only relations between kinds "</span>
                            <span class="string">"of object can be used in 'Understand' tokens."</span><span class="plain">);</span>
                        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">K_object</span><span class="plain">;</span>
                    <span class="plain">}</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain"> = </span><span class="identifier">BinaryPredicates::get_i6_storage_property</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">);</span>
                    <span class="identifier">reverse</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">BinaryPredicates::is_the_wrong_way_round</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">)) </span><span class="identifier">reverse</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">BinaryPredicates::get_form_of_relation</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">) == </span><span class="identifier">Relation_VtoO</span><span class="plain">) {</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">reverse</span><span class="plain">) </span><span class="identifier">reverse</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">; </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">reverse</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                    <span class="plain">}</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prn</span><span class="plain">) {</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">reverse</span><span class="plain">) {</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">provides_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::code</span><span class="plain">();</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>

                                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">propertyvalue_interp</span><span class="plain">);</span>
                                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
                                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                                            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>

                            <span class="identifier">continue_loop_on_fail</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
                        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">BinaryPredicates::term_kind</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">, 1);</span>
                            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                                <span class="identifier">Problems::quote_source</span><span class="plain">(2, </span><span class="identifier">pn</span><span class="plain">);</span>
                                <span class="identifier">Problems::quote_kind</span><span class="plain">(3, </span><span class="identifier">K</span><span class="plain">);</span>
                                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_GrammarValueRelation2</span><span class="plain">));</span>
                                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                                    <span class="string">"The grammar you give in %1 contains a token "</span>
                                    <span class="string">"which relates things to values - %2. (It would "</span>
                                    <span class="string">"need to match the name of %3, which isn't a kind "</span>
                                    <span class="string">"of thing.) At present, this is not allowed: only "</span>
                                    <span class="string">"relations between kinds of object can be used in "</span>
                                    <span class="string">"'Understand' tokens."</span><span class="plain">);</span>
                                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">K_object</span><span class="plain">;</span>
                            <span class="plain">}</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">objectloopx_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Kinds::RunTime::I6_classname</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">));</span>
                                <span class="identifier">Emit::code</span><span class="plain">();</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">and_interp</span><span class="plain">);</span>
                                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">provides_interp</span><span class="plain">);</span>
                                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
                                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">propertyvalue_interp</span><span class="plain">);</span>
                                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                                                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
                                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">SELF_HL</span><span class="plain">));</span>
                                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">continue_loop_on_fail</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                        <span class="plain">}</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Trouble with: $2\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">bp</span><span class="plain">);</span>
                        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Whose reversal is: $2\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">BinaryPredicates::get_reversal</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">));</span>
                        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                        <span class="identifier">Problems::quote_source</span><span class="plain">(2, </span><span class="identifier">pn</span><span class="plain">);</span>
                        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_GrammarTokenCowardice</span><span class="plain">));</span>
                        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                            <span class="string">"The grammar you give in %1 contains a token "</span>
                            <span class="string">"which uses a relation I'm unable to test - %2."</span><span class="plain">);</span>
                        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">K_object</span><span class="plain">;</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>

                                    <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::code</span><span class="plain">();</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">continue_loop_on_fail</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                                        &lt;<span class="cwebmacro">Jump to our doom</span> <span class="cwebmacronumber">12.2</span>&gt;<span class="plain">;</span>
                                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">continue_interp</span><span class="plain">);</span>
                                    <span class="plain">}</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>

                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::ref_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">plus_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::inv_call</span><span class="plain">(</span><span class="identifier">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">TRYGIVENOBJECT_HL</span><span class="plain">)));</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                                        <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>

                            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">);</span>
                            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">, </span><span class="string">".ol_mm_%d"</span><span class="plain">, </span><span class="identifier">ol_loop_counter</span><span class="plain">++);</span>
                            <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">exit_label</span><span class="plain"> = </span><span class="identifier">Emit::reserve_label</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">);</span>
                            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">);</span>

                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">gt_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::code</span><span class="plain">();</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">jump_interp</span><span class="plain">);</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::lab</span><span class="plain">(</span><span class="identifier">exit_label</span><span class="plain">);</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>

                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    &lt;<span class="cwebmacro">Jump to our doom</span> <span class="cwebmacronumber">12.2</span>&gt;<span class="plain">;</span>
                    <span class="identifier">Emit::place_label</span><span class="plain">(</span><span class="identifier">exit_label</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="plain">}</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="plain">}</span>

        <span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">ParseTree::get_grammar_value</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">spec</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="functiontext">PL::Parsing::Tokens::determine</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, 10, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">ParseTree::get_grammar_value</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">spec</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"$T"</span><span class="plain">, </span><span class="identifier">pn</span><span class="plain">);</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"NULL result of non-preposition token"</span><span class="plain">);</span>
        <span class="plain">}</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Specifications::is_kind_like</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) {</span>
            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">ParseTree::get_kind_of_value</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp;</span>
                <span class="plain">(</span><span class="identifier">Kinds::Compare::eq</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_understanding</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Behaviour::offers_I6_GPR</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">)) {</span>
                    <span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">i6_gpr_name</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_explicit_I6_GPR</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">code_mode</span><span class="plain">) {</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::inv_call</span><span class="plain">(</span><span class="identifier">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSETOKENSTOPPED_HL</span><span class="plain">)));</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_TT_HL</span><span class="plain">));</span>
                                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Str::len</span><span class="plain">(</span><span class="identifier">i6_gpr_name</span><span class="plain">) &gt; 0)</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find_by_name</span><span class="plain">(</span><span class="identifier">i6_gpr_name</span><span class="plain">));</span>
                                <span class="reserved">else</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Kinds::RunTime::get_kind_GPR_iname</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">));</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">ne_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_NUMBER_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                            &lt;<span class="cwebmacro">Then jump to our doom</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_NUMBER_HL</span><span class="plain">));</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Str::len</span><span class="plain">(</span><span class="identifier">i6_gpr_name</span><span class="plain">) &gt; 0)</span>
                            <span class="identifier">Emit::array_iname_entry</span><span class="plain">(</span><span class="identifier">Hierarchy::find_by_name</span><span class="plain">(</span><span class="identifier">i6_gpr_name</span><span class="plain">));</span>
                        <span class="reserved">else</span>
                            <span class="identifier">Emit::array_iname_entry</span><span class="plain">(</span><span class="identifier">Kinds::RunTime::get_kind_GPR_iname</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">));</span>
                    <span class="plain">}</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">K</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="comment">internal_error("Let an invalid type token through");</span>
            <span class="plain">}</span>
        <span class="plain">}</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Descriptions::is_complex</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) {</span>
            <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
            <span class="identifier">Problems::quote_source</span><span class="plain">(2, </span><span class="identifier">pn</span><span class="plain">);</span>
            <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_OverComplexToken</span><span class="plain">));</span>
            <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                <span class="string">"The grammar you give in %1 contains a token "</span>
                <span class="string">"which is just too complicated - %2. %PFor instance, a "</span>
                <span class="string">"token using subordinate clauses - such as '[a person who "</span>
                <span class="string">"can see the player]' will probably not be allowed."</span><span class="plain">);</span>
            <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">K_object</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">gtc</span><span class="plain"> = </span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">grammar_token_code_ANNOT</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gtc</span><span class="plain"> &lt; 0) {</span>
                <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">i6_token_iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Tokens::iname_for_special_token</span><span class="plain">(</span><span class="identifier">gtc</span><span class="plain">);</span>
                <span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Tokens::kind_for_special_token</span><span class="plain">(</span><span class="identifier">gtc</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">code_mode</span><span class="plain">) {</span>
                    <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">consult_mode</span><span class="plain">) &amp;&amp; (</span><span class="identifier">gtc</span><span class="plain"> == </span><span class="constant">TOPIC_TOKEN_GTC</span><span class="plain">)) {</span>
                        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_TextTokenRestricted</span><span class="plain">),</span>
                            <span class="string">"the '[text]' token is not allowed with 'matches' "</span>
                            <span class="string">"or in table columns"</span><span class="plain">,</span>
                            <span class="string">"as it is just too complicated to sort out: a "</span>
                            <span class="string">"'[text]' is supposed to extract a snippet from "</span>
                            <span class="string">"the player's command, but here we already have "</span>
                            <span class="string">"a snippet, and don't want to snip it further."</span><span class="plain">);</span>
                    <span class="plain">}</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::inv_call</span><span class="plain">(</span><span class="identifier">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSETOKENSTOPPED_HL</span><span class="plain">)));</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">ELEMENTARY_TT_HL</span><span class="plain">));</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">i6_token_iname</span><span class="plain">);</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_FAIL_HL</span><span class="plain">));</span>
                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                        &lt;<span class="cwebmacro">Then jump to our doom</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                        <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="identifier">Emit::array_iname_entry</span><span class="plain">(</span><span class="identifier">i6_token_iname</span><span class="plain">);</span>
                <span class="plain">}</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) {</span>
                    <span class="identifier">K</span><span class="plain"> = </span><span class="identifier">Specifications::to_kind</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Descriptions::is_qualified</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) {</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">code_mode</span><span class="plain">) {</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                <span class="identifier">Emit::inv_call</span><span class="plain">(</span><span class="identifier">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSETOKENSTOPPED_HL</span><span class="plain">)));</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="functiontext">PL::Parsing::Tokens::Filters::compile_id</span><span class="plain">(</span><span class="identifier">gtc</span><span class="plain">);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_FAIL_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                &lt;<span class="cwebmacro">Then jump to our doom</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                            <span class="identifier">Emit::down</span><span class="plain">();</span>
                                <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                                <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                            <span class="identifier">Emit::up</span><span class="plain">();</span>
                        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                            <span class="functiontext">PL::Parsing::Tokens::Filters::emit_id</span><span class="plain">(</span><span class="identifier">gtc</span><span class="plain">);</span>
                        <span class="plain">}</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Behaviour::offers_I6_GPR</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">)) {</span>
                            <span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">i6_gpr_name</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_explicit_I6_GPR</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
                            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">code_mode</span><span class="plain">) {</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::inv_call</span><span class="plain">(</span><span class="identifier">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSETOKENSTOPPED_HL</span><span class="plain">)));</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_TT_HL</span><span class="plain">));</span>
                                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Str::len</span><span class="plain">(</span><span class="identifier">i6_gpr_name</span><span class="plain">) &gt; 0)</span>
                                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find_by_name</span><span class="plain">(</span><span class="identifier">i6_gpr_name</span><span class="plain">));</span>
                                        <span class="reserved">else</span>
                                            <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Kinds::RunTime::get_kind_GPR_iname</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">));</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">ne_interp</span><span class="plain">);</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_NUMBER_HL</span><span class="plain">));</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                    &lt;<span class="cwebmacro">Then jump to our doom</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_NUMBER_HL</span><span class="plain">));</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Str::len</span><span class="plain">(</span><span class="identifier">i6_gpr_name</span><span class="plain">) &gt; 0)</span>
                                    <span class="identifier">Emit::array_iname_entry</span><span class="plain">(</span><span class="identifier">Hierarchy::find_by_name</span><span class="plain">(</span><span class="identifier">i6_gpr_name</span><span class="plain">));</span>
                                <span class="reserved">else</span>
                                    <span class="identifier">Emit::array_iname_entry</span><span class="plain">(</span><span class="identifier">Kinds::RunTime::get_kind_GPR_iname</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">));</span>
                            <span class="plain">}</span>
                        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)) {</span>
                            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">code_mode</span><span class="plain">) {</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::inv_call</span><span class="plain">(</span><span class="identifier">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSETOKENSTOPPED_HL</span><span class="plain">)));</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="functiontext">PL::Parsing::Tokens::Filters::compile_id</span><span class="plain">(</span><span class="identifier">gtc</span><span class="plain">);</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_FAIL_HL</span><span class="plain">));</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                    &lt;<span class="cwebmacro">Then jump to our doom</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                                <span class="functiontext">PL::Parsing::Tokens::Filters::emit_id</span><span class="plain">(</span><span class="identifier">gtc</span><span class="plain">);</span>
                            <span class="plain">}</span>
                            <span class="identifier">K</span><span class="plain"> = </span><span class="identifier">K_object</span><span class="plain">;</span>
                        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"no token for description"</span><span class="plain">);</span>
                    <span class="plain">}</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">CONSTANT_NT</span><span class="plain">)) {</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Rvalues::is_CONSTANT_of_kind</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">K_understanding</span><span class="plain">)) {</span>
                            <span class="identifier">gv</span><span class="plain"> = </span><span class="identifier">Rvalues::to_grammar_verb</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
                            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">code_mode</span><span class="plain">) {</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::inv_call</span><span class="plain">(</span><span class="identifier">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSETOKENSTOPPED_HL</span><span class="plain">)));</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_TT_HL</span><span class="plain">));</span>
                                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">PL::Parsing::Verbs::i6_token_as_iname</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">));</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_FAIL_HL</span><span class="plain">));</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                    &lt;<span class="cwebmacro">Then jump to our doom</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>

                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">ne_interp</span><span class="plain">);</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_PREPOSITION_HL</span><span class="plain">));</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                    <span class="identifier">Emit::code</span><span class="plain">();</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                                        <span class="identifier">Emit::down</span><span class="plain">();</span>
                                            <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                                            <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                        <span class="identifier">Emit::up</span><span class="plain">();</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                                <span class="identifier">Emit::array_iname_entry</span><span class="plain">(</span><span class="functiontext">PL::Parsing::Verbs::i6_token_as_iname</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">));</span>
                            <span class="plain">}</span>
                            <span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::get_data_type_as_token</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">);</span>
                        <span class="plain">}</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Rvalues::is_object</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) {</span>
                            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">code_mode</span><span class="plain">) {</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::inv_call</span><span class="plain">(</span><span class="identifier">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">PARSETOKENSTOPPED_HL</span><span class="plain">)));</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="functiontext">PL::Parsing::Tokens::Filters::compile_id</span><span class="plain">(</span><span class="identifier">gtc</span><span class="plain">);</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">if_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">eq_interp</span><span class="plain">);</span>
                                    <span class="identifier">Emit::down</span><span class="plain">();</span>
                                        <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                        <span class="identifier">Emit::val_iname</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_FAIL_HL</span><span class="plain">));</span>
                                    <span class="identifier">Emit::up</span><span class="plain">();</span>
                                    &lt;<span class="cwebmacro">Then jump to our doom</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                                <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">store_interp</span><span class="plain">);</span>
                                <span class="identifier">Emit::down</span><span class="plain">();</span>
                                    <span class="identifier">Emit::ref_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;rv_s</span><span class="plain">);</span>
                                    <span class="identifier">Emit::val_symbol</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-</span><span class="element">&gt;w_s</span><span class="plain">);</span>
                                <span class="identifier">Emit::up</span><span class="plain">();</span>
                            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                                <span class="functiontext">PL::Parsing::Tokens::Filters::emit_id</span><span class="plain">(</span><span class="identifier">gtc</span><span class="plain">);</span>
                            <span class="plain">}</span>
                            <span class="identifier">K</span><span class="plain"> = </span><span class="identifier">K_object</span><span class="plain">;</span>
                        <span class="plain">}</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">K_object</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">K</span><span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Tokens::compile is used in 5/gl (<a href="5-gl.html#SP20">&#167;20</a>).</p>

<p class="inwebparagraph"><a id="SP12_1"></a><b>&#167;12.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Then jump to our doom</span> <span class="cwebmacronumber">12.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Emit::code</span><span class="plain">();</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            &lt;<span class="cwebmacro">Jump to our doom</span> <span class="cwebmacronumber">12.2</span>&gt;<span class="plain">;</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a> (15 times).</p>

<p class="inwebparagraph"><a id="SP12_2"></a><b>&#167;12.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Jump to our doom</span> <span class="cwebmacronumber">12.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">jump_interp</span><span class="plain">);</span>
        <span class="identifier">Emit::down</span><span class="plain">();</span>
            <span class="identifier">Emit::lab</span><span class="plain">(</span><span class="identifier">failure_label</span><span class="plain">);</span>
        <span class="identifier">Emit::up</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a> (four times), <a href="#SP12_1">&#167;12.1</a>.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="5-gt.html">Back to 'Grammar Types'</a></li><li><a href="5-nft.html">Continue with 'Noun Filter Tokens'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

