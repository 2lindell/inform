<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>5/gp</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '5/gv' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">if</a></li><li><a href="index.html#5">Chapter 5: Command Grammar</a></li><li><b>Grammar Verbs</b></li></ul><p class="purpose">A grammar verb is not literally a verb, as the name is a hangover from the way I6 defines grammar. It might be said to be a necklace onto which we thread the sea-shells of grammar lines. Each grammar verb has its own purpose: to match various possibilities (one for each grammar line) against text aimed at a particular result. For instance, all run time commands beginning with TAKE are parsed with a single grammar verb. If we create a new grammar token, "[polite remark]", for use in other grammar, then that too will have its own "grammar verb". If we define the word "eleventy-one" as meaning the number 111, it will be added to a grammar verb attached to the kind "number" which parses eccentric names for number values. And so on. Probably a better name for this structure would be simply "grammar", but that might be confusing in other ways, and anyway the ship has sailed.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP6">&#167;6. Command words</a></li><li><a href="#SP13">&#167;13. Named grammar tokens</a></li><li><a href="#SP16">&#167;16. Consultation grammars</a></li><li><a href="#SP17">&#167;17. Subject parsing grammars</a></li><li><a href="#SP18">&#167;18. Data type parsing grammars</a></li><li><a href="#SP19">&#167;19. Property name parsing grammars</a></li><li><a href="#SP20">&#167;20. The list of grammar lines</a></li><li><a href="#SP23">&#167;23. Grammar Preparation</a></li><li><a href="#SP24">&#167;24. Phase I: Slash Grammar</a></li><li><a href="#SP25">&#167;25. Phase II: Determining Grammar</a></li><li><a href="#SP26">&#167;26. Phases III and IV: Sort and Compile Grammar</a></li><li><a href="#SP31">&#167;31. Kinds as GVs</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>There are five different sorts of grammar verb, then, and only the first
of these is associated with a genuine typed-by-the-player command verb:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">GV_IS_COMMAND</span><span class="plain"> 1  </span>    <span class="comment">an imperative verbal command at run-time</span>
    <span class="definitionkeyword">define</span> <span class="constant">GV_IS_TOKEN</span><span class="plain">   2  </span>    <span class="comment">a square-bracketed token in other grammar</span>
    <span class="definitionkeyword">define</span> <span class="constant">GV_IS_OBJECT</span><span class="plain">  3  </span>    <span class="comment">a noun phrase at run time: a name for an object</span>
    <span class="definitionkeyword">define</span> <span class="constant">GV_IS_VALUE</span><span class="plain">   4  </span>    <span class="comment">a noun phrase at run time: a name for a value</span>
    <span class="definitionkeyword">define</span> <span class="constant">GV_IS_CONSULT</span><span class="plain"> 5  </span>    <span class="comment">a pattern to match in part of a command (such as "consult")</span>
    <span class="definitionkeyword">define</span> <span class="constant">GV_IS_PROPERTY_NAME</span><span class="plain"> 6  </span>    <span class="comment">a noun phrase at run time: a name for an either/or pval</span>
</pre>
<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>The following maxima are imposed by the I6 compiler:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">MAX_ALIASED_COMMANDS</span><span class="plain"> 32</span>
    <span class="definitionkeyword">define</span> <span class="constant">MAX_LINES_PER_COMMAND</span><span class="plain"> 32</span>
</pre>

<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">grammar_verb</span><span class="plain"> {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">gv_is</span><span class="plain">; </span>    <span class="comment">one of the five values above</span>

        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">grammar_type</span><span class="plain"> </span><span class="identifier">gv_type</span><span class="plain">;</span>

        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">grammar_line</span><span class="plain"> *</span><span class="identifier">first_line</span><span class="plain">; </span>    <span class="comment">linked list in creation order</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">grammar_line</span><span class="plain"> *</span><span class="identifier">sorted_first_line</span><span class="plain">; </span>    <span class="comment">and in logical applicability order</span>

        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">command</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">GV_IS_COMMAND</span></code>: word number at which command found</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">aliased_command</span><span class="plain">[</span><span class="constant">MAX_ALIASED_COMMANDS</span><span class="plain">]; </span>    <span class="comment">...and other commands synonymous</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">no_aliased_commands</span><span class="plain">; </span>    <span class="comment">...and how many of them there are</span>

        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">name</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">GV_IS_TOKEN</span></code>: name of this token</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">gv_line_iname</span><span class="plain">;</span>

        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj_understood</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">GV_IS_OBJECT</span></code>: what this provides names for</span>

        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">kind_understood</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">GV_IS_VALUE</span></code>: for which type it names an instance of</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">gv_parse_name_iname</span><span class="plain">;</span>

        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">property</span><span class="plain"> *</span><span class="identifier">prn_understood</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">GV_IS_PROPERTY_NAME</span></code>: which prn this names</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">gv_prn_iname</span><span class="plain">; </span>    <span class="comment">the relevant GPR is called this</span>

        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">where_gv_created</span><span class="plain">; </span>    <span class="comment">for problem message reports</span>

        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">gv_consult_iname</span><span class="plain">; </span>    <span class="comment">for the consult parsing routine if needed</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">gv_I6_identifier</span><span class="plain">; </span>    <span class="comment">when a token is delegated to an I6 routine</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">slashed</span><span class="plain">; </span>    <span class="comment">slashing has been done</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">determined</span><span class="plain">; </span>    <span class="comment">determination has been done</span>

        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">grammar_verb</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure grammar_verb is accessed in 2/bd, 3/tnt, 3/sm, 3/tp, 3/bck, 3/rgn, 3/tm, 3/em, 3/sc, 3/scn, 4/act, 4/anl, 4/nap, 5/gp, 5/gpr and here.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>A few imperative verbs are reserved for Inform testing, such as SHOWME.
We record those as instances of the following:
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">reserved_command_verb</span><span class="plain"> {</span>
        <span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">reserved_text</span><span class="plain">;</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">reserved_command_verb</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure reserved_command_verb is private to this section.</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>We begin as usual with a constructor and some debug log tracing.
</p>


<pre class="display">
    <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Verbs::gv_new</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">gv_is</span><span class="plain">) {</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain">);</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_type</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Tokens::Types::new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> = </span><span class="identifier">gv_is</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;no_aliased_commands</span><span class="plain"> = 0;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;sorted_first_line</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;subj_understood</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;kind_understood</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_parse_name_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;prn_understood</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;where_gv_created</span><span class="plain"> = </span><span class="identifier">current_sentence</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_consult_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_prn_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_line_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_I6_identifier</span><span class="plain"> = </span><span class="identifier">Str::new</span><span class="plain">();</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;slashed</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;determined</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">gv</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::log</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"&lt;GV%d:"</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain">);</span>
        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_COMMAND</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">)) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"command=no-verb verb"</span><span class="plain">);</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"command=%W"</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_TOKEN</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"token=%W"</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_OBJECT</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"object"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_VALUE</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"value=$u"</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;kind_understood</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_CONSULT</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"consult"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_PROPERTY_NAME</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"property-name"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">default</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"&lt;unknown&gt;"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"&gt;"</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::gv_new is used in <a href="#SP7">&#167;7</a>, <a href="#SP13">&#167;13</a>, <a href="#SP16">&#167;16</a>, <a href="#SP17">&#167;17</a>, <a href="#SP18">&#167;18</a>, <a href="#SP19">&#167;19</a>.</p>

<p class="endnote">The function PL::Parsing::Verbs::log is used in 1/im (<a href="1-im.html#SP4">&#167;4</a>, <a href="1-im.html#SP4_4">&#167;4.4</a>).</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Command words. </b>Some GVs are used to represent the command grammar for imperative verbs
used by the player at run-time. Such a GV handles multiple commands, which
are considered equivalent at run-time: the first of these is the official
command word, and the rest are "aliases". For instance, the Standard Rules
create a GV for the command PULL with one alias, DRAG. (This somewhat
asymmetric approach is used because it matches the way I6 <code class="display"><span class="extract">Verb</span></code> declarations
are laid out.)
</p>

<p class="inwebparagraph">A complication is that one GV is permitted to be a special case: the
so-called "no verb verb", whose main command word is empty and which
can have no aliases. This is used to parse verbless commands at run-time:
for instance, the I7 designer can specify that a command consisting only
of a number followed by the word GO should cause some action, and this
is implemented not with a command verb but using I6's hooks for verbless
commands. The grammar "[number] go" is attached as a grammar line to
the "no verb verb", which is distinguished by having its command word
number set to <code class="display"><span class="extract">-1</span></code>. Note that the "no verb verb" exists only in runs of
NI where it has been needed: the Standard Rules do not use it.
</p>

<p class="inwebparagraph">Command GVs other than the "no verb verb" are said to be "genuinely
verbal".
</p>


<pre class="display">
    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::get_verb_text</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::gv_is_genuinely_verbal</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_COMMAND</span><span class="plain">) &amp;&amp; (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">)))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::get_verb_text is used in 5/gl (<a href="5-gl.html#SP25">&#167;25</a>, <a href="5-gl.html#SP26">&#167;26</a>).</p>

<p class="endnote">The function PL::Parsing::Verbs::gv_is_genuinely_verbal is used in <a href="#SP25">&#167;25</a>, <a href="#SP29">&#167;29</a>.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>The next routine finds, or if necessary creates, a GV for a given command
word encountered without any indication that it should alias another. Note
that calling this with word number <code class="display"><span class="extract">-1</span></code> finds, or creates, the "no verb
verb".
</p>


<pre class="display">
    <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Verbs::find_or_create_command</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::find_command</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">gv</span><span class="plain">;</span>

        <span class="identifier">gv</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::gv_new</span><span class="plain">(</span><span class="constant">GV_IS_COMMAND</span><span class="plain">);</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain"> = </span><span class="identifier">W</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">NO_VERB_VERB_DEFINED_HL</span><span class="plain">);</span>
            <span class="identifier">Emit::named_numeric_constant</span><span class="plain">(</span><span class="identifier">iname</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) 1);</span>
            <span class="identifier">UseOptions::no_verb_verb</span><span class="plain">();</span>
        <span class="plain">}</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR_CONSTRUCTION</span><span class="plain">, </span><span class="string">"GV%d has verb %W\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>

        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">gv</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::find_or_create_command is used in 5/tfg (<a href="5-tfg.html#SP21">&#167;21</a>).</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>By contrast, this routine merely finds a GV, or returns null if none
exists with the given command word.
</p>


<pre class="display">
    <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Verbs::find_command</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_COMMAND</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">gv</span><span class="plain">;</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::match</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">gv</span><span class="plain">;</span>
                    <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;no_aliased_commands</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++)</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::match</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;aliased_command</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">], </span><span class="identifier">W</span><span class="plain">))</span>
                            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">gv</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::find_command is used in <a href="#SP7">&#167;7</a>, 4/ai (<a href="4-ai.html#SP3">&#167;3</a>), 5/tfg (<a href="5-tfg.html#SP16_2_1">&#167;16.2.1</a>).</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>We now have routines to add or remove commands from a given GV. Removing
is the tricky case, since detaching the main command word means that one
of the aliases must become the new main command; or, in the worst case,
that there are no commands left, in which case we need to empty the GV
of grammar lines so that it can either be ignored or re-used (in the
event that the designer, having cancelled the old meaning of the command,
now supplies new ones).
</p>

<p class="inwebparagraph">It is not possible to add to, or remove from, the "no verb verb".
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::add_command</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to add alias command to null GV"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> != </span><span class="constant">GV_IS_COMMAND</span><span class="plain">)</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to add alias command to non-command GV"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;no_aliased_commands</span><span class="plain"> == </span><span class="constant">MAX_ALIASED_COMMANDS</span><span class="plain">) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_TooManyAliases</span><span class="plain">),</span>
                <span class="string">"this 'understand the command ... as ...' makes too many aliases "</span>
                <span class="string">"for the same command"</span><span class="plain">,</span>
                <span class="string">"exceeding the limit of 32."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;aliased_command</span><span class="plain">[</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;no_aliased_commands</span><span class="plain">++] = </span><span class="identifier">W</span><span class="plain">;</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR</span><span class="plain">, </span><span class="string">"Adding alias '%W' to G%d '%W'\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::remove_command</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to detach alias command from null GV"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> != </span><span class="constant">GV_IS_COMMAND</span><span class="plain">)</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to detach alias command from non-command GV"</span><span class="plain">);</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR</span><span class="plain">, </span><span class="string">"Detaching verb '%W' from grammar\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)	</span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::match</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR</span><span class="plain">, </span><span class="string">"Detached verb is the head-verb\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;no_aliased_commands</span><span class="plain"> == 0) {</span>
                <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
                <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR</span><span class="plain">, </span><span class="string">"Which had no aliases: clearing grammar to NULL\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain"> = </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;aliased_command</span><span class="plain">[--(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;no_aliased_commands</span><span class="plain">)];</span>
                <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR</span><span class="plain">, </span><span class="string">"Which had aliases: making new head-verb '%W'\</span><span class="plain">n</span><span class="string">"</span><span class="plain">,</span>
                    <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR</span><span class="plain">, </span><span class="string">"Detached verb is one of the aliases\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;no_aliased_commands</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::match</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;aliased_command</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">], </span><span class="identifier">W</span><span class="plain">)) {</span>
                    <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">j</span><span class="plain">=</span><span class="identifier">i</span><span class="plain">; </span><span class="identifier">j</span><span class="plain">&lt;</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;no_aliased_commands</span><span class="plain">-1; </span><span class="identifier">j</span><span class="plain">++)</span>
                        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;aliased_command</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">] = </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;aliased_command</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">+1];</span>
                    <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;no_aliased_commands</span><span class="plain">--;</span>
                    <span class="reserved">break</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::index_command_aliases</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">n</span><span class="plain"> = </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;no_aliased_commands</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">n</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++)</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"/%N"</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;aliased_command</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]));</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::remove_action</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">action_name</span><span class="plain"> *</span><span class="identifier">an</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> != </span><span class="constant">GV_IS_COMMAND</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Lines::list_remove</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain">, </span><span class="identifier">an</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::add_command is used in 5/tfg (<a href="5-tfg.html#SP16_2_1">&#167;16.2.1</a>).</p>

<p class="endnote">The function PL::Parsing::Verbs::remove_command is used in 5/tfg (<a href="5-tfg.html#SP16_2_1">&#167;16.2.1</a>).</p>

<p class="endnote">The function PL::Parsing::Verbs::index_command_aliases is used in 4/ai (<a href="4-ai.html#SP3">&#167;3</a>).</p>

<p class="endnote">The function PL::Parsing::Verbs::remove_action is used in 5/tfg (<a href="5-tfg.html#SP20">&#167;20</a>).</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>Command GVs are destined to be compiled into <code class="display"><span class="extract">Verb</span></code> directives, as follows.
</p>


<pre class="display">
    <span class="identifier">packaging_state</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::gv_compile_Verb_directive_header</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">, </span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">array_iname</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> != </span><span class="constant">GV_IS_COMMAND</span><span class="plain">)</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to compile Verb from non-command GV"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"compiling Verb for empty grammar"</span><span class="plain">);</span>

        <span class="identifier">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="identifier">Emit::named_verb_array_begin</span><span class="plain">(</span><span class="identifier">array_iname</span><span class="plain">, </span><span class="identifier">K_value</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">))</span>
            <span class="identifier">Emit::array_dword_entry</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"no.verb"</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">vt</span><span class="plain">);</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">vt</span><span class="plain">, </span><span class="string">"%W"</span><span class="plain">, </span><span class="identifier">Wordings::one_word</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">)));</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">PL::Parsing::Verbs::command_verb_reserved</span><span class="plain">(</span><span class="identifier">vt</span><span class="plain">)) {</span>
                <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;where_gv_created</span><span class="plain">;</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">);</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"You wrote %1, but %2 is a built-in Inform testing verb, which "</span>
                    <span class="string">"means it is reserved for Inform's own use and can't be used "</span>
                    <span class="string">"for ordinary play purposes. %PThe verbs which are reserved in "</span>
                    <span class="string">"this way are all listed in the alphabetical catalogue on the "</span>
                    <span class="string">"Actions Index page."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
            <span class="plain">}</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">vt</span><span class="plain">);</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">WD</span><span class="plain">);</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">WD</span><span class="plain">, </span><span class="string">"%N"</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">));</span>
            <span class="identifier">Emit::array_dword_entry</span><span class="plain">(</span><span class="identifier">WD</span><span class="plain">);</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">WD</span><span class="plain">);</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;no_aliased_commands</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) {</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">WD</span><span class="plain">);</span>
                <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">WD</span><span class="plain">, </span><span class="string">"%N"</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;aliased_command</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]));</span>
                <span class="identifier">Emit::array_dword_entry</span><span class="plain">(</span><span class="identifier">WD</span><span class="plain">);</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">WD</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">save</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::gv_compile_Verb_directive_header is used in <a href="#SP27">&#167;27</a>.</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b>Reserved verb names are collated as the I6 template files are read:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::reserve</span><span class="plain">(</span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">verb_name</span><span class="plain">) {</span>
        <span class="reserved">reserved_command_verb</span><span class="plain"> *</span><span class="identifier">rcv</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">reserved_command_verb</span><span class="plain">);</span>
        <span class="identifier">rcv</span><span class="plain">-</span><span class="element">&gt;reserved_text</span><span class="plain"> = </span><span class="identifier">Str::new</span><span class="plain">();</span>
        <span class="functiontext">PL::Parsing::Verbs::normalise_cv_to</span><span class="plain">(</span><span class="identifier">rcv</span><span class="plain">-</span><span class="element">&gt;reserved_text</span><span class="plain">, </span><span class="identifier">verb_name</span><span class="plain">);</span>
        <span class="functiontext">PL::Actions::Index::test_verb</span><span class="plain">(</span><span class="identifier">rcv</span><span class="plain">-</span><span class="element">&gt;reserved_text</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::command_verb_reserved</span><span class="plain">(</span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">verb_tried</span><span class="plain">) {</span>
        <span class="reserved">reserved_command_verb</span><span class="plain"> *</span><span class="identifier">rcv</span><span class="plain">;</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">normalised_vt</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Verbs::normalise_cv_to</span><span class="plain">(</span><span class="identifier">normalised_vt</span><span class="plain">, </span><span class="identifier">verb_tried</span><span class="plain">);</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">rcv</span><span class="plain">, </span><span class="reserved">reserved_command_verb</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Str::eq</span><span class="plain">(</span><span class="identifier">normalised_vt</span><span class="plain">, </span><span class="identifier">rcv</span><span class="plain">-</span><span class="element">&gt;reserved_text</span><span class="plain">))</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">normalised_vt</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::normalise_cv_to</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">from</span><span class="plain">) {</span>
        <span class="identifier">Str::clear</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">);</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=0; (</span><span class="identifier">i</span><span class="plain">&lt;31) &amp;&amp; (</span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">Str::len</span><span class="plain">(</span><span class="identifier">from</span><span class="plain">)); </span><span class="identifier">i</span><span class="plain">++)</span>
            <span class="identifier">PUT</span><span class="plain">(</span><span class="identifier">Characters::tolower</span><span class="plain">(</span><span class="identifier">Str::get_at</span><span class="plain">(</span><span class="identifier">from</span><span class="plain">, </span><span class="identifier">i</span><span class="plain">)));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::reserve appears nowhere else.</p>

<p class="endnote">The function PL::Parsing::Verbs::command_verb_reserved is used in <a href="#SP10">&#167;10</a>.</p>

<p class="endnote">The function PL::Parsing::Verbs::normalise_cv_to appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b>The "Commands available to the player" portion of the Actions index page
is, in effect, an alphabetised merge of the GLs found within the command GVs.
GLs for the "no verb verb" appear under the special headword "0" (which
is not displayed); otherwise GLs appear under the main command word, and
aliases are shown with references like: "drag", same as "pull".
</p>

<p class="inwebparagraph">One routine takes a GV and creates suitable entries for the Actions index
to process; the other two routines act upon any such entries once they are
needed.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::make_command_index_entries</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_COMMAND</span><span class="plain">) &amp;&amp; (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">))</span>
                <span class="functiontext">PL::Actions::Index::vie_new_from</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">L</span><span class="string">"0"</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">, </span><span class="constant">NORMAL_COMMAND</span><span class="plain">);</span>
            <span class="reserved">else</span>
                <span class="functiontext">PL::Actions::Index::vie_new_from</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">)), </span><span class="identifier">gv</span><span class="plain">, </span><span class="constant">NORMAL_COMMAND</span><span class="plain">);</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;no_aliased_commands</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++)</span>
                <span class="functiontext">PL::Actions::Index::vie_new_from</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;aliased_command</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">])), </span><span class="identifier">gv</span><span class="plain">, </span><span class="constant">ALIAS_COMMAND</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::index_normal</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">, </span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">headword</span><span class="plain">) {</span>
        <span class="functiontext">PL::Parsing::Lines::sorted_list_index_normal</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;sorted_first_line</span><span class="plain">, </span><span class="identifier">headword</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::index_alias</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">, </span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">headword</span><span class="plain">) {</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&amp;quot;%S&amp;quot;, &lt;i&gt;same as&lt;/i&gt; &amp;quot;%N&amp;quot;"</span><span class="plain">,</span>
            <span class="identifier">headword</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">));</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">link</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">link</span><span class="plain">, </span><span class="string">"%N"</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;command</span><span class="plain">));</span>
        <span class="identifier">Index::below_link</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">link</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">link</span><span class="plain">);</span>
        <span class="identifier">HTML_TAG</span><span class="plain">(</span><span class="string">"br"</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::make_command_index_entries is used in 4/ai (<a href="4-ai.html#SP3">&#167;3</a>).</p>

<p class="endnote">The function PL::Parsing::Verbs::index_normal is used in 4/ai (<a href="4-ai.html#SP3">&#167;3</a>).</p>

<p class="endnote">The function PL::Parsing::Verbs::index_alias is used in 4/ai (<a href="4-ai.html#SP3">&#167;3</a>).</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. Named grammar tokens. </b>These are like text substitutions in reverse. For instance, we could define
a token "[suitable colour]". These are identified solely by their textual
names (e.g., "suitable colour").
</p>


<pre class="display">
    <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Verbs::named_token_new</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::named_token_by_name</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">gv</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::gv_new</span><span class="plain">(</span><span class="constant">GV_IS_TOKEN</span><span class="plain">);</span>
            <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain"> = </span><span class="identifier">W</span><span class="plain">;</span>
            <span class="identifier">package_request</span><span class="plain"> *</span><span class="identifier">PR</span><span class="plain"> = </span><span class="identifier">Hierarchy::local_package</span><span class="plain">(</span><span class="identifier">NAMED_TOKENS_HAP</span><span class="plain">);</span>
            <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_line_iname</span><span class="plain"> = </span><span class="identifier">Hierarchy::make_iname_in</span><span class="plain">(</span><span class="identifier">PARSE_LINE_FN_HL</span><span class="plain">, </span><span class="identifier">PR</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">gv</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Verbs::named_token_by_name</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_TOKEN</span><span class="plain">) &amp;&amp; (</span><span class="identifier">Wordings::match</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain">)))</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">gv</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::named_token_new is used in <a href="#SP15">&#167;15</a>, 5/tfg (<a href="5-tfg.html#SP21">&#167;21</a>).</p>

<p class="endnote">The function PL::Parsing::Verbs::named_token_by_name is used in 5/gt2 (<a href="5-gt2.html#SP10">&#167;10</a>).</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::index_tokens</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">) {</span>
        <span class="functiontext">PL::Parsing::Verbs::index_tokens_for</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="string">"anybody"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"someone_token"</span><span class="plain">, </span><span class="string">"same as \</span><span class="plain">"</span><span class="string">[someone]\</span><span class="plain">"</span><span class="string">"</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Verbs::index_tokens_for</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="string">"anyone"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"someone_token"</span><span class="plain">, </span><span class="string">"same as \</span><span class="plain">"</span><span class="string">[someone]\</span><span class="plain">"</span><span class="string">"</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Verbs::index_tokens_for</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="string">"anything"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"things_token"</span><span class="plain">, </span><span class="string">"same as \</span><span class="plain">"</span><span class="string">[thing]\</span><span class="plain">"</span><span class="string">"</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Verbs::index_tokens_for</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="string">"other things"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"things_token"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Verbs::index_tokens_for</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="string">"somebody"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"someone_token"</span><span class="plain">, </span><span class="string">"same as \</span><span class="plain">"</span><span class="string">[someone]\</span><span class="plain">"</span><span class="string">"</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Verbs::index_tokens_for</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="string">"someone"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"someone_token"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Verbs::index_tokens_for</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="string">"something"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"things_token"</span><span class="plain">, </span><span class="string">"same as \</span><span class="plain">"</span><span class="string">[thing]\</span><span class="plain">"</span><span class="string">"</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Verbs::index_tokens_for</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="string">"something preferably held"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"things_token"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Verbs::index_tokens_for</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="string">"text"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"text_token"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Verbs::index_tokens_for</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="string">"things"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"things_token"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Verbs::index_tokens_for</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="string">"things inside"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"things_token"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Verbs::index_tokens_for</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="string">"things preferably held"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"things_token"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_TOKEN</span><span class="plain">)</span>
                <span class="functiontext">PL::Parsing::Verbs::index_tokens_for</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">,</span>
                    <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;where_gv_created</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;sorted_first_line</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::index_tokens_for</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">char</span><span class="plain"> *</span><span class="identifier">special</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">where</span><span class="plain">,</span>
        <span class="reserved">grammar_line</span><span class="plain"> *</span><span class="identifier">defns</span><span class="plain">, </span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">help</span><span class="plain">, </span><span class="reserved">char</span><span class="plain"> *</span><span class="identifier">explanation</span><span class="plain">) {</span>
        <span class="identifier">HTMLFiles::open_para</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, 1, </span><span class="string">"tight"</span><span class="plain">);</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"\</span><span class="plain">"</span><span class="string">["</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">special</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%s"</span><span class="plain">, </span><span class="identifier">special</span><span class="plain">); </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"]\</span><span class="plain">"</span><span class="string">"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">where</span><span class="plain">) </span><span class="identifier">Index::link</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">where</span><span class="plain">)));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Str::len</span><span class="plain">(</span><span class="identifier">help</span><span class="plain">) &gt; 0) </span><span class="identifier">Index::DocReferences::link</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">help</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">explanation</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" - %s"</span><span class="plain">, </span><span class="identifier">explanation</span><span class="plain">);</span>
        <span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">defns</span><span class="plain">) </span><span class="functiontext">PL::Parsing::Lines::index_list_for_token</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">defns</span><span class="plain">);</span>
    <span class="plain">}</span>

</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::index_tokens is used in 4/ai (<a href="4-ai.html#SP5">&#167;5</a>).</p>

<p class="endnote">The function PL::Parsing::Verbs::index_tokens_for appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b>A slight variation is provided by those which are defined by I6 routines.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::translates</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p2</span><span class="plain">) {</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_TOKEN</span><span class="plain">) &amp;&amp; (</span><span class="identifier">Wordings::match</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain">))) {</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_GrammarTranslatedAlready</span><span class="plain">),</span>
                    <span class="string">"this grammar token has already been translated"</span><span class="plain">,</span>
                    <span class="string">"so there must be some duplication somewhere."</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="identifier">gv</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::named_token_new</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_I6_identifier</span><span class="plain">, </span><span class="string">"%N"</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p2</span><span class="plain">)));</span>
    <span class="plain">}</span>

    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Verbs::i6_token_as_iname</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Str::len</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_I6_identifier</span><span class="plain">) &gt; 0)</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">Produce::find_by_name</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_I6_identifier</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_line_iname</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"no token GPR"</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_line_iname</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::translates appears nowhere else.</p>

<p class="endnote">The function PL::Parsing::Verbs::i6_token_as_iname is used in 5/gt2 (<a href="5-gt2.html#SP12">&#167;12</a>).</p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16. Consultation grammars. </b>These are used for grammar included as a column of a table or in a
conditional match. The terminology goes back to the early days of I6, when
CONSULT was a command capable of parsing arbitrary text, something which
a game called Curses made heavy use of.
</p>


<pre class="display">
    <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Verbs::consultation_new</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::gv_new</span><span class="plain">(</span><span class="constant">GV_IS_CONSULT</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">gv</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::consultation_new is used in 5/gpr (<a href="5-gpr.html#SP3">&#167;3</a>).</p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17. Subject parsing grammars. </b>Each inference subject can optionally have a GV, used to parse unusual forms of
its name (though of course many subjects are never parsed at all, so this is
only used in practice for objects and their kinds). The following routine finds
or creates such.
</p>


<pre class="display">
    <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Verbs::for_subject</span><span class="plain">(</span><span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain">) {</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">PF_S</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">)-</span><span class="element">&gt;understand_as_this_object</span><span class="plain"> != </span><span class="identifier">NULL</span><span class="plain">)</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">PF_S</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">)-</span><span class="element">&gt;understand_as_this_object</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::gv_new</span><span class="plain">(</span><span class="constant">GV_IS_OBJECT</span><span class="plain">);</span>
        <span class="identifier">PF_S</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">)-</span><span class="element">&gt;understand_as_this_object</span><span class="plain"> = </span><span class="identifier">gv</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;subj_understood</span><span class="plain"> = </span><span class="identifier">subj</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">gv</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::take_out_one_word_grammar</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> != </span><span class="constant">GV_IS_OBJECT</span><span class="plain">)</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"One-word optimisation applies only to objects"</span><span class="plain">);</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Lines::list_take_out_one_word_grammar</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::allow_mixed_lines</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_OBJECT</span><span class="plain">) || (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_VALUE</span><span class="plain">))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::for_subject is used in 5/tfg (<a href="5-tfg.html#SP21">&#167;21</a>).</p>

<p class="endnote">The function PL::Parsing::Verbs::take_out_one_word_grammar is used in 5/gp (<a href="5-gp.html#SP10_1">&#167;10.1</a>).</p>

<p class="endnote">The function PL::Parsing::Verbs::allow_mixed_lines is used in 5/gl (<a href="5-gl.html#SP14">&#167;14</a>).</p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18. Data type parsing grammars. </b>Each kind can optionally have a GV, used to parse unusual forms of
its literals. The following routine finds or creates this.
</p>


<pre class="display">
    <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Verbs::for_kind</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">PL::Parsing::Verbs::get_parsing_grammar</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">) != </span><span class="identifier">NULL</span><span class="plain">)</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::get_parsing_grammar</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
        <span class="identifier">gv</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::gv_new</span><span class="plain">(</span><span class="constant">GV_IS_VALUE</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Verbs::set_parsing_grammar</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">);</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;kind_understood</span><span class="plain"> = </span><span class="identifier">K</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">gv</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::for_kind is used in 5/tfg (<a href="5-tfg.html#SP21">&#167;21</a>).</p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19. Property name parsing grammars. </b>Only either/or properties can have a GV, used to parse unusual forms of
the alternatives as used when properties are describing objects. The
following routine finds or creates this for a given property.
</p>


<pre class="display">
    <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Verbs::for_prn</span><span class="plain">(</span><span class="identifier">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Properties::EitherOr::get_parsing_grammar</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">) != </span><span class="identifier">NULL</span><span class="plain">)</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">Properties::EitherOr::get_parsing_grammar</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">);</span>
        <span class="identifier">gv</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::gv_new</span><span class="plain">(</span><span class="constant">GV_IS_PROPERTY_NAME</span><span class="plain">);</span>
        <span class="identifier">Properties::EitherOr::set_parsing_grammar</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">);</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;prn_understood</span><span class="plain"> = </span><span class="identifier">prn</span><span class="plain">;</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_prn_iname</span><span class="plain"> = </span><span class="identifier">Hierarchy::make_iname_in</span><span class="plain">(</span><span class="identifier">EITHER_OR_GPR_FN_HL</span><span class="plain">, </span><span class="identifier">Properties::package</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">gv</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::for_prn is used in 5/tfg (<a href="5-tfg.html#SP21">&#167;21</a>).</p>

<p class="inwebparagraph"><a id="SP20"></a><b>&#167;20. The list of grammar lines. </b>Every GV has a list of GLs: indeed, this list is really the grammar. Here
we test this for emptiness, and provide for adding to it. Removals are not
possible.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::is_empty</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">gv</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::add_line</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">grammar_line</span><span class="plain"> *</span><span class="identifier">gl</span><span class="plain">) {</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR</span><span class="plain">, </span><span class="string">"Adding grammar line $g to verb $G\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">gl</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_COMMAND</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="functiontext">PL::Parsing::Lines::list_length</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain">) &gt;= </span><span class="constant">MAX_LINES_PER_COMMAND</span><span class="plain">)) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_TooManyGrammarLines</span><span class="plain">),</span>
                <span class="string">"this command verb now has too many Understand possibilities"</span><span class="plain">,</span>
                <span class="string">"that is, there are too many 'Understand \</span><span class="plain">"</span><span class="string">whatever ...\</span><span class="plain">"</span><span class="string"> as ...' "</span>
                <span class="string">"which share the same initial word 'whatever'. The best way to "</span>
                <span class="string">"get around this is to try to consolidate some of those lines "</span>
                <span class="string">"together, perhaps by using slashes to combine alternative "</span>
                <span class="string">"wordings, or by defining new grammar tokens [in square brackets]."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Lines::list_add</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain">, </span><span class="identifier">gl</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::is_empty is used in 5/tfg (<a href="5-tfg.html#SP16_2_1">&#167;16.2.1</a>), 5/gpr (<a href="5-gpr.html#SP5">&#167;5</a>).</p>

<p class="endnote">The function PL::Parsing::Verbs::add_line is used in 5/tfg (<a href="5-tfg.html#SP21">&#167;21</a>).</p>

<p class="inwebparagraph"><a id="SP21"></a><b>&#167;21.  </b>Each GV has the potential to carry a kind made up of the number of
values produced, and what their types are. This is only really meaningful
for the GVs trying to express a single value: the following routine returns
<code class="display"><span class="extract">UNKNOWN_NT</span></code> unless that's the case.
</p>


<pre class="display">
    <span class="identifier">kind</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Verbs::get_data_type_as_token</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::Types::get_data_type_as_token</span><span class="plain">(&amp;(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_type</span><span class="plain">));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::get_data_type_as_token is used in 5/gt2 (<a href="5-gt2.html#SP12">&#167;12</a>).</p>

<p class="inwebparagraph"><a id="SP22"></a><b>&#167;22.  </b>Some tokens require suitable I6 routines to have already been compiled,
if they are to work nicely: the following routine goes through the tokens
by exploring each GV in turn.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::compile_conditions</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain">)	{</span>
            <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;where_gv_created</span><span class="plain">;</span>
            <span class="functiontext">PL::Parsing::Lines::line_list_compile_condition_tokens</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::compile_conditions appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP23"></a><b>&#167;23. Grammar Preparation. </b>This simply causes Phases I and II of grammar processing to take place, one
after the other.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::prepare</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="functiontext">PL::Parsing::Verbs::gv_slash_all</span><span class="plain">();</span>
        <span class="functiontext">PL::Parsing::Verbs::gv_determine_all</span><span class="plain">();</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::prepare appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP24"></a><b>&#167;24. Phase I: Slash Grammar. </b>Slashing is really a grammar-line based activity, so we do no more than
pass the buck down to the list of grammar lines.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::gv_slash_all</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">;</span>
        <span class="identifier">Log::new_stage</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"Slashing grammar (G1)"</span><span class="plain">);</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;slashed</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR_CONSTRUCTION</span><span class="plain">, </span><span class="string">"Slashing $G\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">);</span>
                <span class="functiontext">PL::Parsing::Lines::line_list_slash</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain">);</span>
                <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;slashed</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::gv_slash_all is used in <a href="#SP23">&#167;23</a>, <a href="#SP26">&#167;26</a>.</p>

<p class="inwebparagraph"><a id="SP25"></a><b>&#167;25. Phase II: Determining Grammar. </b>Again, at this top level we are really only calling downwards.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::gv_determine_all</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">;</span>
        <span class="identifier">Log::new_stage</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"Determining grammar (G2)"</span><span class="plain">);</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;determined</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain">)) {</span>
                <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;where_gv_created</span><span class="plain">;</span>
                <span class="functiontext">PL::Parsing::Verbs::determine</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, 0);</span>
                <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;determined</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Verbs::determine</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">depth</span><span class="plain">) {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec_union</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;where_gv_created</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">PL::Parsing::Tokens::Types::has_return_type</span><span class="plain">(&amp;(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_type</span><span class="plain">)))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Tokens::Types::get_single_type</span><span class="plain">(&amp;(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_type</span><span class="plain">));</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">depth</span><span class="plain"> &gt; </span><span class="identifier">NUMBER_CREATED</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain">)) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_GrammarIllFounded</span><span class="plain">),</span>
                <span class="string">"grammar tokens are not allowed to be defined in terms of "</span>
                <span class="string">"themselves"</span><span class="plain">,</span>
                <span class="string">"either directly or indirectly."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="plain">}</span>

        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR_CONSTRUCTION</span><span class="plain">, </span><span class="string">"Determining $G\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">);</span>

        <span class="identifier">spec_union</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Lines::line_list_determine</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain">, </span><span class="identifier">depth</span><span class="plain">,</span>
            <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">, </span><span class="functiontext">PL::Parsing::Verbs::gv_is_genuinely_verbal</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">));</span>

        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR_CONSTRUCTION</span><span class="plain">, </span><span class="string">"Result of verb $G is $P\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">, </span><span class="identifier">spec_union</span><span class="plain">);</span>

        <span class="functiontext">PL::Parsing::Tokens::Types::set_single_type</span><span class="plain">(&amp;(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_type</span><span class="plain">), </span><span class="identifier">spec_union</span><span class="plain">);</span>

        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">spec_union</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::gv_determine_all is used in <a href="#SP23">&#167;23</a>, <a href="#SP26">&#167;26</a>.</p>

<p class="endnote">The function PL::Parsing::Verbs::determine is used in 5/gt2 (<a href="5-gt2.html#SP11_1">&#167;11.1</a>).</p>

<p class="inwebparagraph"><a id="SP26"></a><b>&#167;26. Phases III and IV: Sort and Compile Grammar. </b>At this highest level phases III and IV are intermingled, in that Phase III
always precedes Phase IV for any given list of grammar lines, but each GV
goes through both Phase III and IV before the next begins Phase III. So it
would not be appropriate to print banners like "Phase III begins here"
in the debugging log.
</p>

<p class="inwebparagraph">Finally, though, some substantive work to do: because it is the GV which
records the purpose of the grammar in question, we must compile a suitable
I6 context for the grammar to appear within.
</p>

<p class="inwebparagraph">Four of the five kinds of GV are compiled by the routine below: the fifth
kind is compiled in "Tokens Parsing Values", in response to different
<code class="display"><span class="extract">.i6t</span></code> commands, because the token routines are needed at a different position
in the final I6 output.
</p>

<p class="inwebparagraph">Sequence is important here: in particular the GPRs must exist before the
<code class="display"><span class="extract">Verb</span></code> directives, because otherwise I6 will throw not-declared-yet errors.
</p>


<pre class="display">
    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">VERB_DIRECTIVE_REVERSE_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">VERB_DIRECTIVE_SLASH_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">VERB_DIRECTIVE_DIVIDER_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">VERB_DIRECTIVE_RESULT_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">VERB_DIRECTIVE_SPECIAL_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">VERB_DIRECTIVE_NUMBER_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">VERB_DIRECTIVE_NOUN_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">VERB_DIRECTIVE_MULTI_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">VERB_DIRECTIVE_MULTIINSIDE_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">VERB_DIRECTIVE_MULTIHELD_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">VERB_DIRECTIVE_HELD_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">VERB_DIRECTIVE_CREATURE_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">VERB_DIRECTIVE_TOPIC_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">VERB_DIRECTIVE_MULTIEXCEPT_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>

    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Verbs::grammar_constant</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">N</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">V</span><span class="plain">) {</span>
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">N</span><span class="plain">);</span>
        <span class="identifier">Emit::named_numeric_constant</span><span class="plain">(</span><span class="identifier">iname</span><span class="plain">, 1);</span>
        <span class="identifier">Hierarchy::make_available</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">iname</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">iname</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::compile_all</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">;</span>
        <span class="functiontext">PL::Parsing::Verbs::gv_slash_all</span><span class="plain">();</span>
        <span class="functiontext">PL::Parsing::Verbs::gv_determine_all</span><span class="plain">();</span>

        <span class="identifier">Log::new_stage</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"Sorting and compiling non-value grammar (G3, G4)"</span><span class="plain">);</span>

        <span class="identifier">VERB_DIRECTIVE_REVERSE_iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::grammar_constant</span><span class="plain">(</span><span class="identifier">VERB_DIRECTIVE_REVERSE_HL</span><span class="plain">, 1);</span>
        <span class="identifier">VERB_DIRECTIVE_SLASH_iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::grammar_constant</span><span class="plain">(</span><span class="identifier">VERB_DIRECTIVE_SLASH_HL</span><span class="plain">, 1);</span>
        <span class="identifier">VERB_DIRECTIVE_DIVIDER_iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::grammar_constant</span><span class="plain">(</span><span class="identifier">VERB_DIRECTIVE_DIVIDER_HL</span><span class="plain">, 1);</span>
        <span class="identifier">VERB_DIRECTIVE_RESULT_iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::grammar_constant</span><span class="plain">(</span><span class="identifier">VERB_DIRECTIVE_RESULT_HL</span><span class="plain">, 2);</span>
        <span class="identifier">VERB_DIRECTIVE_SPECIAL_iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::grammar_constant</span><span class="plain">(</span><span class="identifier">VERB_DIRECTIVE_SPECIAL_HL</span><span class="plain">, 3);</span>
        <span class="identifier">VERB_DIRECTIVE_NUMBER_iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::grammar_constant</span><span class="plain">(</span><span class="identifier">VERB_DIRECTIVE_NUMBER_HL</span><span class="plain">, 4);</span>
        <span class="identifier">VERB_DIRECTIVE_NOUN_iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::grammar_constant</span><span class="plain">(</span><span class="identifier">VERB_DIRECTIVE_NOUN_HL</span><span class="plain">, 5);</span>
        <span class="identifier">VERB_DIRECTIVE_MULTI_iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::grammar_constant</span><span class="plain">(</span><span class="identifier">VERB_DIRECTIVE_MULTI_HL</span><span class="plain">, 6);</span>
        <span class="identifier">VERB_DIRECTIVE_MULTIINSIDE_iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::grammar_constant</span><span class="plain">(</span><span class="identifier">VERB_DIRECTIVE_MULTIINSIDE_HL</span><span class="plain">, 7);</span>
        <span class="identifier">VERB_DIRECTIVE_MULTIHELD_iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::grammar_constant</span><span class="plain">(</span><span class="identifier">VERB_DIRECTIVE_MULTIHELD_HL</span><span class="plain">, 8);</span>
        <span class="identifier">VERB_DIRECTIVE_HELD_iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::grammar_constant</span><span class="plain">(</span><span class="identifier">VERB_DIRECTIVE_HELD_HL</span><span class="plain">, 9);</span>
        <span class="identifier">VERB_DIRECTIVE_CREATURE_iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::grammar_constant</span><span class="plain">(</span><span class="identifier">VERB_DIRECTIVE_CREATURE_HL</span><span class="plain">, 10);</span>
        <span class="identifier">VERB_DIRECTIVE_TOPIC_iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::grammar_constant</span><span class="plain">(</span><span class="identifier">VERB_DIRECTIVE_TOPIC_HL</span><span class="plain">, 11);</span>
        <span class="identifier">VERB_DIRECTIVE_MULTIEXCEPT_iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Verbs::grammar_constant</span><span class="plain">(</span><span class="identifier">VERB_DIRECTIVE_MULTIEXCEPT_HL</span><span class="plain">, 12);</span>

        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_TOKEN</span><span class="plain">)</span>
                <span class="functiontext">PL::Parsing::Verbs::compile</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">); </span>    <span class="comment">makes GPRs for designed tokens</span>

        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_COMMAND</span><span class="plain">)</span>
                <span class="functiontext">PL::Parsing::Verbs::compile</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">); </span>    <span class="comment">makes <code class="display"><span class="extract">Verb</span></code> directives</span>

        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_OBJECT</span><span class="plain">)</span>
                <span class="functiontext">PL::Parsing::Verbs::compile</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">); </span>    <span class="comment">makes routines for use in <code class="display"><span class="extract">parse_name</span></code></span>

        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_CONSULT</span><span class="plain">)</span>
                <span class="functiontext">PL::Parsing::Verbs::compile</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">); </span>    <span class="comment">routines to parse snippets, used as values</span>

        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> == </span><span class="constant">GV_IS_PROPERTY_NAME</span><span class="plain">)</span>
                <span class="functiontext">PL::Parsing::Verbs::compile</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">); </span>    <span class="comment">makes routines for use in <code class="display"><span class="extract">parse_name</span></code></span>

        <span class="functiontext">PL::Parsing::Lines::compile_slash_gprs</span><span class="plain">();</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::grammar_constant appears nowhere else.</p>

<p class="endnote">The function PL::Parsing::Verbs::compile_all appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP27"></a><b>&#167;27.  </b>The following routine unites, so far as possible, the different forms of
GV by compiling each of them as a sandwich: top slice, filling, bottom slice.
The interesting case is of a GV representing names for an object: the
name-behaviour needs to be inherited from the object's kind, and so on up
the kinds hierarchy, but this is a case where I7's kind hierarchy does not
agree with I6's class hierarchy. I6 has no (nice) way to inherit <code class="display"><span class="extract">parse_name</span></code>
behaviour from a class to an instance. So we will simply pile up extra
fillings into the sandwich. The order of these is important: by getting
in first, grammar for the instance takes priority; its immediate kind has
next priority, and so on up the hierarchy.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::compile</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>

        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR</span><span class="plain">, </span><span class="string">"Compiling grammar verb $G\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">);</span>

        <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;where_gv_created</span><span class="plain">;</span>

        <span class="functiontext">PL::Parsing::Lines::reset_labels</span><span class="plain">();</span>
        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_COMMAND</span><span class="plain">: {</span>
                <span class="identifier">package_request</span><span class="plain"> *</span><span class="identifier">PR</span><span class="plain"> = </span><span class="identifier">Hierarchy::synoptic_package</span><span class="plain">(</span><span class="identifier">COMMANDS_HAP</span><span class="plain">);</span>
                <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">array_iname</span><span class="plain"> = </span><span class="identifier">Hierarchy::make_iname_in</span><span class="plain">(</span><span class="identifier">VERB_DECLARATION_ARRAY_HL</span><span class="plain">, </span><span class="identifier">PR</span><span class="plain">);</span>
                <span class="identifier">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> =</span>
                    <span class="functiontext">PL::Parsing::Verbs::gv_compile_Verb_directive_header</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">, </span><span class="identifier">array_iname</span><span class="plain">);</span>
                <span class="functiontext">PL::Parsing::Verbs::gv_compile_lines</span><span class="plain">(</span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">);</span>
                <span class="identifier">Emit::array_end</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_TOKEN</span><span class="plain">: {</span>
                <span class="reserved">gpr_kit</span><span class="plain"> </span><span class="identifier">gprk</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Tokens::Values::new_kit</span><span class="plain">();</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_line_iname</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"gv token not ready"</span><span class="plain">);</span>
                <span class="identifier">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="identifier">Routines::begin</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_line_iname</span><span class="plain">);</span>
                <span class="functiontext">PL::Parsing::Tokens::Values::add_original</span><span class="plain">(&amp;</span><span class="identifier">gprk</span><span class="plain">);</span>
                <span class="functiontext">PL::Parsing::Tokens::Values::add_standard_set</span><span class="plain">(&amp;</span><span class="identifier">gprk</span><span class="plain">);</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="element">.original_wn_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="element">.rv_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_PREPOSITION_HL</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                <span class="functiontext">PL::Parsing::Verbs::gv_compile_lines</span><span class="plain">(&amp;</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">);</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">RETURN_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_FAIL_HL</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Routines::end</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_CONSULT</span><span class="plain">: {</span>
                <span class="reserved">gpr_kit</span><span class="plain"> </span><span class="identifier">gprk</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Tokens::Values::new_kit</span><span class="plain">();</span>
                <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Tokens::General::consult_iname</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">);</span>
                <span class="identifier">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="identifier">Routines::begin</span><span class="plain">(</span><span class="identifier">iname</span><span class="plain">);</span>
                <span class="functiontext">PL::Parsing::Tokens::Values::add_range_calls</span><span class="plain">(&amp;</span><span class="identifier">gprk</span><span class="plain">);</span>
                <span class="functiontext">PL::Parsing::Tokens::Values::add_original</span><span class="plain">(&amp;</span><span class="identifier">gprk</span><span class="plain">);</span>
                <span class="functiontext">PL::Parsing::Tokens::Values::add_standard_set</span><span class="plain">(&amp;</span><span class="identifier">gprk</span><span class="plain">);</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="element">.range_from_s</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="element">.original_wn_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="element">.rv_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_PREPOSITION_HL</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                <span class="functiontext">PL::Parsing::Verbs::gv_compile_lines</span><span class="plain">(&amp;</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">);</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">RETURN_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_FAIL_HL</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Routines::end</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_OBJECT</span><span class="plain">: {</span>
                <span class="reserved">gpr_kit</span><span class="plain"> </span><span class="identifier">gprk</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Tokens::Values::new_kit</span><span class="plain">();</span>
                <span class="identifier">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="identifier">Emit::unused_packaging_state</span><span class="plain">();</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">PL::Parsing::Tokens::General::compile_parse_name_head</span><span class="plain">(&amp;</span><span class="identifier">save</span><span class="plain">, &amp;</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;subj_understood</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">)) {</span>
                    <span class="functiontext">PL::Parsing::Verbs::gv_compile_parse_name_lines</span><span class="plain">(&amp;</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">);</span>
                    <span class="functiontext">PL::Parsing::Tokens::General::compile_parse_name_tail</span><span class="plain">(&amp;</span><span class="identifier">gprk</span><span class="plain">);</span>
                    <span class="identifier">Routines::end</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_VALUE</span><span class="plain">:</span>
                <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"iv"</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">GV_IS_PROPERTY_NAME</span><span class="plain">: {</span>
                <span class="reserved">gpr_kit</span><span class="plain"> </span><span class="identifier">gprk</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Tokens::Values::new_kit</span><span class="plain">();</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_prn_iname</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"PRN PN not ready"</span><span class="plain">);</span>
                <span class="identifier">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="identifier">Routines::begin</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_prn_iname</span><span class="plain">);</span>
                <span class="functiontext">PL::Parsing::Tokens::Values::add_original</span><span class="plain">(&amp;</span><span class="identifier">gprk</span><span class="plain">);</span>
                <span class="functiontext">PL::Parsing::Tokens::Values::add_standard_set</span><span class="plain">(&amp;</span><span class="identifier">gprk</span><span class="plain">);</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="element">.original_wn_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">WN_HL</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="element">.rv_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_PREPOSITION_HL</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                <span class="functiontext">PL::Parsing::Verbs::gv_compile_lines</span><span class="plain">(&amp;</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">);</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">RETURN_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Hierarchy::find</span><span class="plain">(</span><span class="identifier">GPR_FAIL_HL</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Routines::end</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::compile_iv</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR</span><span class="plain">, </span><span class="string">"Compiling grammar verb $G\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">);</span>
        <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;where_gv_created</span><span class="plain">;</span>
        <span class="functiontext">PL::Parsing::Lines::reset_labels</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain"> != </span><span class="constant">GV_IS_VALUE</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"not iv"</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Verbs::gv_compile_lines</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::compile is used in <a href="#SP26">&#167;26</a>.</p>

<p class="endnote">The function PL::Parsing::Verbs::compile_iv is used in 5/tpv (<a href="5-tpv.html#SP1">&#167;1</a>, <a href="5-tpv.html#SP1_1">&#167;1.1</a>).</p>

<p class="inwebparagraph"><a id="SP28"></a><b>&#167;28.  </b>The special thing about <code class="display"><span class="extract">GV_IS_OBJECT</span></code> grammars is that each is attached
to an inference subject, and when we compile them we recurse up the subject
hierarchy: thus if the red ball is of kind ball which is of kind thing,
then the <code class="display"><span class="extract">parse_name</span></code> for the red ball consists of grammar lines specified
for the red ball, then those specified for all balls, and lastly those
specified for all things. (This mimics I6 class-to-instance inheritance.)
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::gv_compile_parse_name_lines</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain"> = </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;subj_understood</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">PF_S</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">)-</span><span class="element">&gt;understand_as_this_object</span><span class="plain"> != </span><span class="identifier">gv</span><span class="plain">)</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"link between subject and GV broken"</span><span class="plain">);</span>

        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR</span><span class="plain">, </span><span class="string">"Parse_name content for $j:\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">);</span>
        <span class="functiontext">PL::Parsing::Verbs::gv_compile_lines</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">PF_S</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">)-</span><span class="element">&gt;understand_as_this_object</span><span class="plain">);</span>

        <span class="identifier">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">infs</span><span class="plain"> = </span><span class="identifier">InferenceSubjects::narrowest_broader_subject</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">);</span>
            <span class="identifier">infs</span><span class="plain">; </span><span class="identifier">infs</span><span class="plain"> = </span><span class="identifier">InferenceSubjects::narrowest_broader_subject</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">PF_S</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">infs</span><span class="plain">))</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">PF_S</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">infs</span><span class="plain">)-</span><span class="element">&gt;understand_as_this_object</span><span class="plain">) {</span>
                    <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">GRAMMAR</span><span class="plain">, </span><span class="string">"And parse_name content inherited from $j:\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">infs</span><span class="plain">);</span>
                    <span class="functiontext">PL::Parsing::Verbs::gv_compile_lines</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">PF_S</span><span class="plain">(</span><span class="identifier">parsing</span><span class="plain">, </span><span class="identifier">infs</span><span class="plain">)-</span><span class="element">&gt;understand_as_this_object</span><span class="plain">);</span>
                <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::gv_compile_parse_name_lines is used in <a href="#SP27">&#167;27</a>.</p>

<p class="inwebparagraph"><a id="SP29"></a><b>&#167;29.  </b>All other grammars are compiled just as they are:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::gv_compile_lines</span><span class="plain">(</span><span class="reserved">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="functiontext">PL::Parsing::Lines::list_assert_ownership</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">); </span>    <span class="comment">Mark for later indexing</span>
        <span class="functiontext">PL::Parsing::Verbs::sort_grammar_verb</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">); </span>    <span class="comment">Phase III for the GLs in the GV happens here</span>
        <span class="functiontext">PL::Parsing::Lines::sorted_line_list_compile</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;sorted_first_line</span><span class="plain">,</span>
            <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;gv_is</span><span class="plain">, </span><span class="identifier">gv</span><span class="plain">, </span><span class="functiontext">PL::Parsing::Verbs::gv_is_genuinely_verbal</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">)); </span>    <span class="comment">And Phase IV here</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::gv_compile_lines is used in <a href="#SP27">&#167;27</a>, <a href="#SP28">&#167;28</a>.</p>

<p class="inwebparagraph"><a id="SP30"></a><b>&#167;30.  </b>All of that was really Phase IV work (compiling), but a very little Phase
III business also happens at this top level. Note that some grammars are
compiled more than once (if a red ball and a blue ball are both of kind
ball, then compiling grammars for them will also involve compiling grammars
for the ball in each case: see above), so the following routine may well be
called more than once for the same GV. We only want to sort once, though, so:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::sort_grammar_verb</span><span class="plain">(</span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;sorted_first_line</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)</span>
            <span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;sorted_first_line</span><span class="plain"> = </span><span class="functiontext">PL::Parsing::Lines::list_sort</span><span class="plain">(</span><span class="identifier">gv</span><span class="plain">-</span><span class="element">&gt;first_line</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::sort_grammar_verb is used in <a href="#SP29">&#167;29</a>.</p>

<p class="inwebparagraph"><a id="SP31"></a><b>&#167;31. Kinds as GVs. </b>If the user writes lines in the source text such as
</p>

<blockquote>
    <p>Understand "eleventy-one" as 111.</p>

</blockquote>

<p class="inwebparagraph">then grammar lines will have to be attached to a kind; in fact, a kind can
have its own <code class="display"><span class="extract">grammar_verb</span></code> structure attached, which holds a sequence of
such grammar lines. (These are possibilities in addition to those provided
by any GPR existing because of the above routines.)
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">PL::Parsing::Verbs::set_parsing_grammar</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">, </span><span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"wrong way to handle object grammar"</span><span class="plain">);</span>
        <span class="identifier">K</span><span class="plain">-&gt;</span><span class="identifier">construct</span><span class="plain">-&gt;</span><span class="identifier">understand_as_values</span><span class="plain"> = </span><span class="identifier">gv</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">grammar_verb</span><span class="plain"> *</span><span class="functiontext">PL::Parsing::Verbs::get_parsing_grammar</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"wrong way to handle object grammar"</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">K</span><span class="plain">-&gt;</span><span class="identifier">construct</span><span class="plain">-&gt;</span><span class="identifier">understand_as_values</span><span class="plain">;</span>
    <span class="plain">}</span>

</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function PL::Parsing::Verbs::set_parsing_grammar is used in <a href="#SP18">&#167;18</a>.</p>

<p class="endnote">The function PL::Parsing::Verbs::get_parsing_grammar is used in <a href="#SP18">&#167;18</a>, 5/tpv (<a href="5-tpv.html#SP1">&#167;1</a>, <a href="5-tpv.html#SP1_1">&#167;1.1</a>).</p>

<hr class="tocbar">
<ul class="toc"><li><a href="5-gp.html">Back to 'Grammar Properties'</a></li><li><a href="5-gl.html">Continue with 'Grammar Lines'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

