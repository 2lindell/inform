<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>2/dr</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '2/li' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">index</a></li><li><a href="index.html#2">Chapter 2: Indexing</a></li><li><b>Lexicon Index</b></li></ul><p class="purpose">To construct the Lexicon portion of the Phrasebook page of the Index, which gives brief definitions and references for nouns, adjectives and verbs used in source text for the current project.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP8">&#167;8. Producing the lexicon</a></li><li><a href="#SP8_2">&#167;8.2. Stocking the lexicon</a></li><li><a href="#SP8_8">&#167;8.8. Processing the lexicon</a></li><li><a href="#SP8_10">&#167;8.10. Printing the lexicon out in HTML format</a></li><li><a href="#SP9">&#167;9. The table of verbs</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>The lexicon is the part of the Index which gives an alphabetised list of
adjectives, nouns, verbs and other words which can be used in descriptions
of things: it's the nearest thing to an index of the meanings inside NI.
This is in one sense quite an elaborate indexing mechanism, since it brings
together meanings relating to various different NI structures under a single
umbrella, the "lexicon entry" structure:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">NOUN_LEXE</span><span class="plain"> 1 </span>    <span class="comment">a kind</span>
    <span class="definitionkeyword">define</span> <span class="constant">PROPER_NOUN_LEXE</span><span class="plain"> 2 </span>    <span class="comment">an instance of "object"</span>
    <span class="definitionkeyword">define</span> <span class="constant">ADJECTIVAL_PHRASE_LEXE</span><span class="plain"> 3 </span>    <span class="comment">the subject of a "Definition:"</span>
    <span class="definitionkeyword">define</span> <span class="constant">ENUMERATED_CONSTANT_LEXE</span><span class="plain"> 4 </span>    <span class="comment">e.g., "green" if colour is a kind of value and green a colour</span>
    <span class="definitionkeyword">define</span> <span class="constant">VERB_LEXE</span><span class="plain"> 5 </span>    <span class="comment">an ordinary verb</span>
    <span class="definitionkeyword">define</span> <span class="constant">ABLE_VERB_LEXE</span><span class="plain"> 6 </span>    <span class="comment">a "to be able to..." verb</span>
    <span class="definitionkeyword">define</span> <span class="constant">PREP_LEXE</span><span class="plain"> 7 </span>    <span class="comment">a "to be upon..." sort of verb</span>
    <span class="definitionkeyword">define</span> <span class="constant">AVERB_LEXE</span><span class="plain"> 8 </span>    <span class="comment">an auxiliary verb</span>
    <span class="definitionkeyword">define</span> <span class="constant">MVERB_LEXE</span><span class="plain"> 9 </span>    <span class="comment">a meaningless verb</span>
    <span class="definitionkeyword">define</span> <span class="constant">MISCELLANEOUS_LEXE</span><span class="plain"> 10 </span>    <span class="comment">a connective, article or determiner</span>
</pre>
<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>We can set entries either to excerpts of words from the source, or to
any collation of up to 5 vocabulary entries.
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">lexicon_entry</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">wording_of_entry</span><span class="plain">; </span>    <span class="comment">either the text of the entry, or empty, in which case...</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">word_assemblage</span><span class="plain"> </span><span class="identifier">text_of_entry</span><span class="plain">;</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">part_of_speech</span><span class="plain">; </span>    <span class="comment">one of those above</span>
        <span class="reserved">char</span><span class="plain"> *</span><span class="identifier">category</span><span class="plain">; </span>    <span class="comment">textual description of said, e.g., <code class="display"><span class="extract">"adjective"</span></code></span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">general_pointer</span><span class="plain"> </span><span class="identifier">entry_refers_to</span><span class="plain">; </span>    <span class="comment">depending on which part of speech</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">verb_defined_at</span><span class="plain">; </span>    <span class="comment">sentence where defined (verbs only)</span>
        <span class="reserved">char</span><span class="plain"> *</span><span class="identifier">gloss_note</span><span class="plain">; </span>    <span class="comment">gloss on the definition, or <code class="display"><span class="extract">NULL</span></code> if none is provided</span>

        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">reduced_to_lower_case</span><span class="plain">; </span>    <span class="comment">text converted to lower case for sorting</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">sorted_next</span><span class="plain">; </span>    <span class="comment">next in lexicographic order</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">lexicon_entry</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure lexicon_entry is private to this section.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b></p>


<pre class="display">
    <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">sorted_lexicon</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">head of list in lexicographic order</span>
    <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">current_main_verb</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">when parsing verb declarations</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>Lexicon entries are created by the following routine:
</p>


<pre class="display">
    <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="functiontext">Index::Lexicon::lexicon_new_entry</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">lex</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">lexicon_entry</span><span class="plain">);</span>
        <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;wording_of_entry</span><span class="plain"> = </span><span class="identifier">W</span><span class="plain">;</span>
        <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;text_of_entry</span><span class="plain"> = </span><span class="identifier">WordAssemblages::lit_0</span><span class="plain">();</span>
        <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> = </span><span class="constant">MISCELLANEOUS_LEXE</span><span class="plain">;</span>
        <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;entry_refers_to</span><span class="plain"> = </span><span class="identifier">NULL_GENERAL_POINTER</span><span class="plain">;</span>
        <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;gloss_note</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;verb_defined_at</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;reduced_to_lower_case</span><span class="plain"> = </span><span class="identifier">Str::new</span><span class="plain">();</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">lex</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Index::Lexicon::lexicon_new_entry is used in <a href="#SP6">&#167;6</a>, <a href="#SP8_2">&#167;8.2</a>, <a href="#SP8_3">&#167;8.3</a>, <a href="#SP8_4">&#167;8.4</a>, <a href="#SP8_5">&#167;8.5</a>.</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>The next two routines provide higher-level creators for lexicon entries.
The <code class="display"><span class="extract">current_main_verb</span></code> setting is used to ensure that inflected forms of the
same verb are grouped together in the verbs table.
</p>


<pre class="display">
    <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="functiontext">Index::Lexicon::new_entry_with_details</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">pos</span><span class="plain">,</span>
        <span class="identifier">word_assemblage</span><span class="plain"> </span><span class="identifier">wa</span><span class="plain">, </span><span class="reserved">char</span><span class="plain"> *</span><span class="identifier">category</span><span class="plain">, </span><span class="reserved">char</span><span class="plain"> *</span><span class="identifier">gloss</span><span class="plain">) {</span>
        <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">lex</span><span class="plain"> = </span><span class="functiontext">Index::Lexicon::lexicon_new_entry</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> = </span><span class="identifier">pos</span><span class="plain">;</span>
        <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;text_of_entry</span><span class="plain"> = </span><span class="identifier">wa</span><span class="plain">;</span>
        <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="identifier">category</span><span class="plain">; </span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;gloss_note</span><span class="plain"> = </span><span class="identifier">gloss</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">lex</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="functiontext">Index::Lexicon::new_main_verb</span><span class="plain">(</span><span class="identifier">word_assemblage</span><span class="plain"> </span><span class="identifier">infinitive</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">part</span><span class="plain">) {</span>
        <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">lex</span><span class="plain"> = </span><span class="functiontext">Index::Lexicon::lexicon_new_entry</span><span class="plain">(</span><span class="identifier">EMPTY_WORDING</span><span class="plain">);</span>
        <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;text_of_entry</span><span class="plain"> = </span><span class="identifier">infinitive</span><span class="plain">;</span>
        <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> = </span><span class="identifier">part</span><span class="plain">;</span>
        <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="string">"verb"</span><span class="plain">;</span>
        <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;verb_defined_at</span><span class="plain"> = </span><span class="identifier">current_sentence</span><span class="plain">;</span>
        <span class="identifier">current_main_verb</span><span class="plain"> = </span><span class="identifier">lex</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">lex</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Index::Lexicon::new_entry_with_details appears nowhere else.</p>

<p class="endnote">The function Index::Lexicon::new_main_verb is used in <a href="#SP8_6">&#167;8.6</a>.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>As we've seen, a lexicon entry's text can be either a word range or a
collection of vocabulary words, and it's therefore convenient to have a utility
routine which extracts the name in plain text from either source.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Index::Lexicon::lexicon_copy_to_stream</span><span class="plain">(</span><span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">lex</span><span class="plain">, </span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">text</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;wording_of_entry</span><span class="plain">))</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">text</span><span class="plain">, </span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;wording_of_entry</span><span class="plain">);</span>
        <span class="reserved">else</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">text</span><span class="plain">, </span><span class="string">"%A"</span><span class="plain">, &amp;(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;text_of_entry</span><span class="plain">));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Index::Lexicon::lexicon_copy_to_stream is used in <a href="#SP8_8">&#167;8.8</a>, <a href="#SP8_11_1">&#167;8.11.1</a>, <a href="#SP9">&#167;9</a>, <a href="#SP10">&#167;10</a>.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Producing the lexicon. </b>The lexicon is by no means empty when the following routine is called:
lexicon entries have already been created for verbs and determiners. But
it doesn't yet contain nouns or adjectives.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Index::Lexicon::index</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">) {</span>
        &lt;<span class="cwebmacro">Stock the lexicon with nouns from names of objects</span> <span class="cwebmacronumber">8.2</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Stock the lexicon with nouns from kinds of object</span> <span class="cwebmacronumber">8.3</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Stock the lexicon with adjectives from names of adjectival phrases</span> <span class="cwebmacronumber">8.4</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Stock the lexicon with nouns from named values</span> <span class="cwebmacronumber">8.5</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Stock the lexicon with meaningless verbs</span> <span class="cwebmacronumber">8.6</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Stock the lexicon with miscellaneous bits and pieces</span> <span class="cwebmacronumber">8.7</span>&gt;<span class="plain">;</span>

        &lt;<span class="cwebmacro">Create lower-case forms of all lexicon entries</span> <span class="cwebmacronumber">8.8</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Sort the lexicon into alphabetical order</span> <span class="cwebmacronumber">8.9</span>&gt;<span class="plain">;</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">common_nouns_only</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="functiontext">Index::anchor</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"LEXICON"</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">Explanatory head-note at the top of the lexicon</span> <span class="cwebmacronumber">8.10</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Main body of the lexicon</span> <span class="cwebmacronumber">8.11</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Index::Lexicon::index is used in 2/ifs (<a href="2-ifs.html#SP7">&#167;7</a>).</p>

<p class="inwebparagraph"><a id="SP8_1"></a><b>&#167;8.1.  </b>And here is a cut-down version which prints a lexicon of common nouns
only, for the foot of the World index.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Index::Lexicon::index_common_nouns</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">common_nouns_only</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        &lt;<span class="cwebmacro">Main body of the lexicon</span> <span class="cwebmacronumber">8.11</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Index::Lexicon::index_common_nouns is used in 2/ifs (<a href="2-ifs.html#SP7">&#167;7</a>).</p>

<p class="inwebparagraph"><a id="SP8_2"></a><b>&#167;8.2. Stocking the lexicon. </b></p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Stock the lexicon with nouns from names of objects</span> <span class="cwebmacronumber">8.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">) {</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Instances::get_name</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
                <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">lex</span><span class="plain"> = </span><span class="functiontext">Index::Lexicon::lexicon_new_entry</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
                <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> = </span><span class="constant">PROPER_NOUN_LEXE</span><span class="plain">;</span>
                <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="string">"noun"</span><span class="plain">;</span>
                <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;entry_refers_to</span><span class="plain"> = </span><span class="identifier">STORE_POINTER_instance</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP8_3"></a><b>&#167;8.3.  </b>Despite the implication of the over-cautious code below, kinds of object do
always have creation nodes &mdash; i.e., their names always derive from the
source text.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Stock the lexicon with nouns from kinds of object</span> <span class="cwebmacronumber">8.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_BASE_KINDS</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::lt</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)) {</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_name</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
                    <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">lex</span><span class="plain"> = </span><span class="functiontext">Index::Lexicon::lexicon_new_entry</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
                    <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> = </span><span class="constant">NOUN_LEXE</span><span class="plain">;</span>
                    <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="string">"noun"</span><span class="plain">;</span>
                    <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;entry_refers_to</span><span class="plain"> = </span><span class="identifier">STORE_POINTER_kind</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP8_4"></a><b>&#167;8.4.  </b>These are adjectives set up by "Definition:".
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Stock the lexicon with adjectives from names of adjectival phrases</span> <span class="cwebmacronumber">8.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">lex</span><span class="plain">;</span>
        <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">adj</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">adj</span><span class="plain">, </span><span class="identifier">adjectival_phrase</span><span class="plain">) {</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Adjectives::get_text</span><span class="plain">(</span><span class="identifier">adj</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
                <span class="identifier">lex</span><span class="plain"> = </span><span class="functiontext">Index::Lexicon::lexicon_new_entry</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
                <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> = </span><span class="constant">ADJECTIVAL_PHRASE_LEXE</span><span class="plain">;</span>
                <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="string">"adjective"</span><span class="plain">;</span>
                <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;entry_refers_to</span><span class="plain"> = </span><span class="identifier">STORE_POINTER_adjectival_phrase</span><span class="plain">(</span><span class="identifier">adj</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP8_5"></a><b>&#167;8.5.  </b>The idea here is that if a new kind of value such as "colour" is created,
then its values should be indexed as nouns &mdash; "red", "blue" and so
on. (Sometimes these will also be listed separately with an adjectival sense.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Stock the lexicon with nouns from named values</span> <span class="cwebmacronumber">8.5</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">lex</span><span class="plain">;</span>
        <span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">qn</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_ENUMERATION_INSTANCES</span><span class="plain">(</span><span class="identifier">qn</span><span class="plain">) {</span>
            <span class="identifier">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain"> =</span>
                <span class="identifier">Properties::Conditions::get_coinciding_property</span><span class="plain">(</span><span class="identifier">Instances::to_kind</span><span class="plain">(</span><span class="identifier">qn</span><span class="plain">));</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prn</span><span class="plain">) &amp;&amp; (</span><span class="identifier">Properties::Conditions::of_what</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">))) </span><span class="reserved">continue</span><span class="plain">;</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">NW</span><span class="plain"> = </span><span class="identifier">Instances::get_name</span><span class="plain">(</span><span class="identifier">qn</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="identifier">lex</span><span class="plain"> = </span><span class="functiontext">Index::Lexicon::lexicon_new_entry</span><span class="plain">(</span><span class="identifier">NW</span><span class="plain">);</span>
            <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> = </span><span class="constant">ENUMERATED_CONSTANT_LEXE</span><span class="plain">;</span>
            <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain"> = </span><span class="string">"noun"</span><span class="plain">;</span>
            <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;entry_refers_to</span><span class="plain"> = </span><span class="identifier">STORE_POINTER_instance</span><span class="plain">(</span><span class="identifier">qn</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP8_6"></a><b>&#167;8.6.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Stock the lexicon with meaningless verbs</span> <span class="cwebmacronumber">8.6</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">verb_conjugation</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">vc_conjugates</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) &amp;&amp; (</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">auxiliary_only</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">instance_of_verb</span><span class="plain">))</span>
                <span class="functiontext">Index::Lexicon::new_main_verb</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">infinitive</span><span class="plain">, </span><span class="constant">MVERB_LEXE</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP8_7"></a><b>&#167;8.7.  </b>It seems unfitting for a dictionary to omit "a", "an", "the", "some",
"which" or "who".
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Stock the lexicon with miscellaneous bits and pieces</span> <span class="cwebmacronumber">8.7</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Preform::Nonparsing::enter_lexicon</span><span class="plain">(&lt;</span><span class="identifier">indefinite</span><span class="plain">-</span><span class="identifier">article</span><span class="plain">&gt;, </span><span class="constant">MISCELLANEOUS_LEXE</span><span class="plain">,</span>
            <span class="string">"indefinite article"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="identifier">Preform::Nonparsing::enter_lexicon</span><span class="plain">(&lt;</span><span class="identifier">definite</span><span class="plain">-</span><span class="identifier">article</span><span class="plain">&gt;, </span><span class="constant">MISCELLANEOUS_LEXE</span><span class="plain">,</span>
            <span class="string">"definite article"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="identifier">Preform::Nonparsing::enter_lexicon</span><span class="plain">(&lt;</span><span class="identifier">relative</span><span class="plain">-</span><span class="identifier">clause</span><span class="plain">-</span><span class="identifier">marker</span><span class="plain">&gt;, </span><span class="constant">MISCELLANEOUS_LEXE</span><span class="plain">,</span>
            <span class="string">"connective"</span><span class="plain">,</span>
            <span class="string">"used to place a further condition on a description: like 'which' in "</span>
            <span class="string">"'A which is B', or 'A which carries B', for instance."</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP8_8"></a><b>&#167;8.8. Processing the lexicon. </b>Before we can sort the lexicon, we need to turn its disparate forms of name
into a single, canonical, lower-case representation.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Create lower-case forms of all lexicon entries</span> <span class="cwebmacronumber">8.8</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">lex</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">, </span><span class="reserved">lexicon_entry</span><span class="plain">) {</span>
            <span class="functiontext">Index::Lexicon::lexicon_copy_to_stream</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">, </span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;reduced_to_lower_case</span><span class="plain">);</span>
            <span class="identifier">LOOP_THROUGH_TEXT</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">, </span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;reduced_to_lower_case</span><span class="plain">)</span>
                <span class="identifier">Str::put</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">, </span><span class="identifier">Characters::tolower</span><span class="plain">(</span><span class="identifier">Str::get</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">)));</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP8_9"></a><b>&#167;8.9.  </b>The lexicon is sorted by insertion sort, which is not ideally fast, but
which is convenient when dealing with linked lists: there are unlikely to be
more than 1000 or so entries, so the speed penalty for insertion rather
than (say) quicksort is not great.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Sort the lexicon into alphabetical order</span> <span class="cwebmacronumber">8.9</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">lex</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">, </span><span class="reserved">lexicon_entry</span><span class="plain">) {</span>
            <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">lex2</span><span class="plain">, *</span><span class="identifier">last_lex</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sorted_lexicon</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
                <span class="identifier">sorted_lexicon</span><span class="plain"> = </span><span class="identifier">lex</span><span class="plain">; </span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;sorted_next</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="reserved">continue</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">last_lex</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">lex2</span><span class="plain"> = </span><span class="identifier">sorted_lexicon</span><span class="plain">; </span><span class="identifier">lex2</span><span class="plain">;</span>
                <span class="identifier">last_lex</span><span class="plain"> = </span><span class="identifier">lex2</span><span class="plain">, </span><span class="identifier">lex2</span><span class="plain"> = </span><span class="identifier">lex2</span><span class="plain">-</span><span class="element">&gt;sorted_next</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Str::cmp</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;reduced_to_lower_case</span><span class="plain">, </span><span class="identifier">lex2</span><span class="plain">-</span><span class="element">&gt;reduced_to_lower_case</span><span class="plain">) &lt; 0) {</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">last_lex</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">sorted_lexicon</span><span class="plain"> = </span><span class="identifier">lex</span><span class="plain">;</span>
                    <span class="reserved">else</span><span class="plain"> </span><span class="identifier">last_lex</span><span class="plain">-</span><span class="element">&gt;sorted_next</span><span class="plain"> = </span><span class="identifier">lex</span><span class="plain">;</span>
                    <span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;sorted_next</span><span class="plain"> = </span><span class="identifier">lex2</span><span class="plain">; </span><span class="reserved">goto</span><span class="plain"> </span><span class="identifier">Inserted</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="identifier">last_lex</span><span class="plain">-</span><span class="element">&gt;sorted_next</span><span class="plain"> = </span><span class="identifier">lex</span><span class="plain">; </span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;sorted_next</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="identifier">Inserted</span><span class="plain">: ;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP8_10"></a><b>&#167;8.10. Printing the lexicon out in HTML format. </b></p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Explanatory head-note at the top of the lexicon</span> <span class="cwebmacronumber">8.10</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">HTML_OPEN</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
        <span class="identifier">HTML_OPEN_WITH</span><span class="plain">(</span><span class="string">"span"</span><span class="plain">, </span><span class="string">"class=\</span><span class="plain">"</span><span class="string">smaller\</span><span class="plain">"</span><span class="string">"</span><span class="plain">);</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"For instance, the description 'an unlocked door' is made "</span>
            <span class="string">"up from the adjective 'unlocked' and the noun 'door', both of which "</span>
            <span class="string">"can be found below. Property adjectives, like 'open', can be used "</span>
            <span class="string">"when creating things - 'In the Ballroom is an open container' is "</span>
            <span class="string">"allowed because 'open' is a property - but those with complicated "</span>
            <span class="string">"definitions, like 'empty', can only be tested during play, e.g. "</span>
            <span class="string">"with rules like 'Instead of taking an empty container, ...'."</span><span class="plain">);</span>
        <span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"span"</span><span class="plain">);</span>
        <span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP8_11"></a><b>&#167;8.11.  </b>Now for the bulk of the work. Entries appear in CSS paragraphs with hanging
indentation and no interparagraph spacing, so we need to insert regular
paragraphs between the As and the Bs, then between the Bs and the Cs, and so
on. Each entry consists of the wording, then maybe some icons, then an
explanation of what it is: for instance,
</p>

<blockquote>
    <p>player's holdall [icon]\quad {\it noun, a kind of} container</p>

</blockquote>

<p class="inwebparagraph">In a few cases, there is a further textual gloss to add.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Main body of the lexicon</span> <span class="cwebmacronumber">8.11</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">lex</span><span class="plain">;</span>
        <span class="identifier">wchar_t</span><span class="plain"> </span><span class="identifier">current_initial_letter</span><span class="plain"> = </span><span class="character">'?'</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">verb_count</span><span class="plain"> = 0, </span><span class="identifier">entry_count</span><span class="plain"> = 0, </span><span class="identifier">c</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lex</span><span class="plain"> = </span><span class="identifier">sorted_lexicon</span><span class="plain">; </span><span class="identifier">lex</span><span class="plain">; </span><span class="identifier">lex</span><span class="plain"> = </span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;sorted_next</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">PROPER_NOUN_LEXE</span><span class="plain">)</span>
                <span class="identifier">entry_count</span><span class="plain">++;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">common_nouns_only</span><span class="plain">) {</span>
            <span class="identifier">HTML::begin_html_table</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, 0, 0, 0, 0, 0);</span>
            <span class="identifier">HTML::first_html_column</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, 0);</span>
        <span class="plain">}</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">c</span><span class="plain"> = 0, </span><span class="identifier">lex</span><span class="plain"> = </span><span class="identifier">sorted_lexicon</span><span class="plain">; </span><span class="identifier">lex</span><span class="plain">; </span><span class="identifier">lex</span><span class="plain"> = </span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;sorted_next</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">common_nouns_only</span><span class="plain">) { </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> != </span><span class="constant">PROPER_NOUN_LEXE</span><span class="plain">) </span><span class="reserved">continue</span><span class="plain">; }</span>
            <span class="reserved">else</span><span class="plain"> { </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">PROPER_NOUN_LEXE</span><span class="plain">) </span><span class="reserved">continue</span><span class="plain">; }</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">common_nouns_only</span><span class="plain">) &amp;&amp; (</span><span class="identifier">c</span><span class="plain"> == </span><span class="identifier">entry_count</span><span class="plain">/2)) </span><span class="identifier">HTML::next_html_column</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, 0);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">current_initial_letter</span><span class="plain"> != </span><span class="identifier">Str::get_first_char</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;reduced_to_lower_case</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">c</span><span class="plain"> &gt; 0) { </span><span class="identifier">HTML_OPEN</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">); </span><span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">); }</span>
                <span class="identifier">current_initial_letter</span><span class="plain"> = </span><span class="identifier">Str::get_first_char</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;reduced_to_lower_case</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="identifier">c</span><span class="plain">++;</span>
            <span class="identifier">HTML_OPEN_WITH</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">, </span><span class="string">"class=\</span><span class="plain">"</span><span class="string">hang\</span><span class="plain">"</span><span class="string">"</span><span class="plain">);</span>

            &lt;<span class="cwebmacro">Text of the actual lexicon entry</span> <span class="cwebmacronumber">8.11.1</span>&gt;<span class="plain">;</span>
            &lt;<span class="cwebmacro">Icon with link to documentation, source or verb table, if any</span> <span class="cwebmacronumber">8.11.2</span>&gt;<span class="plain">;</span>

            <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain">) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">ADJECTIVAL_PHRASE_LEXE</span><span class="plain">:</span>
                    &lt;<span class="cwebmacro">Definition of adjectival phrase entry</span> <span class="cwebmacronumber">8.11.5</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">ENUMERATED_CONSTANT_LEXE</span><span class="plain">:</span>
                    &lt;<span class="cwebmacro">Definition of enumerated instance entry</span> <span class="cwebmacronumber">8.11.6</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">PROPER_NOUN_LEXE</span><span class="plain">:</span>
                    &lt;<span class="cwebmacro">Definition of proper noun entry</span> <span class="cwebmacronumber">8.11.4</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOUN_LEXE</span><span class="plain">:</span>
                    &lt;<span class="cwebmacro">Definition of noun entry</span> <span class="cwebmacronumber">8.11.3</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;gloss_note</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" &lt;i&gt;%s&lt;/i&gt;"</span><span class="plain">, </span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;gloss_note</span><span class="plain">);</span>
            <span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">common_nouns_only</span><span class="plain">) { </span><span class="identifier">HTML::end_html_row</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">); </span><span class="identifier">HTML::end_html_table</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">); }</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>, <a href="#SP8_1">&#167;8.1</a>.</p>

<p class="inwebparagraph"><a id="SP8_11_1"></a><b>&#167;8.11.1.  </b>In traditional dictionary fashion, we present the text in what may not be
the most normal ordering, in order to place the alphabetically important
part first: thus "see, to be able to" rather than "to be able to see".
(Compare "Gallifreyan High Council, continual incidences of madness and
treachery amongst the" in "Doctor Who: The Completely Useless
Encyclopaedia", eds. Howarth and Lyons (1996).)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Text of the actual lexicon entry</span> <span class="cwebmacronumber">8.11.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="functiontext">Index::Lexicon::lexicon_copy_to_stream</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">, </span><span class="identifier">OUT</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">ABLE_VERB_LEXE</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">", to be able to"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">PREP_LEXE</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">", to be"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8_11">&#167;8.11</a>.</p>

<p class="inwebparagraph"><a id="SP8_11_2"></a><b>&#167;8.11.2.  </b>Main lexicon entries to do with verbs link further down the index page
to the corresponding entries in the verb table. We want to use numbered
anchors for these links, but we want to avoid colliding with numbered
anchors already used for other purposes higher up on the Phrasebook index
page. So we use a set of anchors numbered 10000 and up, which is guaranteed
not to coincide with any of those.
</p>

<p class="inwebparagraph">We omit source links to an adjectival phrase because these are polymorphic,
that is, the phrase may have multiple definitions in different parts of the
source text: so any single link would be potentially misleading.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Icon with link to documentation, source or verb table, if any</span> <span class="cwebmacronumber">8.11.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOUN_LEXE</span><span class="plain">: {</span>
                <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">RETRIEVE_POINTER_kind</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;entry_refers_to</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">K</span><span class="plain">) &amp;&amp; (</span><span class="identifier">Kinds::Behaviour::get_documentation_reference</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">)))</span>
                    <span class="functiontext">Index::DocReferences::link</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">Kinds::Behaviour::get_documentation_reference</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">));</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">VERB_LEXE</span><span class="plain">:</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">ABLE_VERB_LEXE</span><span class="plain">:</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">PREP_LEXE</span><span class="plain">:</span>
                <span class="functiontext">Index::below_link_numbered</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, 10000+</span><span class="identifier">verb_count</span><span class="plain">++);</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> != </span><span class="constant">ADJECTIVAL_PHRASE_LEXE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;wording_of_entry</span><span class="plain">)))</span>
            <span class="functiontext">Index::link</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;wording_of_entry</span><span class="plain">));</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8_11">&#167;8.11</a>.</p>

<p class="inwebparagraph"><a id="SP8_11_3"></a><b>&#167;8.11.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Definition of noun entry</span> <span class="cwebmacronumber">8.11.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">RETRIEVE_POINTER_kind</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;entry_refers_to</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::lt</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)) {</span>
            <span class="identifier">K</span><span class="plain"> = </span><span class="identifier">Kinds::Compare::super</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_name</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
                &lt;<span class="cwebmacro">Begin definition text</span> <span class="cwebmacronumber">8.11.3.1</span>&gt;<span class="plain">;</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">", a kind of "</span><span class="plain">);</span>
                &lt;<span class="cwebmacro">End definition text</span> <span class="cwebmacronumber">8.11.3.2</span>&gt;<span class="plain">;</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            &lt;<span class="cwebmacro">Begin definition text</span> <span class="cwebmacronumber">8.11.3.1</span>&gt;<span class="plain">;</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">", a kind"</span><span class="plain">);</span>
            &lt;<span class="cwebmacro">End definition text</span> <span class="cwebmacronumber">8.11.3.2</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8_11">&#167;8.11</a>.</p>

<p class="inwebparagraph"><a id="SP8_11_4"></a><b>&#167;8.11.4.  </b>Simply the name of an instance.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Definition of proper noun entry</span> <span class="cwebmacronumber">8.11.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain"> = </span><span class="identifier">RETRIEVE_POINTER_instance</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;entry_refers_to</span><span class="plain">);</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">define_noun</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::eq</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_thing</span><span class="plain">)) </span><span class="identifier">define_noun</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">define_noun</span><span class="plain">) {</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_name</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
                &lt;<span class="cwebmacro">Begin definition text</span> <span class="cwebmacronumber">8.11.3.1</span>&gt;<span class="plain">;</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
                &lt;<span class="cwebmacro">End definition text</span> <span class="cwebmacronumber">8.11.3.2</span>&gt;<span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8_11">&#167;8.11</a>.</p>

<p class="inwebparagraph"><a id="SP8_11_5"></a><b>&#167;8.11.5.  </b>As mentioned above, an adjectival phrase can be multiply defined in
different contexts. We want to quote all of those.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Definition of adjectival phrase entry</span> <span class="cwebmacronumber">8.11.5</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">ac</span><span class="plain"> = 0, </span><span class="identifier">nc</span><span class="plain">;</span>
        <span class="identifier">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">;</span>
        <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain"> = </span><span class="identifier">RETRIEVE_POINTER_adjectival_phrase</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;entry_refers_to</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">Begin definition text</span> <span class="cwebmacronumber">8.11.3.1</span>&gt;<span class="plain">;</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">": "</span><span class="plain">);</span>
        <span class="identifier">LOOP_OVER_SORTED_MEANINGS</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">am</span><span class="plain">) </span><span class="identifier">ac</span><span class="plain">++; </span><span class="identifier">nc</span><span class="plain"> = </span><span class="identifier">ac</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_SORTED_MEANINGS</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">am</span><span class="plain">) {</span>
            <span class="identifier">ac</span><span class="plain">--;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">nc</span><span class="plain"> &gt; 1) {</span>
                <span class="identifier">HTML_TAG</span><span class="plain">(</span><span class="string">"br"</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%d. "</span><span class="plain">, </span><span class="identifier">nc</span><span class="plain">-</span><span class="identifier">ac</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="identifier">Adjectives::Meanings::print_to_index</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">am</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ac</span><span class="plain"> &gt;= 1) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"; "</span><span class="plain">);</span>
        <span class="plain">}</span>
        &lt;<span class="cwebmacro">End definition text</span> <span class="cwebmacronumber">8.11.3.2</span>&gt;<span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8_11">&#167;8.11</a>.</p>

<p class="inwebparagraph"><a id="SP8_11_6"></a><b>&#167;8.11.6.  </b>Lastly and most easily, the name of an enumerated value of some kind
of value.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Definition of enumerated instance entry</span> <span class="cwebmacronumber">8.11.6</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">instance</span><span class="plain"> *</span><span class="identifier">qn</span><span class="plain"> = </span><span class="identifier">RETRIEVE_POINTER_instance</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;entry_refers_to</span><span class="plain">);</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">Instances::to_kind</span><span class="plain">(</span><span class="identifier">qn</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">Begin definition text</span> <span class="cwebmacronumber">8.11.3.1</span>&gt;<span class="plain">;</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">", value of "</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">End definition text</span> <span class="cwebmacronumber">8.11.3.2</span>&gt;<span class="plain">;</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">Kinds::Behaviour::get_name</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">));</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8_11">&#167;8.11</a>.</p>

<p class="inwebparagraph"><a id="SP8_11_3_1"></a><b>&#167;8.11.3.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Begin definition text</span> <span class="cwebmacronumber">8.11.3.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" ... &lt;i&gt;"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">common_nouns_only</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain">))</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%s"</span><span class="plain">, </span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;category</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8_11_3">&#167;8.11.3</a> (twice), <a href="#SP8_11_4">&#167;8.11.4</a>, <a href="#SP8_11_5">&#167;8.11.5</a>, <a href="#SP8_11_6">&#167;8.11.6</a>.</p>

<p class="inwebparagraph"><a id="SP8_11_3_2"></a><b>&#167;8.11.3.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">End definition text</span> <span class="cwebmacronumber">8.11.3.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;/i&gt;"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8_11_3">&#167;8.11.3</a> (twice), <a href="#SP8_11_4">&#167;8.11.4</a>, <a href="#SP8_11_5">&#167;8.11.5</a>, <a href="#SP8_11_6">&#167;8.11.6</a>.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. The table of verbs. </b>This is used in two different ways: firstly, at the foot of the lexicon &mdash;
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Index::Lexicon::index_verbs</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">) {</span>
        <span class="identifier">HTML_OPEN</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">); </span><span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">); </span>    <span class="comment">for spacing</span>
        <span class="identifier">HTML_OPEN</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">); </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"Verbs listed as \</span><span class="plain">"</span><span class="string">for saying only\</span><span class="plain">"</span><span class="string"> are values of the kind \</span><span class="plain">"</span><span class="string">verb\</span><span class="plain">"</span><span class="string"> "</span>
            <span class="string">"and can be used in adaptive text, but they have no meaning to Inform, so "</span>
            <span class="string">"they can't be used in sentences about what's in the story."</span><span class="plain">);</span>
        <span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
        <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">lex</span><span class="plain"> = </span><span class="identifier">sorted_lexicon</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">verb_count</span><span class="plain"> = 0;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lex</span><span class="plain"> = </span><span class="identifier">sorted_lexicon</span><span class="plain">; </span><span class="identifier">lex</span><span class="plain">; </span><span class="identifier">lex</span><span class="plain"> = </span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;sorted_next</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">VERB_LEXE</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">MVERB_LEXE</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">PREP_LEXE</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">ABLE_VERB_LEXE</span><span class="plain">)) {</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">entry_text</span><span class="plain">);</span>
                <span class="identifier">HTML_OPEN_WITH</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">, </span><span class="string">"class=\</span><span class="plain">"</span><span class="string">hang\</span><span class="plain">"</span><span class="string">"</span><span class="plain">);</span>
                <span class="functiontext">Index::anchor_numbered</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, 10000+</span><span class="identifier">verb_count</span><span class="plain">++); </span>    <span class="comment">anchors from 10000: see above</span>
                <span class="functiontext">Index::Lexicon::lexicon_copy_to_stream</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">, </span><span class="identifier">entry_text</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">VERB_LEXE</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"To &lt;b&gt;%S&lt;/b&gt;"</span><span class="plain">, </span><span class="identifier">entry_text</span><span class="plain">);</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">MVERB_LEXE</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"To &lt;b&gt;%S&lt;/b&gt;"</span><span class="plain">, </span><span class="identifier">entry_text</span><span class="plain">);</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">AVERB_LEXE</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;b&gt;%S&lt;/b&gt;"</span><span class="plain">, </span><span class="identifier">entry_text</span><span class="plain">);</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">PREP_LEXE</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"To be &lt;b&gt;%S&lt;/b&gt;"</span><span class="plain">, </span><span class="identifier">entry_text</span><span class="plain">);</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"To be able to &lt;b&gt;%S&lt;/b&gt;"</span><span class="plain">, </span><span class="identifier">entry_text</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;wording_of_entry</span><span class="plain">))</span>
                    <span class="functiontext">Index::link</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;wording_of_entry</span><span class="plain">));</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">AVERB_LEXE</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" ... &lt;i&gt;auxiliary verb&lt;/i&gt;"</span><span class="plain">);</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">MVERB_LEXE</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" ... for saying only"</span><span class="plain">);</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="identifier">NewVerbs::tabulate_meaning</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lex</span><span class="plain">);</span>
                <span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
                <span class="identifier">NewVerbs::tabulate</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lex</span><span class="plain">, </span><span class="identifier">IS_TENSE</span><span class="plain">, </span><span class="string">"present"</span><span class="plain">);</span>
                <span class="identifier">NewVerbs::tabulate</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lex</span><span class="plain">, </span><span class="identifier">WAS_TENSE</span><span class="plain">, </span><span class="string">"past"</span><span class="plain">);</span>
                <span class="identifier">NewVerbs::tabulate</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lex</span><span class="plain">, </span><span class="identifier">HASBEEN_TENSE</span><span class="plain">, </span><span class="string">"present perfect"</span><span class="plain">);</span>
                <span class="identifier">NewVerbs::tabulate</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lex</span><span class="plain">, </span><span class="identifier">HADBEEN_TENSE</span><span class="plain">, </span><span class="string">"past perfect"</span><span class="plain">);</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">entry_text</span><span class="plain">);</span>
            <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Index::Lexicon::index_verbs is used in 2/ifs (<a href="2-ifs.html#SP7">&#167;7</a>).</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>&mdash; and secondly, in the documentation for extensions, where we want to
be able to print out a table of just those verbs created in that extension.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Index::Lexicon::list_verbs_in_file</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="identifier">source_file</span><span class="plain"> *</span><span class="identifier">sf</span><span class="plain">, </span><span class="identifier">inform_extension</span><span class="plain"> *</span><span class="identifier">E</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">verb_count</span><span class="plain"> = 0;</span>
        <span class="reserved">lexicon_entry</span><span class="plain"> *</span><span class="identifier">lex</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">, </span><span class="reserved">lexicon_entry</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (((</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">VERB_LEXE</span><span class="plain">) || (</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">ABLE_VERB_LEXE</span><span class="plain">))</span>
                <span class="plain">&amp;&amp; (</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;verb_defined_at</span><span class="plain">)</span>
                <span class="plain">&amp;&amp; (</span><span class="identifier">Lexer::file_of_origin</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;verb_defined_at</span><span class="plain">))) == </span><span class="identifier">sf</span><span class="plain">)) {</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">entry_text</span><span class="plain">);</span>
                <span class="functiontext">Index::Lexicon::lexicon_copy_to_stream</span><span class="plain">(</span><span class="identifier">lex</span><span class="plain">, </span><span class="identifier">entry_text</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">verb_count</span><span class="plain">++ == 0) { </span><span class="identifier">HTML_OPEN</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">); </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"Verbs: "</span><span class="plain">); } </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">", "</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lex</span><span class="plain">-</span><span class="element">&gt;part_of_speech</span><span class="plain"> == </span><span class="constant">VERB_LEXE</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"to &lt;b&gt;%S&lt;/b&gt;"</span><span class="plain">, </span><span class="identifier">entry_text</span><span class="plain">);</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"to be able to &lt;b&gt;%S&lt;/b&gt;"</span><span class="plain">, </span><span class="identifier">entry_text</span><span class="plain">);</span>
                <span class="identifier">Extensions::Dictionary::new_entry_from_stream</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"verb"</span><span class="plain">, </span><span class="identifier">E</span><span class="plain">, </span><span class="identifier">entry_text</span><span class="plain">);</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">entry_text</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">verb_count</span><span class="plain"> &gt; 0) </span><span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Index::Lexicon::list_verbs_in_file appears nowhere else.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="2-dr.html">Back to 'Documentation References'</a></li><li><i>(This section ends Chapter 2: Indexing.)</i></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

