<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>What This Module Does</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script src="http://code.jquery.com/jquery-1.12.4.min.js"
	integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>

<script src="../docs-assets/Bigfoot.js"></script>
<link href="../docs-assets/Bigfoot.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../compiler.html">compiler tools</a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul><h2>Compiler Webs</h2><ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul><h2>Inbuild Modules</h2><ul>
<li><a href="../supervisor-module/index.html">supervisor</a></li>
</ul><h2>Inform7 Modules</h2><ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="index.html"><span class="selectedlink">kinds</span></a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul><h2>Inter Modules</h2><ul>
<li><a href="../bytecode-module/index.html">bytecode</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul><h2>Services</h2><ul>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../html-module/index.html">html</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'What This Module Does' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../compiler.html">Services</a></li><li><a href="index.html">kinds</a></li><li><a href="index.html#P">Preliminaries</a></li><li><b>What This Module Does</b></li></ul></div>
<p class="purpose">An overview of the kinds module's role and abilities.</p>

<ul class="toc"><li><a href="P-wtmd.html#SP1">&#167;1. Prerequisites</a></li><li><a href="P-wtmd.html#SP2">&#167;2. Kinds, definiteness, and safety</a></li><li><a href="P-wtmd.html#SP4">&#167;4. Kinds and knowledge</a></li><li><a href="P-wtmd.html#SP5">&#167;5. A strongly typed language mixing static and dynamic typing</a></li><li><a href="P-wtmd.html#SP6">&#167;6. Casting and coercion</a></li><li><a href="P-wtmd.html#SP8">&#167;8. What this module offers</a></li><li><a href="P-wtmd.html#SP11">&#167;11. Making new kinds</a></li><li><a href="P-wtmd.html#SP12">&#167;12. Where kind constructors come from</a></li><li><a href="P-wtmd.html#SP13">&#167;13. Making new kind constructors</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1"></a><b>&#167;1. Prerequisites. </b>The kinds module is a part of the Inform compiler toolset. It is
presented as a literate program or "web". Before diving in:
</p>

<ul class="items"><li>(a) It helps to have some experience of reading webs: see <a href="../../../inweb/docs/index.html" class="internal">inweb</a> for more.
</li><li>(b) The module is written in C, in fact ANSI C99, but this is disguised by the
fact that it uses some extension syntaxes provided by the <a href="../../../inweb/docs/index.html" class="internal">inweb</a> literate
programming tool, making it a dialect of C called InC. See <a href="../../../inweb/docs/index.html" class="internal">inweb</a> for
full details, but essentially: it's C without predeclarations or header files,
and where functions have names like <span class="extract"><span class="extract-syntax">Tags::add_by_name</span></span> rather than <span class="extract"><span class="extract-syntax">add_by_name</span></span>.
</li><li>(c) This module uses other modules drawn from the <a href="../compiler.html" class="internal">compiler</a>, and also
uses a module of utility functions called <a href="../../../inweb/docs/foundation-module/index.html" class="internal">foundation</a>.
For more, see <a href="../../../inweb/docs/foundation-module/P-abgtf.html" class="internal">A Brief Guide to Foundation (in foundation)</a>.
</li></ul>
<p class="commentary firstcommentary"><a id="SP2"></a><b>&#167;2. Kinds, definiteness, and safety. </b>To begin, an overview of the type system used by Inform, since this module
is essentially an isolated implementation of it.
</p>

<p class="commentary">Inform is like most programming languages in that it deals with a rich
variety of values, that is, individual pieces of data. The number
17, the time "3:15 PM" and the "Entire Game" (a named scene) are all
examples of values. Except that Inform uses the word "kind" rather than
"type" for the different sorts of values which exist, I have tried to
follow conventional computer-science terminology in this source code.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>
</p>

<p class="commentary">Kinds such as <span class="extract"><span class="extract-syntax">number</span></span> are "definite", in that they unambiguously say what
format a piece of data has. If the compiler can prove that a value has a
definite kind, it knows exactly how to print it, initialise it and so on.
Variables, constants, literal values and properties all have definite kinds.
</p>

<p class="commentary">But other kinds, such as <span class="extract"><span class="extract-syntax">arithmetic value</span></span>, merely express a guarantee
that a value can be used in some way. These are "indefinite". In some
contemporary languages this latter meaning would be a "typeclass"
(e.g., Haskell) or "protocol" (e.g., Swift) but not a "type".<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> The
ultimate in indefiniteness is the kind <span class="extract"><span class="extract-syntax">value</span></span>, which expresses only that
something is a piece of data. Phrase tokens can be indefinite, as this
example shows:
</p>

<blockquote>
    <p>To display (X - an arithmetic value):</p>
</blockquote>

<ul class="footnotetexts"><li class="footnote" id="fn:1"><p class="inwebfootnote"><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> See for instance definitions in Michael L. Scott, "Programming Language
Pragmatics" (second edition, 2006), chapter 7. We will refer to "kind checking"
and "kind compatibility" rather than "type checking" and "type compatibility",
for example.
<a href="#fnref:1" title="return to text"> &#x21A9;</a></p></li><li class="footnote" id="fn:2"><p class="inwebfootnote"><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> Swift syntax blurs this distinction and (rightly) encourages users to
make use of protocols in place of types in, for example, function parameters.
We shall do the same.
<a href="#fnref:2" title="return to text"> &#x21A9;</a></p></li></ul>
<p class="commentary firstcommentary"><a id="SP3"></a><b>&#167;3.  </b>The virtue of knowing that a piece of data has a given kind is that one
can guarantee that it can safely be used in some way. For example, it is
unsafe to divide by a <span class="extract"><span class="extract-syntax">text</span></span>, and an attempt to do so would be meaningless
at best, and liable to crash the compiled program at worst. The compiler
must therefore reject any requests to do so. That can only be done by
constant monitoring of their kinds of all values being dealt with.
</p>

<p class="commentary">Inform is a high-level language designed for ease of use. Accordingly:
</p>

<ul class="items"><li>(a) Inform does not trade safety for efficiency, as low-level languages
like C do. There are no pointers, no arrays with unchecked boundaries, no
union kinds, no exceptions, no labels, and no explicit type coercions.
</li><li>(b) All values are first-class, whatever their kind, meaning that they can
be passed to phrases, returned by phrases or stored in variables. All
copies and comparisons are deep: that is, to copy a pointer value
replicates its entire contents, and to compare two pointer values is to
examine their complete contents.
</li><li>(c) All memory management is automatic. The author of an Inform source text
never needs to know whether a given value is stored as a word or as a pointer
to data on the heap. (Indeed, this isn't even shown on the Kinds index page.)
</li></ul>
<p class="commentary firstcommentary"><a id="SP4"></a><b>&#167;4. Kinds and knowledge. </b>Inform uses the kinds system when building its world model of knowledge, and
not only to monitor specific computational operations. For example, if the
source text says:
</p>

<blockquote>
    <p>A wheelbarrow is a kind of vehicle. The blue garden barrow is a wheelbarrow.</p>
</blockquote>

<p class="commentary">then the value "blue garden barrow" has kind <span class="extract"><span class="extract-syntax">wheelbarrow</span></span>, which is
within <span class="extract"><span class="extract-syntax">vehicle</span></span>, within <span class="extract"><span class="extract-syntax">thing</span></span>, within <span class="extract"><span class="extract-syntax">object</span></span>. As this example suggests,
knowledge and property ownership passes through a single-inheritance hierarchy;
that is, each kind inherits directly from only one other kind.
</p>

<p class="commentary firstcommentary"><a id="SP5"></a><b>&#167;5. A strongly typed language mixing static and dynamic typing. </b>Programming languages with types are often classified by two criteria.
One is how rigorously they maintain safety, with safer languages being
strongly typed, and more libertarian ones weakly typed. The other is when
types are checked, with statically typed languages being checked at compile
time, dynamically typed languages being checked at run-time. Both strong/weak
and static/dynamic are really ranges of possibilities.
</p>

<ul class="items"><li>(a) Inform is a strongly typed language, in that any source text which
produces no Problem messages is guaranteed safe.
</li><li>(b) Inform is a hybrid between being statically and dynamically typed. At
compile time, Inform determines that the usage is either certainly safe or
else conditionally safe dependent on specific checks to be made at
run-time, which it compiles explicit code to carry out. Because of this,
Problem messages about safety violations can be issued either at compile
time or at run-time.
</li></ul>
<p class="commentary firstcommentary"><a id="SP6"></a><b>&#167;6. Casting and coercion. </b>Using data of one kind where another is expected is called "casting", and is
not always unsafe. Inform has no explicit syntax for casting, so all casts are
implicit &mdash; that is, the user just goes ahead and tries it.
</p>

<p class="commentary">Casts can be either "converting" or "non-converting". In a non-converting cast,
the data can be left exactly as it is. For instance, a <span class="extract"><span class="extract-syntax">vehicle</span></span> is stored at
run-time as an object number, and so is a <span class="extract"><span class="extract-syntax">thing</span></span>, so any <span class="extract"><span class="extract-syntax">vehicle</span></span> value is
already a <span class="extract"><span class="extract-syntax">thing</span></span> value. But to use a "snippet" as a "text" requires substantial
code to extract the compressed, read-only string from the text and store it
instead as a list of characters on the heap &mdash; this is a converting cast.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>
</p>

<ul class="footnotetexts"><li class="footnote" id="fn:3"><p class="inwebfootnote"><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> Some authors use the term "is-a" for what we call a non-converting cast.
Thus a <span class="extract"><span class="extract-syntax">vehicle</span></span> "is-a" <span class="extract"><span class="extract-syntax">thing</span></span>, but a <span class="extract"><span class="extract-syntax">snippet</span></span> is not a <span class="extract"><span class="extract-syntax">text</span></span>.
<a href="#fnref:3" title="return to text"> &#x21A9;</a></p></li></ul>
<p class="commentary firstcommentary"><a id="SP7"></a><b>&#167;7.  </b>However, it's worth noting that while Inform source text is strongly
typed, Inter is mostly typeless language, so that safety can be circumvented
by defining a phrase inline using an insertion of Inter code. For instance:
</p>

<blockquote>
    <p>To decide which text is (N - a number) as text: (- {N} -).</p>
</blockquote>

<p class="commentary">is analogous to a C function like so:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">char</span><span class="plain-syntax"> *</span><span class="identifier-syntax">number_as_text</span><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">N</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> (</span><span class="reserved-syntax">char</span><span class="plain-syntax"> *) </span><span class="identifier-syntax">N</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<p class="commentary">This is a legal C program but completely unsafe to run, and even worse can be
done if C functions are used to wrap, say, x86 assembly language. Defining
phrases with Inter inclusions is the equivalent in Inform.
</p>

<p class="commentary firstcommentary"><a id="SP8"></a><b>&#167;8. What this module offers. </b>The <a href="index.html" class="internal">kinds</a> module provides the Inform type system as a stand-alone utility,
at least in principle.
</p>

<p class="commentary">A kind is represented by a <a href="2-knd.html#SP1" class="internal">kind</a> object. Clearly some, like <span class="extract"><span class="extract-syntax">number</span></span>, are
atomic while others, like <span class="extract"><span class="extract-syntax">relation of numbers to texts</span></span>, are composite. Each
<a href="2-knd.html#SP1" class="internal">kind</a> object is formally a "construction" resulting from applying a
<a href="2-kc2.html#SP2" class="internal">kind_constructor</a> to other kinds.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> Each different possible constructor has
a fixed "arity", the number of other kinds it builds on. For example, to make
the kind <span class="extract"><span class="extract-syntax">relation of texts to lists of times</span></span>, we need four constructions
in a row:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    (nothing) --&gt; text</span>
<span class="plain-syntax">    (nothing) --&gt; time</span>
<span class="plain-syntax">    time --&gt; list of times</span>
<span class="plain-syntax">    text, list of times --&gt; relation of texts to lists of times</span>
</pre>
<p class="commentary">At each step there is only a finite choice of possible "kind constructions"
which can be made, but since there can in principle be an unlimited number
of steps, the set of all possible kinds is infinite. At each step we make
use of 0, 1 or 2 existing kinds to make a new one: this number (0, 1 or 2)
is the "arity" of the construction. These four steps have arities 0, 0, 1, 2,
and use the constructors "text", "time", "list of K" and "relation of K to L".
</p>

<p class="commentary">We will often use the word "base" to refer to arity-0 constructors
(or to the kinds which use them): thus, "text" and "time" are bases,
but "list of K" is not. We call constructors of higher arity "proper".
</p>

<ul class="footnotetexts"><li class="footnote" id="fn:4"><p class="inwebfootnote"><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> This term follows the traditional usage of "type constructor". Haskell and
some other functional languages mean something related but different by this.
<a href="#fnref:4" title="return to text"> &#x21A9;</a></p></li></ul>
<p class="commentary firstcommentary"><a id="SP9"></a><b>&#167;9.  </b><span class="extract"><span class="extract-syntax">kind</span></span> pointers actually point to tree structures, then, showing the
construction. <span class="extract"><span class="extract-syntax">relation of texts to lists of times</span></span> looks like so:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    relation of K to L</span>
<span class="plain-syntax">        text</span>
<span class="plain-syntax">        list of K</span>
<span class="plain-syntax">            time</span>
</pre>
<p class="commentary">It would be neat if there were exactly one <span class="extract"><span class="extract-syntax">kind</span></span> structure somewhere in
memory for each different kind. In practice (i) this would be tricky to
arrange, and (ii) we want to abstract equality through a function called
<a href="2-kc.html#SP9" class="internal">Kinds::Compare::eq</a>. Judicious use of caches makes the memory cost of
duplication negligible.
</p>

<p class="commentary firstcommentary"><a id="SP10"></a><b>&#167;10.  </b>In principle we could imagine constructors needing arbitrarily large
arity, or needing different arity in different usages, so the scheme of
having fixed arities in the range 0 to 2 looks limited. In practice we get
around that by using "punctuation nodes" in a kind tree. For example,
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    function K -&gt; L</span>
<span class="plain-syntax">        CON_TUPLE_ENTRY</span>
<span class="plain-syntax">            text</span>
<span class="plain-syntax">            CON_TUPLE_ENTRY</span>
<span class="plain-syntax">                text</span>
<span class="plain-syntax">                CON_NIL</span>
<span class="plain-syntax">        number</span>
</pre>
<p class="commentary">represents <span class="extract"><span class="extract-syntax">function (text, text) -&gt; number</span></span>. Note two special constructors
used here: <span class="extract"><span class="extract-syntax">CON_TUPLE_ENTRY</span></span> and <span class="extract"><span class="extract-syntax">CON_NIL</span></span>. These are called "punctuation",
and cannot be expressed in Inform source text, or occur in isolation. No
Inform variable can have kind <span class="extract"><span class="extract-syntax">CON_NIL</span></span>, for example.
</p>

<p class="commentary firstcommentary"><a id="SP11"></a><b>&#167;11. Making new kinds. </b>When we need a new <span class="extract"><span class="extract-syntax">kind *</span></span> value inside our code, what do we do? The
answer depends on how simple it is.
</p>

<ul class="items"><li>(a) If it's one of the standard built-in base kinds, we should just use a
preconstructed pointer: for example, <span class="extract"><span class="extract-syntax">K_number</span></span> can be used for <span class="extract"><span class="extract-syntax">number</span></span>.
See <a href="2-fk.html" class="internal">Familiar Kinds</a>.
</li><li>(b) And otherwise we call one of the functions <a href="2-knd.html#SP3" class="internal">Kinds::base_construction</a>.
<a href="2-knd.html#SP3_3" class="internal">Kinds::unary_construction</a> or <a href="2-knd.html#SP3_3" class="internal">Kinds::binary_construction</a>, according
to whether our constructor has arity 0, 1 or 2.
</li></ul>
<p class="commentary">For example, the following make valid representations of <span class="extract"><span class="extract-syntax">text</span></span>, <span class="extract"><span class="extract-syntax">list of numbers</span></span>
and <span class="extract"><span class="extract-syntax">relation of numbers to texts</span></span> respectively:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    K_text</span>
<span class="plain-syntax">    Kinds::unary_construction(CON_list_of, K_number)</span>
<span class="plain-syntax">    Kinds::binary_construction(CON_relation, K_number, K_text)</span>
</pre>
<p class="commentary">For the constructor values <span class="extract"><span class="extract-syntax">CON_list_of</span></span> and so on, again see <a href="2-fk.html" class="internal">Familiar Kinds</a>.
</p>

<p class="commentary firstcommentary"><a id="SP12"></a><b>&#167;12. Where kind constructors come from. </b>The built-in kind constructors, such as "number" or "list of K", are not really
built in. They are read in from configuration files &mdash; these are not written
in Inform source text, and look more like dictionaries of key-value pairs,
though they're simpler in syntax than XML.
</p>

<p class="commentary">Whole files can be read with <a href="4-kf.html#SP1" class="internal">KindFiles::load</a>, or individual commands
issued with <a href="4-kc.html#SP13" class="internal">KindCommands::despatch</a>.
</p>

<p class="commentary">Inform makes use of this by placing such files inside kits of Inter, because
in practice built-in kinds always need some run-time support written in Inter
code.
</p>

<p class="commentary firstcommentary"><a id="SP13"></a><b>&#167;13. Making new kind constructors. </b>When Inform acts on sentences like these:
</p>

<blockquote>
    <p>A weight is a kind of value. A mammal is a kind of animal.</p>
</blockquote>

<p class="commentary">it in fact makes new <a href="2-kc2.html#SP2" class="internal">kind_constructor</a> objects, not new <a href="2-knd.html#SP1" class="internal">kind</a> objects.
</p>

<p class="commentary">"Weight" and "mammal" are base constructors, i.e., they have arity 0.
High-level Inform source is not currently able to define new constructors of
higher arity, though kind configuration files do.
</p>

<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprevoff">&#10094;</li><li class="progresscurrentchapter">P</li><li class="progresscurrent">wtmd</li><li class="progresssection"><a href="P-htitm.html">htitm</a></li><li class="progresschapter"><a href="1-km.html">1</a></li><li class="progresschapter"><a href="2-knd.html">2</a></li><li class="progresschapter"><a href="3-dmn.html">3</a></li><li class="progresschapter"><a href="4-kf.html">4</a></li><li class="progressnext"><a href="P-htitm.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

