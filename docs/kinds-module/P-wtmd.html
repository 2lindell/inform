<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>What This Module Does</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script src="http://code.jquery.com/jquery-1.12.4.min.js"
	integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>

<script src="../docs-assets/Bigfoot.js"></script>
<link href="../docs-assets/Bigfoot.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
MathJax = {
	tex: {
		inlineMath: '$', '$'], ['\\(', '\\)'
	},
	svg: {
		fontCache: 'global'
	}
};
</script>
<script type="text/javascript" id="MathJax-script" async
	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../compiler.html">compiler tools</a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul><h2>Compiler Webs</h2><ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul><h2>Inbuild Modules</h2><ul>
<li><a href="../supervisor-module/index.html">supervisor</a></li>
</ul><h2>Inform7 Modules</h2><ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="index.html"><span class="selectedlink">kinds</span></a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul><h2>Inter Modules</h2><ul>
<li><a href="../bytecode-module/index.html">bytecode</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul><h2>Services</h2><ul>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../html-module/index.html">html</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'What This Module Does' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../compiler.html">Services</a></li><li><a href="index.html">kinds</a></li><li><a href="index.html#P">Preliminaries</a></li><li><b>What This Module Does</b></li></ul></div>
<p class="purpose">An overview of the kinds module's role and abilities.</p>

<ul class="toc"><li><a href="P-wtmd.html#SP1">&#167;1. Prerequisites</a></li><li><a href="P-wtmd.html#SP2">&#167;2. Kinds, definiteness, and safety</a></li><li><a href="P-wtmd.html#SP4">&#167;4. Kinds and knowledge</a></li><li><a href="P-wtmd.html#SP5">&#167;5. A strongly typed language mixing static and dynamic typing</a></li><li><a href="P-wtmd.html#SP6">&#167;6. Casting and coercion</a></li><li><a href="P-wtmd.html#SP8">&#167;8. What this module offers</a></li><li><a href="P-wtmd.html#SP12">&#167;12. Kind variables</a></li><li><a href="P-wtmd.html#SP14">&#167;14. Conformance</a></li><li><a href="P-wtmd.html#SP17">&#167;17. Compatibility</a></li><li><a href="P-wtmd.html#SP19">&#167;19. Making new kinds</a></li><li><a href="P-wtmd.html#SP20">&#167;20. Where kind constructors come from</a></li><li><a href="P-wtmd.html#SP21">&#167;21. Making new kind constructors</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1"></a><b>&#167;1. Prerequisites. </b>The kinds module is a part of the Inform compiler toolset. It is
presented as a literate program or "web". Before diving in:
</p>

<ul class="items"><li>(a) It helps to have some experience of reading webs: see <a href="../../../inweb/docs/index.html" class="internal">inweb</a> for more.
</li><li>(b) The module is written in C, in fact ANSI C99, but this is disguised by the
fact that it uses some extension syntaxes provided by the <a href="../../../inweb/docs/index.html" class="internal">inweb</a> literate
programming tool, making it a dialect of C called InC. See <a href="../../../inweb/docs/index.html" class="internal">inweb</a> for
full details, but essentially: it's C without predeclarations or header files,
and where functions have names like <span class="extract"><span class="extract-syntax">Tags::add_by_name</span></span> rather than <span class="extract"><span class="extract-syntax">add_by_name</span></span>.
</li><li>(c) This module uses other modules drawn from the <a href="../compiler.html" class="internal">compiler</a>, and also
uses a module of utility functions called <a href="../../../inweb/docs/foundation-module/index.html" class="internal">foundation</a>.
For more, see <a href="../../../inweb/docs/foundation-module/P-abgtf.html" class="internal">A Brief Guide to Foundation (in foundation)</a>.
</li></ul>
<p class="commentary firstcommentary"><a id="SP2"></a><b>&#167;2. Kinds, definiteness, and safety. </b>To begin, an overview of the type system used by Inform, since this module
is essentially an isolated implementation of it.
</p>

<p class="commentary">Inform is like most programming languages in that it deals with a rich
variety of values, that is, individual pieces of data. The number
17, the time "3:15 PM" and the "Entire Game" (a named scene) are all
examples of values. Except that Inform uses the word "kind" rather than
"type" for the different sorts of values which exist, I have tried to
follow conventional computer-science terminology in this source code.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>
</p>

<p class="commentary">Kinds such as <span class="extract"><span class="extract-syntax">number</span></span> are "definite", in that they unambiguously say what
format a piece of data has. If the compiler can prove that a value has a
definite kind, it knows exactly how to print it, initialise it and so on.
Variables, constants, literal values and properties all have definite kinds.
</p>

<p class="commentary">But other kinds, such as <span class="extract"><span class="extract-syntax">arithmetic value</span></span>, merely express a guarantee
that a value can be used in some way. These are "indefinite". In some
contemporary languages this latter meaning would be a "typeclass"
(e.g., Haskell) or "protocol" (e.g., Swift) but not a "type".<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> The
ultimate in indefiniteness is the kind <span class="extract"><span class="extract-syntax">value</span></span>, which expresses only that
something is a piece of data. Phrase tokens can be indefinite, as this
example shows:
</p>

<blockquote>
    <p>To display (X - an arithmetic value):</p>
</blockquote>

<ul class="footnotetexts"><li class="footnote" id="fn:1"><p class="inwebfootnote"><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> See for instance definitions in Michael L. Scott, "Programming Language
Pragmatics" (second edition, 2006), chapter 7. We will refer to "kind checking"
and "kind compatibility" rather than "type checking" and "type compatibility",
for example.
<a href="#fnref:1" title="return to text"> &#x21A9;</a></p></li><li class="footnote" id="fn:2"><p class="inwebfootnote"><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> Swift syntax blurs this distinction and (rightly) encourages users to
make use of protocols in place of types in, for example, function parameters.
We shall do the same.
<a href="#fnref:2" title="return to text"> &#x21A9;</a></p></li></ul>
<p class="commentary firstcommentary"><a id="SP3"></a><b>&#167;3.  </b>The virtue of knowing that a piece of data has a given kind is that one
can guarantee that it can safely be used in some way. For example, it is
unsafe to divide by a <span class="extract"><span class="extract-syntax">text</span></span>, and an attempt to do so would be meaningless
at best, and liable to crash the compiled program at worst. The compiler
must therefore reject any requests to do so. That can only be done by
constant monitoring of their kinds of all values being dealt with.
</p>

<p class="commentary">Inform is a high-level language designed for ease of use. Accordingly:
</p>

<ul class="items"><li>(a) Inform does not trade safety for efficiency, as low-level languages
like C do. There are no pointers, no arrays with unchecked boundaries, no
union kinds, no exceptions, no labels, and no explicit type coercions.
</li><li>(b) All values are first-class, whatever their kind, meaning that they can
be passed to phrases, returned by phrases or stored in variables. All
copies and comparisons are deep: that is, to copy a pointer value
replicates its entire contents, and to compare two pointer values is to
examine their complete contents.
</li><li>(c) All memory management is automatic. The author of an Inform source text
never needs to know whether a given value is stored as a word or as a pointer
to data on the heap. (Indeed, this isn't even shown on the Kinds index page.)
</li></ul>
<p class="commentary firstcommentary"><a id="SP4"></a><b>&#167;4. Kinds and knowledge. </b>Inform uses the kinds system when building its world model of knowledge, and
not only to monitor specific computational operations. For example, if the
source text says:
</p>

<blockquote>
    <p>A wheelbarrow is a kind of vehicle. The blue garden barrow is a wheelbarrow.</p>
</blockquote>

<p class="commentary">then the value "blue garden barrow" has kind <span class="extract"><span class="extract-syntax">wheelbarrow</span></span>, which is
within <span class="extract"><span class="extract-syntax">vehicle</span></span>, within <span class="extract"><span class="extract-syntax">thing</span></span>, within <span class="extract"><span class="extract-syntax">object</span></span>. As this example suggests,
knowledge and property ownership passes through a single-inheritance hierarchy;
that is, each kind inherits directly from only one other kind.
</p>

<p class="commentary firstcommentary"><a id="SP5"></a><b>&#167;5. A strongly typed language mixing static and dynamic typing. </b>Programming languages with types are often classified by two criteria.
One is how rigorously they maintain safety, with safer languages being
strongly typed, and more libertarian ones weakly typed. The other is when
types are checked, with statically typed languages being checked at compile
time, dynamically typed languages being checked at run-time. Both strong/weak
and static/dynamic are really ranges of possibilities.
</p>

<ul class="items"><li>(a) Inform is a strongly typed language, in that any source text which
produces no Problem messages is guaranteed safe.
</li><li>(b) Inform is a hybrid between being statically and dynamically typed. At
compile time, Inform determines that the usage is either certainly safe or
else conditionally safe dependent on specific checks to be made at
run-time, which it compiles explicit code to carry out. Because of this,
Problem messages about safety violations can be issued either at compile
time or at run-time.
</li></ul>
<p class="commentary firstcommentary"><a id="SP6"></a><b>&#167;6. Casting and coercion. </b>Using data of one kind where another is expected is called "casting", and is
not always unsafe. Inform has no explicit syntax for casting, so all casts are
implicit &mdash; that is, the user just goes ahead and tries it.
</p>

<p class="commentary">Casts can be either "converting" or "non-converting". In a non-converting cast,
the data can be left exactly as it is. For instance, a <span class="extract"><span class="extract-syntax">vehicle</span></span> is stored at
run-time as an object number, and so is a <span class="extract"><span class="extract-syntax">thing</span></span>, so any <span class="extract"><span class="extract-syntax">vehicle</span></span> value is
already a <span class="extract"><span class="extract-syntax">thing</span></span> value. But to use a "snippet" as a "text" requires substantial
code to extract the compressed, read-only string from the text and store it
instead as a list of characters on the heap &mdash; this is a converting cast.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>
</p>

<ul class="footnotetexts"><li class="footnote" id="fn:3"><p class="inwebfootnote"><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> Some authors use the term "is-a" for what we call a non-converting cast.
Thus a <span class="extract"><span class="extract-syntax">vehicle</span></span> "is-a" <span class="extract"><span class="extract-syntax">thing</span></span>, but a <span class="extract"><span class="extract-syntax">snippet</span></span> is not a <span class="extract"><span class="extract-syntax">text</span></span>.
<a href="#fnref:3" title="return to text"> &#x21A9;</a></p></li></ul>
<p class="commentary firstcommentary"><a id="SP7"></a><b>&#167;7.  </b>However, it's worth noting that while Inform source text is strongly
typed, Inter is mostly typeless language, so that safety can be circumvented
by defining a phrase inline using an insertion of Inter code. For instance:
</p>

<blockquote>
    <p>To decide which text is (N - a number) as text: (- {N} -).</p>
</blockquote>

<p class="commentary">is analogous to a C function like so:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">char</span><span class="plain-syntax"> *</span><span class="identifier-syntax">number_as_text</span><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">N</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> (</span><span class="reserved-syntax">char</span><span class="plain-syntax"> *) </span><span class="identifier-syntax">N</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<p class="commentary">This is a legal C program but completely unsafe to run, and even worse can be
done if C functions are used to wrap, say, x86 assembly language. Defining
phrases with Inter inclusions is the equivalent in Inform.
</p>

<p class="commentary firstcommentary"><a id="SP8"></a><b>&#167;8. What this module offers. </b>The <a href="index.html" class="internal">kinds</a> module provides the Inform type system as a stand-alone utility,
and one way to toy with it in isolation is to run test "programs" through the
<a href="../kinds-test/index.html" class="internal">kinds-test</a> tool. This is like a calculator, but for kinds and not values.
A "program" is a series of descriptions of kinds, and the output consists of
their evaluations. As a simple example:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="element-syntax">'number'</span><span class="plain-syntax">:</span><span class="string-syntax"> number</span>
<span class="element-syntax">'list of texts'</span><span class="plain-syntax">:</span><span class="string-syntax"> list of texts</span>
<span class="element-syntax">'phrase number -&gt; text'</span><span class="plain-syntax">:</span><span class="string-syntax"> phrase number -&gt; text</span>
<span class="element-syntax">'arithmetic value'</span><span class="plain-syntax">:</span><span class="string-syntax"> arithmetic value</span>
<span class="element-syntax">'relation of numbers to truth states'</span><span class="plain-syntax">:</span><span class="string-syntax"> relation of numbers to truth states</span>
<span class="element-syntax">'relation of numbers to numbers'</span><span class="plain-syntax">:</span><span class="string-syntax"> relation of numbers</span>
</pre>
<p class="commentary">This is more of a test than it appears. In each line <a href="../kinds-test/index.html" class="internal">kinds-test</a> has read in
the textual description in quotes, parsed it into a <a href="2-knd.html#SP1" class="internal">kind</a> object using the &lt;k-kind&gt;
Preform nonterminal, then printed it out with <a href="2-dk.html#SP22" class="internal">Kinds::Textual::write</a> (or
in fact by using the <span class="extract"><span class="extract-syntax">%u</span></span> string escape, which amounts to the same thing).
</p>

<p class="commentary firstcommentary"><a id="SP9"></a><b>&#167;9.  </b>A kind is represented by a <a href="2-knd.html#SP1" class="internal">kind</a> object. Clearly some, like <span class="extract"><span class="extract-syntax">number</span></span>, are
atomic while others, like <span class="extract"><span class="extract-syntax">relation of numbers to texts</span></span>, are composite. Each
<a href="2-knd.html#SP1" class="internal">kind</a> object is formally a "construction" resulting from applying a
<a href="2-kc.html#SP2" class="internal">kind_constructor</a> to other kinds.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> Each different possible constructor has
a fixed "arity", the number of other kinds it builds on. For example, to make
the kind <span class="extract"><span class="extract-syntax">relation of texts to lists of times</span></span>, we need four constructions
in a row:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    (nothing) --&gt; text</span>
<span class="plain-syntax">    (nothing) --&gt; time</span>
<span class="plain-syntax">    time --&gt; list of times</span>
<span class="plain-syntax">    text, list of times --&gt; relation of texts to lists of times</span>
</pre>
<p class="commentary">At each step there is only a finite choice of possible "kind constructions"
which can be made, but since there can in principle be an unlimited number
of steps, the set of all possible kinds is infinite. At each step we make
use of 0, 1 or 2 existing kinds to make a new one: this number (0, 1 or 2)
is the "arity" of the construction. These four steps have arities 0, 0, 1, 2,
and use the constructors "text", "time", "list of K" and "relation of K to L".
</p>

<p class="commentary">We will often use the word "base" to refer to arity-0 constructors
(or to the kinds which use them): thus, "text" and "time" are bases,
but "list of K" is not. We call constructors of higher arity "proper".
</p>

<ul class="footnotetexts"><li class="footnote" id="fn:4"><p class="inwebfootnote"><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> This term follows the traditional usage of "type constructor". Haskell and
some other functional languages mean something related but different by this.
<a href="#fnref:4" title="return to text"> &#x21A9;</a></p></li></ul>
<p class="commentary firstcommentary"><a id="SP10"></a><b>&#167;10.  </b>Here is <a href="../kinds-test/index.html" class="internal">kinds-test</a> exercising the construction system. Note that
it has "functions" to extract the first and second term of a construction.
(The REPL language of <a href="../kinds-test/index.html" class="internal">kinds-test</a> has quite a number of functions like
this, for testing different features of <a href="index.html" class="internal">kinds</a>.)
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="element-syntax">'X = object'</span><span class="plain-syntax">:</span><span class="string-syntax"> object</span>
<span class="element-syntax">'first term of X'</span><span class="plain-syntax">:</span><span class="string-syntax"> nothing</span>
<span class="element-syntax">'second term of X'</span><span class="plain-syntax">:</span><span class="string-syntax"> nothing</span>
<span class="element-syntax">'Y = list of numbers'</span><span class="plain-syntax">:</span><span class="string-syntax"> list of numbers</span>
<span class="element-syntax">'first term of Y'</span><span class="plain-syntax">:</span><span class="string-syntax"> number</span>
<span class="element-syntax">'second term of Y'</span><span class="plain-syntax">:</span><span class="string-syntax"> nothing</span>
<span class="element-syntax">'Z = relation of texts to numbers'</span><span class="plain-syntax">:</span><span class="string-syntax"> relation of texts to numbers</span>
<span class="element-syntax">'first term of Z'</span><span class="plain-syntax">:</span><span class="string-syntax"> text</span>
<span class="element-syntax">'second term of Z'</span><span class="plain-syntax">:</span><span class="string-syntax"> number</span>
<span class="element-syntax">'W = phrase (relation of texts to numbers, text) -&gt; truth state'</span><span class="plain-syntax">:</span><span class="string-syntax"> phrase (relation of texts to numbers, text) -&gt; truth state</span>
<span class="element-syntax">'first term of W'</span><span class="plain-syntax">:</span><span class="string-syntax"> relation of texts to numbers, text</span>
<span class="element-syntax">'first term of first term of W'</span><span class="plain-syntax">:</span><span class="string-syntax"> relation of texts to numbers</span>
<span class="element-syntax">'first term of first term of first term of W'</span><span class="plain-syntax">:</span><span class="string-syntax"> text</span>
<span class="element-syntax">'second term of first term of first term of W'</span><span class="plain-syntax">:</span><span class="string-syntax"> number</span>
<span class="element-syntax">'second term of first term of W'</span><span class="plain-syntax">:</span><span class="string-syntax"> text</span>
<span class="element-syntax">'second term of W'</span><span class="plain-syntax">:</span><span class="string-syntax"> truth state</span>
</pre>
<p class="commentary firstcommentary"><a id="SP11"></a><b>&#167;11.  </b>In principle we could imagine constructors needing arbitrarily large
arity, or needing different arity in different usages, so the scheme of
having fixed arities in the range 0 to 2 looks limited. In practice we get
around that by using "punctuation nodes" in a kind tree. For example,
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    function K -&gt; L</span>
<span class="plain-syntax">        CON_TUPLE_ENTRY</span>
<span class="plain-syntax">            text</span>
<span class="plain-syntax">            CON_TUPLE_ENTRY</span>
<span class="plain-syntax">                text</span>
<span class="plain-syntax">                CON_NIL</span>
<span class="plain-syntax">        number</span>
</pre>
<p class="commentary">represents <span class="extract"><span class="extract-syntax">function (text, text) -&gt; number</span></span>. Note two special constructors
used here: <span class="extract"><span class="extract-syntax">CON_TUPLE_ENTRY</span></span> and <span class="extract"><span class="extract-syntax">CON_NIL</span></span>. These are called "punctuation",
and cannot be expressed in Inform source text, or occur in isolation. No
Inform variable can have kind <span class="extract"><span class="extract-syntax">CON_NIL</span></span>, for example.
</p>

<p class="commentary firstcommentary"><a id="SP12"></a><b>&#167;12. Kind variables. </b>The 26 letters A to Z, written in upper case, can serve as kind variables &mdash;
placeholders for kinds. In practice A is best avoided because it looks too
much like an indefinite article, but it's very rare to need more than two.<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>
Phrase definitions in the standard Inform extensions use only K and L.
</p>

<p class="commentary">The meaning of, say, "list of K" depends on context. If K is currently set to,
say, <span class="extract"><span class="extract-syntax">number</span></span>, then "list of K" means <span class="extract"><span class="extract-syntax">list of number</span></span>; if it has no current
setting, then K remains a placeholder and the result is <span class="extract"><span class="extract-syntax">list of K</span></span>. Note that
the same variable can occur more than once, as for example in <span class="extract"><span class="extract-syntax">phrase K -&gt; K</span></span>.
A kind with variables is always indefinite &mdash; unless one knows what <span class="extract"><span class="extract-syntax">K</span></span> will
be, there's no way to know what format of data a <span class="extract"><span class="extract-syntax">list of K</span></span> value has.
</p>

<p class="commentary">A process called "substitution" enables <span class="extract"><span class="extract-syntax">list of K</span></span> to be transformed to
<span class="extract"><span class="extract-syntax">list of numbers</span></span>, or whatever may be. See <a href="2-knd.html#SP14" class="internal">Kinds::substitute</a>.
</p>

<p class="commentary">The kinds module has to ask the parent tool for the current meanings of these
variables, which may have all kinds of scoping considerations beyond our
understanding here. See <a href="2-knd.html#SP20" class="internal">Kinds::variable_from_context</a>.
</p>

<ul class="footnotetexts"><li class="footnote" id="fn:5"><p class="inwebfootnote"><sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup> Indeed, in early functional languages type variables were sometimes written
as <span class="extract"><span class="extract-syntax">*</span></span>, <span class="extract"><span class="extract-syntax">**</span></span>, <span class="extract"><span class="extract-syntax">***</span></span>, and so on, a syntax making clear that nobody expected
to see many of them at once. Type variables always have very local scope.
<a href="#fnref:5" title="return to text"> &#x21A9;</a></p></li></ul>
<p class="commentary firstcommentary"><a id="SP13"></a><b>&#167;13.  </b>In <a href="../kinds-test/index.html" class="internal">kinds-test</a>, the 26 variables are initially unset, but can be given
values by writing <span class="extract"><span class="extract-syntax">K = number</span></span>, or similar. For example:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="element-syntax">'Q'</span><span class="plain-syntax">:</span><span class="string-syntax"> Q</span>
<span class="element-syntax">'list of relations of Q to R'</span><span class="plain-syntax">:</span><span class="string-syntax"> list of relations of Qs to Rs</span>
<span class="element-syntax">'substitute number for Q in Q'</span><span class="plain-syntax">:</span><span class="string-syntax"> number</span>
<span class="element-syntax">'substitute number for Q in list of Q'</span><span class="plain-syntax">:</span><span class="string-syntax"> list of numbers</span>
<span class="element-syntax">'substitute number for Q in list of relations of Q to Q'</span><span class="plain-syntax">:</span><span class="string-syntax"> list of relations of numbers</span>
<span class="element-syntax">'X = relation of Y to Y'</span><span class="plain-syntax">:</span><span class="string-syntax"> relation of Ys</span>
<span class="element-syntax">'X is definite?'</span><span class="plain-syntax">:</span><span class="string-syntax"> false</span>
<span class="element-syntax">'X = relation of numbers to numbers'</span><span class="plain-syntax">:</span><span class="string-syntax"> relation of numbers</span>
<span class="element-syntax">'X is definite?'</span><span class="plain-syntax">:</span><span class="string-syntax"> true</span>
</pre>
<p class="commentary firstcommentary"><a id="SP14"></a><b>&#167;14. Conformance. </b>The set of all kinds has a sort of ordering<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup> called "conformance": we write
\(K\leq L\) if \(K\) conforms to \(L\). For any kinds \(K, L, M\) not making use of
kind variables<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup> it is true that:
</p>

<ul class="items"><li>(a) \(K \leq K\) &mdash; reflexivity.
</li><li>(b) If \(K\leq L\) and \(L\leq M\) then \(K\leq M\) &mdash; transitivity.
</li><li>(c) <span class="extract"><span class="extract-syntax">K_nil</span></span> \(\leq K \leq\) <span class="extract"><span class="extract-syntax">value</span></span> &mdash; there are top and bottom elements.
</li><li>(d) If \(K \leq L\) then a value of kind \(K\) can always be substituted for a
value of kind \(L\) without modification &mdash; the Liskov substitution principle.<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup>
</li></ul>
<p class="commentary"><span class="extract"><span class="extract-syntax">K_nil</span></span> is a kind which exists only for kind-checking purposes: it represents
"a member of the empty set", and therefore no value can ever have it. This
differs from <span class="extract"><span class="extract-syntax">K_void</span></span>, which means "the absence of a value". A rule producing
no result, for example, has as production kind <span class="extract"><span class="extract-syntax">K_void</span></span>.
</p>

<ul class="footnotetexts"><li class="footnote" id="fn:6"><p class="inwebfootnote"><sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup> It need not be antisymmetric and only has joins to a limited extent, so
it is formally not a semilattice, nor even a partial ordering.
<a href="#fnref:6" title="return to text"> &#x21A9;</a></p></li><li class="footnote" id="fn:7"><p class="inwebfootnote"><sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup> Introducing kind variables complicates the picture, because whether or not
<span class="extract"><span class="extract-syntax">list of K</span></span> conforms to <span class="extract"><span class="extract-syntax">list of arithmetic values</span></span> depends on the current
value of <span class="extract"><span class="extract-syntax">K</span></span> and therefore on the current context.
<a href="#fnref:7" title="return to text"> &#x21A9;</a></p></li><li class="footnote" id="fn:8"><p class="inwebfootnote"><sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup> Also known as strong behavioural subtyping. This only applies to definite
kinds, because no value ever has an indefinite kind.
<a href="#fnref:8" title="return to text"> &#x21A9;</a></p></li></ul>
<p class="commentary firstcommentary"><a id="SP15"></a><b>&#167;15.  </b>Conformance is tested with the function <a href="2-knd.html#SP22" class="internal">Kinds::conforms_to</a>, and the
following shows it in action.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="element-syntax">'new kind thing of object'</span><span class="plain-syntax">:</span><span class="string-syntax"> ok</span>
<span class="element-syntax">'new kind device of thing'</span><span class="plain-syntax">:</span><span class="string-syntax"> ok</span>
<span class="element-syntax">'new kind vehicle of thing'</span><span class="plain-syntax">:</span><span class="string-syntax"> ok</span>
<span class="element-syntax">'new unit length'</span><span class="plain-syntax">:</span><span class="string-syntax"> ok</span>
<span class="element-syntax">'number &lt;= number?'</span><span class="plain-syntax">:</span><span class="string-syntax"> true</span>
<span class="element-syntax">'number &lt;= real number?'</span><span class="plain-syntax">:</span><span class="string-syntax"> false</span>
<span class="element-syntax">'value &lt;= number?'</span><span class="plain-syntax">:</span><span class="string-syntax"> false</span>
<span class="element-syntax">'object &lt;= text?'</span><span class="plain-syntax">:</span><span class="string-syntax"> false</span>
<span class="element-syntax">'object &lt;= thing?'</span><span class="plain-syntax">:</span><span class="string-syntax"> false</span>
<span class="element-syntax">'thing &lt;= object?'</span><span class="plain-syntax">:</span><span class="string-syntax"> true</span>
<span class="element-syntax">'device &lt;= thing?'</span><span class="plain-syntax">:</span><span class="string-syntax"> true</span>
<span class="element-syntax">'device &lt;= object?'</span><span class="plain-syntax">:</span><span class="string-syntax"> true</span>
<span class="element-syntax">'list of devices &lt;= thing?'</span><span class="plain-syntax">:</span><span class="string-syntax"> false</span>
<span class="element-syntax">'list of devices &lt;= list of things?'</span><span class="plain-syntax">:</span><span class="string-syntax"> true</span>
<span class="element-syntax">'relation of things to texts &lt;= relation of devices to texts?'</span><span class="plain-syntax">:</span><span class="string-syntax"> false</span>
<span class="element-syntax">'relation of devices to texts &lt;= relation of things to texts?'</span><span class="plain-syntax">:</span><span class="string-syntax"> true</span>
<span class="element-syntax">'phrase thing -&gt; text &lt;= phrase device -&gt; text?'</span><span class="plain-syntax">:</span><span class="string-syntax"> true</span>
<span class="element-syntax">'phrase device -&gt; text &lt;= phrase thing -&gt; text?'</span><span class="plain-syntax">:</span><span class="string-syntax"> false</span>
<span class="element-syntax">'phrase text -&gt; thing &lt;= phrase text -&gt; device?'</span><span class="plain-syntax">:</span><span class="string-syntax"> false</span>
<span class="element-syntax">'phrase text -&gt; device &lt;= phrase text -&gt; thing?'</span><span class="plain-syntax">:</span><span class="string-syntax"> true</span>
</pre>
<p class="commentary">Note that:
</p>

<ul class="items"><li>(a) <span class="extract"><span class="extract-syntax">number</span></span> does not conform to <span class="extract"><span class="extract-syntax">real number</span></span>. It can be cast to a real
number, and this happens implicitly in Inform, but the cast requires explicit
code; so it would violate Liskov substitution to have <span class="extract"><span class="extract-syntax">number</span></span> \(\leq\) <span class="extract"><span class="extract-syntax">real number</span></span>.
</li><li>(b) The "list of K" constructor is covariant, in that \(K\leq L\) means
<span class="extract"><span class="extract-syntax">list of K</span></span> \(\leq\) <span class="extract"><span class="extract-syntax">list of L</span></span>, whereas the "phrase K -&gt; L" constructor
is contravariant in the first term, covariant in the second. See
<a href="2-tlok.html#SP9" class="internal">Latticework::order_relation</a> for more.
</li></ul>
<p class="commentary firstcommentary"><a id="SP16"></a><b>&#167;16.  </b>The indefinite <span class="extract"><span class="extract-syntax">arithmetic kind</span></span> used by Inform is a good example of what
in other languages would be called a protocol. Here we see conformance:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="element-syntax">'new unit length'</span><span class="plain-syntax">:</span><span class="string-syntax"> ok</span>
<span class="element-syntax">'number &lt;= arithmetic value?'</span><span class="plain-syntax">:</span><span class="string-syntax"> true</span>
<span class="element-syntax">'real number &lt;= arithmetic value?'</span><span class="plain-syntax">:</span><span class="string-syntax"> true</span>
<span class="element-syntax">'length &lt;= arithmetic value?'</span><span class="plain-syntax">:</span><span class="string-syntax"> true</span>
<span class="element-syntax">'text &lt;= arithmetic value?'</span><span class="plain-syntax">:</span><span class="string-syntax"> false</span>
<span class="element-syntax">'arithmetic value &lt;= value?'</span><span class="plain-syntax">:</span><span class="string-syntax"> true</span>
<span class="element-syntax">'value &lt;= arithmetic value?'</span><span class="plain-syntax">:</span><span class="string-syntax"> false</span>
<span class="element-syntax">'arithmetic value &lt;= sayable value?'</span><span class="plain-syntax">:</span><span class="string-syntax"> true</span>
</pre>
<p class="commentary">Note that <span class="extract"><span class="extract-syntax">arithmetic value</span></span> does not conform to <span class="extract"><span class="extract-syntax">sayable value</span></span> &mdash; it is true
that every value on which arithmetic can be performed can also be said, but
this is not why. This example shows that \(K\leq L \Rightarrow K\leq M\) does
not necessarily mean that \(L\leq M\).
</p>

<p class="commentary firstcommentary"><a id="SP17"></a><b>&#167;17. Compatibility. </b>A related but different question is "compatibility". This asks whether a
value of kind \(K\) can be used where \(L\) is expected, but
</p>

<ul class="items"><li>(i) It is now okay if explicit code to perform a conversion would be needed;
</li><li>(ii) There are now three possible answers &mdash; always, never and sometimes, where
"sometimes" means that code can be compiled which would test compatibility at
run time rather than compile time;
</li><li>(iii) <span class="extract"><span class="extract-syntax">value</span></span>, anomalously, is compatible with everything.
</li></ul>
<p class="commentary">Note that \(K\leq L\) certainly means \(K\) is compatible with \(L\), but there
are many other compatible cases. For example:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="element-syntax">'new kind thing of object'</span><span class="plain-syntax">:</span><span class="string-syntax"> ok</span>
<span class="element-syntax">'new kind device of thing'</span><span class="plain-syntax">:</span><span class="string-syntax"> ok</span>
<span class="element-syntax">'new kind vehicle of thing'</span><span class="plain-syntax">:</span><span class="string-syntax"> ok</span>
<span class="element-syntax">'new unit length'</span><span class="plain-syntax">:</span><span class="string-syntax"> ok</span>
<span class="element-syntax">'number compatible with number?'</span><span class="plain-syntax">:</span><span class="string-syntax"> always</span>
<span class="element-syntax">'number compatible with real number?'</span><span class="plain-syntax">:</span><span class="string-syntax"> always</span>
<span class="element-syntax">'value compatible with number?'</span><span class="plain-syntax">:</span><span class="string-syntax"> never</span>
<span class="element-syntax">'object compatible with text?'</span><span class="plain-syntax">:</span><span class="string-syntax"> never</span>
<span class="element-syntax">'object compatible with thing?'</span><span class="plain-syntax">:</span><span class="string-syntax"> sometimes</span>
<span class="element-syntax">'thing compatible with object?'</span><span class="plain-syntax">:</span><span class="string-syntax"> always</span>
<span class="element-syntax">'device compatible with thing?'</span><span class="plain-syntax">:</span><span class="string-syntax"> always</span>
<span class="element-syntax">'device compatible with object?'</span><span class="plain-syntax">:</span><span class="string-syntax"> always</span>
<span class="element-syntax">'list of devices compatible with thing?'</span><span class="plain-syntax">:</span><span class="string-syntax"> never</span>
<span class="element-syntax">'list of devices compatible with list of things?'</span><span class="plain-syntax">:</span><span class="string-syntax"> always</span>
<span class="element-syntax">'relation of things to texts compatible with relation of devices to texts?'</span><span class="plain-syntax">:</span><span class="string-syntax"> never</span>
<span class="element-syntax">'relation of devices to texts compatible with relation of things to texts?'</span><span class="plain-syntax">:</span><span class="string-syntax"> always</span>
<span class="element-syntax">'phrase thing -&gt; text compatible with phrase device -&gt; text?'</span><span class="plain-syntax">:</span><span class="string-syntax"> always</span>
<span class="element-syntax">'phrase device -&gt; text compatible with phrase thing -&gt; text?'</span><span class="plain-syntax">:</span><span class="string-syntax"> never</span>
<span class="element-syntax">'phrase text -&gt; thing compatible with phrase text -&gt; device?'</span><span class="plain-syntax">:</span><span class="string-syntax"> never</span>
<span class="element-syntax">'phrase text -&gt; device compatible with phrase text -&gt; thing?'</span><span class="plain-syntax">:</span><span class="string-syntax"> always</span>
<span class="element-syntax">'activity on numbers compatible with activity?'</span><span class="plain-syntax">:</span><span class="string-syntax"> always</span>
<span class="element-syntax">'first term of activity'</span><span class="plain-syntax">:</span><span class="string-syntax"> nothing</span>
<span class="element-syntax">'activity on numbers compatible with activity on values?'</span><span class="plain-syntax">:</span><span class="string-syntax"> never</span>
</pre>
<p class="commentary">Note that <span class="extract"><span class="extract-syntax">number</span></span> is compatible with <span class="extract"><span class="extract-syntax">real number</span></span>. Run-time code will be
needed to convert the value, but the answer is "always". We also see that
"device" is always compatible with "thing" &mdash; every device is a thing &mdash;
but also that "thing" is sometimes compatible with "device". If we pass a
thing to a function expecting to see a device, run-time code can check whether
the value passed is indeed a device, and reject the call with a run-time error
if not.
</p>

<p class="commentary">The anomaly over <span class="extract"><span class="extract-syntax">value</span></span> looks and is odd.
</p>

<p class="commentary firstcommentary"><a id="SP18"></a><b>&#167;18.  </b>We support a sort of hybrid kinds system, in which some base kinds have
subkinds and superkinds, while others do not.
</p>

<p class="commentary">In Inform, <span class="extract"><span class="extract-syntax">object</span></span> sits at the top of a hierarchy of subkinds &mdash; that is,
the kinds allowed to have subkinds are <span class="extract"><span class="extract-syntax">object</span></span> itself, subkinds of <span class="extract"><span class="extract-syntax">object</span></span>,
their subkinds in turn, and so on. In a typical work of parser IF, <span class="extract"><span class="extract-syntax">woman</span></span>
is a subkind of <span class="extract"><span class="extract-syntax">person</span></span> which is a subkind of <span class="extract"><span class="extract-syntax">thing</span></span> which is a subkind of
<span class="extract"><span class="extract-syntax">object</span></span>. On the other hand, <span class="extract"><span class="extract-syntax">number</span></span> and <span class="extract"><span class="extract-syntax">text</span></span>, for example, have no subkinds.
This means that <span class="extract"><span class="extract-syntax">object</span></span> plays a unique role in the Inform type system, in a
way which pervades the compiler's source code. But the <a href="index.html" class="internal">kinds</a> module itself
takes no position on this, and <span class="extract"><span class="extract-syntax">object</span></span> (which need not even exist) plays no
special role here.
</p>

<p class="commentary">Indeed, by default there are no subkinds at all, unless the parent tool uses
the <span class="extract"><span class="extract-syntax">HIERARCHY_*_KINDS_CALLBACK</span></span> functions &mdash; see <a href="P-htitm.html" class="internal">How To Include This Module</a>.
For convenience, <a href="../kinds-test/index.html" class="internal">kinds-test</a> uses the same convention as Inform, i.e., that
only objects have subkinds.
</p>

<p class="commentary firstcommentary"><a id="SP19"></a><b>&#167;19. Making new kinds. </b>When we need a new <span class="extract"><span class="extract-syntax">kind *</span></span> value inside our code, what do we do? The
answer depends on how simple it is.
</p>

<ul class="items"><li>(a) If it's one of the standard built-in base kinds, we should just use a
preconstructed pointer: for example, <span class="extract"><span class="extract-syntax">K_number</span></span> can be used for <span class="extract"><span class="extract-syntax">number</span></span>.
See <a href="2-fk.html" class="internal">Familiar Kinds</a>.
</li><li>(b) And otherwise we call one of the functions <a href="2-knd.html#SP3" class="internal">Kinds::base_construction</a>.
<a href="2-knd.html#SP3_3" class="internal">Kinds::unary_construction</a> or <a href="2-knd.html#SP3_3" class="internal">Kinds::binary_construction</a>, according
to whether our constructor has arity 0, 1 or 2.
</li></ul>
<p class="commentary">For example, the following make valid representations of <span class="extract"><span class="extract-syntax">text</span></span>, <span class="extract"><span class="extract-syntax">list of numbers</span></span>
and <span class="extract"><span class="extract-syntax">relation of numbers to texts</span></span> respectively:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    K_text</span>
<span class="plain-syntax">    Kinds::unary_construction(CON_list_of, K_number)</span>
<span class="plain-syntax">    Kinds::binary_construction(CON_relation, K_number, K_text)</span>
</pre>
<p class="commentary">For the constructor values <span class="extract"><span class="extract-syntax">CON_list_of</span></span> and so on, again see <a href="2-fk.html" class="internal">Familiar Kinds</a>.
</p>

<p class="commentary firstcommentary"><a id="SP20"></a><b>&#167;20. Where kind constructors come from. </b>The built-in kind constructors, such as "number" or "list of K", are not really
built in. They are read in from configuration files &mdash; these are not written
in Inform source text, and look more like dictionaries of key-value pairs,
though they're simpler in syntax than XML.
</p>

<p class="commentary">Whole files can be read with <a href="4-kf.html#SP1" class="internal">KindFiles::load</a>, or individual commands
issued with <a href="4-kc.html#SP13" class="internal">KindCommands::despatch</a>.
</p>

<p class="commentary">Inform makes use of this by placing such files inside kits of Inter, because
in practice built-in kinds always need some run-time support written in Inter
code.
</p>

<p class="commentary firstcommentary"><a id="SP21"></a><b>&#167;21. Making new kind constructors. </b>When Inform acts on sentences like these:
</p>

<blockquote>
    <p>A weight is a kind of value. A mammal is a kind of animal.</p>
</blockquote>

<p class="commentary">it in fact makes new <a href="2-kc.html#SP2" class="internal">kind_constructor</a> objects, not new <a href="2-knd.html#SP1" class="internal">kind</a> objects.
</p>

<p class="commentary">"Weight" and "mammal" are base constructors, i.e., they have arity 0.
High-level Inform source is not currently able to define new constructors of
higher arity, though kind configuration files do.
</p>

<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprevoff">&#10094;</li><li class="progresscurrentchapter">P</li><li class="progresscurrent">wtmd</li><li class="progresssection"><a href="P-htitm.html">htitm</a></li><li class="progresschapter"><a href="1-km.html">1</a></li><li class="progresschapter"><a href="2-knd.html">2</a></li><li class="progresschapter"><a href="3-dmn.html">3</a></li><li class="progresschapter"><a href="4-kf.html">4</a></li><li class="progressnext"><a href="P-htitm.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

