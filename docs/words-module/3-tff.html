<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Text From Files</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-src/Figures/Inform.png" height=72">
</a></h1>
<ul><li><a href="../compiler.html">compiler tools</a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul><h2>Compiler Webs</h2><ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul><h2>Inbuild Modules</h2><ul>
<li><a href="../supervisor-module/index.html">supervisor</a></li>
</ul><h2>Inform7 Modules</h2><ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul><h2>Inter Modules</h2><ul>
<li><a href="../bytecode-module/index.html">bytecode</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul><h2>Shared Modules</h2><ul>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="index.html"><span class="selectedlink">words</span></a></li>
<li><a href="../html-module/index.html">html</a></li>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>

</ul>
		</nav>
		<main role="main">
		
<!--Weave of 'Text From Files' generated by 7-->
<ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../compiler.html">Shared Modules</a></li><li><a href="index.html">words</a></li><li><a href="index.html#3">Chapter 3: Words in Sequence</a></li><li><b>Text From Files</b></li></ul><p class="purpose">This is where source text is read in, whether from extension files or from the main source text file, and fed into the lexer.</p>

<ul class="toc"><li><a href="3-tff.html#SP1">&#167;1. Source files</a></li><li><a href="3-tff.html#SP2">&#167;2. Feeding whole files into the lexer</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Source files. </b>Each separate file of text read into the lexer has its identity docketed
in a <code class="display"><span class="extract">source_file</span></code> structure, as follows.
</p>

<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">source_file</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">filename</span><span class="plain"> *</span><span class="identifier">name</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">words_of_source</span><span class="plain">; </span><span class="comment"> word count, omitting comments and verbatim matter</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">wording</span><span class="plain"> </span><span class="identifier">text_read</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">words_of_quoted_text</span><span class="plain">; </span><span class="comment"> word count for text in double-quotes</span>
        <span class="reserved">FILE</span><span class="plain"> *</span><span class="identifier">handle</span><span class="plain">; </span><span class="comment"> file handle while open</span>
        <span class="identifier">general_pointer</span><span class="plain"> </span><span class="identifier">your_ref</span><span class="plain">; </span><span class="comment"> for the client to attach some meaning</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">source_file</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure source_file is private to this section.</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Feeding whole files into the lexer. </b>This is one of the two feeder routines for the lexer, the other being in
Lexical Writing Back.w: see Lexer.w for its obligations.
</p>

<p class="inwebparagraph">We feed characters from an open file into the lexer, and continue until there
is nothing left in it. Inform is used on operating systems which between them
use all four of the sequences <code class="display"><span class="extract">0a</span></code>, <code class="display"><span class="extract">0d</span></code>, <code class="display"><span class="extract">0a0d</span></code> and <code class="display"><span class="extract">0d0a</span></code> to divide lines in
text files, so each of these is converted to a single <code class="display"><span class="extract">'\n'</span></code>. Tabs are treated
as if spaces in most contexts, but not when parsing formatted tables, for
instance, so they are not similarly converted.
</p>

<pre class="display">
    <span class="reserved">source_file</span><span class="plain"> *</span><span class="functiontext">TextFromFiles::feed_open_file_into_lexer<button class="popup" onclick="togglePopup('usagePopup110')">...<span class="popuptext" id="usagePopup110">Usage of <b>TextFromFiles::feed_open_file_into_lexer</b>:<br><a href="3-tff.html#SP3">&#167;3</a></span></button></span><span class="plain">(</span><span class="identifier">filename</span><span class="plain"> *</span><span class="identifier">F</span><span class="plain">, </span><span class="reserved">FILE</span><span class="plain"> *</span><span class="identifier">handle</span><span class="plain">,</span>
        <span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">leaf</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">documentation_only</span><span class="plain">, </span><span class="identifier">general_pointer</span><span class="plain"> </span><span class="identifier">ref</span><span class="plain">) {</span>
        <span class="reserved">source_file</span><span class="plain"> *</span><span class="identifier">sf</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">source_file</span><span class="plain">);</span>
        <span class="identifier">sf</span><span class="plain">-&gt;</span><span class="element">words_of_source</span><span class="plain"> = </span><span class="constant">0</span><span class="plain">;</span>
        <span class="identifier">sf</span><span class="plain">-&gt;</span><span class="element">words_of_quoted_text</span><span class="plain"> = </span><span class="constant">0</span><span class="plain">;</span>
        <span class="identifier">sf</span><span class="plain">-&gt;</span><span class="element">your_ref</span><span class="plain"> = </span><span class="identifier">ref</span><span class="plain">;</span>
        <span class="identifier">sf</span><span class="plain">-&gt;</span><span class="element">name</span><span class="plain"> = </span><span class="identifier">F</span><span class="plain">;</span>
        <span class="identifier">sf</span><span class="plain">-&gt;</span><span class="element">handle</span><span class="plain"> = </span><span class="identifier">handle</span><span class="plain">;</span>
        <span class="reserved">source_location</span><span class="plain"> </span><span class="identifier">top_of_file</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">cr</span><span class="plain">, </span><span class="identifier">last_cr</span><span class="plain">, </span><span class="identifier">next_cr</span><span class="plain">, </span><span class="identifier">read_cr</span><span class="plain">, </span><span class="identifier">newline_char</span><span class="plain"> = </span><span class="constant">0</span><span class="plain">;</span>

        <span class="identifier">unicode_file_buffer</span><span class="plain"> </span><span class="identifier">ufb</span><span class="plain"> = </span><span class="identifier">TextFiles::create_ufb</span><span class="plain">();</span>

        <span class="identifier">top_of_file</span><span class="plain">.</span><span class="element">file_of_origin</span><span class="plain"> = </span><span class="identifier">sf</span><span class="plain">;</span>
        <span class="identifier">top_of_file</span><span class="plain">.</span><span class="element">line_number</span><span class="plain"> = </span><span class="constant">1</span><span class="plain">;</span>

        <span class="functiontext"><a href="3-lxr.html#SP24">Lexer::feed_begins</a></span><span class="plain">(</span><span class="identifier">top_of_file</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">documentation_only</span><span class="plain">) </span><span class="identifier">lexer_wait_for_dashes</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>

        <span class="identifier">last_cr</span><span class="plain"> = </span><span class="character">' '</span><span class="plain">; </span><span class="identifier">cr</span><span class="plain"> = </span><span class="character">' '</span><span class="plain">; </span><span class="identifier">next_cr</span><span class="plain"> = </span><span class="identifier">TextFiles::utf8_fgetc</span><span class="plain">(</span><span class="identifier">sf</span><span class="plain">-&gt;</span><span class="element">handle</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, &amp;</span><span class="identifier">ufb</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">next_cr</span><span class="plain"> == </span><span class="constant">0xFEFF</span><span class="plain">) </span><span class="identifier">next_cr</span><span class="plain"> = </span><span class="identifier">TextFiles::utf8_fgetc</span><span class="plain">(</span><span class="identifier">sf</span><span class="plain">-&gt;</span><span class="element">handle</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, &amp;</span><span class="identifier">ufb</span><span class="plain">); </span><span class="comment"> Unicode BOM code</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">next_cr</span><span class="plain"> != </span><span class="identifier">EOF</span><span class="plain">)</span>
            <span class="reserved">while</span><span class="plain"> (((</span><span class="identifier">read_cr</span><span class="plain"> = </span><span class="identifier">TextFiles::utf8_fgetc</span><span class="plain">(</span><span class="identifier">sf</span><span class="plain">-&gt;</span><span class="element">handle</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, &amp;</span><span class="identifier">ufb</span><span class="plain">)), </span><span class="identifier">next_cr</span><span class="plain">) != </span><span class="identifier">EOF</span><span class="plain">) {</span>
                <span class="identifier">last_cr</span><span class="plain"> = </span><span class="identifier">cr</span><span class="plain">; </span><span class="identifier">cr</span><span class="plain"> = </span><span class="identifier">next_cr</span><span class="plain">; </span><span class="identifier">next_cr</span><span class="plain"> = </span><span class="identifier">read_cr</span><span class="plain">;</span>
                <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">cr</span><span class="plain">) {</span>
                    <span class="reserved">case</span><span class="plain"> </span><span class="character">'\x0a'</span><span class="plain">:</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">newline_char</span><span class="plain"> == </span><span class="character">'\x0d'</span><span class="plain">) {</span>
                            <span class="identifier">newline_char</span><span class="plain"> = </span><span class="constant">0</span><span class="plain">; </span><span class="reserved">continue</span><span class="plain">; </span><span class="comment"> suppress <code class="display"><span class="extract">0x000A</span></code> when it follows <code class="display"><span class="extract">0x000D</span></code></span>
                        <span class="plain">}</span>
                        <span class="identifier">newline_char</span><span class="plain"> = </span><span class="identifier">cr</span><span class="plain">; </span><span class="identifier">cr</span><span class="plain"> = </span><span class="character">'\n'</span><span class="plain">; /* </span><span class="identifier">and</span><span class="plain"> </span><span class="identifier">otherwise</span><span class="plain"> </span><span class="identifier">convert</span><span class="plain"> </span><span class="identifier">to</span><span class="plain"> |</span><span class="character">'\n'</span><span class="plain">| */</span>
                        <span class="reserved">break</span><span class="plain">;</span>
                    <span class="reserved">case</span><span class="plain"> </span><span class="character">'\x0d'</span><span class="plain">:</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">newline_char</span><span class="plain"> == </span><span class="character">'\x0a'</span><span class="plain">) {</span>
                            <span class="identifier">newline_char</span><span class="plain"> = </span><span class="constant">0</span><span class="plain">; </span><span class="reserved">continue</span><span class="plain">; </span><span class="comment"> suppress <code class="display"><span class="extract">0x000D</span></code> when it follows <code class="display"><span class="extract">0x000A</span></code></span>
                        <span class="plain">}</span>
                        <span class="identifier">newline_char</span><span class="plain"> = </span><span class="identifier">cr</span><span class="plain">; </span><span class="identifier">cr</span><span class="plain"> = </span><span class="character">'\n'</span><span class="plain">; /* </span><span class="identifier">and</span><span class="plain"> </span><span class="identifier">otherwise</span><span class="plain"> </span><span class="identifier">convert</span><span class="plain"> </span><span class="identifier">to</span><span class="plain"> |</span><span class="character">'\n'</span><span class="plain">| */</span>
                        <span class="reserved">break</span><span class="plain">;</span>
                    <span class="identifier">default:</span>
                        <span class="identifier">newline_char</span><span class="plain"> = </span><span class="constant">0</span><span class="plain">;</span>
                        <span class="reserved">break</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="functiontext"><a href="3-lxr.html#SP25">Lexer::feed_triplet</a></span><span class="plain">(</span><span class="identifier">last_cr</span><span class="plain">, </span><span class="identifier">cr</span><span class="plain">, </span><span class="identifier">next_cr</span><span class="plain">);</span>
            <span class="plain">}</span>

        <span class="identifier">sf</span><span class="plain">-&gt;</span><span class="element">text_read</span><span class="plain"> = </span><span class="functiontext"><a href="3-lxr.html#SP24">Lexer::feed_ends</a></span><span class="plain">(</span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">leaf</span><span class="plain">);</span>

        &lt;<span class="cwebmacro">Word count the new material</span> <span class="cwebmacronumber">2.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">sf</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2_1"></a><b>&#167;2.1.  </b>We word count all source files, both as to their source text and their
quoted text (i.e., their text within double-quotes).
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Word count the new material</span> <span class="cwebmacronumber">2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">wc</span><span class="plain">, </span><span class="identifier">sf</span><span class="plain">-&gt;</span><span class="element">text_read</span><span class="plain">)</span>
            <span class="identifier">sf</span><span class="plain">-&gt;</span><span class="element">words_of_source</span><span class="plain"> += </span><span class="functiontext"><a href="3-tff.html#SP4">TextFromFiles::word_count</a></span><span class="plain">(</span><span class="identifier">wc</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="3-tff.html#SP2">&#167;2</a>.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>A much simpler version:
</p>

<pre class="display">
    <span class="reserved">source_file</span><span class="plain"> *</span><span class="functiontext">TextFromFiles::feed_into_lexer<button class="popup" onclick="togglePopup('usagePopup111')">...<span class="popuptext" id="usagePopup111">Usage of <b>TextFromFiles::feed_into_lexer</b>:<br>none</span></button></span><span class="plain">(</span><span class="identifier">filename</span><span class="plain"> *</span><span class="identifier">F</span><span class="plain">, </span><span class="identifier">general_pointer</span><span class="plain"> </span><span class="identifier">ref</span><span class="plain">) {</span>
        <span class="reserved">FILE</span><span class="plain"> *</span><span class="identifier">handle</span><span class="plain"> = </span><span class="identifier">Filenames::fopen</span><span class="plain">(</span><span class="identifier">F</span><span class="plain">, </span><span class="string">"r"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">handle</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">source_file</span><span class="plain"> *</span><span class="identifier">sf</span><span class="plain"> = </span><span class="functiontext"><a href="3-tff.html#SP2">TextFromFiles::feed_open_file_into_lexer</a></span><span class="plain">(</span><span class="identifier">F</span><span class="plain">, </span><span class="identifier">handle</span><span class="plain">,</span>
            <span class="identifier">Filenames::get_leafname</span><span class="plain">(</span><span class="identifier">F</span><span class="plain">), </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">ref</span><span class="plain">);</span>
        <span class="identifier">fclose</span><span class="plain">(</span><span class="identifier">handle</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">sf</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b></p>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">TextFromFiles::word_count<button class="popup" onclick="togglePopup('usagePopup112')">...<span class="popuptext" id="usagePopup112">Usage of <b>TextFromFiles::word_count</b>:<br><a href="3-tff.html#SP2_1">&#167;2.1</a></span></button></span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">wc</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">N</span><span class="plain"> = </span><span class="constant">0</span><span class="plain">;</span>
        <span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="functiontext"><a href="3-lxr.html#SP18">Lexer::word_text</a></span><span class="plain">(</span><span class="identifier">wc</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (*</span><span class="identifier">p</span><span class="plain"> == </span><span class="character">'"'</span><span class="plain">) {</span>
            <span class="comment"> inside quoted text, each run of non-whitespace counts as 1 word</span>
            <span class="identifier">p</span><span class="plain">++; </span><span class="comment"> skip opening quotation mark</span>
            <span class="reserved">while</span><span class="plain"> (*</span><span class="identifier">p</span><span class="plain"> != </span><span class="constant">0</span><span class="plain">) {</span>
                <span class="reserved">while</span><span class="plain"> ((*</span><span class="identifier">p</span><span class="plain"> == </span><span class="character">' '</span><span class="plain">) || (*</span><span class="identifier">p</span><span class="plain"> == </span><span class="identifier">NEWLINE_IN_STRING</span><span class="plain">)) </span><span class="identifier">p</span><span class="plain">++; /* </span><span class="identifier">move</span><span class="plain"> </span><span class="identifier">past</span><span class="plain"> </span><span class="identifier">white</span><span class="plain"> </span><span class="identifier">space</span><span class="plain"> */</span>
                <span class="reserved">if</span><span class="plain"> ((*</span><span class="identifier">p</span><span class="plain"> == </span><span class="character">'"'</span><span class="plain">) || (*</span><span class="identifier">p</span><span class="plain"> == </span><span class="constant">0</span><span class="plain">)) </span><span class="reserved">break</span><span class="plain">; /* </span><span class="identifier">stop</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> </span><span class="identifier">this</span><span class="plain"> </span><span class="identifier">reaches</span><span class="plain"> </span><span class="identifier">the</span><span class="plain"> </span><span class="identifier">end</span><span class="plain"> */</span>
                <span class="identifier">N</span><span class="plain">++; </span><span class="comment"> otherwise we have a word</span>
                <span class="reserved">while</span><span class="plain"> ((*</span><span class="identifier">p</span><span class="plain"> != </span><span class="character">' '</span><span class="plain">) &amp;&amp; (*</span><span class="identifier">p</span><span class="plain"> != </span><span class="identifier">NEWLINE_IN_STRING</span><span class="plain">)</span>
                    <span class="plain">&amp;&amp; (*</span><span class="identifier">p</span><span class="plain"> != </span><span class="character">'"'</span><span class="plain">) &amp;&amp; (*</span><span class="identifier">p</span><span class="plain"> != </span><span class="constant">0</span><span class="plain">)) </span><span class="identifier">p</span><span class="plain">++; /* </span><span class="identifier">move</span><span class="plain"> </span><span class="identifier">to</span><span class="plain"> </span><span class="identifier">white</span><span class="plain"> </span><span class="identifier">space</span><span class="plain"> </span><span class="identifier">or</span><span class="plain"> </span><span class="identifier">end</span><span class="plain"> */</span>
            <span class="plain">}</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="comment"> outside quoted text, each lexer word not wholly composed of punctuation scores 1</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext"><a href="3-lxr.html#SP18">Lexer::word</a></span><span class="plain">(</span><span class="identifier">wc</span><span class="plain">) != </span><span class="identifier">PARBREAK_V</span><span class="plain">)</span>
                <span class="reserved">for</span><span class="plain"> (; *</span><span class="identifier">p</span><span class="plain"> != </span><span class="constant">0</span><span class="plain">; </span><span class="identifier">p</span><span class="plain">++)</span>
                    <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext"><a href="3-lxr.html#SP16">Lexer::is_punctuation</a></span><span class="plain">(*</span><span class="identifier">p</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (*</span><span class="identifier">p</span><span class="plain"> != </span><span class="character">'|'</span><span class="plain">)) {</span>
                        <span class="identifier">N</span><span class="plain">++;</span>
                        <span class="reserved">break</span><span class="plain">;</span>
                    <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">N</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>At present, though, the only use made of these two word counts is via
the following routine, which combines them into one.
</p>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">TextFromFiles::total_word_count<button class="popup" onclick="togglePopup('usagePopup113')">...<span class="popuptext" id="usagePopup113">Usage of <b>TextFromFiles::total_word_count</b>:<br>none</span></button></span><span class="plain">(</span><span class="reserved">source_file</span><span class="plain"> *</span><span class="identifier">sf</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sf</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">0</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">sf</span><span class="plain">-&gt;</span><span class="identifier">words_of_source</span><span class="plain"> + </span><span class="identifier">sf</span><span class="plain">-&gt;</span><span class="identifier">words_of_quoted_text</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">TextFromFiles::last_lexed_word<button class="popup" onclick="togglePopup('usagePopup114')">...<span class="popuptext" id="usagePopup114">Usage of <b>TextFromFiles::last_lexed_word</b>:<br>none</span></button></span><span class="plain">(</span><span class="reserved">source_file</span><span class="plain"> *</span><span class="identifier">sf</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext"><a href="3-wrd.html#SP8">Wordings::last_wn</a></span><span class="plain">(</span><span class="identifier">sf</span><span class="plain">-&gt;</span><span class="element">text_read</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>Finally, we translate between the tiresomely many representations of
files we seem to be stuck with. The method used by <code class="display"><span class="extract">TextFromFiles::filename_to_source_file</span></code>
looks vulnerable to case-insensitive filename issues, but isn't, because
each filename is present in Inform in only one form.
</p>

<pre class="display">
    <span class="identifier">filename</span><span class="plain"> *</span><span class="functiontext">TextFromFiles::get_filename<button class="popup" onclick="togglePopup('usagePopup115')">...<span class="popuptext" id="usagePopup115">Usage of <b>TextFromFiles::get_filename</b>:<br>none</span></button></span><span class="plain">(</span><span class="reserved">source_file</span><span class="plain"> *</span><span class="identifier">sf</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sf</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to read filename of null source file"</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">sf</span><span class="plain">-&gt;</span><span class="identifier">name</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">source_file</span><span class="plain"> *</span><span class="functiontext">TextFromFiles::filename_to_source_file<button class="popup" onclick="togglePopup('usagePopup116')">...<span class="popuptext" id="usagePopup116">Usage of <b>TextFromFiles::filename_to_source_file</b>:<br>none</span></button></span><span class="plain">(</span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">name2</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">l2</span><span class="plain"> = </span><span class="identifier">Str::len</span><span class="plain">(</span><span class="identifier">name2</span><span class="plain">);</span>
        <span class="reserved">source_file</span><span class="plain"> *</span><span class="identifier">sf</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">sf</span><span class="plain">, </span><span class="reserved">source_file</span><span class="plain">) {</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">name1</span><span class="plain">);</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">name1</span><span class="plain">, </span><span class="string">"%f"</span><span class="plain">, </span><span class="identifier">sf</span><span class="plain">-&gt;</span><span class="element">name</span><span class="plain">);</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">l1</span><span class="plain"> = </span><span class="identifier">Str::len</span><span class="plain">(</span><span class="identifier">name1</span><span class="plain">);</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">minl</span><span class="plain"> = (</span><span class="identifier">l1</span><span class="plain">&lt;</span><span class="identifier">l2</span><span class="plain">)?</span><span class="identifier">l1:l2</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Str::suffix_eq</span><span class="plain">(</span><span class="identifier">name1</span><span class="plain">, </span><span class="identifier">name2</span><span class="plain">, </span><span class="identifier">minl</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">sf</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="3-wrd.html">Back to 'Wordings'</a></li><li><a href="3-fds.html">Continue with 'Feeds'</a></li></ul><hr class="tocbar">
<!--End of weave-->
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
		</main>
	</body>
</html>

