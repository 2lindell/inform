<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Terms</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
MathJax = {
	tex: {
		inlineMath: '$', '$'], ['\\(', '\\)'
	},
	svg: {
		fontCache: 'global'
	}
};
</script>
<script type="text/javascript" id="MathJax-script" async
	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script src="http://code.jquery.com/jquery-1.12.4.min.js"
	integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>

<script src="../docs-assets/Bigfoot.js"></script>
<link href="../docs-assets/Bigfoot.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../compiler.html">compiler tools</a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul><h2>Compiler Webs</h2><ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul><h2>Inbuild Modules</h2><ul>
<li><a href="../supervisor-module/index.html">supervisor</a></li>
</ul><h2>Inform7 Modules</h2><ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul><h2>Inter Modules</h2><ul>
<li><a href="../bytecode-module/index.html">bytecode</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul><h2>Services</h2><ul>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="index.html"><span class="selectedlink">calculus</span></a></li>
<li><a href="../html-module/index.html">html</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Terms' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../compiler.html">Services</a></li><li><a href="index.html">calculus</a></li><li><a href="index.html#3">Chapter 3: Propositions</a></li><li><b>Terms</b></li></ul></div>
<p class="purpose">Terms are the representations of values in predicate calculus: variables, constants or functions of other terms.</p>

<ul class="toc"><li><a href="3-trm.html#SP1">&#167;1. About terms</a></li><li><a href="3-trm.html#SP4">&#167;4. Creating new terms</a></li><li><a href="3-trm.html#SP5">&#167;5. Copying</a></li><li><a href="3-trm.html#SP6">&#167;6. Variable letters</a></li><li><a href="3-trm.html#SP8">&#167;8. Underlying terms</a></li><li><a href="3-trm.html#SP9">&#167;9. Adjective-noun conversions</a></li><li><a href="3-trm.html#SP11">&#167;11. Compiling terms</a></li><li><a href="3-trm.html#SP12">&#167;12. Writing to text</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. About terms. </b>A "term" can be a constant, a variable, or a function of another term: see
<a href="P-wtmd.html" class="internal">What This Module Does</a>. Our data structure therefore falls into three
cases. At all times exactly one of the three relevant fields, <span class="extract"><span class="extract-syntax">variable</span></span>,
<span class="extract"><span class="extract-syntax">constant</span></span> and <span class="extract"><span class="extract-syntax">function</span></span> is used.
</p>

<ul class="items"><li>(a) Variables are represented by the numbers 0 to 25, and <span class="extract"><span class="extract-syntax">-1</span></span> means
"not a variable".
</li><li>(b) Constants are pointers to <span class="extract"><span class="extract-syntax">specification</span></span> structures of main
type <span class="extract"><span class="extract-syntax">VALUE</span></span>, and <span class="extract"><span class="extract-syntax">NULL</span></span> means "not a constant".
</li><li>(c) Functions are pointers to <span class="extract"><span class="extract-syntax">pcalc_func</span></span> structures (see below), and
<span class="extract"><span class="extract-syntax">NULL</span></span> means "not a function".
</li></ul>
<p class="commentary">Cinders are discussed in <a href="../core-module/12-cad.html" class="internal">Cinders and Deferrals (in core)</a>, and can be ignored for now.
</p>

<p class="commentary">In order to verify that a proposition makes sense and does not mix up
incompatible kinds of value, we will need to type-check it, and one part
of that involves assigning a kind of value \(K\) to every term \(t\) occurring
in the proposition. This calculation does involve some work, so we cache
the result in the <span class="extract"><span class="extract-syntax">term_checked_as_kind</span></span> field.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">variable</span><span class="plain-syntax">; </span><span class="comment-syntax"> 0 to 25, or </span><span class="extract"><span class="extract-syntax">-1</span></span><span class="comment-syntax"> for "not a variable"</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">constant</span><span class="plain-syntax">; </span><span class="comment-syntax"> or </span><span class="extract"><span class="extract-syntax">NULL</span></span><span class="comment-syntax"> for "not a constant"</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">pcalc_func</span><span class="plain-syntax"> *</span><span class="identifier-syntax">function</span><span class="plain-syntax">; </span><span class="comment-syntax"> or </span><span class="extract"><span class="extract-syntax">NULL</span></span><span class="comment-syntax"> for "not a function of another term"</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">cinder</span><span class="plain-syntax">; </span><span class="comment-syntax"> complicated, this: used to worry about scope of I6 local variables</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">term_checked_as_kind</span><span class="plain-syntax">; </span><span class="comment-syntax"> or </span><span class="extract"><span class="extract-syntax">NULL</span></span><span class="comment-syntax"> if unchecked</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>The structure pcalc_term is accessed in 2/cs, 3/ap, 3/prp, 3/bas, 3/tcp, 3/smp and here.</li></ul>
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2.  </b>The <span class="extract"><span class="extract-syntax">pcalc_func</span></span> structure represents a usage of a function inside a term.
Terms such as \(f_A(f_B(f_C(x)))\) often occur, an example which would be stored
as:
</p>

<ul class="items"><li>(1) A <span class="extract"><span class="extract-syntax">pcalc_term</span></span> structure which has a <span class="extract"><span class="extract-syntax">function</span></span> field pointing to
</li><li>(2) A <span class="extract"><span class="extract-syntax">pcalc_func</span></span> structure whose <span class="extract"><span class="extract-syntax">bp</span></span> field points to A, and whose <span class="extract"><span class="extract-syntax">fn_of</span></span>
field is
</li><li>(3) A <span class="extract"><span class="extract-syntax">pcalc_term</span></span> structure which has a <span class="extract"><span class="extract-syntax">function</span></span> field pointing to
</li><li>(4) A <span class="extract"><span class="extract-syntax">pcalc_func</span></span> structure whose <span class="extract"><span class="extract-syntax">bp</span></span> field points to B, and whose <span class="extract"><span class="extract-syntax">fn_of</span></span>
field is
</li><li>(5) A <span class="extract"><span class="extract-syntax">pcalc_term</span></span> structure which has a <span class="extract"><span class="extract-syntax">function</span></span> field pointing to
</li><li>(6) A <span class="extract"><span class="extract-syntax">pcalc_func</span></span> structure whose <span class="extract"><span class="extract-syntax">bp</span></span> field points to C, and whose <span class="extract"><span class="extract-syntax">fn_of</span></span>
field is
</li><li>(7) A <span class="extract"><span class="extract-syntax">pcalc_term</span></span> structure which has a <span class="extract"><span class="extract-syntax">variable</span></span> field set to 0 (which is \(x\)).
</li></ul>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">pcalc_func</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax">; </span><span class="comment-syntax"> the predicate B</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">from_term</span><span class="plain-syntax">; </span><span class="comment-syntax"> which term of the predicate this derives from</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">fn_of</span><span class="plain-syntax">; </span><span class="comment-syntax"> the term to which we apply the function</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">pcalc_func</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>The structure pcalc_func is accessed in 3/bas, 3/tcp, 3/smp and here.</li></ul>
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3.  </b>Terms are really quite simple, as the following <a href="../calculus-test/index.html" class="internal">calculus-test</a> exercise shows:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">'</span><span class="element-syntax">new binary sees (none, sees-f1)</span><span class="plain-syntax">':</span><span class="string-syntax"> ok</span>
<span class="plain-syntax">'</span><span class="element-syntax">new binary knows (knows-f0, none)</span><span class="plain-syntax">':</span><span class="string-syntax"> ok</span>
<span class="plain-syntax">'</span><span class="element-syntax">term 7</span><span class="plain-syntax">':</span><span class="string-syntax"> '7'</span>
<span class="plain-syntax">'</span><span class="element-syntax">term z</span><span class="plain-syntax">':</span><span class="string-syntax"> z</span>
<span class="plain-syntax">'</span><span class="element-syntax">term sees-f1 (7)</span><span class="plain-syntax">':</span><span class="string-syntax"> &lt;sees-f1(*1) : '7'&gt;</span>
<span class="plain-syntax">'</span><span class="element-syntax">term knows-f0 (sees-f1 (x))</span><span class="plain-syntax">':</span><span class="string-syntax"> &lt;knows-f0(*1) : &lt;sees-f1(*1) : x&gt;&gt;</span>
<span class="plain-syntax">'</span><span class="element-syntax">constant underlying 7</span><span class="plain-syntax">':</span><span class="string-syntax"> '7'</span>
<span class="plain-syntax">'</span><span class="element-syntax">constant underlying y</span><span class="plain-syntax">':</span><span class="string-syntax"> --</span>
<span class="plain-syntax">'</span><span class="element-syntax">constant underlying sees-f1 (7)</span><span class="plain-syntax">':</span><span class="string-syntax"> '7'</span>
<span class="plain-syntax">'</span><span class="element-syntax">variable underlying 7</span><span class="plain-syntax">':</span><span class="string-syntax"> --</span>
<span class="plain-syntax">'</span><span class="element-syntax">variable underlying y</span><span class="plain-syntax">':</span><span class="string-syntax"> y</span>
<span class="plain-syntax">'</span><span class="element-syntax">variable underlying knows-f0 (sees-f1 (x))</span><span class="plain-syntax">':</span><span class="string-syntax"> x</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4. Creating new terms. </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="function-syntax">Terms::new_variable</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">Terms::new_variable</span></span>:<br/><a href="3-trm.html#SP9">&#167;9</a><br/>The Adjectival Predicates - <a href="2-tap.html#SP2">&#167;2</a><br/>Atomic Propositions - <a href="3-ap.html#SP6">&#167;6</a>, <a href="3-ap.html#SP11">&#167;11</a><br/>Propositions - <a href="3-prp.html#SP28">&#167;28</a>, <a href="3-prp.html#SP29">&#167;29</a><br/>Simplifications - <a href="3-smp.html#SP2_2">&#167;2.2</a>, <a href="3-smp.html#SP3">&#167;3</a>, <a href="3-smp.html#SP7">&#167;7</a>, <a href="3-smp.html#SP9_3_2">&#167;9.3.2</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">v</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">pt</span><span class="plain-syntax">; </span><span class="named-paragraph-container code-font"><a href="3-trm.html#SP4_1" class="named-paragraph-link"><span class="named-paragraph">Make new blank term structure pt</span><span class="named-paragraph-number">4.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">v</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">v</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">26</span><span class="plain-syntax">)) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"bad variable term created"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">variable</span><span class="plain-syntax"> = </span><span class="identifier-syntax">v</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">pt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="function-syntax">Terms::new_constant</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">Terms::new_constant</span></span>:<br/><a href="3-trm.html#SP9">&#167;9</a><br/>Compilation Schemas - <a href="2-cs.html#SP6">&#167;6</a>, <a href="2-cs.html#SP8">&#167;8</a><br/>Atomic Propositions - <a href="3-ap.html#SP11">&#167;11</a><br/>Propositions - <a href="3-prp.html#SP29">&#167;29</a><br/>Binding and Substitution - <a href="3-bas.html#SP15">&#167;15</a><br/>Simplifications - <a href="3-smp.html#SP3">&#167;3</a>, <a href="3-smp.html#SP14">&#167;14</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">c</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">pt</span><span class="plain-syntax">; </span><span class="named-paragraph-container code-font"><a href="3-trm.html#SP4_1" class="named-paragraph-link"><span class="named-paragraph">Make new blank term structure pt</span><span class="named-paragraph-number">4.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">constant</span><span class="plain-syntax"> = </span><span class="identifier-syntax">c</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">pt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="function-syntax">Terms::new_function</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">Terms::new_function</span></span>:<br/><a href="3-trm.html#SP5">&#167;5</a><br/>Simplifications - <a href="3-smp.html#SP12">&#167;12</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax">, </span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">ptof</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">t</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">t</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">t</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">MAX_ATOM_ARITY</span><span class="plain-syntax">)) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"term out of range"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">pt</span><span class="plain-syntax">; </span><span class="named-paragraph-container code-font"><a href="3-trm.html#SP4_1" class="named-paragraph-link"><span class="named-paragraph">Make new blank term structure pt</span><span class="named-paragraph-number">4.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">pcalc_func</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pf</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">pcalc_func</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pf</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">bp</span><span class="plain-syntax"> = </span><span class="identifier-syntax">bp</span><span class="plain-syntax">; </span><span class="identifier-syntax">pf</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">fn_of</span><span class="plain-syntax"> = </span><span class="identifier-syntax">ptof</span><span class="plain-syntax">; </span><span class="identifier-syntax">pf</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">from_term</span><span class="plain-syntax"> = </span><span class="identifier-syntax">t</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">function</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pf</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">pt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4_1" class="paragraph-anchor"></a><b>&#167;4.1.  </b>Where, in all three cases:
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make new blank term structure pt</span><span class="named-paragraph-number">4.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">variable</span><span class="plain-syntax"> = -1;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">constant</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">function</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">cinder</span><span class="plain-syntax"> = -1; </span><span class="comment-syntax"> that is, no cinder</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">term_checked_as_kind</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-trm.html#SP4">&#167;4</a> (three times).</li></ul>
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5. Copying. </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="function-syntax">Terms::copy</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">Terms::copy</span></span>:<br/>Propositions - <a href="3-prp.html#SP13">&#167;13</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">pt</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">constant</span><span class="plain-syntax">) </span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">constant</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">constant</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">function</span><span class="plain-syntax">) </span><span class="identifier-syntax">pt</span><span class="plain-syntax"> = </span><a href="3-trm.html#SP4" class="function-link"><span class="function-syntax">Terms::new_function</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">function</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">bp</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><a href="3-trm.html#SP5" class="function-link"><span class="function-syntax">Terms::copy</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">function</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">fn_of</span><span class="plain-syntax">), </span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">function</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">from_term</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">pt</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6. Variable letters. </b>The number 26 turns up quite often in this chapter, and while it's normally
good style to define named constants, here we're not going to. 26 is a number
which anyone<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> will immediately associate with the size of the alphabet.
Moreover, we can't really raise the total, because we will want to compile
these with single-character identifier names, <span class="extract"><span class="extract-syntax">a</span></span> to <span class="extract"><span class="extract-syntax">z</span></span>.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> To have a
variable limit lower than 26 would be artificial, since there are no memory
constraints arguing for it; but a proposition with 27 or more variables would
be too huge to evaluate at run-time in any remotely plausible length of time.
So although the 26-variables-only limit is embedded in Inform, it really is
not any restriction, and it greatly simplifies the code.
</p>

<ul class="footnotetexts"><li class="footnote" id="fn:1"><p class="inwebfootnote"><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> Well, perhaps not a string theorist. "There aren't enough small numbers to
meet the many demands made of them" (Richard Guy).
<a href="#fnref:1" title="return to text"> &#x21A9;</a></p></li><li class="footnote" id="fn:2"><p class="inwebfootnote"><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> Strictly speaking there is also <span class="extract"><span class="extract-syntax">_</span></span>, but we won't go there.
<a href="#fnref:2" title="return to text"> &#x21A9;</a></p></li></ul>
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7.  </b>The variables 0 to 25 are referred to by the letters \(x, y, z, a, b, c, ..., w\),
as provided for by this lookup array:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">char</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pcalc_vars</span><span class="plain-syntax"> = </span><span class="string-syntax">"xyzabcdefghijklmnopqrstuvw"</span><span class="plain-syntax">;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8. Underlying terms. </b>Routines to see if a term is a constant \(C\), or if it is a chain of functions
at the bottom of which is a constant \(C\); and similarly for variables.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">Terms::constant_underlying</span><button class="popup" onclick="togglePopup('usagePopup5')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup5">Usage of <span class="code-font"><span class="function-syntax">Terms::constant_underlying</span></span>:<br/>Type Check Propositions - <a href="3-tcp.html#SP4_1">&#167;4.1</a><br/>Simplifications - <a href="3-smp.html#SP2">&#167;2</a>, <a href="3-smp.html#SP3">&#167;3</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">t</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">t</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"null term"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">t</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">constant</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">t</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">constant</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">t</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">function</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="3-trm.html#SP8" class="function-link"><span class="function-syntax">Terms::constant_underlying</span></a><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">t</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">function</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">fn_of</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Terms::variable_underlying</span><button class="popup" onclick="togglePopup('usagePopup6')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup6">Usage of <span class="code-font"><span class="function-syntax">Terms::variable_underlying</span></span>:<br/>Propositions - <a href="3-prp.html#SP25">&#167;25</a>, <a href="3-prp.html#SP27">&#167;27</a><br/>Binding and Substitution - <a href="3-bas.html#SP1">&#167;1</a>, <a href="3-bas.html#SP7">&#167;7</a>, <a href="3-bas.html#SP13_1">&#167;13.1</a><br/>Simplifications - <a href="3-smp.html#SP13">&#167;13</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">t</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">t</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"null term"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">t</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">variable</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">t</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">variable</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">t</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">function</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="3-trm.html#SP8" class="function-link"><span class="function-syntax">Terms::variable_underlying</span></a><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">t</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">function</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">fn_of</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> -1;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9. Adjective-noun conversions. </b>As we shall see, a general unary predicate stores a type-reference
pointer to an adjectival phrase &mdash; the adjective it tests. But
sometimes the same word acts both as adjective and noun in English. In
"the green door", clearly "green" is an adjective; in "the door
is green", it is possibly a noun; in "the colour of the door is
green", it must surely be a noun. Yet these are all really the same
meaning. To cope with this ambiguity, we need a way to convert the
adjectival form of such an adjective into its noun form, and back
again.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">#</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="function-syntax">Terms::adj_to_noun_conversion</span><button class="popup" onclick="togglePopup('usagePopup7')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup7">Usage of <span class="code-font"><span class="function-syntax">Terms::adj_to_noun_conversion</span></span>:<br/>Propositions - <a href="3-prp.html#SP29">&#167;29</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">unary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">tr</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">aph</span><span class="plain-syntax"> = </span><a href="2-tap.html#SP4" class="function-link"><span class="function-syntax">AdjectivalPredicates::to_adjective</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">tr</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Adjectives::Meanings::has_ENUMERATIVE_meaning</span><span class="plain-syntax">(</span><span class="identifier-syntax">aph</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">I</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="3-trm.html#SP4" class="function-link"><span class="function-syntax">Terms::new_constant</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">Rvalues::from_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prn</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Adjectives::Meanings::has_EORP_meaning</span><span class="plain-syntax">(</span><span class="identifier-syntax">aph</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">prn</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="3-trm.html#SP4" class="function-link"><span class="function-syntax">Terms::new_constant</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">Rvalues::from_property</span><span class="plain-syntax">(</span><span class="identifier-syntax">prn</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="3-trm.html#SP4" class="function-link"><span class="function-syntax">Terms::new_variable</span></a><span class="plain-syntax">(0);</span>
<span class="plain-syntax">}</span>
<span class="plain-syntax">#</span><span class="identifier-syntax">endif</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10.  </b>And conversely:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">unary_predicate</span><span class="plain-syntax"> *</span><span class="function-syntax">Terms::noun_to_adj_conversion</span><button class="popup" onclick="togglePopup('usagePopup8')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup8">Usage of <span class="code-font"><span class="function-syntax">Terms::noun_to_adj_conversion</span></span>:<br/>Type Check Propositions - <a href="3-tcp.html#SP4_6">&#167;4.6</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">pt</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">C</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">constant</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">C</span><span class="plain-syntax">, </span><span class="identifier-syntax">CONSTANT_NT</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_kind_of_value</span><span class="plain-syntax">(</span><span class="identifier-syntax">C</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Properties::Conditions::get_coinciding_property</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">) == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::is_an_enumeration</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_constant_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">C</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="2-tap.html#SP2" class="function-link"><span class="function-syntax">AdjectivalPredicates::new_up</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">Instances::get_adjective</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP11" class="paragraph-anchor"></a><b>&#167;11. Compiling terms. </b>We are now ready to compile a general predicate-calculus term, which
may be a constant (perhaps with a cinder marking), a variable or a function
of another term.
</p>

<p class="commentary">Variables are compiled to I6 locals <span class="extract"><span class="extract-syntax">x</span></span>, <span class="extract"><span class="extract-syntax">y</span></span>, <span class="extract"><span class="extract-syntax">z</span></span>, ...; cindered constants to
<span class="extract"><span class="extract-syntax">const_0</span></span>, <span class="extract"><span class="extract-syntax">const_1</span></span>, ... These will only be valid inside a deferred routine
like <span class="extract"><span class="extract-syntax">Prop_19</span></span>, but that is fine because they cannot arise anywhere else.
If we are compiling an undeferred proposition then all constants are uncindered
and there are no variables (if there were, it would have been deferred).
</p>

<p class="commentary">Functions \(f_R(t)\) are compiled by expanding an I6 schema for \(f_R\) with \(t\)
as parameter.
</p>

<p class="commentary">One small wrinkle is that we type-check any use of a phrase to decide a
value, because this might not yet have been checked otherwise.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">#</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Terms::emit</span><button class="popup" onclick="togglePopup('usagePopup9')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup9">Usage of <span class="code-font"><span class="function-syntax">Terms::emit</span></span>:<br/>Compilation Schemas - <a href="2-cs.html#SP8">&#167;8</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">pt</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">variable</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">local_variable</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lvar</span><span class="plain-syntax"> = </span><span class="identifier-syntax">LocalVariables::find_pcalc_var</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">variable</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">lvar</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"var is %d\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">variable</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"absent calculus variable"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inter_symbol</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lvar_s</span><span class="plain-syntax"> = </span><span class="identifier-syntax">LocalVariables::declare_this</span><span class="plain-syntax">(</span><span class="identifier-syntax">lvar</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">8</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Produce::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">Emit::tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">lvar_s</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">constant</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">cinder</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Calculus::Deferrals::Cinders::emit</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">cinder</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">ParseTreeUsage::is_phrasal</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">constant</span><span class="plain-syntax">))</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Dash::check_value</span><span class="plain-syntax">(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">constant</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Specifications::Compiler::emit_as_val</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">constant</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="identifier-syntax">function</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">function</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">bp</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">i6_schema</span><span class="plain-syntax"> *</span><span class="identifier-syntax">fn</span><span class="plain-syntax"> = </span><a href="2-bp.html#SP35" class="function-link"><span class="function-syntax">BinaryPredicates::get_term_as_fn_of_other</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">bp</span><span class="plain-syntax">, </span><span class="constant-syntax">1</span><span class="plain-syntax">-</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">function</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">from_term</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">fn</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"function of non-functional predicate"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><a href="2-cs.html#SP6" class="function-link"><span class="function-syntax">Calculus::Schemas::emit_expand_from_terms</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">fn</span><span class="plain-syntax">, &amp;(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">.</span><span class="element-syntax">function</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">fn_of</span><span class="plain-syntax">), </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"Broken pcalc term"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
<span class="plain-syntax">#</span><span class="identifier-syntax">endif</span>
</pre>
<p class="commentary firstcommentary"><a id="SP12" class="paragraph-anchor"></a><b>&#167;12. Writing to text. </b>The art of this is to be unobtrusive; when a proposition is being logged,
we don't much care about the constant terms, and want to display them
concisely and without fuss.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Terms::log</span><button class="popup" onclick="togglePopup('usagePopup10')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup10">Usage of <span class="code-font"><span class="function-syntax">Terms::log</span></span>:<br/>Calculus Module - <a href="1-cm.html#SP3">&#167;3</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pt</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><a href="3-trm.html#SP12" class="function-link"><span class="function-syntax">Terms::write</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">DL</span><span class="plain-syntax">, </span><span class="identifier-syntax">pt</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Terms::write</span><button class="popup" onclick="togglePopup('usagePopup11')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup11">Usage of <span class="code-font"><span class="function-syntax">Terms::write</span></span>:<br/>Compilation Schemas - <a href="2-cs.html#SP10">&#167;10</a><br/>Atomic Propositions - <a href="3-ap.html#SP14_1">&#167;14.1</a>, <a href="3-ap.html#SP14_4">&#167;14.4</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pt</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"&lt;null-term&gt;"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">constant</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">C</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">constant</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cinder</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">0</span><span class="plain-syntax">) { </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"const_%d"</span><span class="plain-syntax">, </span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cinder</span><span class="plain-syntax">); </span><span class="reserved-syntax">return</span><span class="plain-syntax">; }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">C</span><span class="plain-syntax">))) { </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"'%W'"</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">C</span><span class="plain-syntax">)); </span><span class="reserved-syntax">return</span><span class="plain-syntax">; }</span>
<span class="plain-syntax">        #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">C</span><span class="plain-syntax">, </span><span class="identifier-syntax">CONSTANT_NT</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Rvalues::to_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">C</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">I</span><span class="plain-syntax">) { </span><span class="identifier-syntax">Instances::write</span><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">); </span><span class="reserved-syntax">return</span><span class="plain-syntax">; }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        #</span><span class="identifier-syntax">endif</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::log_node</span><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">C</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">function</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">function</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">bp</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">i6_schema</span><span class="plain-syntax"> *</span><span class="identifier-syntax">fn</span><span class="plain-syntax"> = </span><a href="2-bp.html#SP35" class="function-link"><span class="function-syntax">BinaryPredicates::get_term_as_fn_of_other</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">bp</span><span class="plain-syntax">, </span><span class="constant-syntax">1</span><span class="plain-syntax">-</span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">function</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">from_term</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">fn</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"function of non-functional predicate"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><a href="2-cs.html#SP10" class="function-link"><span class="function-syntax">Calculus::Schemas::write_applied</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">fn</span><span class="plain-syntax">, &amp;(</span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">function</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">fn_of</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">variable</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">j</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pt</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">variable</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">j</span><span class="plain-syntax">&lt;26) </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"%c"</span><span class="plain-syntax">, </span><span class="identifier-syntax">pcalc_vars</span><span class="plain-syntax">[</span><span class="identifier-syntax">j</span><span class="plain-syntax">]); </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"&lt;bad-var=%d&gt;"</span><span class="plain-syntax">, </span><span class="identifier-syntax">j</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"&lt;bad-term&gt;"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="2-ter.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-cm.html">1</a></li><li class="progresschapter"><a href="2-cs.html">2</a></li><li class="progresscurrentchapter">3</li><li class="progresscurrent">trm</li><li class="progresssection"><a href="3-ap.html">ap</a></li><li class="progresssection"><a href="3-prp.html">prp</a></li><li class="progresssection"><a href="3-bas.html">bas</a></li><li class="progresssection"><a href="3-tcp.html">tcp</a></li><li class="progresssection"><a href="3-smp.html">smp</a></li><li class="progressnext"><a href="3-ap.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

