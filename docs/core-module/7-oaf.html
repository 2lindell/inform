<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>7/ns</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '7/oaf' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#7">Chapter 7: Sentences</a></li><li><b>Of and From</b></li></ul><p class="purpose">To verify that "of" and "from" subtrees in assertion sentence noun phrases are validly used, and reconstruct their sentences without them if they are not.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP3">&#167;3. Tidying up ofs and from</a></li><li><a href="#SP5">&#167;5. Traversal 1</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>At this point in the narrative, the source text has been parsed into a
large parse tree in which every assertion is represented by a <code class="display"><span class="extract">SENTENCE_NT</span></code>
node. This is a child of the root of the tree, and its own children form
a subtree which parses it into a verb phrase and associated noun phrases.
Pretty well whenever it possibly could, the noun-phrase-maker created
<code class="display"><span class="extract">X_OF_Y_NT</span></code> subtrees in these noun phrases.
</p>

<p class="inwebparagraph">But <code class="display"><span class="extract">X_OF_Y_NT</span></code> nodes are valid only when describing a value
property associated with something ("description of the cards"), which
means that the noun-phrase-maker will have been wildly overzealous in
creating these. It had to be: it had no way of knowing, so early in
Inform's run, which handful of the many such nodes it made were actually
valid. It didn't know what the property names were, nor what the direction
names were. (For chicken-and-egg reasons, it couldn't know this.) So it
almost certainly made some spurious noun phrase subtrees like this one:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">X_OF_Y_NT "worn patch of carpet"</span>
        <span class="plain">    PROPER_NOUN_NT "carpet"</span>
        <span class="plain">    PROPERTY_LIST_NT "worn patch"</span>
</pre>

<p class="inwebparagraph">Now comes the reckoning. The existing parse tree may contain a few bogus
nodes, but it's good enough to determine all the property and direction
names. This then enables us to go back and check all the <code class="display"><span class="extract">X_OF_Y_NT</span></code>
subtrees, expunging the ones which are spurious.
</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Tidying up ofs and from. </b>In deciding whether "worn patch of carpet" is to be treated as a single noun,
as a property ("worn patch") belonging to a noun ("carpet"), or as a
direction ("worn patch") relative to a noun ("carpet") &mdash; consider the
cases "description of carpet" and "east of the lawn" &mdash; the key thing
is to understand the meaning of the subject ("worn patch"). Unfortunately,
the model world will not be created, much less named, for quite a long
time to come: so we cannot simply parse the subject as an expression. At this
early stage the best we can do is to scan ahead through the parse tree to
try to find direction and property declarations. We do this with a sequence
of three traversals:
</p>

<p class="inwebparagraph">(-1.) Look for property and direction declarations. Create the property
names called for; do not actually create the directions (that will happen
much later), but remember their names.
(-2.) Reconstruct the parse trees of any sentences which refer to
property names which themselves contain an "of" (as may happen if, for
instance, there is a property called "point of view").
(-3.) Look for location phrases like "east from the lawn", which we can
distinguish from other uses of "from" now that we know the direction
names; at the same time look for "X of Y" phrases where the "of" should
not be treated as a possessive, and expunge them.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Sentences::Rearrangement::further_material</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="functiontext">Sentences::Rearrangement::tidy_up_ofs_and_froms</span><span class="plain">();</span>
        <span class="functiontext">Sentences::RuleSubtrees::register_recently_lexed_phrases</span><span class="plain">();</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Sentences::Rearrangement::tidy_up_ofs_and_froms</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">ParseTree::verify_integrity</span><span class="plain">(</span><span class="identifier">tree_root</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="identifier">ParseTree::traverse_wfirst</span><span class="plain">(</span><span class="functiontext">Sentences::Rearrangement::traverse_for_property_names</span><span class="plain">);</span>
        <span class="identifier">ParseTree::traverse</span><span class="plain">(</span><span class="functiontext">Sentences::Rearrangement::traverse_for_nonbreaking_ofs</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Sentences::Rearrangement::further_material appears nowhere else.</p>

<p class="endnote">The function Sentences::Rearrangement::tidy_up_ofs_and_froms is used in 1/htc (<a href="1-htc.html#SP2_4">&#167;2.4</a>).</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>The following array is used only by Traversals 1 to 3, and is how we
remember direction names.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">MAX_DIRECTIONS</span><span class="plain"> 100 </span>    <span class="comment">the Standard Rules define only 12, so this is plenty</span>
</pre>

<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">directions_noticed</span><span class="plain">[</span><span class="constant">MAX_DIRECTIONS</span><span class="plain">];</span>
    <span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="identifier">direction_relations_noticed</span><span class="plain">[</span><span class="constant">MAX_DIRECTIONS</span><span class="plain">];</span>
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">no_directions_noticed</span><span class="plain"> = 0;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Traversal 1. </b>We now come to the routine which traverses the entire tree looking for
property declarations.
</p>

<p class="inwebparagraph">In this as in the subsequent traversals, we use a loop rather than recursion
to span the width of the tree: otherwise our stack usage goes through the
roof, since it might need to recurse thousands of function calls deep.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Sentences::Rearrangement::traverse_for_property_names</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">) == </span><span class="identifier">AVERB_NT</span><span class="plain">)</span>
            &lt;<span class="cwebmacro">See if this assertion creates property names with "... has ... called ..."</span> <span class="cwebmacronumber">5.3</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Sentences::Rearrangement::traverse_for_property_names is used in <a href="#SP3">&#167;3</a>.</p>

<p class="inwebparagraph"><a id="SP5_1"></a><b>&#167;5.1.  </b>Directions are detected in sentences having the form "D is a direction."
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Sentences::Rearrangement::check_sentence_for_direction_creation</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">) {</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">) != </span><span class="identifier">SENTENCE_NT</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">) != </span><span class="identifier">AVERB_NT</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">) != </span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">) != </span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">pn</span><span class="plain">;</span>
        <span class="identifier">pn</span><span class="plain"> = </span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (!((&lt;</span><span class="identifier">notable</span><span class="plain">-</span><span class="identifier">map</span><span class="plain">-</span><span class="identifier">kinds</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)))</span>
                <span class="plain">&amp;&amp; (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt; == 0))) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">no_directions_noticed</span><span class="plain"> &gt;= </span><span class="constant">MAX_DIRECTIONS</span><span class="plain">) {</span>
            <span class="identifier">Problems::Issue::limit_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_TooManyDirections</span><span class="plain">),</span>
                <span class="string">"different directions"</span><span class="plain">, </span><span class="constant">MAX_DIRECTIONS</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">direction_relations_noticed</span><span class="plain">[</span><span class="identifier">no_directions_noticed</span><span class="plain">] =</span>
            <span class="identifier">PL::MapDirections::create_sketchy_mapping_direction</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">));</span>
        <span class="identifier">directions_noticed</span><span class="plain">[</span><span class="identifier">no_directions_noticed</span><span class="plain">++] = </span><span class="identifier">pn</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">endif</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Sentences::Rearrangement::check_sentence_for_direction_creation is used in 7/ns (<a href="7-ns.html#SP8">&#167;8</a>).</p>

<p class="inwebparagraph"><a id="SP5_2"></a><b>&#167;5.2.  </b>And to extract that sketchy BP later, for completion when possible:
</p>


<pre class="display">
    <span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="functiontext">Sentences::Rearrangement::relation_noticed</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">direction_relations_noticed</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">];</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Sentences::Rearrangement::relation_noticed appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP5_3"></a><b>&#167;5.3.  </b>Typical patterns here are sentences in the form "X has a K called P".
The trouble is that at this stage we can't verify that X is an instance
or kind (they don't exist yet), nor that K is itself a kind (for the same
reason). We must simply rely on the fact that assertions cannot take this
form without being property declarations &mdash; with one exception: see below.
</p>

<p class="inwebparagraph">We therefore look for this subtree structure:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">SENTENCE_NT "A container has a number called volume"</span>
        <span class="plain">    AVERB_NT "has"</span>
        <span class="plain">    PROPER_NOUN_NT "container" article:indefinite</span>
        <span class="plain">    CALLED_NT "called"</span>
        <span class="plain">        PROPER_NOUN_NT "number" article:indefinite</span>
        <span class="plain">        PROPER_NOUN_NT "volume"</span>
</pre>

<p class="inwebparagraph">...and then extract the bottom-most, rightmost noun-phrase as the name of
the new property.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">See if this assertion creates property names with "... has ... called ..."</span> <span class="cwebmacronumber">5.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">) == </span><span class="constant">ASSERT_VB</span><span class="plain">)</span>
            <span class="plain">&amp;&amp; (</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">possessive_verb_ANNOT</span><span class="plain">))</span>
            <span class="plain">&amp;&amp; (</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)</span>
            <span class="plain">&amp;&amp; (</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)</span>
            <span class="plain">&amp;&amp; (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">) == </span><span class="identifier">CALLED_NT</span><span class="plain">)</span>
            <span class="plain">&amp;&amp; (</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">)</span>
            <span class="plain">&amp;&amp; (</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)) {</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">apparent_subject</span><span class="plain"> = </span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SW</span><span class="plain"> = </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">apparent_subject</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">apparent_subject</span><span class="plain">) == </span><span class="identifier">WITH_NT</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">apparent_subject</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">) {</span>
                    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">s1</span><span class="plain"> = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">apparent_subject</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">));</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">apparent_subject</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)</span>
                        <span class="identifier">SW</span><span class="plain"> = </span><span class="identifier">Wordings::new</span><span class="plain">(</span><span class="identifier">s1</span><span class="plain">, </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">apparent_subject</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)));</span>
                    <span class="reserved">else</span>
                        <span class="identifier">SW</span><span class="plain"> = </span><span class="identifier">Wordings::new</span><span class="plain">(</span><span class="identifier">s1</span><span class="plain">, </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">SW</span><span class="plain">));</span>
                <span class="plain">}</span>

            <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">prohibited</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">owners</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="plain">&lt;</span><span class="identifier">has</span><span class="plain">-</span><span class="identifier">properties</span><span class="plain">-</span><span class="identifier">called</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">));</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP5">&#167;5</a>.</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>A tricky point in detecting property declarations is that they share the
syntax used for action, activity and rulebook variables. For instance:
</p>

<blockquote>
    <p>The taking action has a number called the hazard level.</p>

</blockquote>

<p class="inwebparagraph">...creates not a property name but an action variable. Fortunately, the names
of such owners have a distinctive look to them:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">prohibited</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">owners</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">action</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">formal</span><span class="plain">&gt; |</span>
        <span class="reserved">&lt;activity</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">formal</span><span class="plain">&gt; |</span>
        <span class="plain">&lt;</span><span class="reserved">rulebook</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">formal</span><span class="plain">&gt;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>And this seems a good place to declare the grammar for our "formal names".
For instance, if we want to talk about the "taking" action in abstract as
a noun, we write it in the formal way "taking action".
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">action</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">formal</span><span class="plain">&gt; ::=</span>
        <span class="plain">... </span><span class="identifier">action</span>

    <span class="reserved">&lt;activity</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">formal</span><span class="plain">&gt; ::=</span>
        <span class="plain">...</span><span class="element"> activity</span>

    <span class="plain">&lt;</span><span class="identifier">relation</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">formal</span><span class="plain">&gt; ::=</span>
        <span class="plain">... </span><span class="identifier">relation</span>

    <span class="plain">&lt;</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">formal</span><span class="plain">&gt; ::=</span>
        <span class="plain">... </span><span class="reserved">rule</span>

    <span class="plain">&lt;</span><span class="reserved">rulebook</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">formal</span><span class="plain">&gt; ::=</span>
        <span class="plain">... </span><span class="reserved">rulebook</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>We need to know the property names early in parsing in order to make sure
we aren't breaking noun phrases at "of" incorrectly. So the following
grammar is applied to sentences in the form:
</p>

<blockquote>
    <p>A vehicle has numbers called seating capacity and fuel efficiency.</p>

</blockquote>

<p class="inwebparagraph">...and creates these property names right now. (We also filter out some bad
property names before they can do any damage.)
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">has</span><span class="plain">-</span><span class="identifier">properties</span><span class="plain">-</span><span class="identifier">called</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">has</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; &lt;</span><span class="identifier">has</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; |</span>
        <span class="plain">&lt;</span><span class="identifier">has</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt;</span>

    <span class="plain">&lt;</span><span class="identifier">has</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; ::=</span>
        <span class="plain">, {</span><span class="identifier">_and</span><span class="plain">} &lt;</span><span class="identifier">has</span><span class="plain">-</span><span class="identifier">properties</span><span class="plain">-</span><span class="identifier">called</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt; |</span>
        <span class="plain">{</span><span class="identifier">_</span><span class="plain">,/</span><span class="identifier">and</span><span class="plain">} &lt;</span><span class="identifier">has</span><span class="plain">-</span><span class="identifier">properties</span><span class="plain">-</span><span class="identifier">called</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;</span>

    <span class="plain">&lt;</span><span class="identifier">has</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">bad</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">diagnosis</span><span class="plain">&gt; |					==&gt; 0</span>
        <span class="plain">...												==&gt; 0; </span><span class="functiontext">Properties::Valued::obtain</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>

    <span class="plain">&lt;</span><span class="identifier">bad</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">diagnosis</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">article</span><span class="plain">&gt; |										==&gt; </span>&lt;<span class="cwebmacro">Issue PM_PropertyCalledArticle problem</span> <span class="cwebmacronumber">8.1</span>&gt;
        <span class="identifier">presence</span><span class="plain"> |										==&gt; </span>&lt;<span class="cwebmacro">Issue PM_PropertyCalledPresence problem</span> <span class="cwebmacronumber">8.2</span>&gt;
        <span class="plain">*** , *** |										==&gt; </span>&lt;<span class="cwebmacro">Issue PM_PropertyNameForbidden problem</span> <span class="cwebmacronumber">8.3</span>&gt;
        <span class="plain">*** &lt;</span><span class="identifier">quoted</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">&gt; ***							==&gt; </span>&lt;<span class="cwebmacro">Issue PM_PropertyNameForbidden problem</span> <span class="cwebmacronumber">8.3</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8_1"></a><b>&#167;8.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_PropertyCalledArticle problem</span> <span class="cwebmacronumber">8.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_PropertyCalledArticle</span><span class="plain">),</span>
            <span class="string">"a property name cannot consist only of an article"</span><span class="plain">,</span>
            <span class="string">"which this one seems to. It would lead to awful ambiguities. "</span>
            <span class="string">"More likely, the end of the sentence has been lost somehow?"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP8_2"></a><b>&#167;8.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_PropertyCalledPresence problem</span> <span class="cwebmacronumber">8.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_PropertyCalledPresence</span><span class="plain">),</span>
            <span class="string">"a property name cannot consist only of the word 'presence'"</span><span class="plain">,</span>
            <span class="string">"because this would lead to ambiguities with the rule clause "</span>
            <span class="string">"'...in the presence of...' (For instance, when writing something "</span>
            <span class="string">"like 'Instead of eating in the presence of the Queen: ...') "</span>
            <span class="string">"The best way to fix this is probably to add another word or "</span>
            <span class="string">"two to the property name: 'stage presence', say, would be fine."</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP8_3"></a><b>&#167;8.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_PropertyNameForbidden problem</span> <span class="cwebmacronumber">8.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_PropertyNameForbidden</span><span class="plain">),</span>
            <span class="string">"a property name cannot contain quoted text or a comma"</span><span class="plain">,</span>
            <span class="string">"which this one seems to. I think I must be misunderstanding: "</span>
            <span class="string">"possibly you've added a subordinate clause which I can't "</span>
            <span class="string">"make sense of?"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a> (twice).</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>Because we might only just have discovered the property names, it's likely
that some of our earlier attempts to break noun phrases were wrong. For
example, not knowing that "point of view" was going to be a property name,
we'll have broken
</p>

<blockquote>
    <p>The point of view of Kathy is "All grammar is bunk."</p>

</blockquote>

<p class="inwebparagraph">as "((The point) of (view of Kathy)) is...".
</p>

<p class="inwebparagraph">So we look back over assertions which might have broken, and if they contain
the text of such a property name, we throw away the existing subtree for the
sentence and build a fresh one. (Very probably smaller and simpler since
it will not now break at what we now suspect to be a bad position.)
</p>

<p class="inwebparagraph">In a few cases, where for some other reason the of-break was not taken
anyway, nothing will change &mdash; for instance, "On the table is a book
called My point of view" does not break at the "of" whether it's a good
break or a bad one, because the "called" construction takes priority.
We could with some more work avoid this, but it causes no nuisance and
wastes only a negligible amount of memory.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">needing</span><span class="plain">-</span><span class="identifier">second</span><span class="plain">-</span><span class="identifier">look</span><span class="plain">&gt; ::=</span>
        <span class="plain">*** &lt;</span><span class="identifier">ambiguous</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; ***</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>And this code effects it:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Sentences::Rearrangement::traverse_for_nonbreaking_ofs</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">) == </span><span class="identifier">SENTENCE_NT</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">) &amp;&amp; (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">) == </span><span class="identifier">AVERB_NT</span><span class="plain">)) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">vn</span><span class="plain"> = </span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (((</span><span class="identifier">vn</span><span class="plain"> == </span><span class="constant">ASSERT_VB</span><span class="plain">) || (</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">, </span><span class="constant">examine_for_ofs_ANNOT</span><span class="plain">))) &amp;&amp;</span>
                <span class="plain">(&lt;</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">needing</span><span class="plain">-</span><span class="identifier">second</span><span class="plain">-</span><span class="identifier">look</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">)))) {</span>
                <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">pn</span><span class="plain">; </span>    <span class="comment">(just in case any problem messages are issued)</span>
                <span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">thus cutting off and forgetting its former subtree</span>
                <span class="functiontext">Sentences::VPs::seek</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">); </span>    <span class="comment">...in order to make a new one</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Sentences::Rearrangement::traverse_for_nonbreaking_ofs is used in <a href="#SP3">&#167;3</a>.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="7-ns.html">Back to 'Nonstructural Sentences'</a></li><li><a href="7-rs.html">Continue with 'Rule Subtrees'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

