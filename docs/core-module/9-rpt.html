<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Refine Parse Tree</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
MathJax = {
	tex: {
		inlineMath: '$', '$'], ['\\(', '\\)'
	},
	svg: {
		fontCache: 'global'
	}
};
</script>
<script type="text/javascript" id="MathJax-script" async
	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Preform-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../compiler.html">compiler tools</a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul><h2>Compiler Webs</h2><ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul><h2>Inbuild Modules</h2><ul>
<li><a href="../supervisor-module/index.html">supervisor</a></li>
</ul><h2>Inform7 Modules</h2><ul>
<li><a href="index.html"><span class="selectedlink">core</span></a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul><h2>Inter Modules</h2><ul>
<li><a href="../bytecode-module/index.html">bytecode</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul><h2>Services</h2><ul>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../html-module/index.html">html</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Refine Parse Tree' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../compiler.html">Inform7 Modules</a></li><li><a href="index.html">core</a></li><li><a href="index.html#9">Chapter 9: The A-Parser</a></li><li><b>Refine Parse Tree</b></li></ul></div>
<p class="purpose">To determine which subjects are referred to by noun phrases such as "the table" and "a paper cup" found in assertion sentences being parsed.</p>

<ul class="toc"><li><a href="9-rpt.html#SP1">&#167;1. How individual nouns are represented after refinement</a></li><li><a href="9-rpt.html#SP5">&#167;5. Representation of single adjectives</a></li><li><a href="9-rpt.html#SP7">&#167;7. The refinery itself</a></li><li><a href="9-rpt.html#SP11">&#167;11. About surgeries</a></li><li><a href="9-rpt.html#SP12">&#167;12. And surgery</a></li><li><a href="9-rpt.html#SP13">&#167;13. With surgery</a></li><li><a href="9-rpt.html#SP14">&#167;14. Location surgery</a></li><li><a href="9-rpt.html#SP15">&#167;15. Called surgery</a></li><li><a href="9-rpt.html#SP16">&#167;16. The player is not yourself</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1"></a><b>&#167;1. How individual nouns are represented after refinement. </b>The parse tree identifies the primary verb in each sentence, but does only the
most basic work in parsing its noun phrases. It can spot the use of certain
keywords like "called", and constructions like "kind of", but otherwise the
NPs are just left unparsed.
</p>

<p class="commentary">Here we "refine" the subtree for a single noun phrase. Refinement means that
we either annotate it with a meaning or break it down into subtree of further
nodes, thus decomposing the NP into smaller clauses which are refined in turn.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Assertions::Refiner::noun_from_infs</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">Assertions::Refiner::noun_from_infs</span></span>:<br/><a href="9-rpt.html#SP9_5_1">&#167;9.5.1</a>, <a href="9-rpt.html#SP9_7">&#167;9.7</a>, <a href="9-rpt.html#SP10_1">&#167;10.1</a>, <a href="9-rpt.html#SP16">&#167;16</a><br/>The Creator - <a href="9-tc.html#SP5_4">&#167;5.4</a>, <a href="9-tc.html#SP8_4">&#167;8.4</a>, <a href="9-tc.html#SP8_4_1">&#167;8.4.1</a><br/>Assemblies - <a href="9-ass.html#SP14">&#167;14</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="reserved-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><a href="9-rpt.html#SP3" class="function-link"><span class="function-syntax">Assertions::Refiner::pn_make_COMMON_or_PROPER</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">infs</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_evaluation</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><a href="16-is.html#SP18" class="function-link"><span class="function-syntax">InferenceSubjects::as_constant</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">infs</span><span class="plain-syntax">));</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Assertions::Refiner::noun_from_value</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">Assertions::Refiner::noun_from_value</span></span>:<br/><a href="9-rpt.html#SP6">&#167;6</a>, <a href="9-rpt.html#SP9_8_4">&#167;9.8.4</a>, <a href="9-rpt.html#SP9_8_4_5">&#167;9.8.4.5</a><br/>The Creator - <a href="9-tc.html#SP5_4">&#167;5.4</a>, <a href="9-tc.html#SP5_4_1_1">&#167;5.4.1.1</a><br/>Make Assertions - <a href="9-ma.html#SP3_3_11">&#167;3.3.11</a>, <a href="9-ma.html#SP5">&#167;5</a><br/>Relation Knowledge - <a href="9-rk.html#SP2">&#167;2</a><br/>Tables - <a href="19-tb.html#SP25_1">&#167;25.1</a><br/>Tables of Definitions - <a href="19-tod.html#SP6_3">&#167;6.3</a>, <a href="19-tod.html#SP6_4_3_1">&#167;6.4.3.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="14-sp.html#SP3" class="function-link"><span class="function-syntax">Specifications::to_proposition</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prop</span><span class="plain-syntax"> = </span><a href="14-sp.html#SP3" class="function-link"><span class="function-syntax">Specifications::to_proposition</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">val</span><span class="plain-syntax"> = </span><a href="11-pr.html#SP24" class="function-link"><span class="function-syntax">Calculus::Propositions::describes_value</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">val</span><span class="plain-syntax">) </span><span class="identifier-syntax">infs</span><span class="plain-syntax"> = </span><a href="16-is.html#SP17" class="function-link"><span class="function-syntax">InferenceSubjects::from_specification</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">val</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><a href="11-bas.html#SP16" class="function-link"><span class="function-syntax">Calculus::Variables::kind_of_variable_0</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Compare::lt</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_object</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">K_object</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">infs</span><span class="plain-syntax"> = </span><a href="13-kak.html#SP1" class="function-link"><span class="function-syntax">Kinds::Knowledge::as_subject</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><a href="9-rpt.html#SP2" class="function-link"><span class="function-syntax">Assertions::Refiner::pn_noun_details_from_spec</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">infs</span><span class="plain-syntax"> = </span><a href="16-is.html#SP17" class="function-link"><span class="function-syntax">InferenceSubjects::from_specification</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="9-rpt.html#SP3" class="function-link"><span class="function-syntax">Assertions::Refiner::pn_make_COMMON_or_PROPER</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">infs</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_evaluation</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP2"></a><b>&#167;2.  </b>Furthermore:
</p>

<ul class="items"><li>(c) If the noun phrase gives a number of items, the <span class="extract"><span class="extract-syntax">multiplicity</span></span> annotation
records how many; thus, for "six lorries" it would be 6.
</li><li>(d) If the noun phrase describes some properties or relations which must be
true &mdash; "an open door", say, or "a woman in London" &mdash; these are recorded
in a <span class="extract"><span class="extract-syntax">creation_proposition</span></span> field.
</li></ul>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Assertions::Refiner::pn_noun_details_from_spec</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">Assertions::Refiner::pn_noun_details_from_spec</span></span>:<br/><a href="9-rpt.html#SP1">&#167;1</a>, <a href="9-rpt.html#SP5">&#167;5</a>, <a href="9-rpt.html#SP10_1">&#167;10.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prop</span><span class="plain-syntax"> = </span><a href="14-ds.html#SP9" class="function-link"><span class="function-syntax">Descriptions::get_quantified_prop</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_creation_proposition</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><a href="11-pr.html#SP14" class="function-link"><span class="function-syntax">Calculus::Propositions::copy</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">prop</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">N</span><span class="plain-syntax"> = </span><a href="14-ds.html#SP9" class="function-link"><span class="function-syntax">Descriptions::get_quantification_parameter</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">N</span><span class="plain-syntax"> &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="constant-syntax">multiplicity_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">N</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP3"></a><b>&#167;3.  </b>And lastly:
</p>

<ul class="items"><li>(e) The node type is <span class="extract"><span class="extract-syntax">COMMON_NOUN_NT</span></span> if and only if the <span class="extract"><span class="extract-syntax">subject</span></span> field is
an inference subject representing a domain rather than a single instance;
thus, if it is kind of object or a kind of value. In all other cases, the
node type is <span class="extract"><span class="extract-syntax">PROPER_NOUN_NT</span></span>.
</li></ul>
<p class="commentary">The linguistic difference between proper and common nouns is a matter of some
disagreement among semanticists, but to us it's very helpful in distinguishing
cases in the assertion-maker.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Assertions::Refiner::pn_make_COMMON_or_PROPER</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">Assertions::Refiner::pn_make_COMMON_or_PROPER</span></span>:<br/><a href="9-rpt.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="reserved-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">infs</span><span class="plain-syntax">) &amp;&amp; (</span><a href="16-is.html#SP21" class="function-link"><span class="function-syntax">InferenceSubjects::domain</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">infs</span><span class="plain-syntax">))) </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">COMMON_NOUN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">PROPER_NOUN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">infs</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4"></a><b>&#167;4.  </b>It's useful to have a safe way of transferring the complete noun details
from one node to another, without breaking the above invariant. (The
<span class="extract"><span class="extract-syntax">nowhere</span></span> annotation is used by the spatial model plugin, if active, and
it probably never needs to be copied, but we do so for safety's sake.)
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Assertions::Refiner::copy_noun_details</span><button class="popup" onclick="togglePopup('usagePopup5')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup5">Usage of <span class="code-font"><span class="function-syntax">Assertions::Refiner::copy_noun_details</span></span>:<br/>Tables - <a href="19-tb.html#SP28">&#167;28</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">to</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">from</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">to</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">from</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_evaluation</span><span class="plain-syntax">(</span><span class="identifier-syntax">to</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_evaluation</span><span class="plain-syntax">(</span><span class="identifier-syntax">from</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_creation_proposition</span><span class="plain-syntax">(</span><span class="identifier-syntax">to</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_creation_proposition</span><span class="plain-syntax">(</span><span class="identifier-syntax">from</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">to</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">from</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">to</span><span class="plain-syntax">, </span><span class="constant-syntax">multiplicity_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">from</span><span class="plain-syntax">, </span><span class="constant-syntax">multiplicity_ANNOT</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">to</span><span class="plain-syntax">, </span><span class="constant-syntax">nowhere_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">from</span><span class="plain-syntax">, </span><span class="constant-syntax">nowhere_ANNOT</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">to</span><span class="plain-syntax">, </span><span class="constant-syntax">creation_site_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">from</span><span class="plain-syntax">, </span><span class="constant-syntax">creation_site_ANNOT</span><span class="plain-syntax">));</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP5"></a><b>&#167;5. Representation of single adjectives. </b>Individual adjective nodes are made as follows. Note that we append noun
details to the nodes so that sentences like this one...
</p>

<blockquote>
    <p>Scenery is usually fixed in place.</p>
</blockquote>

<p class="commentary">...can work; here "scenery", though an adjective, is effectively a common
noun in disguise. (It's a deficiency of English that a surprising number of
common things, which ought to have count nouns, in fact have mass nouns &mdash;
compare "clothing" and "clothes", which has no adequate singular.)
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Assertions::Refiner::pn_make_adjective</span><button class="popup" onclick="togglePopup('usagePopup6')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup6">Usage of <span class="code-font"><span class="function-syntax">Assertions::Refiner::pn_make_adjective</span></span>:<br/><a href="9-rpt.html#SP10_3">&#167;10.3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="reserved-syntax">unary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ale</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">aph</span><span class="plain-syntax"> = </span><a href="6-up.html#SP4" class="function-link"><span class="function-syntax">UnaryPredicates::get_adj</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">ale</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="constant-syntax">ADJECTIVE_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_aph</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">aph</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_evaluation</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="9-rpt.html#SP2" class="function-link"><span class="function-syntax">Assertions::Refiner::pn_noun_details_from_spec</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="6-up.html#SP4" class="function-link"><span class="function-syntax">UnaryPredicates::get_parity</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">ale</span><span class="plain-syntax">)) </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="constant-syntax">negated_boolean_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="constant-syntax">negated_boolean_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP6"></a><b>&#167;6.  </b>A different reason why adjective and nouns overlap is due to words like
"green", which describe a state and also suggest that something possesses it.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Assertions::Refiner::coerce_adjectival_usage_to_noun</span><button class="popup" onclick="togglePopup('usagePopup7')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup7">Usage of <span class="code-font"><span class="function-syntax">Assertions::Refiner::coerce_adjectival_usage_to_noun</span></span>:<br/>Make Assertions - <a href="9-ma.html#SP3_3_22">&#167;3.3.22</a>, <a href="9-ma.html#SP3_3_26">&#167;3.3.26</a><br/>Property Knowledge - <a href="9-pk.html#SP4_3">&#167;4.3</a><br/>Relation Knowledge - <a href="9-rk.html#SP3_1">&#167;3.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">leaf</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">leaf</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">leaf</span><span class="plain-syntax">) == </span><span class="constant-syntax">ADJECTIVE_NT</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">q</span><span class="plain-syntax"> = </span><a href="4-am.html#SP13" class="function-link"><span class="function-syntax">Adjectives::Meanings::has_ENUMERATIVE_meaning</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_aph</span><span class="plain-syntax">(</span><span class="identifier-syntax">leaf</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">q</span><span class="plain-syntax">) </span><a href="9-rpt.html#SP1" class="function-link"><span class="function-syntax">Assertions::Refiner::noun_from_value</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">leaf</span><span class="plain-syntax">, </span><a href="14-rv.html#SP3" class="function-link"><span class="function-syntax">Rvalues::from_instance</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">q</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP7"></a><b>&#167;7. The refinery itself. </b>Time to get started, then. Each subtree can be refined only once.
</p>

<p class="commentary">The <span class="extract"><span class="extract-syntax">creation_rule</span></span> can have three values:
</p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="constant-syntax">FORBID_CREATION</span><span class="plain-syntax"> </span><span class="constant-syntax">0</span><span class="plain-syntax"> </span><span class="comment-syntax"> never create an object with this name</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">ALLOW_CREATION</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax"> </span><span class="comment-syntax"> create an object with this name if that looks sensible</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">MANDATE_CREATION</span><span class="plain-syntax"> </span><span class="constant-syntax">2</span><span class="plain-syntax"> </span><span class="comment-syntax"> always create an object with this name, except for "it"</span>
</pre>
<p class="commentary firstcommentary"><a id="SP8"></a><b>&#167;8.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">forbid_nowhere</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Assertions::Refiner::refine</span><button class="popup" onclick="togglePopup('usagePopup8')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup8">Usage of <span class="code-font"><span class="function-syntax">Assertions::Refiner::refine</span></span>:<br/><a href="9-rpt.html#SP9_1">&#167;9.1</a>, <a href="9-rpt.html#SP9_2">&#167;9.2</a>, <a href="9-rpt.html#SP9_2_1">&#167;9.2.1</a>, <a href="9-rpt.html#SP9_3">&#167;9.3</a>, <a href="9-rpt.html#SP9_4">&#167;9.4</a>, <a href="9-rpt.html#SP9_5">&#167;9.5</a>, <a href="9-rpt.html#SP9_6">&#167;9.6</a>, <a href="9-rpt.html#SP9_8_2">&#167;9.8.2</a><br/>To Be and To Have - <a href="9-tbath.html#SP5">&#167;5</a><br/>Property Declarations - <a href="9-pd.html#SP5">&#167;5</a><br/>Tree Conversions - <a href="11-tc.html#SP7_1">&#167;7.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">p</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"Refine parse tree on null pn"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="constant-syntax">resolved_ANNOT</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="constant-syntax">resolved_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">NOUN_RESOLUTION</span><span class="plain-syntax">, </span><span class="string-syntax">"Refine subtree (%s creation):\n$T"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        ((</span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax"> == </span><span class="constant-syntax">FORBID_CREATION</span><span class="plain-syntax">)?</span><span class="string-syntax">"forbid"</span><span class="plain-syntax">:</span>
<span class="plain-syntax">            ((</span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax"> == </span><span class="constant-syntax">ALLOW_CREATION</span><span class="plain-syntax">)?</span><span class="string-syntax">"allow"</span><span class="plain-syntax">:</span><span class="string-syntax">"mandate"</span><span class="plain-syntax">)), </span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOG_INDENT</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><a href="9-rpt.html#SP9" class="function-link"><span class="function-syntax">Assertions::Refiner::refine_parse_tree_inner</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">LOG_OUTDENT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">NOUN_RESOLUTION</span><span class="plain-syntax">, </span><span class="string-syntax">"Refined subtree is:\n$T"</span><span class="plain-syntax">, </span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9"></a><b>&#167;9.  </b>What we do depends on the crude structure already found.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Assertions::Refiner::refine_parse_tree_inner</span><button class="popup" onclick="togglePopup('usagePopup9')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup9">Usage of <span class="code-font"><span class="function-syntax">Assertions::Refiner::refine_parse_tree_inner</span></span>:<br/><a href="9-rpt.html#SP8">&#167;8</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">switch</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">X_OF_Y_NT:</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_1" class="named-paragraph-link"><span class="named-paragraph">Refine an X-of-Y subtree</span><span class="named-paragraph-number">9.1</span></a></span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">WITH_NT:</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_2" class="named-paragraph-link"><span class="named-paragraph">Refine an X-with-Y subtree</span><span class="named-paragraph-number">9.2</span></a></span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">AND_NT:</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_3" class="named-paragraph-link"><span class="named-paragraph">Refine an X-and-Y subtree</span><span class="named-paragraph-number">9.3</span></a></span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">RELATIONSHIP_NT:</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_5" class="named-paragraph-link"><span class="named-paragraph">Refine a relationship subtree</span><span class="named-paragraph-number">9.5</span></a></span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">CALLED_NT:</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_4" class="named-paragraph-link"><span class="named-paragraph">Refine a calling subtree</span><span class="named-paragraph-number">9.4</span></a></span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">KIND_NT:</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_6" class="named-paragraph-link"><span class="named-paragraph">Refine a kind subtree</span><span class="named-paragraph-number">9.6</span></a></span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">PRONOUN_NT:</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_7" class="named-paragraph-link"><span class="named-paragraph">Refine a pronoun</span><span class="named-paragraph-number">9.7</span></a></span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">DEFECTIVE_NOUN_NT:</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">PROPER_NOUN_NT:</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">UNPARSED_NOUN_NT:</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_8" class="named-paragraph-link"><span class="named-paragraph">Refine what seems to be a noun phrase</span><span class="named-paragraph-number">9.8</span></a></span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9_1"></a><b>&#167;9.1.  </b>Recall that an <span class="extract"><span class="extract-syntax">X_OF_Y_NT</span></span> subtree has the form owner followed by
property name, so we forbid creation of a new object from the property name
subtree.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Refine an X-of-Y subtree</span><span class="named-paragraph-number">9.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><a href="9-rpt.html#SP8" class="function-link"><span class="function-syntax">Assertions::Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="9-rpt.html#SP8" class="function-link"><span class="function-syntax">Assertions::Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">, </span><span class="constant-syntax">FORBID_CREATION</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9">&#167;9</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_2"></a><b>&#167;9.2.  </b><span class="extract"><span class="extract-syntax">WITH_NT</span></span> is used to create something with a list of properties. This
leads to some awkward cases &mdash; for instance, where a "with" in an action
pattern like "doing something with the bucket" has been misinterpreted.
We fix those cases by hand, by reconstructing the text before it was
divided, to form the word range \((a_1, a_2)\); then parsing it as an action
pattern; if it works, that reading is allowed to stand.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Refine an X-with-Y subtree</span><span class="named-paragraph-number">9.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><a href="9-rpt.html#SP8" class="function-link"><span class="function-syntax">Assertions::Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="9-rpt.html#SP13" class="function-link"><span class="function-syntax">Assertions::Refiner::perform_with_surgery</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">) == </span><span class="identifier-syntax">WITH_NT</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">IF_MODULE</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Wordings::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">Wordings::first_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">)),</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Wordings::last_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">)));</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;action-pattern&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="constant-syntax">ACTION_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Node::set_action_meaning</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Node::set_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">); </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        #</span><span class="identifier-syntax">endif</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="constant-syntax">resolved_ANNOT</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_2_1" class="named-paragraph-link"><span class="named-paragraph">Start the refinement over</span><span class="named-paragraph-number">9.2.1</span></a></span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9">&#167;9</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_2_1"></a><b>&#167;9.2.1.  </b>After surgery on the tree, it's usually best to start over again:
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Start the refinement over</span><span class="named-paragraph-number">9.2.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="constant-syntax">resolved_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="9-rpt.html#SP8" class="function-link"><span class="function-syntax">Assertions::Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9_2">&#167;9.2</a>, <a href="9-rpt.html#SP9_4">&#167;9.4</a>, <a href="9-rpt.html#SP9_5">&#167;9.5</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_3"></a><b>&#167;9.3.  </b><span class="extract"><span class="extract-syntax">AND_NT</span></span> is easy, except for "and surgery", of which more below.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Refine an X-and-Y subtree</span><span class="named-paragraph-number">9.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><a href="9-rpt.html#SP8" class="function-link"><span class="function-syntax">Assertions::Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="9-rpt.html#SP8" class="function-link"><span class="function-syntax">Assertions::Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="9-rpt.html#SP12" class="function-link"><span class="function-syntax">Assertions::Refiner::perform_and_surgery</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9">&#167;9</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_4"></a><b>&#167;9.4.  </b>A <span class="extract"><span class="extract-syntax">CALLED_NT</span></span> node has two children: in the phrase "an X called Y", they
will represent X and Y respectively. Y must be created afresh whatever its
name, since the whole point of "called" is that it enables the designer
to use names which would otherwise be interpreted as meaning something
significant: it is a sort of literal escape, like the backslash character
in C strings. X is never something new: it is expected to be a kind.
We convert the whole node into a simple <span class="extract"><span class="extract-syntax">PROPER_NOUN_NT</span></span> with the name
of Y and the kind of X. In this way, all <span class="extract"><span class="extract-syntax">CALLED_NT</span></span> nodes are removed
from the tree.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Refine a calling subtree</span><span class="named-paragraph-number">9.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">) == </span><span class="identifier-syntax">RELATIONSHIP_NT</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><a href="9-rpt.html#SP15" class="function-link"><span class="function-syntax">Assertions::Refiner::perform_called_surgery</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_2_1" class="named-paragraph-link"><span class="named-paragraph">Start the refinement over</span><span class="named-paragraph-number">9.2.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><a href="9-rpt.html#SP8" class="function-link"><span class="function-syntax">Assertions::Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">, </span><span class="constant-syntax">FORBID_CREATION</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">, </span><span class="constant-syntax">multiplicity_ANNOT</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">1</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_MultipleCalled</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"I can only make a single 'called' thing at a time"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"or rather, the 'called' is only allowed to apply to one thing "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"at a time. For instance, 'A thing called a vodka and tonic is "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"on the table.' is allowed, but 'Two things called vodka and tonic' "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"is not."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">forbid_nowhere</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax"> == </span><span class="constant-syntax">FORBID_CREATION</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">BelievedImpossible</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"'called' can't be used in this context"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"and is best reserved for full sentences."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><a href="9-rpt.html#SP8" class="function-link"><span class="function-syntax">Assertions::Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">, </span><span class="constant-syntax">MANDATE_CREATION</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">forbid_nowhere</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9">&#167;9</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_5"></a><b>&#167;9.5.  </b>A <span class="extract"><span class="extract-syntax">RELATIONSHIP_NT</span></span> node may have no children, representing "here"; or
it may have one child, a room or door which lies in some map direction. But
in general it has two children: for instance "a green marble in a blue box"
has the marble and the box as its children, the relationship being containment.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Refine a relationship subtree</span><span class="named-paragraph-number">9.5</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><a href="9-rpt.html#SP14" class="function-link"><span class="function-syntax">Assertions::Refiner::perform_location_surgery</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">) == </span><span class="identifier-syntax">AND_NT</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_2_1" class="named-paragraph-link"><span class="named-paragraph">Start the refinement over</span><span class="named-paragraph-number">9.2.1</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><a href="9-rpt.html#SP8" class="function-link"><span class="function-syntax">Assertions::Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">IF_MODULE</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">dir</span><span class="plain-syntax"> = </span><span class="identifier-syntax">PL::MapDirections::get_mapping_relationship</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">dir</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_5_1" class="named-paragraph-link"><span class="named-paragraph">Make the relation one which refers to a map direction</span><span class="named-paragraph-number">9.5.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        #</span><span class="identifier-syntax">endif</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">) </span><a href="9-rpt.html#SP8" class="function-link"><span class="function-syntax">Assertions::Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9">&#167;9</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_5_1"></a><b>&#167;9.5.1.  </b>This handles the case of a one-child node representing a map direction,
but fills in a second child as the direction object in question. Thus if
the relation is mapped-north-of, then the second child will become the
direction object for "north".
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make the relation one which refers to a map direction</span><span class="named-paragraph-number">9.5.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">NOUN_RESOLUTION</span><span class="plain-syntax">, </span><span class="string-syntax">"Directional predicate with BP from $O\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">dir</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">DW</span><span class="plain-syntax"> = </span><a href="5-ins.html#SP14" class="function-link"><span class="function-syntax">Instances::get_name</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">dir</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Diagrams::new_UNPARSED_NOUN</span><span class="plain-syntax">(</span><span class="identifier-syntax">DW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="9-rpt.html#SP1" class="function-link"><span class="function-syntax">Assertions::Refiner::noun_from_infs</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">, </span><a href="5-ins.html#SP13" class="function-link"><span class="function-syntax">Instances::as_subject</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">dir</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">, </span><span class="constant-syntax">resolved_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9_5">&#167;9.5</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_6"></a><b>&#167;9.6.  </b>A <span class="extract"><span class="extract-syntax">KIND_NT</span></span> node may have no children, and if so it represents the bare
word "kind": the reference must be to the kind "kind" itself.
Otherwise it has one child &mdash; the name of an existing kind of value or
object. After refinement, it will be annotated with a valid non-null
inference subject representing the domain to which any new kind would belong.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Refine a kind subtree</span><span class="named-paragraph-number">9.6</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax"> = </span><a href="13-kak.html#SP1" class="function-link"><span class="function-syntax">Kinds::Knowledge::as_subject</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">K_object</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">what</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><a href="9-rpt.html#SP8" class="function-link"><span class="function-syntax">Assertions::Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">what</span><span class="plain-syntax">, </span><span class="constant-syntax">FORBID_CREATION</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">what</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) || (</span><a href="16-is.html#SP21" class="function-link"><span class="function-syntax">InferenceSubjects::domain</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax">) == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_6_1" class="named-paragraph-link"><span class="named-paragraph">Issue a problem message for a kind of instance</span><span class="named-paragraph-number">9.6.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><a href="16-is.html#SP19" class="function-link"><span class="function-syntax">InferenceSubjects::as_nonobject_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax"> != </span><a href="13-kak.html#SP1" class="function-link"><span class="function-syntax">Kinds::Knowledge::as_subject</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax"> != </span><a href="13-kak.html#SP1" class="function-link"><span class="function-syntax">Kinds::Knowledge::as_subject</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">K_object</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_6_2" class="named-paragraph-link"><span class="named-paragraph">Issue a problem message for a disallowed subkind</span><span class="named-paragraph-number">9.6.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9">&#167;9</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_6_1"></a><b>&#167;9.6.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue a problem message for a kind of instance</span><span class="named-paragraph-number">9.6.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><a href="16-is.html#SP20" class="function-link"><span class="function-syntax">InferenceSubjects::is_an_object</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax">)) ||</span>
<span class="plain-syntax">        (</span><a href="16-is.html#SP20" class="function-link"><span class="function-syntax">InferenceSubjects::is_a_kind_of_object</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_KindOfInstance</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"kinds can only be made from other kinds"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"so 'a kind of container' is allowed but 'a kind of Mona Lisa' (where "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"Mona Lisa is a specific thing you've already made), wouldn't be "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"allowed. There is only one Mona Lisa."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax"> = </span><a href="13-kak.html#SP1" class="function-link"><span class="function-syntax">Kinds::Knowledge::as_subject</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">K_object</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_KindOfActualValue</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"I don't recognise that as a kind"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"such as 'room' or 'door': it would need to be straightforwardly the name "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"of a kind, and not be qualified with adjectives like 'open'."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax"> = </span><a href="13-kak.html#SP1" class="function-link"><span class="function-syntax">Kinds::Knowledge::as_subject</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9_6">&#167;9.6</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_6_2"></a><b>&#167;9.6.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue a problem message for a disallowed subkind</span><span class="named-paragraph-number">9.6.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_KindOfExotica</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="string-syntax">"you are only allowed to create kinds of objects (things, rooms, and "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"so on) and kinds of 'value'"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"so for example 'colour is a kind of value' is allowed but 'prime is "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"a kind of number' is not."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax"> = </span><a href="13-kak.html#SP1" class="function-link"><span class="function-syntax">Kinds::Knowledge::as_subject</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9_6">&#167;9.6</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_7"></a><b>&#167;9.7.  </b>The following could clearly be improved.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Refine a pronoun</span><span class="named-paragraph-number">9.7</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">pronoun_usage</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pro</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_pronoun</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pro</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pro</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">pronoun_used</span><span class="plain-syntax"> == </span><span class="identifier-syntax">here_pronoun</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">RELATIONSHIP_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Diagrams::new_PRONOUN</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">), </span><span class="identifier-syntax">pro</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pro</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">pronoun_used</span><span class="plain-syntax"> == </span><span class="identifier-syntax">implied_pronoun</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><a href="26-pc.html#SP6" class="function-link"><span class="function-syntax">Plugins::Call::refine_implicit_noun</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">PROPER_NOUN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Stock::usage_might_be_singular</span><span class="plain-syntax">(</span><span class="identifier-syntax">pro</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">usage</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            (</span><a href="9-tfa.html#SP12" class="function-link"><span class="function-syntax">Assertions::Traverse::get_current_subject_plurality</span></a><span class="plain-syntax">())) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_EnigmaticThey</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                </span><span class="string-syntax">"I'm unable to handle 'they' here"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="string-syntax">"since it looks as if it needs to refer to more than one "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"object here, and that's something I can't manage."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">referent</span><span class="plain-syntax"> = </span><a href="9-tfa.html#SP12" class="function-link"><span class="function-syntax">Assertions::Traverse::get_current_object</span></a><span class="plain-syntax">();</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">referent</span><span class="plain-syntax">) </span><a href="9-rpt.html#SP1" class="function-link"><span class="function-syntax">Assertions::Refiner::noun_from_infs</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">referent</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_EnigmaticPronoun</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                </span><span class="string-syntax">"I'm not sure what to make of the pronoun here"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="string-syntax">"since it is unclear what previously mentioned thing "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"is being referred to. In general, it's best only to use "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"'it' where it's unambiguous, and it may be worth noting "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"that 'they' is not allowed to stand for more than one "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"object at a time."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">PRONOUNS</span><span class="plain-syntax">, </span><span class="string-syntax">"Interpreting 'it' as $j\n$P"</span><span class="plain-syntax">, </span><span class="identifier-syntax">referent</span><span class="plain-syntax">, </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"misconstrued pronoun"</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9">&#167;9</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_8"></a><b>&#167;9.8.  </b>The simple description of what happens to a <span class="extract"><span class="extract-syntax">PROPER_NOUN_NT</span></span> node is that
if it's an existing object or value, then it should be annotated with a
reference to that object or value; and if not, then a new object should be
created with that name. (We don't actually create here, though: we just mark
such a noun phrase by changing its node type to <span class="extract"><span class="extract-syntax">CREATED_NT</span></span>.) The more
complicated description is as follows:
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Refine what seems to be a noun phrase</span><span class="named-paragraph-number">9.8</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">PROPER_NOUN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_8_2" class="named-paragraph-link"><span class="named-paragraph">Act on a newly-discovered property of something</span><span class="named-paragraph-number">9.8.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">forbid_nowhere</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_8_3" class="named-paragraph-link"><span class="named-paragraph">Act on any special noun phrases significant to plugins</span><span class="named-paragraph-number">9.8.3</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax"> != </span><span class="constant-syntax">MANDATE_CREATION</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_8_4" class="named-paragraph-link"><span class="named-paragraph">Interpret this as an existing noun if possible</span><span class="named-paragraph-number">9.8.4</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax"> != </span><span class="constant-syntax">FORBID_CREATION</span><span class="plain-syntax">) </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="constant-syntax">CREATED_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">Node::set_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9">&#167;9</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_8_1"></a><b>&#167;9.8.1.  </b>The following is needed to handle something like "colour of the box",
where "colour" is a property name. We must be careful, though, to avoid
confusion with variable declarations:
</p>

<blockquote>
    <p>The interesting var is a description of numbers that varies.</p>
</blockquote>

<p class="commentary">which would otherwise be misread as an attempt to set the "description"
property of something.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;newfound-property-of&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">in</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">the</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">presence</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">of</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { advance Wordings::delta(WR[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">that</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">varies</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { advance Wordings::delta(WR[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">variable</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { advance Wordings::delta(WR[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">{&lt;property-name-v&gt;}</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">of</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax">		</span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { 0, RP[1] }</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_8_2"></a><b>&#167;9.8.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Act on a newly-discovered property of something</span><span class="named-paragraph-number">9.8.2</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prn</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">PW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">, </span><span class="identifier-syntax">OW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;newfound-property-of&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">prn</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">PW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">GET_RW</span><span class="plain-syntax">(</span><span class="function-syntax">&lt;newfound-property-of&gt;</span><span class="plain-syntax">, </span><span class="constant-syntax">1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">OW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">GET_RW</span><span class="plain-syntax">(</span><span class="function-syntax">&lt;newfound-property-of&gt;</span><span class="plain-syntax">, </span><span class="constant-syntax">2</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">prn</span><span class="plain-syntax">) &amp;&amp; (</span><a href="15-pr.html#SP16" class="function-link"><span class="function-syntax">Properties::is_value_property</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">prn</span><span class="plain-syntax">)) </span><span class="comment-syntax"> &amp;&amp;</span>
<span class="plain-syntax">        (</span><a href="15-vp.html#SP6" class="function-link"><span class="function-syntax">Properties::Valued::coincides_with_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">prn</span><span class="plain-syntax">)) */) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">NOUN_RESOLUTION</span><span class="plain-syntax">, </span><span class="string-syntax">"Resolving new-property of: $Y\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">prn</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="constant-syntax">X_OF_Y_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="function-syntax">&lt;np-articled&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">OW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="function-syntax">&lt;np-as-object&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">PW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="constant-syntax">resolved_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">NOUN_RESOLUTION</span><span class="plain-syntax">, </span><span class="string-syntax">"Resolved new-property to:\n$T\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><a href="9-rpt.html#SP8" class="function-link"><span class="function-syntax">Assertions::Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9_8">&#167;9.8</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_8_3"></a><b>&#167;9.8.3.  </b>For example, "above" and "below" become significant if the mapping plugin
is active, and "nowhere" if the spatial one is.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Act on any special noun phrases significant to plugins</span><span class="named-paragraph-number">9.8.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="26-pc.html#SP6" class="function-link"><span class="function-syntax">Plugins::Call::act_on_special_NPs</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9_8">&#167;9.8</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_8_4"></a><b>&#167;9.8.4.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Interpret this as an existing noun if possible</span><span class="named-paragraph-number">9.8.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_8_4_1" class="named-paragraph-link"><span class="named-paragraph">Parse the noun phrase as a value property name</span><span class="named-paragraph-number">9.8.4.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_8_4_3" class="named-paragraph-link"><span class="named-paragraph">Parse the noun phrase as a value</span><span class="named-paragraph-number">9.8.4.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="constant-syntax">NONLOCAL_VARIABLE_NT</span><span class="plain-syntax">)) ||</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="constant-syntax">CONSTANT_NT</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><a href="9-rpt.html#SP1" class="function-link"><span class="function-syntax">Assertions::Refiner::noun_from_value</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="14-sp.html#SP3" class="function-link"><span class="function-syntax">Specifications::is_description</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_8_4_5" class="named-paragraph-link"><span class="named-paragraph">Act on a description used as a noun phrase</span><span class="named-paragraph-number">9.8.4.5</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_8_4_4" class="named-paragraph-link"><span class="named-paragraph">Act on an action pattern used as a noun phrase</span><span class="named-paragraph-number">9.8.4.4</span></a></span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9_8">&#167;9.8</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_8_4_1"></a><b>&#167;9.8.4.1.  </b>Perhaps it is the name of a valued property? If so, it is used as a noun,
without obvious reference to any owner: we convert it to a noun node.
</p>

<p class="commentary">(This is the next priority so that "description" will be read as its
property name meaning, not as the name of a kind of value.)
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Parse the noun phrase as a value property name</span><span class="named-paragraph-number">9.8.4.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;value-property-name&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="14-rv.html#SP1" class="function-link"><span class="function-syntax">Rvalues::from_property</span></a><span class="plain-syntax">(</span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9_8_4">&#167;9.8.4</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP_1"></a><b>&#167;.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue PM_VagueVariable problem</span><span class="named-paragraph-number">.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_VagueVariable</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="string-syntax">"'variable' is too vague a description"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"because it doesn't say what kind of value should go into the variable. "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"'number variable' or 'a number that varies' - whatever kind of value you "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"need - would be much clearer."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    ==&gt; { </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, - };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9_8_4_2">&#167;9.8.4.2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_8_4_2"></a><b>&#167;9.8.4.2.  </b>When a noun phrase in an assertion represents a value, it's normally a
constant ("13") or else something like a description of values ("a number").
It wouldn't make sense to refer to a temporary value like a local variable,
but a global ("player" or "time of day") is possible.
</p>

<p class="commentary">The "action of taking something" syntax is provided as a way of escaping
the usual handling of action patterns; it enables "taking something" to be
a noun instead of a condition testing the current action.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;assertion-np-as-value&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">variable</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                         </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP_1" class="named-paragraph-link"><span class="named-paragraph">Issue PM_VagueVariable problem</span><span class="named-paragraph-number">.1</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">action</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">of</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-explicit-action&gt;</span><span class="Preform-plain-syntax">	</span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { TRUE, RP[1] }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-descriptive-type-expression&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { TRUE, RP[1] }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-global-variable&gt;</span><span class="Preform-plain-syntax">                </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { TRUE, RP[1] }</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_8_4_3"></a><b>&#167;9.8.4.3.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Parse the noun phrase as a value</span><span class="named-paragraph-number">9.8.4.3</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;assertion-np-as-value&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;&lt;r&gt;&gt;</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="14-sp.html#SP8" class="function-link"><span class="function-syntax">Specifications::new_UNKNOWN</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="14-ds.html#SP9" class="function-link"><span class="function-syntax">Descriptions::get_quantifier</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_8_4_3_1" class="named-paragraph-link"><span class="named-paragraph">Check that this noun phrase is allowed a quantifier</span><span class="named-paragraph-number">9.8.4.3.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">NOUN_RESOLUTION</span><span class="plain-syntax">, </span><span class="string-syntax">"Noun phrase %W parsed as value: $P\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">), </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9_8_4">&#167;9.8.4</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP_1"></a><b>&#167;.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue a problem for a variable described without a kind</span><span class="named-paragraph-number">.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is never used.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_8_4_3_1"></a><b>&#167;9.8.4.3.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Check that this noun phrase is allowed a quantifier</span><span class="named-paragraph-number">9.8.4.3.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Quantifiers::can_be_used_in_assertions</span><span class="plain-syntax">(</span><a href="14-ds.html#SP9" class="function-link"><span class="function-syntax">Descriptions::get_quantifier</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">)) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"$T\nSo $D\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">, </span><a href="14-sp.html#SP3" class="function-link"><span class="function-syntax">Specifications::to_proposition</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_ComplexDeterminer</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"complicated determiners are not allowed in assertions"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"so for instance 'More than three people are in the Dining Room' "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"or 'None of the containers is open' will be rejected. Only "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"simple numbers will be allowed, as in examples like 'Three "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"people are in the Dining Room.'"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="14-ds.html#SP9" class="function-link"><span class="function-syntax">Descriptions::get_quantifier</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">) == </span><span class="identifier-syntax">for_all_quantifier</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><a href="14-sp.html#SP1" class="function-link"><span class="function-syntax">Specifications::to_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">K</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            (</span><a href="14-ds.html#SP5" class="function-link"><span class="function-syntax">Descriptions::to_instance</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">) == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            (</span><a href="14-ds.html#SP8" class="function-link"><span class="function-syntax">Descriptions::number_of_adjectives_applied_to</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">) == </span><span class="constant-syntax">0</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Node::set_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><a href="13-kak.html#SP1" class="function-link"><span class="function-syntax">Kinds::Knowledge::as_subject</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="constant-syntax">EVERY_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_ComplexEvery</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"in an assertion 'every' or 'all' can only be used with a kind"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"so for instance 'A coin is in every container' is all right, "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"because 'container' is a kind, but not 'A coin is in every "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"open container', because 'open container' is now a kind "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"qualified by a property which may come or go during play. "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"(This problem sometimes happens because a thing has been "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"called something like an 'all in one survival kit' - if you "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"need that sort of name, try using 'called' to set it.)"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9_8_4_3">&#167;9.8.4.3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_8_4_4"></a><b>&#167;9.8.4.4.  </b>If the noun phrase is a valid action pattern, such as "taking something",
we change it to a new node type to mark this. We don't keep the pattern:
it will be reparsed much later on.
</p>

<p class="commentary">We have to be a little cautious, because of the way English allows participles
as nouns to mean the result of some action having taken place on something &mdash;
consider "the scoring", for instance, in the sense of a mark scored on a
piece of wood. So we parse action patterns with a lower priority than values
here, given that we know we are looking for a noun.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Act on an action pattern used as a noun phrase</span><span class="named-paragraph-number">9.8.4.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">IF_MODULE</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Node::get_article</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">) == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;action-pattern&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="constant-syntax">ACTION_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Node::set_action_meaning</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9_8_4">&#167;9.8.4</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_8_4_5"></a><b>&#167;9.8.4.5.  </b>This case has been left to last, since it's so much the most difficult.
Descriptions have to be converted into a surprising range of different
subtrees &mdash; otherwise it will not be possible to issue a wide range of
to-the-point problem messages for badly constructed sentences.
</p>

<p class="commentary">Oddly, it's not the complicated descriptions which give trouble...
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Act on a description used as a noun phrase</span><span class="named-paragraph-number">9.8.4.5</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="14-ds.html#SP7" class="function-link"><span class="function-syntax">Descriptions::is_complex</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><a href="9-rpt.html#SP1" class="function-link"><span class="function-syntax">Assertions::Refiner::noun_from_value</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP9_8_4_5_1" class="named-paragraph-link"><span class="named-paragraph">Act on a simple description</span><span class="named-paragraph-number">9.8.4.5.1</span></a></span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9_8_4">&#167;9.8.4</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP9_8_4_5_1"></a><b>&#167;9.8.4.5.1.  </b>...it's the shorter phrases where, perversely, the risk of a
misunderstanding is higher. For one thing, we deliberately ignore a valid
description in two cases:
</p>

<ul class="items"><li>(a) Adjective(s) followed by the name of a specific object.
</li><li>(b) An indefinite article followed by the name of a specific object.
</li></ul>
<p class="commentary">For (a), see the example "Goat-Cheese and Sage Chicken". This contains a
kettle which can be in several states, described adjectivally, and one of
those is "heating". This means the S-parser reads "heating kettle" as if it
meant "the kettle when in the heating state". But we don't want this to be
recognised in an assertion, because it's not useful to talk about individual
objects in particular states when setting up the initial state &mdash; the kettle
either starts out as heating, or it doesn't. Moreover, we don't want to
misread a line like:
</p>

<blockquote>
    <p>Heating Kettle is a scene.</p>
</blockquote>

<p class="commentary">(also a sentence from "Goat-Cheese and Sage Chicken"). Because of this and
similar ambiguities, we ignore the S-parser's recommendation of reading
adjective(s) plus proper noun as a reference to that noun in a special state.
</p>

<p class="commentary">Case (b) comes out of a point of difference between proper and common nouns:
use of an indefinite article is fine with common nouns &mdash; "a container", for
example &mdash; but not with proper nouns: talking about "a silver bar" suggests
that this is not the same silver bar referred to in some previous
sentence.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Act on a simple description</span><span class="named-paragraph-number">9.8.4.5.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (!((</span><a href="14-ds.html#SP5" class="function-link"><span class="function-syntax">Descriptions::to_instance</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">        ((</span><a href="14-ds.html#SP8" class="function-link"><span class="function-syntax">Descriptions::number_of_adjectives_applied_to</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) ||</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">Articles::may_be_definite</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_article</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">)) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)))) {</span>
<span class="plain-syntax">        </span><a href="9-rpt.html#SP10" class="function-link"><span class="function-syntax">Assertions::Refiner::refine_from_simple_description</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP9_8_4_5">&#167;9.8.4.5</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP10"></a><b>&#167;10.  </b>The following turns the node <span class="extract"><span class="extract-syntax">p</span></span> into a subtree representing the content of
a simple description in <span class="extract"><span class="extract-syntax">spec</span></span>. Besides being used above, it's also convenient
for assemblies.
</p>

<p class="commentary">Depending on the circumstances, we get a subtree in which the headword if any
is represented by an <span class="extract"><span class="extract-syntax">COMMON_NOUN_NT</span></span> node (where the headword is a kind of
object) or a <span class="extract"><span class="extract-syntax">PROPER_NOUN_NT</span></span> (where the headword is a specific object), and
where the adjectives each become <span class="extract"><span class="extract-syntax">ADJECTIVE_NT</span></span> nodes.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Assertions::Refiner::refine_from_simple_description</span><button class="popup" onclick="togglePopup('usagePopup10')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup10">Usage of <span class="code-font"><span class="function-syntax">Assertions::Refiner::refine_from_simple_description</span></span>:<br/><a href="9-rpt.html#SP9_8_4_5_1">&#167;9.8.4.5.1</a><br/>Assemblies - <a href="9-ass.html#SP9_3">&#167;9.3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">head</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP10_1" class="named-paragraph-link"><span class="named-paragraph">Set the attachment node to the headword, if there is one</span><span class="named-paragraph-number">10.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="14-ds.html#SP8" class="function-link"><span class="function-syntax">Descriptions::number_of_adjectives_applied_to</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">head</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP10_2" class="named-paragraph-link"><span class="named-paragraph">Insert a WITH node joining adjective tree to headword</span><span class="named-paragraph-number">10.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="9-rpt.html#SP10_3" class="named-paragraph-link"><span class="named-paragraph">Place a subtree of adjectives at the attachment node</span><span class="named-paragraph-number">10.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10_1"></a><b>&#167;10.1.  </b>Crucially, the headword node gets one extra annotation: its "full phrase
evaluation", which retains the original description information &mdash; in
particular, quantification data such as that in "four doors", which
would be lost if we simply applied <span class="extract"><span class="extract-syntax">Assertions::Refiner::noun_from_infs</span></span> to the inference
subject for "door".
</p>

<p class="commentary">If <span class="extract"><span class="extract-syntax">head</span></span> is not set, it doesn't matter what we do, because there'll be
no headword node &mdash; this is why we don't bother to find any subject to
set for it.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Set the attachment node to the headword, if there is one</span><span class="named-paragraph-number">10.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="14-ds.html#SP5" class="function-link"><span class="function-syntax">Descriptions::to_instance</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">head</span><span class="plain-syntax"> = </span><a href="5-ins.html#SP13" class="function-link"><span class="function-syntax">Instances::as_subject</span></a><span class="plain-syntax">(</span><a href="14-ds.html#SP5" class="function-link"><span class="function-syntax">Descriptions::to_instance</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">head</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><a href="9-rpt.html#SP1" class="function-link"><span class="function-syntax">Assertions::Refiner::noun_from_infs</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">head</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><a href="9-rpt.html#SP2" class="function-link"><span class="function-syntax">Assertions::Refiner::pn_noun_details_from_spec</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="14-ds.html#SP4" class="function-link"><span class="function-syntax">Descriptions::makes_kind_explicit</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><a href="14-sp.html#SP1" class="function-link"><span class="function-syntax">Specifications::to_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">head</span><span class="plain-syntax"> = </span><a href="13-kak.html#SP1" class="function-link"><span class="function-syntax">Kinds::Knowledge::as_subject</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><a href="9-rpt.html#SP1" class="function-link"><span class="function-syntax">Assertions::Refiner::noun_from_infs</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">head</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_evaluation</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><a href="14-sp.html#SP1" class="function-link"><span class="function-syntax">Specifications::from_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><a href="9-rpt.html#SP2" class="function-link"><span class="function-syntax">Assertions::Refiner::pn_noun_details_from_spec</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP10">&#167;10</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP10_2"></a><b>&#167;10.2.  </b>We put a WITH node in the attachment position, displacing the headword
content to its first child, and making its second child the new attachment
position &mdash; so that that is where the adjectives subtree will go.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Insert a WITH node joining adjective tree to headword</span><span class="named-paragraph-number">10.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lower_copy</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">PROPER_NOUN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">lower_copy</span><span class="plain-syntax">, </span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">WITH_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">lower_copy</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">lower_copy</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">PROPER_NOUN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">lower_copy</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP10">&#167;10</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP10_3"></a><b>&#167;10.3.  </b>When there are two or more adjectives, they must occur as leaves of a
binary tree whose non-leaf nodes are <span class="extract"><span class="extract-syntax">AND_NT</span></span>. We do this pretty inefficiently,
making no effort to balance the tree, since it has negligible effect on speed
or memory.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Place a subtree of adjectives at the attachment node</span><span class="named-paragraph-number">10.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">no_adjectives</span><span class="plain-syntax"> = </span><a href="14-ds.html#SP8" class="function-link"><span class="function-syntax">Descriptions::number_of_adjectives_applied_to</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">no_adjectives</span><span class="plain-syntax"> == </span><span class="constant-syntax">1</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><a href="9-rpt.html#SP5" class="function-link"><span class="function-syntax">Assertions::Refiner::pn_make_adjective</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><a href="14-ds.html#SP8" class="function-link"><span class="function-syntax">Descriptions::first_unary_predicate</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">), </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_type_and_clear_annotations</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">AND_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">unary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ale</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">AND_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ale_prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOOP_THROUGH_ADJECTIVE_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">ale</span><span class="plain-syntax">, </span><span class="identifier-syntax">ale_prop</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p3</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="constant-syntax">ADJECTIVE_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><a href="9-rpt.html#SP5" class="function-link"><span class="function-syntax">Assertions::Refiner::pn_make_adjective</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p3</span><span class="plain-syntax">, </span><span class="identifier-syntax">ale</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">i</span><span class="plain-syntax"> &lt; </span><span class="identifier-syntax">no_adjectives</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">AND_p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p3</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">i</span><span class="plain-syntax">+1 &lt; </span><span class="identifier-syntax">no_adjectives</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">p3</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">AND_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">AND_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p3</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">            } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">AND_p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p3</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="9-rpt.html#SP10">&#167;10</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11"></a><b>&#167;11. About surgeries. </b>The rest of this section is taken up with four local surgical operations
performed on the tree in the light of what we can now see. In each case, the
problem is that two clausal constructions implied by the nodes inserted
earlier have been applied the wrong way round:
</p>

<ul class="items"><li>(1) "And surgery": <span class="extract"><span class="extract-syntax">AND_NT</span></span> and <span class="extract"><span class="extract-syntax">WITH_NT</span></span> the wrong way round.
</li><li>(2) "With surgery": <span class="extract"><span class="extract-syntax">WITH_NT</span></span> and <span class="extract"><span class="extract-syntax">WITH_NT</span></span> where just one will do, though
in disguised form this is another clash with <span class="extract"><span class="extract-syntax">AND_NT</span></span>.
</li><li>(3) "Location surgery": <span class="extract"><span class="extract-syntax">AND_NT</span></span> and <span class="extract"><span class="extract-syntax">RELATIONSHIP_NT</span></span> the wrong way round.
</li><li>(4) "Called surgery": <span class="extract"><span class="extract-syntax">CALLED_NT</span></span> and <span class="extract"><span class="extract-syntax">RELATIONSHIP_NT</span></span> the wrong way round.
</li></ul>
<p class="commentary firstcommentary"><a id="SP12"></a><b>&#167;12. And surgery. </b>"And surgery" is a fiddly operation to correct the parse tree after
resolution of all the nouns in a phrase which involves both "and" and
"with" in a particular way. There's no problem with either of these:
</p>

<blockquote>
    <p>In the Pitch are a bat and ball with score for finding 10. In the Pitch is a sweater with score for finding 5 and description "White wool."</p>
</blockquote>

<p class="commentary">neither of which is altered by and surgery. The difficulty arises with
</p>

<blockquote>
    <p>In the Pitch is an openable and open door with description "The Hut door."</p>
</blockquote>

<p class="commentary">which, we notice, has exactly the same grammatical structure as the first of
the two sentences above, yet a very different meaning, since "openable" is a
property whereas "bat" was an object. We perform surgery on:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    AND_NT</span>
<span class="plain-syntax">        ADJECTIVE_NT prop:p46_openable</span>
<span class="plain-syntax">        WITH_NT</span>
<span class="plain-syntax">            COMMON_NOUN_NT K4_door</span>
<span class="plain-syntax">            ADJECTIVE_NT prop:p44_open</span>
</pre>
<p class="commentary">to restructure the nodes as:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    WITH_NT</span>
<span class="plain-syntax">        COMMON_NOUN_NT K4_door</span>
<span class="plain-syntax">        AND_NT</span>
<span class="plain-syntax">            ADJECTIVE_NT prop:p46_openable</span>
<span class="plain-syntax">            ADJECTIVE_NT prop:p44_open</span>
</pre>
<p class="commentary">This innocent-looking little routine involved drawing a lot of diagrams
on the back of an envelope. Change at your peril.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Assertions::Refiner::perform_and_surgery</span><button class="popup" onclick="togglePopup('usagePopup11')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup11">Usage of <span class="code-font"><span class="function-syntax">Assertions::Refiner::perform_and_surgery</span></span>:<br/><a href="9-rpt.html#SP9_3">&#167;9.3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">x</span><span class="plain-syntax">, *</span><span class="identifier-syntax">a_p</span><span class="plain-syntax">, *</span><span class="identifier-syntax">w_p</span><span class="plain-syntax">, *</span><span class="identifier-syntax">p1_p</span><span class="plain-syntax">, *</span><span class="identifier-syntax">p2_p</span><span class="plain-syntax">, *</span><span class="identifier-syntax">i_p</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">) == </span><span class="constant-syntax">ADJECTIVE_NT</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        &amp;&amp; (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">) == </span><span class="identifier-syntax">WITH_NT</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">a_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">; </span><span class="identifier-syntax">p1_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">; </span><span class="identifier-syntax">w_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">i_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">w_p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">; </span><span class="identifier-syntax">p2_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i_p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">;</span>

<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">a_p</span><span class="plain-syntax">, </span><span class="identifier-syntax">WITH_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_type_and_clear_annotations</span><span class="plain-syntax">(</span><span class="identifier-syntax">w_p</span><span class="plain-syntax">, </span><span class="identifier-syntax">AND_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">a_p</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">w_p</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">w_p</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">x</span><span class="plain-syntax"> = </span><span class="identifier-syntax">a_p</span><span class="plain-syntax">; </span><span class="identifier-syntax">a_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">w_p</span><span class="plain-syntax">; </span><span class="identifier-syntax">w_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">x</span><span class="plain-syntax">;</span>

<span class="plain-syntax">        </span><span class="identifier-syntax">w_p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i_p</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">i_p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">a_p</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">a_p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p1_p</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">a_p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p2_p</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP13"></a><b>&#167;13. With surgery. </b>This is a less traumatic operation, motivated by sentences like:
</p>

<blockquote>
    <p>In the Pitch is an open container with description "The box of stumps and bails."</p>
</blockquote>

<p class="commentary">The initial parse tree for such a sentence will have two nested <span class="extract"><span class="extract-syntax">WITH_NT</span></span>
clauses, which is arguably correct &mdash; "a (container with property open)
with description ..." &mdash; but which is inconvenient for our implementation
of <span class="extract"><span class="extract-syntax">WITH_NT</span></span> later on. So we construe the sentence instead with a single
"with", as "a container with properties open and description ..." In
terms of the tree,
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    WITH_NT</span>
<span class="plain-syntax">        WITH_NT</span>
<span class="plain-syntax">            COMMON_NOUN_NT K4_container</span>
<span class="plain-syntax">            ADJECTIVE_NT prop:p44_open</span>
<span class="plain-syntax">        PROPERTY_LIST_NT "The box..."</span>
</pre>
<p class="commentary">is reconstructed as:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    WITH_NT</span>
<span class="plain-syntax">        COMMON_NOUN_NT K4_container</span>
<span class="plain-syntax">        AND_NT</span>
<span class="plain-syntax">            ADJECTIVE_NT prop:p44_open</span>
<span class="plain-syntax">            PROPERTY_LIST_NT "The box..."</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Assertions::Refiner::perform_with_surgery</span><button class="popup" onclick="togglePopup('usagePopup12')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup12">Usage of <span class="code-font"><span class="function-syntax">Assertions::Refiner::perform_with_surgery</span></span>:<br/><a href="9-rpt.html#SP9_2">&#167;9.2</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">inst</span><span class="plain-syntax">, *</span><span class="identifier-syntax">prop_1</span><span class="plain-syntax">, *</span><span class="identifier-syntax">prop_2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">) == </span><span class="identifier-syntax">WITH_NT</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">) == </span><span class="identifier-syntax">WITH_NT</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inst</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">prop_1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">prop_2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">inst</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">AND_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">prop_1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">prop_2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP14"></a><b>&#167;14. Location surgery. </b>This is needed to make sentences like the second one
here work:
</p>

<blockquote>
    <p>The escalator is a door. It is below the Kudamm and above the U-Bahn.</p>
</blockquote>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">        RELATIONSHIP_NT &lt;below&gt; (CONTAINS_THINGS_INF)</span>
<span class="plain-syntax">            AND_NT</span>
<span class="plain-syntax">                PROPER_NOUN_NT &lt;kudamm&gt; (definite)</span>
<span class="plain-syntax">                RELATIONSHIP_NT &lt;above&gt; (CONTAINS_THINGS_INF)</span>
<span class="plain-syntax">                    PROPER_NOUN_NT &lt;u-bahn&gt; (definite)</span>
</pre>
<p class="commentary">into:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">        AND_NT</span>
<span class="plain-syntax">            RELATIONSHIP_NT &lt;below&gt; (CONTAINS_THINGS_INF)</span>
<span class="plain-syntax">                PROPER_NOUN_NT &lt;kudamm&gt; (definite)</span>
<span class="plain-syntax">            RELATIONSHIP_NT &lt;above&gt; (CONTAINS_THINGS_INF)</span>
<span class="plain-syntax">                PROPER_NOUN_NT &lt;u-bahn&gt; (definite)</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Assertions::Refiner::perform_location_surgery</span><button class="popup" onclick="togglePopup('usagePopup13')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup13">Usage of <span class="code-font"><span class="function-syntax">Assertions::Refiner::perform_location_surgery</span></span>:<br/><a href="9-rpt.html#SP9_5">&#167;9.5</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">old_and</span><span class="plain-syntax">, *</span><span class="identifier-syntax">old_np1</span><span class="plain-syntax">, *</span><span class="identifier-syntax">old_loc2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">) == </span><span class="identifier-syntax">RELATIONSHIP_NT</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">) == </span><span class="identifier-syntax">AND_NT</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">) == </span><span class="identifier-syntax">RELATIONSHIP_NT</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="constant-syntax">resolved_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">); </span><span class="comment-syntax"> otherwise this will be wrongly copied</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">old_and</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">old_np1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">old_and</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">old_loc2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">old_and</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">old_and</span><span class="plain-syntax">, </span><span class="identifier-syntax">p</span><span class="plain-syntax">); </span><span class="comment-syntax"> making this the new first location node</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_type_and_clear_annotations</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">AND_NT</span><span class="plain-syntax">); </span><span class="comment-syntax"> and this is new AND</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">old_and</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">old_and</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">old_np1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">old_and</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">old_loc2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">old_np1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP15"></a><b>&#167;15. Called surgery. </b>The following case occurs very rarely, on a noun phrase such as
"north of a room called the Hot and Cold Room". The problem, as usual, is
the two clauses are the wrong way around, so we perform surgery to turn:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    CALLED_NT  &lt;called&gt;</span>
<span class="plain-syntax">        RELATIONSHIP_NT  &lt;north of a room&gt; (type:direction)</span>
<span class="plain-syntax">            PROPER_NOUN_NT  &lt;room&gt; (indefinite)</span>
<span class="plain-syntax">            PROPER_NOUN_NT  &lt;north&gt; (no article)</span>
<span class="plain-syntax">        PROPER_NOUN_NT  &lt;hot and cold room&gt; (definite)</span>
</pre>
<p class="commentary">into:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    RELATIONSHIP_NT  &lt;called&gt; (type:direction)</span>
<span class="plain-syntax">        CALLED_NT  &lt;north of a room&gt;</span>
<span class="plain-syntax">            COMMON_NOUN_NT  &lt;room&gt;</span>
<span class="plain-syntax">            CREATED_NT  &lt;hot and cold room&gt;</span>
<span class="plain-syntax">        PROPER_NOUN_NT  &lt;north&gt; (no article)</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Assertions::Refiner::perform_called_surgery</span><button class="popup" onclick="togglePopup('usagePopup14')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup14">Usage of <span class="code-font"><span class="function-syntax">Assertions::Refiner::perform_called_surgery</span></span>:<br/><a href="9-rpt.html#SP9_4">&#167;9.4</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">x_pn</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">; </span><span class="comment-syntax"> "north" in the example</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">name_pn</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">; </span><span class="comment-syntax"> "hot and cold room" in the example</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">RELATIONSHIP_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">, </span><span class="identifier-syntax">CALLED_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">x_pn</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">name_pn</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP16"></a><b>&#167;16. The player is not yourself. </b>The following routine handles a feature added to Inform to handle just one
peculiarity of syntax: that the source text will often talk about "the
player" to mean the object which represents the player at the start of
play (properly called "yourself"), not the variable whose value is the
object currently representing the player.
</p>

<p class="commentary">But no explicit mention of this case appears here; in theory any plugin
can set up aliases of variable names to constants like this.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Assertions::Refiner::turn_player_to_yourself</span><button class="popup" onclick="togglePopup('usagePopup15')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup15">Usage of <span class="code-font"><span class="function-syntax">Assertions::Refiner::turn_player_to_yourself</span></span>:<br/>Make Assertions - <a href="9-ma.html#SP3_3_13">&#167;3.3.13</a>, <a href="9-ma.html#SP3_3_20">&#167;3.3.20</a>, <a href="9-ma.html#SP3_3_25">&#167;3.3.25</a>, <a href="9-ma.html#SP3_3_26">&#167;3.3.26</a>, <a href="9-ma.html#SP3_3_29">&#167;3.3.29</a>, <a href="9-ma.html#SP3_3_36">&#167;3.3.36</a>, <a href="9-ma.html#SP3_3_37">&#167;3.3.37</a><br/>Relation Knowledge - <a href="9-rk.html#SP3_1">&#167;3.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pn</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">pn</span><span class="plain-syntax">))) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">pn</span><span class="plain-syntax">) == </span><span class="identifier-syntax">PROPER_NOUN_NT</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">pn</span><span class="plain-syntax">, </span><span class="constant-syntax">turned_already_ANNOT</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">nonlocal_variable</span><span class="plain-syntax"> *</span><span class="identifier-syntax">q</span><span class="plain-syntax"> = </span><a href="5-nv.html#SP9" class="function-link"><span class="function-syntax">NonlocalVariables::parse</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">pn</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">diversion</span><span class="plain-syntax"> = </span><a href="5-nv.html#SP24" class="function-link"><span class="function-syntax">NonlocalVariables::get_alias</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">q</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">diversion</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><a href="9-rpt.html#SP1" class="function-link"><span class="function-syntax">Assertions::Refiner::noun_from_infs</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">pn</span><span class="plain-syntax">, </span><span class="identifier-syntax">diversion</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">pn</span><span class="plain-syntax">, </span><span class="constant-syntax">turned_already_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="9-tbath.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-cm.html">1</a></li><li class="progresschapter"><a href="2-up.html">2</a></li><li class="progresschapter"><a href="3-nl.html">3</a></li><li class="progresschapter"><a href="4-its.html">4</a></li><li class="progresschapter"><a href="5-lp.html">5</a></li><li class="progresschapter"><a href="6-up.html">6</a></li><li class="progresschapter"><a href="7-ptu.html">7</a></li><li class="progresschapter"><a href="8-ef.html">8</a></li><li class="progresscurrentchapter">9</li><li class="progresssection"><a href="9-ita.html">ita</a></li><li class="progresssection"><a href="9-tfa.html">tfa</a></li><li class="progresssection"><a href="9-tbath.html">tbath</a></li><li class="progresscurrent">rpt</li><li class="progresssection"><a href="9-tc.html">tc</a></li><li class="progresssection"><a href="9-ma.html">ma</a></li><li class="progresssection"><a href="9-pk.html">pk</a></li><li class="progresssection"><a href="9-rk.html">rk</a></li><li class="progresssection"><a href="9-ass.html">ass</a></li><li class="progresssection"><a href="9-imp.html">imp</a></li><li class="progresssection"><a href="9-pd.html">pd</a></li><li class="progresschapter"><a href="10-aots.html">10</a></li><li class="progresschapter"><a href="11-itpc.html">11</a></li><li class="progresschapter"><a href="12-ter.html">12</a></li><li class="progresschapter"><a href="13-kak.html">13</a></li><li class="progresschapter"><a href="14-sp.html">14</a></li><li class="progresschapter"><a href="15-pr.html">15</a></li><li class="progresschapter"><a href="16-is.html">16</a></li><li class="progresschapter"><a href="17-tl.html">17</a></li><li class="progresschapter"><a href="18-lc.html">18</a></li><li class="progresschapter"><a href="19-tc.html">19</a></li><li class="progresschapter"><a href="20-eq.html">20</a></li><li class="progresschapter"><a href="21-rl.html">21</a></li><li class="progresschapter"><a href="22-itp.html">22</a></li><li class="progresschapter"><a href="23-ad.html">23</a></li><li class="progresschapter"><a href="24-lv.html">24</a></li><li class="progresschapter"><a href="25-in.html">25</a></li><li class="progresschapter"><a href="26-fc.html">26</a></li><li class="progresschapter"><a href="27-hr.html">27</a></li><li class="progressnext"><a href="9-tc.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

