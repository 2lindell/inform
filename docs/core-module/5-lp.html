<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>4/am</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '5/lp' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#5">Chapter 5: Nouns</a></li><li><b>Literal Patterns</b></li></ul><p class="purpose">To manage the possible notations with which literal values can be written.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP9">&#167;9. Creating patterns, tokens and elements</a></li><li><a href="#SP12">&#167;12. Listing LPs</a></li><li><a href="#SP17">&#167;17. Optional break points</a></li><li><a href="#SP18">&#167;18. Matching an LP in the source text</a></li><li><a href="#SP19">&#167;19. Matching an LP at run-time</a></li><li><a href="#SP20">&#167;20. Indexing literal patterns for a given kind</a></li><li><a href="#SP23">&#167;23. Printing values in an LP's notation to the index at compile-time</a></li><li><a href="#SP27">&#167;27. Printing the I6 variable |value| out in an LP's notation at run-time</a></li><li><a href="#SP31">&#167;31. Creating new literal patterns</a></li><li><a href="#SP40">&#167;40. I7 phrases to print values in specified ways</a></li><li><a href="#SP41">&#167;41. I7 phrases to pack and unpack the value</a></li><li><a href="#SP42">&#167;42. The kind's list</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>Literals are excerpts of text which explicitly specify values, rather than
by indirectly naming them. "15" is a literal but "the score" is not, even
if it happens to have the value 15. Inform contains specific code to parse
literals such as
</p>

<blockquote>
    <p>-314, "Morocco leather", 10:41 PM</p>

</blockquote>

<p class="inwebparagraph">(see "Lexer.w" and "Parsing Literals.w"), but it also has a system
allowing the user to create new notations for quasi-numerical kinds of value.
For example,
</p>

<blockquote>
    <p>16:9 specifies an aspect ratio.</p>

</blockquote>

<p class="inwebparagraph">establishes a new notation for writing literal aspect ratios. This notation
is stored internally as a "literal pattern", and the code to handle it
is found in this section. (No other sorts of literal are parsed here.)
Each kind of value has a linked list of literal notations which can specify
it, if any. We sometimes need to iterate through the this list, and can do
so with the following macro:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="identifier">LITERAL_FORMS_LOOP</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">)</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> = </span><span class="functiontext">LiteralPatterns::list_of_literal_forms</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">); </span><span class="identifier">lp</span><span class="plain">;</span>
            <span class="identifier">lp</span><span class="plain">=</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain">)</span>
</pre>
<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>LPs with just a single numerical part to them (like "20 yards" rather than
"16:9") are of special interest for holding scientific measurements, and
we provide elaborate extra features for this form of LP.
</p>

<p class="inwebparagraph">A given kind can have many different LPs to represent it, and this is
especially convenient for physics &mdash; it means we can give ways to describe
mass (a kind of value) in grams, kilograms or tonnes (all literal patterns).
Among these, one LP is special and is called the "benchmark" for the kind &mdash;
it is the default notation, the one considered most natural, and other LPs for
the same kind are scaled relative to this. For instance, the benchmark for
mass might be the notation "1 kg"; the notations "1 g" and "1 tonne" would
then be scaled down by 1000, or scaled up by 1000, as compared with the
benchmark.
</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>Syntactically, a literal pattern is a series of "tokens", of which more
below. Some tokens are simply fixed lettering or wording, but others
represent positions where "elements" &mdash; the numerical parts &mdash; appear. In
the "16:9" notation, there are three tokens &mdash; an element token, a fixed
colon, and another element token. At least one of the tokens has to be a
element token.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">MAX_ELEMENTS_PER_LITERAL</span><span class="plain"> 8</span>
    <span class="definitionkeyword">define</span> <span class="constant">MAX_TOKENS_PER_LITERAL</span><span class="plain"> 100</span>
</pre>

<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">literal_pattern</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">kind_specified</span><span class="plain">; </span>    <span class="comment">the kind of the result: i.e., what it specifies</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">next_for_this_kind</span><span class="plain">; </span>    <span class="comment">continuing list for this kind</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">prototype_text</span><span class="plain">; </span>    <span class="comment">where the prototype specification is</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">no_lp_tokens</span><span class="plain">; </span>    <span class="comment">number of tokens in parse_node</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">literal_pattern_token</span><span class="plain"> </span><span class="identifier">lp_tokens</span><span class="plain">[</span><span class="constant">MAX_TOKENS_PER_LITERAL</span><span class="plain">];</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">no_lp_elements</span><span class="plain">; </span>    <span class="comment">how many tokens are numbers</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">literal_pattern_element</span><span class="plain"> </span><span class="identifier">lp_elements</span><span class="plain">[</span><span class="constant">MAX_ELEMENTS_PER_LITERAL</span><span class="plain">];</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">number_signed</span><span class="plain">; </span>    <span class="comment">for instance -10 cm would be allowed if this is set</span>

        <span class="comment">used when we have a sequence of alternative notations for the same unit</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">primary_alternative</span><span class="plain">; </span>    <span class="comment">first of a set of alternatives?</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">next_alternative_lp</span><span class="plain">; </span>    <span class="comment">continuing list of alternatives</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">singular_form_only</span><span class="plain">; </span>    <span class="comment">print using this notation only for 1 unit</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">plural_form_only</span><span class="plain">; </span>    <span class="comment">print using this notation for 2 units, 0.5 units, etc.</span>

        <span class="comment">used when printing and calculating values</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">scaling_transformation</span><span class="plain"> </span><span class="identifier">scaling</span><span class="plain">; </span>    <span class="comment">how to convert apparent to actual values</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">equivalent_unit</span><span class="plain">; </span>    <span class="comment">is this just an equivalent to another LP?</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">benchmark</span><span class="plain">; </span>    <span class="comment">is this the benchmark LP for its kind?</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">last_resort</span><span class="plain">; </span>    <span class="comment">is this the last possible LP to use when printing a value of the kind?</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">marked_for_printing</span><span class="plain">; </span>    <span class="comment">used in compiling printing routines</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">jump_label</span><span class="plain">;</span>

        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">literal_pattern</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure literal_pattern is private to this section.</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">LITERAL_PATTERNS</span>
</pre>
<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>There are three sorts of token: character, word and element. Each token can
be a whole word, or only part of a word. For instance, in
</p>

<blockquote>
    <p>28kg net specifies a weight.</p>

</blockquote>

<p class="inwebparagraph">we have a sequence of four tokens: an element token, marked as beginning a
word; a character token <code class="display"><span class="extract">k</span></code>; a character token <code class="display"><span class="extract">g</span></code>; and a word token <code class="display"><span class="extract">net</span></code>,
which necessarily begins a word. Word boundaries in the source text must
match those in the specification, so this notation does not match the text
"41 kg net", for instance.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">WORD_LPT</span><span class="plain"> 1</span>
    <span class="definitionkeyword">define</span> <span class="constant">CHARACTER_LPT</span><span class="plain"> 2</span>
    <span class="definitionkeyword">define</span> <span class="constant">ELEMENT_LPT</span><span class="plain"> 3</span>
</pre>

<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">literal_pattern_token</span><span class="plain"> {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">new_word_at</span><span class="plain">; </span>    <span class="comment">does token start a new word?</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">lpt_type</span><span class="plain">; </span>    <span class="comment">one of the three constants defined above</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">token_char</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">CHARACTER_LPT</span></code> only; the character to match</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">token_wn</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">WORD_LPT</span></code> only; word number in source text of the prototype</span>
    <span class="plain">} </span><span class="reserved">literal_pattern_token</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure literal_pattern_token is private to this section.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>A value notated this way is like an old-school Pascal packed integer,
where a small data structure was joined into a single word of data. For
instance, in the "16:9" example, e_0:e_1 would be stored as
e_0r_1+e_1 where r_1 = 10 is one more than the maximum value of e_1.
So "4:3" would be stored as 4.(9+1) + 3 = 43.
</p>

<p class="inwebparagraph">More formally, we call the numbers in such a literal its "elements". In the
case of "16:9", there are two elements, e_0 = 16 and e_1 = 9. The general
formula is:
 N = Σ_{i=0}^{n-1} e_i. Π_{j&gt;i} r_j 
where (e_0, e_1, ..., e_{n-1}) are the values and r_j, the "range",
is the constraint such that 0&lt;= e_j &lt; r_j.
Note that r_0 is never required, since e_0 is constrained in size only
by the need for N to fit into a single virtual machine integer. The value
 m_i = Π_{j&gt;i} r_j 
is called the "multiplier", and note that m_{n-1} = 1. Conversely,
e_i = N/m_0 if i=0, and N/m_i ~mod~ r_i otherwise.
The rightmost element e_{n-1} is the least significant numerically.
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">literal_pattern_element</span><span class="plain"> {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">element_index</span><span class="plain">; </span>    <span class="comment">the value i placing this within its LP, where 0&lt;= i&lt;n</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">element_range</span><span class="plain">; </span>    <span class="comment">the value r_i for this LP</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">element_multiplier</span><span class="plain">; </span>    <span class="comment">the value m_i for this LP</span>

        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">element_name</span><span class="plain">; </span>    <span class="comment">if we define a name for the element</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">is_real</span><span class="plain">; </span>    <span class="comment">store as a real number, not an integer?</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">without_leading_zeros</span><span class="plain">; </span>    <span class="comment">normally without?</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">element_optional</span><span class="plain">; </span>    <span class="comment">can we truncate the LP here?</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">preamble_optional</span><span class="plain">; </span>    <span class="comment">if so, can we lose the preamble as well?</span>
    <span class="plain">} </span><span class="reserved">literal_pattern_element</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure literal_pattern_element is accessed in 1/kts and here.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>For the sake of printing, we can specify which notation is to be used in
printing a value back. For instance,
</p>

<blockquote>
    <p>1 tonne (in tonnes, singular) specifies a mass scaled up by 1000.</p>

</blockquote>

<p class="inwebparagraph">assigns the name "in tonnes" to this notation for writing a mass. There can
be several notation associated with "in tonnes":
</p>

<blockquote>
    <p>2 tonnes (in tonnes, plural) specifies a mass scaled up by 1000.</p>

</blockquote>

<p class="inwebparagraph">and hence the linked list of LPs associated with a single "literal pattern
name". Moreover, a given kind of value can support multiple named notations;
mass might also support "in kilograms" and "in grams", for instance.
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">literal_pattern_name</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">notation_name</span><span class="plain">; </span>    <span class="comment">name for this notation, if any; e.g. "in centimetres"</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">can_use_this_lp</span><span class="plain">; </span>    <span class="comment">list of LPs used under this name</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">literal_pattern_name</span><span class="plain"> *</span><span class="identifier">next</span><span class="plain">; </span>    <span class="comment">other names for the same kind</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">literal_pattern_name</span><span class="plain"> *</span><span class="identifier">next_with_rp</span><span class="plain">; </span>    <span class="comment">used in parsing only: list applied to one notation</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">lpn_compiled_already</span><span class="plain">;</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">literal_pattern_name</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure literal_pattern_name is accessed in 3/pd, 5/ut, 5/un, 5/ins, 6/rlt, 6/nv, 7/ss, 7/hdn, 7/ns, 7/oaf, 7/rs, 8/ie, 8/ec, 8/ed, 9/tfa, 9/tbath, 9/rpt, 9/tc, 9/ma, 9/rk, 9/ass, 9/imp, 9/pd, 10/teav, 10/cap, 11/ap, 11/pr, 11/bas, 11/tc, 11/sm, 12/dtd, 12/cdp, 14/rv, 14/lv, 14/cn, 14/ds, 14/ds2, 15/cp, 16/is, 16/in, 19/tb, 19/rsft, 19/tod, 20/eq, 21/rl, 21/rl2, 21/fao, 21/rps, 21/sv, 21/ac, 22/ph, 22/tp, 22/tp2, 23/ad, 24/lv, 24/sf, 25/in, 25/pi, 25/cii, 25/cp, 26/uo, 26/tti, 26/pc, 26/ts, 27/cm and here.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Creating patterns, tokens and elements. </b></p>


<pre class="display">
    <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="functiontext">LiteralPatterns::lp_new</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">literal_pattern</span><span class="plain">);</span>
        <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;plural_form_only</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;singular_form_only</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;kind_specified</span><span class="plain"> = </span><span class="identifier">K</span><span class="plain">;</span>
        <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;prototype_text</span><span class="plain"> = </span><span class="identifier">W</span><span class="plain">;</span>
        <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;primary_alternative</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_alternative_lp</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_elements</span><span class="plain"> = 0;</span>
        <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_tokens</span><span class="plain"> = 0;</span>
        <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;number_signed</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain"> = </span><span class="identifier">Kinds::Scalings::new</span><span class="plain">(</span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">LP_SCALED_AT</span><span class="plain">, 1, 1.0, 0, 0.0);</span>
        <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;equivalent_unit</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;benchmark</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;jump_label</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">lp</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::lp_new is used in <a href="#SP34_9">&#167;34.9</a>.</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b></p>


<pre class="display">
    <span class="reserved">literal_pattern_token</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::lpt_new</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">t</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">nw</span><span class="plain">) {</span>
        <span class="reserved">literal_pattern_token</span><span class="plain"> </span><span class="identifier">lpt</span><span class="plain">;</span>
        <span class="identifier">lpt</span><span class="element">.new_word_at</span><span class="plain"> = </span><span class="identifier">nw</span><span class="plain">;</span>
        <span class="identifier">lpt</span><span class="element">.lpt_type</span><span class="plain"> = </span><span class="identifier">t</span><span class="plain">;</span>
        <span class="identifier">lpt</span><span class="element">.token_char</span><span class="plain"> = 0;</span>
        <span class="identifier">lpt</span><span class="element">.token_wn</span><span class="plain"> = -1;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">lpt</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::lpt_new is used in <a href="#SP34_10">&#167;34.10</a>, <a href="#SP34_10_1">&#167;34.10.1</a>.</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b></p>


<pre class="display">
    <span class="reserved">literal_pattern_element</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::lpe_new</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">r</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">sgn</span><span class="plain">) {</span>
        <span class="reserved">literal_pattern_element</span><span class="plain"> </span><span class="identifier">lpe</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain"> == 0) </span><span class="identifier">lpe</span><span class="element">.element_range</span><span class="plain"> = -1; </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">lpe</span><span class="element">.element_range</span><span class="plain"> = </span><span class="identifier">r</span><span class="plain">;</span>
        <span class="identifier">lpe</span><span class="element">.element_multiplier</span><span class="plain"> = 1;</span>
        <span class="identifier">lpe</span><span class="element">.element_index</span><span class="plain"> = </span><span class="identifier">i</span><span class="plain">;</span>
        <span class="identifier">lpe</span><span class="element">.element_name</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">lpe</span><span class="element">.preamble_optional</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">lpe</span><span class="element">.element_optional</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">lpe</span><span class="element">.without_leading_zeros</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">lpe</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::lpe_new is used in <a href="#SP34_10_1">&#167;34.10.1</a>.</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Listing LPs. </b>A routine to append a LP to the linked list of LPs for a given kind. But
it's a little more involved because this is where we calculate the scale
factors which relate LPs in the list, and also because we need to keep the
list in a particular order.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">PM_ZMachineOverflow2_issued</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>

    <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="functiontext">LiteralPatterns::list_add</span><span class="plain">(</span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">list_head</span><span class="plain">,</span>
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">new_lp</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">using_integer_scaling</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">list_head</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span>&lt;<span class="cwebmacro">Begin a new list with just the new LP in it</span> <span class="cwebmacronumber">12.1</span>&gt;
        <span class="reserved">else</span><span class="plain"> </span>&lt;<span class="cwebmacro">Add the new LP to the existing list</span> <span class="cwebmacronumber">12.2</span>&gt;<span class="plain">;</span>

        &lt;<span class="cwebmacro">Correct the "last resort" flags in the list of LPs</span> <span class="cwebmacronumber">12.3</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Automatically enable signed literals if there are scaled LPs in the list</span> <span class="cwebmacronumber">12.4</span>&gt;<span class="plain">;</span>

        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">list_head</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::list_add is used in <a href="#SP42">&#167;42</a>.</p>

<p class="inwebparagraph"><a id="SP12_1"></a><b>&#167;12.1.  </b>When the new LP is the first one, it can only be scaled in absolute terms:
"scaled at", which specifies its M value.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Begin a new list with just the new LP in it</span> <span class="cwebmacronumber">12.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Kinds::Scalings::determine_M</span><span class="plain">(&amp;(</span><span class="identifier">new_lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">), </span><span class="identifier">NULL</span><span class="plain">,</span>
            <span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">new_lp</span><span class="plain">-</span><span class="element">&gt;equivalent_unit</span><span class="plain">, </span><span class="identifier">new_lp</span><span class="plain">-</span><span class="element">&gt;primary_alternative</span><span class="plain">);</span>
        <span class="identifier">list_head</span><span class="plain"> = </span><span class="identifier">new_lp</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP12_2"></a><b>&#167;12.2.  </b>But if other LPs already exist, then absolute scalings are forbidden. The
new LP must be scaled up or down relative to existing notations, or pegged
equivalent to an exact value.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Add the new LP to the existing list</span> <span class="cwebmacronumber">12.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">;</span>
        <span class="identifier">scaling_transformation</span><span class="plain"> *</span><span class="identifier">benchmark_sc</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">list_head</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;benchmark</span><span class="plain">) </span><span class="identifier">benchmark_sc</span><span class="plain"> = &amp;(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">);</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">rescale_factor</span><span class="plain"> = </span><span class="identifier">Kinds::Scalings::determine_M</span><span class="plain">(&amp;(</span><span class="identifier">new_lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">), </span><span class="identifier">benchmark_sc</span><span class="plain">,</span>
            <span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">new_lp</span><span class="plain">-</span><span class="element">&gt;equivalent_unit</span><span class="plain">, </span><span class="identifier">new_lp</span><span class="plain">-</span><span class="element">&gt;primary_alternative</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">rescale_factor</span><span class="plain"> != 1)</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">list_head</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">lp</span><span class="plain"> != </span><span class="identifier">new_lp</span><span class="plain">) &amp;&amp; (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;equivalent_unit</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">))</span>
                    <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain"> =</span>
                        <span class="identifier">Kinds::Scalings::enlarge</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">, </span><span class="identifier">rescale_factor</span><span class="plain">);</span>

        <span class="identifier">list_head</span><span class="plain"> = </span><span class="functiontext">LiteralPatterns::lp_list_add_inner</span><span class="plain">(</span><span class="identifier">list_head</span><span class="plain">, </span><span class="identifier">new_lp</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">VirtualMachines::is_16_bit</span><span class="plain">()) &amp;&amp; (</span><span class="identifier">PM_ZMachineOverflow2_issued</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">))</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">list_head</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Scalings::quantum</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">) &gt; 32767) {</span>
                    <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ZMachineOverflow2</span><span class="plain">),</span>
                        <span class="string">"you've set up literal specifications needing a range of "</span>
                        <span class="string">"values too broad to be stored at run-time"</span><span class="plain">,</span>
                        <span class="string">"at least with the Settings for this project as they currently are. "</span>
                        <span class="string">"(Change to Glulx to be allowed to use much larger numbers; "</span>
                        <span class="string">"or for really enormous values, use real arithmetic.)"</span><span class="plain">);</span>
                    <span class="identifier">PM_ZMachineOverflow2_issued</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                    <span class="reserved">break</span><span class="plain">;</span>
                <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP12_3"></a><b>&#167;12.3.  </b>Within the list, exactly one LP is marked with the <code class="display"><span class="extract">last_resort</span></code> flag: the
last one not marked as an equivalent unit. (You can only be equivalent to
something already there, so it's not possible for all the LPs in the list to
be equivalent.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Correct the "last resort" flags in the list of LPs</span> <span class="cwebmacronumber">12.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">, *</span><span class="identifier">last_resorter</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">list_head</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain">) {</span>
            <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;last_resort</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;equivalent_unit</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">last_resorter</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">last_resorter</span><span class="plain">) </span><span class="identifier">last_resorter</span><span class="plain">-</span><span class="element">&gt;last_resort</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP12_4"></a><b>&#167;12.4.  </b>Inform is ordinarily a bit picky about not allowing negative values within
these notations, unless they have explicitly been defined to allow it. That
makes sense for basically combinatorial notations (room 1 to room 64, say)
but would be a nonsense for scientific measurements where we intend to perform
arithmetic. So:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Automatically enable signed literals if there are scaled LPs in the list</span> <span class="cwebmacronumber">12.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">scalings_exist</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">list_head</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Scalings::involves_scale_change</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">))</span>
                <span class="identifier">scalings_exist</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">scalings_exist</span><span class="plain">)</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">list_head</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain">)</span>
                <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;number_signed</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b>The actual insertion of the new LP into the list is carried out here, and
is complicated by the fact that we need to keep these in a special order.
</p>


<pre class="display">
    <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="functiontext">LiteralPatterns::lp_list_add_inner</span><span class="plain">(</span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">list_head</span><span class="plain">, </span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">new_lp</span><span class="plain">) {</span>
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">, *</span><span class="identifier">lp_prev</span><span class="plain">;</span>
        <span class="identifier">new_lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">list_head</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">new_lp</span><span class="plain">;</span>
        <span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">list_head</span><span class="plain">; </span><span class="identifier">lp_prev</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">LiteralPatterns::lp_precedes</span><span class="plain">(</span><span class="identifier">new_lp</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">)) {</span>
                <span class="identifier">new_lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp_prev</span><span class="plain">) </span><span class="identifier">lp_prev</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain"> = </span><span class="identifier">new_lp</span><span class="plain">;</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="identifier">list_head</span><span class="plain"> = </span><span class="identifier">new_lp</span><span class="plain">;</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">list_head</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="identifier">lp_prev</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">;</span>
            <span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">lp_prev</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain"> = </span><span class="identifier">new_lp</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">list_head</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::lp_list_add_inner is used in <a href="#SP12_2">&#167;12.2</a>.</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14.  </b>Highly scaled values come before less scaled ones; otherwise plural forms
come before singular ones; and otherwise an earlier-defined LP comes before
a later one.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::lp_precedes</span><span class="plain">(</span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">A</span><span class="plain">, </span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">B</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">s</span><span class="plain"> = </span><span class="identifier">Kinds::Scalings::compare</span><span class="plain">(</span><span class="identifier">A</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">, </span><span class="identifier">B</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">s</span><span class="plain"> &gt; 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">s</span><span class="plain"> &lt; 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">A</span><span class="plain">-</span><span class="element">&gt;primary_alternative</span><span class="plain">) &amp;&amp; (</span><span class="identifier">B</span><span class="plain">-</span><span class="element">&gt;primary_alternative</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">A</span><span class="plain">-</span><span class="element">&gt;primary_alternative</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">B</span><span class="plain">-</span><span class="element">&gt;primary_alternative</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">A</span><span class="plain">-</span><span class="element">&gt;plural_form_only</span><span class="plain">) &amp;&amp; (</span><span class="identifier">B</span><span class="plain">-</span><span class="element">&gt;plural_form_only</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">A</span><span class="plain">-</span><span class="element">&gt;plural_form_only</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">B</span><span class="plain">-</span><span class="element">&gt;plural_form_only</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">A</span><span class="plain">-</span><span class="element">&gt;singular_form_only</span><span class="plain">) &amp;&amp; (</span><span class="identifier">B</span><span class="plain">-</span><span class="element">&gt;singular_form_only</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">A</span><span class="plain">-</span><span class="element">&gt;singular_form_only</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">B</span><span class="plain">-</span><span class="element">&gt;singular_form_only</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">A</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain"> &lt; </span><span class="identifier">B</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::lp_precedes is used in <a href="#SP13">&#167;13</a>.</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b>One member of the list is the "benchmark", as noted above.
</p>


<pre class="display">
    <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="functiontext">LiteralPatterns::get_benchmark</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">;</span>
        <span class="identifier">LITERAL_FORMS_LOOP</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;benchmark</span><span class="plain">)</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">lp</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::get_benchmark is used in <a href="#SP16">&#167;16</a>, <a href="#SP20">&#167;20</a>.</p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16.  </b>And this returns the multiplier of the benchmark, which is important for
performing multiplications (see "Dimensions").
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::scale_factor</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">benchmark_lp</span><span class="plain"> = </span><span class="functiontext">LiteralPatterns::get_benchmark</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">benchmark_lp</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">Kinds::Scalings::get_integer_multiplier</span><span class="plain">(</span><span class="identifier">benchmark_lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> 1;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::scale_factor appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17. Optional break points. </b>Sometimes the pattern allows later numerical elements to be skipped, in which
case they are understood to be 0.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::at_optional_break_point</span><span class="plain">(</span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">ec</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">tc</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">ec</span><span class="plain">&lt;</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_elements</span><span class="plain">) &amp;&amp; </span>    <span class="comment">i.e., if there are still numerical elements to supply</span>
            <span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">ec</span><span class="plain">]</span><span class="element">.element_optional</span><span class="plain">) &amp;&amp; </span>    <span class="comment">but which are optional</span>
            <span class="plain">((</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">ec</span><span class="plain">]</span><span class="element">.preamble_optional</span><span class="plain">) || </span>    <span class="comment">and either the preamble tokens are also optional</span>
                <span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.lpt_type</span><span class="plain"> == </span><span class="constant">ELEMENT_LPT</span><span class="plain">))) </span>    <span class="comment">or we're at the number token</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::at_optional_break_point is used in <a href="#SP18_1">&#167;18.1</a>, <a href="#SP19">&#167;19</a>.</p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18. Matching an LP in the source text. </b>Given an excerpt <code class="display"><span class="extract">(w1, w2)</span></code>, we try to parse it as a constant value written
in the LP notation: if it passes, we return the kind of value, and if not
we return <code class="display"><span class="extract">NULL</span></code>.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">waive_lp_overflows</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">last_LP_problem_at</span><span class="plain"> = -1;</span>
    <span class="reserved">double</span><span class="plain"> </span><span class="identifier">latest_constructed_real</span><span class="plain"> = 0.0;</span>

    <span class="identifier">kind</span><span class="plain"> *</span><span class="functiontext">LiteralPatterns::match</span><span class="plain">(</span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">found</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">matched_number</span><span class="plain"> = 0, </span><span class="identifier">overflow_16_bit_flag</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">overflow_32_bit_flag</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">literal_pattern_element</span><span class="plain"> *</span><span class="identifier">sign_used_at</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">, *</span><span class="identifier">element_overflow_at</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>

        <span class="comment">if the excerpt is longer than the maximum length of such a notation, give up quickly:</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">) &gt; </span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;prototype_text</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>

        &lt;<span class="cwebmacro">Try to match the excerpt against the whole prototype or up to an optional break</span> <span class="cwebmacronumber">18.1</span>&gt;<span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sign_used_at</span><span class="plain">) </span>&lt;<span class="cwebmacro">Check that a negative number can be used in this notation</span> <span class="cwebmacronumber">18.2</span>&gt;<span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">waive_lp_overflows</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">element_overflow_at</span><span class="plain">) </span>&lt;<span class="cwebmacro">Report a problem because one element in the notation overflows</span> <span class="cwebmacronumber">18.4</span>&gt;<span class="plain">;</span>
            &lt;<span class="cwebmacro">Check that the value found lies within the range which the VM can hold</span> <span class="cwebmacronumber">18.3</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>

        <span class="plain">*</span><span class="identifier">found</span><span class="plain"> = </span><span class="identifier">matched_number</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;kind_specified</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::match is used in 10/pl (<a href="10-pl.html#SP1">&#167;1</a>).</p>

<p class="inwebparagraph"><a id="SP18_1"></a><b>&#167;18.1.  </b>Scanning the tokens one at a time. The scan position is represented as a
word number <code class="display"><span class="extract">wn</span></code> together with a character position within the word, <code class="display"><span class="extract">wpos</span></code>.
The <code class="display"><span class="extract">wpos</span></code> value -1 means that word <code class="display"><span class="extract">wn</span></code> has not yet been started.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Try to match the excerpt against the whole prototype or up to an optional break</span> <span class="cwebmacronumber">18.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">tc</span><span class="plain">, </span><span class="identifier">wn</span><span class="plain"> = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">), </span><span class="identifier">wpos</span><span class="plain"> = -1, </span><span class="identifier">ec</span><span class="plain"> = 0, </span><span class="identifier">matched_scaledown</span><span class="plain"> = 1, </span><span class="identifier">parsed_as_real</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">wd</span><span class="plain"> = </span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">tc</span><span class="plain">=0; </span><span class="identifier">tc</span><span class="plain">&lt;</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_tokens</span><span class="plain">; </span><span class="identifier">tc</span><span class="plain">++) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wn</span><span class="plain"> &gt; </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">wpos</span><span class="plain"> == -1) </span>    <span class="comment">i.e., if we are cleanly at a word boundary</span>
                    <span class="plain">&amp;&amp; (</span><span class="functiontext">LiteralPatterns::at_optional_break_point</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">ec</span><span class="plain">, </span><span class="identifier">tc</span><span class="plain">))) </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.lpt_type</span><span class="plain">) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">WORD_LPT</span><span class="plain">: </span>&lt;<span class="cwebmacro">Match a fixed word token within a literal pattern</span> <span class="cwebmacronumber">18.1.1</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">CHARACTER_LPT</span><span class="plain">: </span>&lt;<span class="cwebmacro">Match a character token within a literal pattern</span> <span class="cwebmacronumber">18.1.2</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">ELEMENT_LPT</span><span class="plain">: </span>&lt;<span class="cwebmacro">Match an element token within a literal pattern</span> <span class="cwebmacronumber">18.1.3</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">default</span><span class="plain">: </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"unknown literal pattern token type"</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wpos</span><span class="plain"> &gt;= 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">we need to end cleanly, not in mid-word</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wn</span><span class="plain"> &lt;= </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">and we need to have used up all of the excerpt</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">parsed_as_real</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">loses_accuracy</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="identifier">scaling_transformation</span><span class="plain"> </span><span class="identifier">sc</span><span class="plain"> =</span>
                <span class="identifier">Kinds::Scalings::contract</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">, </span><span class="identifier">matched_scaledown</span><span class="plain">, &amp;</span><span class="identifier">loses_accuracy</span><span class="plain">);</span>
            <span class="identifier">matched_number</span><span class="plain"> = </span><span class="identifier">Kinds::Scalings::quanta_to_value</span><span class="plain">(</span><span class="identifier">sc</span><span class="plain">, </span><span class="identifier">matched_number</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">loses_accuracy</span><span class="plain">) </span>&lt;<span class="cwebmacro">Report a problem because not enough accuracy is available</span> <span class="cwebmacronumber">18.1.4</span>&gt;<span class="plain">;</span>
            <span class="reserved">long</span><span class="plain"> </span><span class="reserved">long</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">max_16_bit</span><span class="plain"> = 32767</span><span class="identifier">LL</span><span class="plain">, </span><span class="identifier">max_32_bit</span><span class="plain"> = 2147483647</span><span class="identifier">LL</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">matched_number</span><span class="plain"> &gt; </span><span class="identifier">max_16_bit</span><span class="plain">) </span><span class="identifier">overflow_16_bit_flag</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">matched_number</span><span class="plain"> &gt; </span><span class="identifier">max_32_bit</span><span class="plain">) </span><span class="identifier">overflow_32_bit_flag</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sign_used_at</span><span class="plain">) </span><span class="identifier">matched_number</span><span class="plain"> = -</span><span class="identifier">matched_number</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="plain">#</span><span class="identifier">pragma</span><span class="plain"> </span><span class="identifier">clang</span><span class="plain"> </span><span class="identifier">diagnostic</span><span class="plain"> </span><span class="identifier">push</span>
            <span class="plain">#</span><span class="identifier">pragma</span><span class="plain"> </span><span class="identifier">clang</span><span class="plain"> </span><span class="identifier">diagnostic</span><span class="plain"> </span><span class="identifier">ignored</span><span class="plain"> </span><span class="string">"-Wsign-conversion"</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sign_used_at</span><span class="plain">) </span><span class="identifier">matched_number</span><span class="plain"> = </span><span class="identifier">matched_number</span><span class="plain"> | 0</span><span class="identifier">x80000000</span><span class="plain">;</span>
            <span class="plain">#</span><span class="identifier">pragma</span><span class="plain"> </span><span class="identifier">clang</span><span class="plain"> </span><span class="identifier">diagnostic</span><span class="plain"> </span><span class="identifier">pop</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18">&#167;18</a>.</p>

<p class="inwebparagraph"><a id="SP18_1_1"></a><b>&#167;18.1.1.  </b>A word token matches an exact word (but allowing for variation in casing).
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Match a fixed word token within a literal pattern</span> <span class="cwebmacronumber">18.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wpos</span><span class="plain"> &gt;= 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">if we're still in the middle of the last word, we must fail</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">compare_words</span><span class="plain">(</span><span class="identifier">wn</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.token_wn</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">wn</span><span class="plain">++;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18_1">&#167;18.1</a>.</p>

<p class="inwebparagraph"><a id="SP18_1_2"></a><b>&#167;18.1.2.  </b>A character token matches only a single character &mdash; note the case insensitivity
here, because of the use of <code class="display"><span class="extract">tolower</span></code>.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Match a character token within a literal pattern</span> <span class="cwebmacronumber">18.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wpos</span><span class="plain"> == -1) { </span><span class="identifier">wpos</span><span class="plain"> = 0; </span><span class="identifier">wd</span><span class="plain"> = </span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">wn</span><span class="plain">); } </span>    <span class="comment">start parsing the interior of a word</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Characters::tolower</span><span class="plain">(</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">++]) != </span><span class="identifier">Characters::tolower</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.token_char</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">] == 0) { </span><span class="identifier">wn</span><span class="plain">++; </span><span class="identifier">wpos</span><span class="plain"> = -1; } </span>    <span class="comment">and stop parsing the interior of a word</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18_1">&#167;18.1</a>.</p>

<p class="inwebparagraph"><a id="SP18_1_3"></a><b>&#167;18.1.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Match an element token within a literal pattern</span> <span class="cwebmacronumber">18.1.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">literal_pattern_element</span><span class="plain"> *</span><span class="identifier">lpe</span><span class="plain"> = &amp;(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">ec</span><span class="plain">++]); </span>    <span class="comment">fetch details of next number</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wpos</span><span class="plain"> == -1) { </span><span class="identifier">wpos</span><span class="plain"> = 0; </span><span class="identifier">wd</span><span class="plain"> = </span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">wn</span><span class="plain">); } </span>    <span class="comment">start parsing the interior of a word</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">] == </span><span class="character">'-'</span><span class="plain">) { </span><span class="identifier">sign_used_at</span><span class="plain"> = </span><span class="identifier">lpe</span><span class="plain">; </span><span class="identifier">wpos</span><span class="plain">++; }</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::FloatingPoint::uses_floating_point</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;kind_specified</span><span class="plain">)) </span>&lt;<span class="cwebmacro">Match a real number element token</span> <span class="cwebmacronumber">18.1.3.2</span>&gt;
        <span class="reserved">else</span><span class="plain"> </span>&lt;<span class="cwebmacro">Match an integer number element token</span> <span class="cwebmacronumber">18.1.3.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">] == 0) { </span><span class="identifier">wn</span><span class="plain">++; </span><span class="identifier">wpos</span><span class="plain"> = -1; } </span>    <span class="comment">and stop parsing the interior of a word</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18_1">&#167;18.1</a>.</p>

<p class="inwebparagraph"><a id="SP18_1_3_1"></a><b>&#167;18.1.3.1.  </b>There are three different sorts of overflow:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(1) The calculation of the packed value exceeding the range which an integer
can store on a 16-bit virtual machine;
</li><li>(2) Ditto, but on a 32-bit virtual machine; and
</li><li>(3) One of the numerical elements inside the notation being given out of range.
</li></ul>
<p class="inwebparagraph">We report none of these as a problem immediately &mdash; only if the pattern would
otherwise match.
</p>

<p class="inwebparagraph">The following assumes that <code class="display"><span class="extract">long long int</span></code> is at least 64-bit, so that it
can hold any 32-bit integer multiplied by 10, and also any product of two
32-bit numbers. This is true for all modern <code class="display"><span class="extract">gcc</span></code> implementations and is
required by PM_, but was not required by C90, so it is just possible that
this could cause trouble on unusual platforms.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Match an integer number element token</span> <span class="cwebmacronumber">18.1.3.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">long</span><span class="plain"> </span><span class="reserved">long</span><span class="plain"> </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">tot</span><span class="plain"> = 0, </span><span class="identifier">max_32_bit</span><span class="plain">, </span><span class="identifier">max_16_bit</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">digits_found</span><span class="plain"> = 0, </span><span class="identifier">point_at</span><span class="plain"> = -1;</span>
        <span class="identifier">max_16_bit</span><span class="plain"> = 32767</span><span class="identifier">LL</span><span class="plain">; </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sign_used_at</span><span class="plain">) </span><span class="identifier">max_16_bit</span><span class="plain"> = 32768</span><span class="identifier">LL</span><span class="plain">;</span>
        <span class="identifier">max_32_bit</span><span class="plain"> = 2147483647</span><span class="identifier">LL</span><span class="plain">; </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sign_used_at</span><span class="plain">) </span><span class="identifier">max_32_bit</span><span class="plain"> = 2147483648</span><span class="identifier">LL</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">Characters::isdigit</span><span class="plain">(</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">])) ||</span>
            <span class="plain">((</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">] == </span><span class="character">'.'</span><span class="plain">) &amp;&amp; (</span><span class="identifier">Kinds::Scalings::get_integer_multiplier</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">) &gt; 1) &amp;&amp; (</span><span class="identifier">point_at</span><span class="plain"> == -1))) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">] == </span><span class="character">'.'</span><span class="plain">) { </span><span class="identifier">point_at</span><span class="plain"> = </span><span class="identifier">digits_found</span><span class="plain">; </span><span class="identifier">wpos</span><span class="plain">++; </span><span class="reserved">continue</span><span class="plain">; }</span>
            <span class="identifier">tot</span><span class="plain"> = 10*</span><span class="identifier">tot</span><span class="plain"> + (</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">++] - </span><span class="character">'0'</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">tot</span><span class="plain"> &gt; </span><span class="identifier">max_16_bit</span><span class="plain">) </span><span class="identifier">overflow_16_bit_flag</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">tot</span><span class="plain"> &gt; </span><span class="identifier">max_32_bit</span><span class="plain">) </span><span class="identifier">overflow_32_bit_flag</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="identifier">digits_found</span><span class="plain">++;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">point_at</span><span class="plain"> == 0) || (</span><span class="identifier">point_at</span><span class="plain"> == </span><span class="identifier">digits_found</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">digits_found</span><span class="plain"> == 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">point_at</span><span class="plain"> &gt; 0) &amp;&amp; (</span><span class="identifier">point_at</span><span class="plain"> &lt; </span><span class="identifier">digits_found</span><span class="plain">)) {</span>
            <span class="identifier">matched_scaledown</span><span class="plain"> *= 10; </span><span class="identifier">point_at</span><span class="plain">++;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">tot</span><span class="plain"> &gt;= </span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_range</span><span class="plain">) &amp;&amp; (</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_index</span><span class="plain"> &gt; 0)) </span><span class="identifier">element_overflow_at</span><span class="plain"> = </span><span class="identifier">lpe</span><span class="plain">;</span>
        <span class="identifier">tot</span><span class="plain"> = (</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_multiplier</span><span class="plain">)*</span><span class="identifier">tot</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">tot</span><span class="plain"> &gt; </span><span class="identifier">max_16_bit</span><span class="plain">) </span><span class="identifier">overflow_16_bit_flag</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">tot</span><span class="plain"> &gt; </span><span class="identifier">max_32_bit</span><span class="plain">) </span><span class="identifier">overflow_32_bit_flag</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">tot</span><span class="plain"> = </span><span class="identifier">matched_number</span><span class="plain"> + </span><span class="identifier">tot</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">tot</span><span class="plain"> &gt; </span><span class="identifier">max_16_bit</span><span class="plain">) </span><span class="identifier">overflow_16_bit_flag</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">tot</span><span class="plain"> &gt; </span><span class="identifier">max_32_bit</span><span class="plain">) </span><span class="identifier">overflow_32_bit_flag</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">matched_number</span><span class="plain"> = (</span><span class="reserved">int</span><span class="plain">) </span><span class="identifier">tot</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18_1_3">&#167;18.1.3</a>.</p>

<p class="inwebparagraph"><a id="SP18_1_3_2"></a><b>&#167;18.1.3.2.  </b>In real arithmetic, though, overflow isn't a problem, since we can use the
infinities to represent arbitrarily large numbers.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Match a real number element token</span> <span class="cwebmacronumber">18.1.3.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">real_buffer</span><span class="plain">);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">point_at</span><span class="plain"> = -1, </span><span class="identifier">mult_at</span><span class="plain"> = -1;</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">Characters::isdigit</span><span class="plain">(</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">])) || ((</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">] == </span><span class="character">'.'</span><span class="plain">) &amp;&amp; (</span><span class="identifier">point_at</span><span class="plain"> == -1))) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">] == </span><span class="character">'.'</span><span class="plain">) </span><span class="identifier">point_at</span><span class="plain"> = </span><span class="identifier">Str::len</span><span class="plain">(</span><span class="identifier">real_buffer</span><span class="plain">);</span>
            <span class="identifier">PUT_TO</span><span class="plain">(</span><span class="identifier">real_buffer</span><span class="plain">, </span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">++]);</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Str::len</span><span class="plain">(</span><span class="identifier">real_buffer</span><span class="plain">) == 0) || (</span><span class="identifier">point_at</span><span class="plain"> == </span><span class="identifier">Str::len</span><span class="plain">(</span><span class="identifier">real_buffer</span><span class="plain">)-1)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Literals::ismultiplicationsign</span><span class="plain">(</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">])) {</span>
            <span class="identifier">mult_at</span><span class="plain"> = </span><span class="identifier">wpos</span><span class="plain">;</span>
            <span class="identifier">PUT_TO</span><span class="plain">(</span><span class="identifier">real_buffer</span><span class="plain">, </span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">++]);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">] == </span><span class="character">'1'</span><span class="plain">) </span><span class="identifier">PUT_TO</span><span class="plain">(</span><span class="identifier">real_buffer</span><span class="plain">, </span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">++]); </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">] == </span><span class="character">'0'</span><span class="plain">) </span><span class="identifier">PUT_TO</span><span class="plain">(</span><span class="identifier">real_buffer</span><span class="plain">, </span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">++]); </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">] == </span><span class="character">'^'</span><span class="plain">) </span><span class="identifier">PUT_TO</span><span class="plain">(</span><span class="identifier">real_buffer</span><span class="plain">, </span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">++]); </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">] == </span><span class="character">'+'</span><span class="plain">) </span><span class="identifier">PUT_TO</span><span class="plain">(</span><span class="identifier">real_buffer</span><span class="plain">, </span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">++]);</span>
            <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">] == </span><span class="character">'-'</span><span class="plain">) </span><span class="identifier">PUT_TO</span><span class="plain">(</span><span class="identifier">real_buffer</span><span class="plain">, </span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">++]);</span>
            <span class="reserved">while</span><span class="plain"> (</span><span class="identifier">Characters::isdigit</span><span class="plain">(</span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">])) {</span>
                <span class="identifier">PUT_TO</span><span class="plain">(</span><span class="identifier">real_buffer</span><span class="plain">, </span><span class="identifier">wd</span><span class="plain">[</span><span class="identifier">wpos</span><span class="plain">++]);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Feeds::feed_stream</span><span class="plain">(</span><span class="identifier">real_buffer</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">real_buffer</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">point_at</span><span class="plain"> == -1) &amp;&amp; (</span><span class="identifier">mult_at</span><span class="plain"> == -1)) {</span>
            <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">cardinal</span><span class="plain">-</span><span class="identifier">number</span><span class="plain">&gt;(</span><span class="identifier">Wordings::first_word</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="identifier">matched_number</span><span class="plain"> = &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;;</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">signbit</span><span class="plain"> = 0;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">matched_number</span><span class="plain"> &lt; 0) { </span><span class="identifier">signbit</span><span class="plain"> = 1; </span><span class="identifier">matched_number</span><span class="plain"> = -</span><span class="identifier">matched_number</span><span class="plain">; }</span>
            <span class="identifier">matched_number</span><span class="plain"> = </span><span class="functiontext">Literals::construct_float</span><span class="plain">(</span><span class="identifier">signbit</span><span class="plain">, </span><span class="identifier">matched_number</span><span class="plain">, 0, 0);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">real</span><span class="plain">-</span><span class="identifier">in</span><span class="plain">-</span><span class="identifier">digits</span><span class="plain">&gt;(</span><span class="identifier">Wordings::first_word</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="identifier">matched_number</span><span class="plain"> = &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;;</span>
        <span class="plain">}</span>

        <span class="identifier">latest_constructed_real</span><span class="plain"> =</span>
            <span class="identifier">Kinds::Scalings::real_quanta_to_value</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">, </span><span class="identifier">latest_constructed_real</span><span class="plain">);</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">signbit</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">latest_constructed_real</span><span class="plain"> &lt; 0) {</span>
            <span class="identifier">latest_constructed_real</span><span class="plain"> = -</span><span class="identifier">latest_constructed_real</span><span class="plain">;</span>
            <span class="identifier">signbit</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">matched_number</span><span class="plain"> = </span><span class="functiontext">Literals::construct_float</span><span class="plain">(</span><span class="identifier">signbit</span><span class="plain">, </span><span class="identifier">latest_constructed_real</span><span class="plain">, 0, 0);</span>
        <span class="identifier">parsed_as_real</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18_1_3">&#167;18.1.3</a>.</p>

<p class="inwebparagraph"><a id="SP18_2"></a><b>&#167;18.2.  </b>Problem messages here have a tendency to be repeated, in some situations,
which is annoying. So we have a mechanism to suppress duplicates:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">ISSUING_LP_PROBLEM</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">last_LP_problem_at</span><span class="plain"> == </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">last_LP_problem_at</span><span class="plain"> = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
</pre>

<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Check that a negative number can be used in this notation</span> <span class="cwebmacronumber">18.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::FloatingPoint::uses_floating_point</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;kind_specified</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sign_used_at</span><span class="plain">-</span><span class="element">&gt;element_index</span><span class="plain"> != 0) {</span>
                <span class="constant">ISSUING_LP_PROBLEM</span><span class="plain">;</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_NegationInternal</span><span class="plain">),</span>
                    <span class="string">"a negative number can't be used in the middle of a constant"</span><span class="plain">,</span>
                    <span class="string">"and the minus sign makes it look as if that's what you are "</span>
                    <span class="string">"trying here."</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;number_signed</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="constant">ISSUING_LP_PROBLEM</span><span class="plain">;</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_NegationForbidden</span><span class="plain">),</span>
                    <span class="string">"the minus sign is not allowed here"</span><span class="plain">,</span>
                    <span class="string">"since this is a kind of value which only allows positive "</span>
                    <span class="string">"values to be written."</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18">&#167;18</a>.</p>

<p class="inwebparagraph"><a id="SP18_3"></a><b>&#167;18.3.  </b>The out of range problem messages:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Check that the value found lies within the range which the VM can hold</span> <span class="cwebmacronumber">18.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">overflow_32_bit_flag</span><span class="plain">) {</span>
            <span class="constant">ISSUING_LP_PROBLEM</span><span class="plain">;</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_EvenOverflow</span><span class="plain">-</span><span class="identifier">G</span><span class="plain">),</span>
                <span class="string">"you use a literal specification to make a value which is too large"</span><span class="plain">,</span>
                <span class="string">"even for a story file compiled with the Glulx setting. (You can "</span>
                <span class="string">"see the size limits for each way of writing a value on the Kinds "</span>
                <span class="string">"page of the Index.)"</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">overflow_16_bit_flag</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">VirtualMachines::is_16_bit</span><span class="plain">())) {</span>
            <span class="constant">ISSUING_LP_PROBLEM</span><span class="plain">;</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ZMachineOverflow</span><span class="plain">),</span>
                <span class="string">"you use a literal specification to make a value which is too large"</span><span class="plain">,</span>
                <span class="string">"at least with the Settings for this project as they currently are. "</span>
                <span class="string">"(Change to Glulx to be allowed to use much larger numbers; "</span>
                <span class="string">"meanwhile, you can see the size limits for each way of writing a "</span>
                <span class="string">"value on the Kinds page of the Index.)"</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18">&#167;18</a>.</p>

<p class="inwebparagraph"><a id="SP18_4"></a><b>&#167;18.4.  </b>The more specific problem of an internal overflow:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Report a problem because one element in the notation overflows</span> <span class="cwebmacronumber">18.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">max</span><span class="plain"> = </span><span class="identifier">element_overflow_at</span><span class="plain">-</span><span class="element">&gt;element_range</span><span class="plain"> - 1;</span>
        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(3, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;prototype_text</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_number</span><span class="plain">(4, &amp;</span><span class="identifier">max</span><span class="plain">);</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">element_overflow_at</span><span class="plain">-</span><span class="element">&gt;element_index</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> 0: </span><span class="identifier">Problems::quote_text</span><span class="plain">(5, </span><span class="string">"first"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 1: </span><span class="identifier">Problems::quote_text</span><span class="plain">(5, </span><span class="string">"second"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 2: </span><span class="identifier">Problems::quote_text</span><span class="plain">(5, </span><span class="string">"third"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 3: </span><span class="identifier">Problems::quote_text</span><span class="plain">(5, </span><span class="string">"fourth"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 4: </span><span class="identifier">Problems::quote_text</span><span class="plain">(5, </span><span class="string">"fifth"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 5: </span><span class="identifier">Problems::quote_text</span><span class="plain">(5, </span><span class="string">"sixth"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 6: </span><span class="identifier">Problems::quote_text</span><span class="plain">(5, </span><span class="string">"seventh"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 7: </span><span class="identifier">Problems::quote_text</span><span class="plain">(5, </span><span class="string">"eighth"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 8: </span><span class="identifier">Problems::quote_text</span><span class="plain">(5, </span><span class="string">"ninth"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 9: </span><span class="identifier">Problems::quote_text</span><span class="plain">(5, </span><span class="string">"tenth"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">default</span><span class="plain">: </span><span class="identifier">Problems::quote_text</span><span class="plain">(5, </span><span class="string">"eventual"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ElementOverflow</span><span class="plain">));</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"In the sentence %1, you use the notation '%2' to write a constant value. "</span>
            <span class="string">"But the notation was specified as '%3', which means that the %5 numerical "</span>
            <span class="string">"part should range between 0 and %4."</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18">&#167;18</a>.</p>

<p class="inwebparagraph"><a id="SP18_1_4"></a><b>&#167;18.1.4.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Report a problem because not enough accuracy is available</span> <span class="cwebmacronumber">18.1.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(3, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;prototype_text</span><span class="plain">);</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPTooLittleAccuracy</span><span class="plain">));</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"In the sentence %1, you use the notation '%2' to write a constant value. "</span>
            <span class="string">"But to store that, I would need greater accuracy than this kind of "</span>
            <span class="string">"value has - see the Kinds page of the Index for the range it has."</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18_1">&#167;18.1</a>.</p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19. Matching an LP at run-time. </b>The following routine compiles an I6 general parsing routine (GPR) to match
typed input in the correct notation. It amounts to printing out a version of
the above routine, but ported to I6, and with the token loop "rolled out"
so that no <code class="display"><span class="extract">tc</span></code> and <code class="display"><span class="extract">ec</span></code> variables are needed at run-time, and simplified
by having the numerical overflow detection removed. (It's a little slow to
perform that check within the VM.)
</p>

<p class="inwebparagraph">Properly speaking this is not an entire GPR, but only a segment of one,
and we should compile code which allows execution to reach the end if and only
if we fail to make a match.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::gpr</span><span class="plain">(</span><span class="identifier">gpr_kit</span><span class="plain"> *</span><span class="identifier">gprk</span><span class="plain">, </span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">label</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">tc</span><span class="plain">, </span><span class="identifier">ec</span><span class="plain">;</span>
        <span class="functiontext">LiteralPatterns::comment_use_of_lp</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">);</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">mid_word_s</span><span class="plain">);</span>
            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">matched_number_s</span><span class="plain">);</span>
            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">SL</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">SL</span><span class="plain">, </span><span class="string">".Succeeded_LP_%d"</span><span class="plain">, </span><span class="identifier">label</span><span class="plain">);</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">succeeded_label</span><span class="plain"> = </span><span class="identifier">Produce::reserve_label</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">SL</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">SL</span><span class="plain">);</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">FL</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">FL</span><span class="plain">, </span><span class="string">".Failed_LP_%d"</span><span class="plain">, </span><span class="identifier">label</span><span class="plain">);</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">failed_label</span><span class="plain"> = </span><span class="identifier">Produce::reserve_label</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">FL</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">FL</span><span class="plain">);</span>

        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">tc</span><span class="plain">=0, </span><span class="identifier">ec</span><span class="plain">=0; </span><span class="identifier">tc</span><span class="plain">&lt;</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_tokens</span><span class="plain">; </span><span class="identifier">tc</span><span class="plain">++) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">lookahead</span><span class="plain"> = -1;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">tc</span><span class="plain">+1&lt;</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_tokens</span><span class="plain">) &amp;&amp; (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">+1]</span><span class="element">.lpt_type</span><span class="plain"> == </span><span class="constant">CHARACTER_LPT</span><span class="plain">))</span>
                <span class="identifier">lookahead</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">+1]</span><span class="element">.token_char</span><span class="plain">;</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">mid_word_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_word_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">NEXTWORDSTOPPED_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTDECREMENT_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::ref_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WN_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">to_label</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
                    <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">ec</span><span class="plain">]</span><span class="element">.preamble_optional</span><span class="plain">) &amp;&amp; (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.lpt_type</span><span class="plain"> == </span><span class="constant">ELEMENT_LPT</span><span class="plain">))</span>
                        <span class="identifier">to_label</span><span class="plain"> = </span><span class="identifier">failed_label</span><span class="plain">;</span>
                    <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">LiteralPatterns::at_optional_break_point</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">ec</span><span class="plain">, </span><span class="identifier">tc</span><span class="plain">))</span>
                        <span class="identifier">to_label</span><span class="plain"> = </span><span class="identifier">succeeded_label</span><span class="plain">;</span>
                    <span class="reserved">else</span>
                        <span class="identifier">to_label</span><span class="plain"> = </span><span class="identifier">failed_label</span><span class="plain">;</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_word_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) -1);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">JUMP_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::lab</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">to_label</span><span class="plain">);</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

            <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.lpt_type</span><span class="plain">) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">WORD_LPT</span><span class="plain">: </span>&lt;<span class="cwebmacro">Compile I6 code to match a fixed word token within a literal pattern</span> <span class="cwebmacronumber">19.1</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">CHARACTER_LPT</span><span class="plain">: </span>&lt;<span class="cwebmacro">Compile I6 code to match a character token within a literal pattern</span> <span class="cwebmacronumber">19.2</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">ELEMENT_LPT</span><span class="plain">: </span>&lt;<span class="cwebmacro">Compile I6 code to match an element token within a literal pattern</span> <span class="cwebmacronumber">19.3</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">default</span><span class="plain">: </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"unknown literal pattern token type"</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>

        <span class="identifier">Produce::place_label</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">succeeded_label</span><span class="plain">);</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">mid_word_s</span><span class="plain">);</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">JUMP_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::lab</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">failed_label</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LT_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">sgn_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">matched_number_s</span><span class="plain">);</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::FloatingPoint::uses_floating_point</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;kind_specified</span><span class="plain">)) {</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">BITWISEOR_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">matched_number_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0</span><span class="identifier">x80000000</span><span class="plain">);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">TIMES_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) -1);</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">matched_number_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="plain">}</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::ref_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_object</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">PARSED_NUMBER_HL</span><span class="plain">));</span>
            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">matched_number_s</span><span class="plain">);</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Kinds::Scalings::compile_quanta_to_value</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">,</span>
            <span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">PARSED_NUMBER_HL</span><span class="plain">), </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">sgn_s</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">x_s</span><span class="plain">, </span><span class="identifier">failed_label</span><span class="plain">);</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IFDEBUG_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">GE_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">PARSER_TRACE_HL</span><span class="plain">));</span>
                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 3);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINT_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_text</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">I</span><span class="string">"  [parsed value "</span><span class="plain">);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINTNUMBER_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_object</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">PARSED_NUMBER_HL</span><span class="plain">));</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINT_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">EXP</span><span class="plain">);</span>
                            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">EXP</span><span class="plain">, </span><span class="string">" by: %W]\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;prototype_text</span><span class="plain">);</span>
                            <span class="identifier">Produce::val_text</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EXP</span><span class="plain">);</span>
                            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">EXP</span><span class="plain">);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">RETURN_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">GPR_NUMBER_HL</span><span class="plain">));</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::place_label</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">failed_label</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::gpr appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP19_1"></a><b>&#167;19.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile I6 code to match a fixed word token within a literal pattern</span> <span class="cwebmacronumber">19.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">mid_word_s</span><span class="plain">);</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">JUMP_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::lab</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">failed_label</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">NE_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_word_s</span><span class="plain">);</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">N</span><span class="plain">);</span>
                <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">N</span><span class="plain">, </span><span class="string">"%N"</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.token_wn</span><span class="plain">);</span>
                <span class="identifier">Produce::val_dword</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">N</span><span class="plain">);</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">N</span><span class="plain">);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">JUMP_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::lab</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">failed_label</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::ref_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WN_HL</span><span class="plain">));</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP19">&#167;19</a>.</p>

<p class="inwebparagraph"><a id="SP19_2"></a><b>&#167;19.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile I6 code to match a character token within a literal pattern</span> <span class="cwebmacronumber">19.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        &lt;<span class="cwebmacro">Compile I6 code to enter mid-word parsing if not already in it</span> <span class="cwebmacronumber">19.2.1</span>&gt;<span class="plain">;</span>
        <span class="identifier">wchar_t</span><span class="plain"> </span><span class="identifier">lower_form</span><span class="plain"> = </span><span class="identifier">Characters::tolower</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.token_char</span><span class="plain">);</span>
        <span class="identifier">wchar_t</span><span class="plain"> </span><span class="identifier">upper_form</span><span class="plain"> = </span><span class="identifier">Characters::toupper</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.token_char</span><span class="plain">);</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">upper_form</span><span class="plain"> != </span><span class="identifier">lower_form</span><span class="plain">) { </span><span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">AND_BIP</span><span class="plain">); </span><span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">()); }</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">NE_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LOOKUPBYTE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_addr_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="identifier">lower_form</span><span class="plain">);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">upper_form</span><span class="plain"> != </span><span class="identifier">lower_form</span><span class="plain">) {</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">NE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LOOKUPBYTE_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_addr_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">MINUS_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="identifier">upper_form</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">upper_form</span><span class="plain"> != </span><span class="identifier">lower_form</span><span class="plain">) { </span><span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">()); }</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">JUMP_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::lab</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">failed_label</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        &lt;<span class="cwebmacro">Compile I6 code to exit mid-word parsing if at end of a word</span> <span class="cwebmacronumber">19.2.2</span>&gt;<span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP19">&#167;19</a>.</p>

<p class="inwebparagraph"><a id="SP19_3"></a><b>&#167;19.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile I6 code to match an element token within a literal pattern</span> <span class="cwebmacronumber">19.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        &lt;<span class="cwebmacro">Compile I6 code to enter mid-word parsing if not already in it</span> <span class="cwebmacronumber">19.2.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">literal_pattern_element</span><span class="plain"> *</span><span class="identifier">lpe</span><span class="plain"> = &amp;(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">ec</span><span class="plain">++]);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ec</span><span class="plain"> == 1) {</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">sgn_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="plain">}</span>
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LOOKUPBYTE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_addr_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="character">'-'</span><span class="plain">);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;number_signed</span><span class="plain">) &amp;&amp; (</span><span class="identifier">ec</span><span class="plain"> == 1)) {</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">sgn_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) -1);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">JUMP_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::lab</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">failed_label</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="plain">}</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::FloatingPoint::uses_floating_point</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;kind_specified</span><span class="plain">))</span>
            &lt;<span class="cwebmacro">Compile I6 code to match a real number here</span> <span class="cwebmacronumber">19.3.1</span>&gt;
        <span class="reserved">else</span>
            &lt;<span class="cwebmacro">Compile I6 code to match an integer here</span> <span class="cwebmacronumber">19.3.2</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Compile I6 code to exit mid-word parsing if at end of a word</span> <span class="cwebmacronumber">19.2.2</span>&gt;<span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP19">&#167;19</a>.</p>

<p class="inwebparagraph"><a id="SP19_3_1"></a><b>&#167;19.3.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile I6 code to match a real number here</span> <span class="cwebmacronumber">19.3.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">x_s</span><span class="plain">);</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PLUS_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_addr_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        &lt;<span class="cwebmacro">March forwards through decimal digits</span> <span class="cwebmacronumber">19.3.1.1</span>&gt;<span class="plain">;</span>
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">JUMP_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::lab</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">failed_label</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_len_s</span><span class="plain">);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WN_HL</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_word_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">NEXTWORDSTOPPED_HL</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WN_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">MINUS_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WN_HL</span><span class="plain">));</span>
                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 2);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_word_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">THEN1__WD_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::ref_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WN_HL</span><span class="plain">));</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PLUS_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WN_HL</span><span class="plain">));</span>
                                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 2);</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">mid_word_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        &lt;<span class="cwebmacro">Compile I6 code to enter mid-word parsing if not already in it</span> <span class="cwebmacronumber">19.2.1</span>&gt;<span class="plain">;</span>
                        &lt;<span class="cwebmacro">March forwards through decimal digits</span> <span class="cwebmacronumber">19.3.1.1</span>&gt;<span class="plain">;</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">tot_s</span><span class="plain">);</span>
            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_len_s</span><span class="plain">);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">tot_s</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_word_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">NEXTWORDSTOPPED_HL</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">mid_word_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                &lt;<span class="cwebmacro">Compile I6 code to enter mid-word parsing if not already in it</span> <span class="cwebmacronumber">19.2.1</span>&gt;<span class="plain">;</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">AND_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LT_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_len_s</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LOOKUPBYTE_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_addr_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="character">'x'</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PLUS_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PLUS_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">tot_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_len_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_word_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">NEXTWORDSTOPPED_HL</span><span class="plain">));</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">mid_word_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        &lt;<span class="cwebmacro">Compile I6 code to enter mid-word parsing if not already in it</span> <span class="cwebmacronumber">19.2.1</span>&gt;<span class="plain">;</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IFELSE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">AND_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LT_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PLUS_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 3);</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_len_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">AND_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LOOKUPBYTE_BIP</span><span class="plain">);</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_addr_s</span><span class="plain">);</span>
                                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="character">'1'</span><span class="plain">);</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">AND_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LOOKUPBYTE_BIP</span><span class="plain">);</span>
                                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                        <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_addr_s</span><span class="plain">);</span>
                                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PLUS_BIP</span><span class="plain">);</span>
                                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="character">'0'</span><span class="plain">);</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LOOKUPBYTE_BIP</span><span class="plain">);</span>
                                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                        <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_addr_s</span><span class="plain">);</span>
                                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PLUS_BIP</span><span class="plain">);</span>
                                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 2);</span>
                                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="character">'^'</span><span class="plain">);</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PLUS_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 3);</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PLUS_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 3);</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">AND_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LT_BIP</span><span class="plain">);</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_len_s</span><span class="plain">);</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">OR_BIP</span><span class="plain">);</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LOOKUPBYTE_BIP</span><span class="plain">);</span>
                                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_addr_s</span><span class="plain">);</span>
                                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="character">'+'</span><span class="plain">);</span>
                                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LOOKUPBYTE_BIP</span><span class="plain">);</span>
                                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_addr_s</span><span class="plain">);</span>
                                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="character">'-'</span><span class="plain">);</span>
                                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        &lt;<span class="cwebmacro">March forwards through decimal digits</span> <span class="cwebmacronumber">19.3.1.1</span>&gt;<span class="plain">;</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTDECREMENT_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">x_s</span><span class="plain">);</span>
            <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">FLOATPARSE_HL</span><span class="plain">));</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">x_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">x_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Site::veneer_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">FLOAT_NAN_VSYMB</span><span class="plain">));</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">JUMP_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::lab</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">failed_label</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">mid_word_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">matched_number_s</span><span class="plain">);</span>
            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">x_s</span><span class="plain">);</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP19_3">&#167;19.3</a>.</p>

<p class="inwebparagraph"><a id="SP19_3_1_1"></a><b>&#167;19.3.1.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">March forwards through decimal digits</span> <span class="cwebmacronumber">19.3.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">WHILE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">AND_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LT_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_len_s</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">GE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">DIGITTOVALUE_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LOOKUPBYTE_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_addr_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP19_3_1">&#167;19.3.1</a> (three times).</p>

<p class="inwebparagraph"><a id="SP19_3_2"></a><b>&#167;19.3.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile I6 code to match an integer here</span> <span class="cwebmacronumber">19.3.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">tot_s</span><span class="plain">);</span>
            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">WHILE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">AND_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LT_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_len_s</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">GE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">DIGITTOVALUE_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LOOKUPBYTE_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_addr_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">DIGITTOVALUE_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LOOKUPBYTE_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_addr_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Kinds::Scalings::compile_scale_and_add</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">tot_s</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">sgn_s</span><span class="plain">, 10, 0, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">, </span><span class="identifier">failed_label</span><span class="plain">);</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">JUMP_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::lab</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">failed_label</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_index</span><span class="plain"> &gt; 0) {</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">GE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">tot_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_range</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">JUMP_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::lab</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">failed_label</span><span class="plain">);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="plain">}</span>

        <span class="identifier">Kinds::Scalings::compile_scale_and_add</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">tot_s</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">sgn_s</span><span class="plain">, </span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_multiplier</span><span class="plain">, 0, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">matched_number_s</span><span class="plain">, </span><span class="identifier">failed_label</span><span class="plain">);</span>
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">matched_number_s</span><span class="plain">);</span>
            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">tot_s</span><span class="plain">);</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">M</span><span class="plain"> = </span><span class="identifier">Kinds::Scalings::get_integer_multiplier</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">M</span><span class="plain"> &gt; 1) {</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_len_s</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::ref_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WN_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_word_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">NEXTWORDSTOPPED_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::ref_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WN_HL</span><span class="plain">));</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">MINUS_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WN_HL</span><span class="plain">));</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 2);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_word_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">THEN1__WD_HL</span><span class="plain">));</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::ref_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WN_HL</span><span class="plain">));</span>
                                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PLUS_BIP</span><span class="plain">);</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WN_HL</span><span class="plain">));</span>
                                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 2);</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">mid_word_s</span><span class="plain">);</span>
                                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            &lt;<span class="cwebmacro">Compile I6 code to enter mid-word parsing if not already in it</span> <span class="cwebmacronumber">19.2.1</span>&gt;<span class="plain">;</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">x_s</span><span class="plain">);</span>
                                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="identifier">M</span><span class="plain">);</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">WHILE_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">AND_BIP</span><span class="plain">);</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">GT_BIP</span><span class="plain">);</span>
                                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                        <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">AND_BIP</span><span class="plain">);</span>
                                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">MODULO_BIP</span><span class="plain">);</span>
                                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                                                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 10);</span>
                                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">GE_BIP</span><span class="plain">);</span>
                                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                            <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">DIGITTOVALUE_HL</span><span class="plain">));</span>
                                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LOOKUPBYTE_BIP</span><span class="plain">);</span>
                                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_addr_s</span><span class="plain">);</span>
                                                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                        <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">w_s</span><span class="plain">);</span>
                                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">DIVIDE_BIP</span><span class="plain">);</span>
                                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">TIMES_BIP</span><span class="plain">);</span>
                                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                                <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">DIGITTOVALUE_HL</span><span class="plain">));</span>
                                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LOOKUPBYTE_BIP</span><span class="plain">);</span>
                                                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                                        <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_addr_s</span><span class="plain">);</span>
                                                        <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                                                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 10);</span>
                                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Kinds::Scalings::compile_scale_and_add</span><span class="plain">(</span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">x_s</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">sgn_s</span><span class="plain">,</span>
                                        <span class="plain">1, 0, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">w_s</span><span class="plain">, </span><span class="identifier">failed_label</span><span class="plain">);</span>
                                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
                                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                        <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                        <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">DIVIDE_BIP</span><span class="plain">);</span>
                                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">f_s</span><span class="plain">);</span>
                                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 10);</span>
                                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP19_3">&#167;19.3</a>.</p>

<p class="inwebparagraph"><a id="SP19_2_1"></a><b>&#167;19.2.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile I6 code to enter mid-word parsing if not already in it</span> <span class="cwebmacronumber">19.2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">mid_word_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">mid_word_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_addr_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WORDADDRESS_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WN_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_len_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WORDLENGTH_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WN_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP19_2">&#167;19.2</a>, <a href="#SP19_3">&#167;19.3</a>, <a href="#SP19_3_1">&#167;19.3.1</a> (three times), <a href="#SP19_3_2">&#167;19.3.2</a>.</p>

<p class="inwebparagraph"><a id="SP19_2_2"></a><b>&#167;19.2.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile I6 code to exit mid-word parsing if at end of a word</span> <span class="cwebmacronumber">19.2.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">wpos_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">cur_len_s</span><span class="plain">);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">POSTINCREMENT_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">WN_HL</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gprk</span><span class="plain">-&gt;</span><span class="identifier">mid_word_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_truth_state</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP19_2">&#167;19.2</a>, <a href="#SP19_3">&#167;19.3</a>.</p>

<p class="inwebparagraph"><a id="SP20"></a><b>&#167;20. Indexing literal patterns for a given kind. </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::index_all</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">, *</span><span class="identifier">benchmark_lp</span><span class="plain"> = </span><span class="functiontext">LiteralPatterns::get_benchmark</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">B</span><span class="plain"> = 1, </span><span class="identifier">scalings_exist</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">benchmark_lp</span><span class="plain">) </span><span class="identifier">B</span><span class="plain"> = </span><span class="identifier">Kinds::Scalings::get_integer_multiplier</span><span class="plain">(</span><span class="identifier">benchmark_lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">);</span>

        <span class="identifier">LITERAL_FORMS_LOOP</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Scalings::involves_scale_change</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">))</span>
                <span class="identifier">scalings_exist</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>

        &lt;<span class="cwebmacro">Index the list of possible LPs for the kind, not counting equivalents</span> <span class="cwebmacronumber">20.1</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Index the list of possible LPs for the kind, only counting equivalents</span> <span class="cwebmacronumber">20.2</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Index the possible names for these notations, as ways of printing them back</span> <span class="cwebmacronumber">20.3</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::index_all is used in 13/ki (<a href="13-ki.html#SP1_8">&#167;1.8</a>).</p>

<p class="inwebparagraph"><a id="SP20_1"></a><b>&#167;20.1.  </b>Each entry in this list is, in principle, a list all by itself &mdash; of
alternatives such as "1 tonne" vs "2 tonnes", which aren't different
enough to be listed separately. Of these exactly one is the "primary"
alternative.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Index the list of possible LPs for the kind, not counting equivalents</span> <span class="cwebmacronumber">20.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">f</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">LITERAL_FORMS_LOOP</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;primary_alternative</span><span class="plain">) &amp;&amp; (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;equivalent_unit</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">f</span><span class="plain">) </span><span class="identifier">HTML_TAG</span><span class="plain">(</span><span class="string">"br"</span><span class="plain">)</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;i&gt;Written as:&lt;/i&gt;"</span><span class="plain">);</span>
                <span class="identifier">HTML_TAG</span><span class="plain">(</span><span class="string">"br"</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">scalings_exist</span><span class="plain">) &amp;&amp; (</span><span class="identifier">benchmark_lp</span><span class="plain">)) {</span>
                    <span class="functiontext">LiteralPatterns::index_lp_possibilities</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">benchmark_lp</span><span class="plain">);</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;prototype_text</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="identifier">f</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP20">&#167;20</a>.</p>

<p class="inwebparagraph"><a id="SP20_2"></a><b>&#167;20.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Index the list of possible LPs for the kind, only counting equivalents</span> <span class="cwebmacronumber">20.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">f</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">LITERAL_FORMS_LOOP</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;primary_alternative</span><span class="plain">) &amp;&amp; (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;equivalent_unit</span><span class="plain">)) {</span>
                <span class="identifier">HTML_TAG</span><span class="plain">(</span><span class="string">"br"</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">f</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;i&gt;With these equivalent units:&lt;/i&gt;"</span><span class="plain">);</span>
                    <span class="identifier">HTML_TAG</span><span class="plain">(</span><span class="string">"br"</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="functiontext">LiteralPatterns::index_lp_possibilities</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">benchmark_lp</span><span class="plain">);</span>
                <span class="identifier">f</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP20">&#167;20</a>.</p>

<p class="inwebparagraph"><a id="SP20_3"></a><b>&#167;20.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Index the possible names for these notations, as ways of printing them back</span> <span class="cwebmacronumber">20.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">f</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">literal_pattern_name</span><span class="plain"> *</span><span class="identifier">lpn</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">lpn</span><span class="plain">, </span><span class="reserved">literal_pattern_name</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">lpn</span><span class="plain">-</span><span class="element">&gt;notation_name</span><span class="plain">)) {</span>
                <span class="identifier">LITERAL_FORMS_LOOP</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">) {</span>
                    <span class="reserved">literal_pattern_name</span><span class="plain"> *</span><span class="identifier">lpn2</span><span class="plain">;</span>
                    <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lpn2</span><span class="plain"> = </span><span class="identifier">lpn</span><span class="plain">; </span><span class="identifier">lpn2</span><span class="plain">; </span><span class="identifier">lpn2</span><span class="plain"> = </span><span class="identifier">lpn2</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> == </span><span class="identifier">lpn2</span><span class="plain">-</span><span class="element">&gt;can_use_this_lp</span><span class="plain">) {</span>
                            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">f</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"; "</span><span class="plain">);</span>
                            <span class="reserved">else</span><span class="plain"> {</span>
                                <span class="identifier">HTML_TAG</span><span class="plain">(</span><span class="string">"br"</span><span class="plain">);</span>
                                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"\</span><span class="plain">n</span><span class="string">&lt;i&gt;Can be printed back:&lt;/i&gt;\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
                                <span class="identifier">HTML_TAG</span><span class="plain">(</span><span class="string">"br"</span><span class="plain">);</span>
                                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"\</span><span class="plain">n</span><span class="string">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"</span><span class="plain">);</span>
                            <span class="plain">}</span>
                            <span class="identifier">f</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">lpn</span><span class="plain">-</span><span class="element">&gt;notation_name</span><span class="plain">);</span>
                            <span class="reserved">goto</span><span class="plain"> </span><span class="identifier">NextLPN</span><span class="plain">;</span>
                        <span class="plain">}</span>
                <span class="plain">}</span>
                <span class="identifier">NextLPN</span><span class="plain">: ;</span>
            <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP20">&#167;20</a>.</p>

<p class="inwebparagraph"><a id="SP21"></a><b>&#167;21.  </b>And here we list of alternatives followed by the relationship this notation
has to the benchmark, e.g., "where 1 tonne = 1000 kg".
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::index_lp_possibilities</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">, </span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">benchmark_lp</span><span class="plain">) {</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"</span><span class="plain">);</span>
        <span class="functiontext">LiteralPatterns::index_lp_possibility</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">benchmark_lp</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;equivalent_unit</span><span class="plain">) {</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" &lt;i&gt;where&lt;/i&gt; "</span><span class="plain">);</span>
            <span class="functiontext">LiteralPatterns::lp_index_quantum_value</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">);</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" = "</span><span class="plain">);</span>
            <span class="functiontext">LiteralPatterns::lp_index_quantum_value</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">benchmark_lp</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Scalings::compare</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">, </span><span class="identifier">benchmark_lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">) &lt; 0) {</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" &lt;i&gt;where&lt;/i&gt; "</span><span class="plain">);</span>
                <span class="functiontext">LiteralPatterns::lp_index_quantum_value</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">benchmark_lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" = "</span><span class="plain">);</span>
                <span class="functiontext">LiteralPatterns::lp_index_quantum_value</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">benchmark_lp</span><span class="plain">, </span><span class="identifier">benchmark_lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Scalings::compare</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">, </span><span class="identifier">benchmark_lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">) &gt; 0) {</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" &lt;i&gt;where&lt;/i&gt; "</span><span class="plain">);</span>
                <span class="functiontext">LiteralPatterns::lp_index_quantum_value</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" = "</span><span class="plain">);</span>
                <span class="functiontext">LiteralPatterns::lp_index_quantum_value</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">benchmark_lp</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::index_lp_possibilities is used in <a href="#SP20_1">&#167;20.1</a>, <a href="#SP20_2">&#167;20.2</a>.</p>

<p class="inwebparagraph"><a id="SP22"></a><b>&#167;22.  </b>This is where the list of alternatives, "1 tonne" followed by "2 tonnes",
say, is produced:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::index_lp_possibility</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">, </span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">benchmark_lp</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> == </span><span class="identifier">benchmark_lp</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;b&gt;"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;plural_form_only</span><span class="plain">)</span>
            <span class="functiontext">LiteralPatterns::lp_index_quantum_value</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">Kinds::Scalings::enlarge</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">, 2));</span>
        <span class="reserved">else</span>
            <span class="functiontext">LiteralPatterns::lp_index_quantum_value</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> == </span><span class="identifier">benchmark_lp</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;/b&gt;"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_alternative_lp</span><span class="plain">) {</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" &lt;i&gt;or&lt;/i&gt; "</span><span class="plain">);</span>
            <span class="functiontext">LiteralPatterns::index_lp_possibility</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_alternative_lp</span><span class="plain">, </span><span class="identifier">benchmark_lp</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::index_lp_possibility is used in <a href="#SP21">&#167;21</a>.</p>

<p class="inwebparagraph"><a id="SP23"></a><b>&#167;23. Printing values in an LP's notation to the index at compile-time. </b>This front-end routine chooses the most appropriate notation to use when
indexing a given value. For instance, a mass of 1000000 is best expressed
as "1 tonne", not "1000000 grams".
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::index_value</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp_list</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">v</span><span class="plain">) {</span>
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">;</span>
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp_possibility</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">k</span><span class="plain"> = 0;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp_list</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">v</span><span class="plain"> == 0) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;benchmark</span><span class="plain">) {</span>
                    <span class="functiontext">LiteralPatterns::lp_index_value_specific</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">v</span><span class="plain">); </span><span class="reserved">return</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;primary_alternative</span><span class="plain">) &amp;&amp; (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;equivalent_unit</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
                    <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">lp_possibility</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">Kinds::Scalings::quantum</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">) != </span><span class="identifier">k</span><span class="plain">)) {</span>
                        <span class="identifier">lp_possibility</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">;</span>
                        <span class="identifier">k</span><span class="plain"> = </span><span class="identifier">Kinds::Scalings::quantum</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">);</span>
                    <span class="plain">}</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">v</span><span class="plain"> &gt;= </span><span class="identifier">Kinds::Scalings::quantum</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">)) {</span>
                        <span class="functiontext">LiteralPatterns::lp_index_value_specific</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">v</span><span class="plain">); </span><span class="reserved">return</span><span class="plain">;</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp_possibility</span><span class="plain">) </span><span class="functiontext">LiteralPatterns::lp_index_value_specific</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp_possibility</span><span class="plain">, </span><span class="identifier">v</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::lp_index_value_specific</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp_list</span><span class="plain">, </span><span class="identifier">v</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::index_value is used in 13/ki (<a href="13-ki.html#SP5_1_1">&#167;5.1.1</a>).</p>

<p class="inwebparagraph"><a id="SP24"></a><b>&#167;24.  </b>Here we index the benchmark value. Pursuing our example of mass, if the
benchmark is 1 kilogram, then the following indexes the value 1000 in
kilograms, resulting in "1 kg". (This will always effectively look like
"1 something", whatever the something is.)
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::index_benchmark_value</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">;</span>
        <span class="identifier">LITERAL_FORMS_LOOP</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;benchmark</span><span class="plain">) {</span>
                <span class="functiontext">LiteralPatterns::lp_index_quantum_value</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"1"</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::index_benchmark_value appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP25"></a><b>&#167;25.  </b>We are rather formal when printing values to the index, so we choose not
to make use of optional truncation.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::lp_index_quantum_value</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">scaling_transformation</span><span class="plain"> </span><span class="identifier">sc</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">v</span><span class="plain"> = 0;</span>
        <span class="reserved">double</span><span class="plain"> </span><span class="identifier">real_v</span><span class="plain"> = 0.0;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::FloatingPoint::uses_floating_point</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;kind_specified</span><span class="plain">))</span>
            <span class="identifier">real_v</span><span class="plain"> = </span><span class="identifier">Kinds::Scalings::real_quantum</span><span class="plain">(</span><span class="identifier">sc</span><span class="plain">);</span>
        <span class="reserved">else</span>
            <span class="identifier">v</span><span class="plain"> = </span><span class="identifier">Kinds::Scalings::quantum</span><span class="plain">(</span><span class="identifier">sc</span><span class="plain">);</span>
        <span class="functiontext">LiteralPatterns::lp_index_value_specific_inner</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">v</span><span class="plain">, </span><span class="identifier">real_v</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::lp_index_value_specific</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">, </span><span class="reserved">double</span><span class="plain"> </span><span class="identifier">alt_value</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">v</span><span class="plain"> = (</span><span class="reserved">int</span><span class="plain">) </span><span class="identifier">alt_value</span><span class="plain">;</span>
        <span class="reserved">double</span><span class="plain"> </span><span class="identifier">real_v</span><span class="plain"> = </span><span class="identifier">alt_value</span><span class="plain">;</span>
        <span class="functiontext">LiteralPatterns::lp_index_value_specific_inner</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">v</span><span class="plain">, </span><span class="identifier">real_v</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::lp_index_value_specific_inner</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">v</span><span class="plain">, </span><span class="reserved">double</span><span class="plain"> </span><span class="identifier">real_v</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) { </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"--"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain">; }</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">tc</span><span class="plain">, </span><span class="identifier">ec</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">tc</span><span class="plain">=0, </span><span class="identifier">ec</span><span class="plain">=0; </span><span class="identifier">tc</span><span class="plain">&lt;</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_tokens</span><span class="plain">; </span><span class="identifier">tc</span><span class="plain">++) {</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">tc</span><span class="plain">&gt;0) &amp;&amp; (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.new_word_at</span><span class="plain">)) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" "</span><span class="plain">);</span>
            <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.lpt_type</span><span class="plain">) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">WORD_LPT</span><span class="plain">: </span>&lt;<span class="cwebmacro">Index a fixed word token within a literal pattern</span> <span class="cwebmacronumber">25.1</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">CHARACTER_LPT</span><span class="plain">: </span>&lt;<span class="cwebmacro">Index a character token within a literal pattern</span> <span class="cwebmacronumber">25.2</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">ELEMENT_LPT</span><span class="plain">: </span>&lt;<span class="cwebmacro">Index an element token within a literal pattern</span> <span class="cwebmacronumber">25.3</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">default</span><span class="plain">: </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"unknown literal pattern token type"</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::lp_index_quantum_value is used in <a href="#SP21">&#167;21</a>, <a href="#SP22">&#167;22</a>, <a href="#SP24">&#167;24</a>.</p>

<p class="endnote">The function LiteralPatterns::lp_index_value_specific is used in <a href="#SP23">&#167;23</a>.</p>

<p class="endnote">The function LiteralPatterns::lp_index_value_specific_inner appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP25_1"></a><b>&#167;25.1.  </b>We parse in a case-insensitive way, but print back case-sensitively &mdash;
note that the following uses the raw text of the word.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Index a fixed word token within a literal pattern</span> <span class="cwebmacronumber">25.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">tc</span><span class="plain"> &gt; 0) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" "</span><span class="plain">);</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%&lt;N"</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.token_wn</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP25">&#167;25</a>.</p>

<p class="inwebparagraph"><a id="SP25_2"></a><b>&#167;25.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Index a character token within a literal pattern</span> <span class="cwebmacronumber">25.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">HTMLFiles::char_out</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.token_char</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP25">&#167;25</a>.</p>

<p class="inwebparagraph"><a id="SP25_3"></a><b>&#167;25.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Index an element token within a literal pattern</span> <span class="cwebmacronumber">25.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::FloatingPoint::uses_floating_point</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;kind_specified</span><span class="plain">)) {</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%g"</span><span class="plain">, </span><span class="identifier">Kinds::Scalings::real_value_to_quanta</span><span class="plain">(</span><span class="identifier">real_v</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">));</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">remainder</span><span class="plain">;</span>
            <span class="identifier">Kinds::Scalings::value_to_quanta</span><span class="plain">(</span><span class="identifier">v</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">, &amp;</span><span class="identifier">v</span><span class="plain">, &amp;</span><span class="identifier">remainder</span><span class="plain">);</span>
            <span class="reserved">literal_pattern_element</span><span class="plain"> *</span><span class="identifier">lpe</span><span class="plain"> = &amp;(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">ec</span><span class="plain">]);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ec</span><span class="plain"> == 0) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%d"</span><span class="plain">, </span><span class="identifier">v</span><span class="plain">/(</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_multiplier</span><span class="plain">));</span>
            <span class="reserved">else</span><span class="plain"> {</span>
                <span class="reserved">char</span><span class="plain"> *</span><span class="identifier">prototype</span><span class="plain"> = </span><span class="string">"%d"</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.new_word_at</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;without_leading_zeros</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">))</span>
                    <span class="identifier">prototype</span><span class="plain"> = </span><span class="functiontext">LiteralPatterns::leading_zero_prototype</span><span class="plain">(</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_range</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="identifier">prototype</span><span class="plain">, (</span><span class="identifier">v</span><span class="plain">/(</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_multiplier</span><span class="plain">)) % (</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_range</span><span class="plain">));</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ec</span><span class="plain"> == 0) </span>&lt;<span class="cwebmacro">Index the fractional part of the value</span> <span class="cwebmacronumber">25.3.1</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">ec</span><span class="plain">++;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP25">&#167;25</a>.</p>

<p class="inwebparagraph"><a id="SP25_3_1"></a><b>&#167;25.3.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Index the fractional part of the value</span> <span class="cwebmacronumber">25.3.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">ranger</span><span class="plain"> = 1, </span><span class="identifier">M</span><span class="plain"> = </span><span class="identifier">Kinds::Scalings::get_integer_multiplier</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">);</span>
        <span class="reserved">while</span><span class="plain"> (</span><span class="identifier">M</span><span class="plain"> &gt; </span><span class="identifier">ranger</span><span class="plain">) </span><span class="identifier">ranger</span><span class="plain"> = </span><span class="identifier">ranger</span><span class="plain">*10;</span>
        <span class="identifier">remainder</span><span class="plain"> = </span><span class="identifier">remainder</span><span class="plain">*(</span><span class="identifier">ranger</span><span class="plain">/</span><span class="identifier">M</span><span class="plain">);</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">remainder</span><span class="plain"> &gt; 0) &amp;&amp; ((</span><span class="identifier">remainder</span><span class="plain"> % 10) == 0)) {</span>
            <span class="identifier">ranger</span><span class="plain"> = </span><span class="identifier">ranger</span><span class="plain">/10; </span><span class="identifier">remainder</span><span class="plain"> = </span><span class="identifier">remainder</span><span class="plain">/10;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">remainder</span><span class="plain"> &gt; 0) {</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"."</span><span class="plain">);</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="functiontext">LiteralPatterns::leading_zero_prototype</span><span class="plain">(</span><span class="identifier">ranger</span><span class="plain">), </span><span class="identifier">remainder</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP25_3">&#167;25.3</a>.</p>

<p class="inwebparagraph"><a id="SP26"></a><b>&#167;26.  </b>Please don't mention the words "logarithm" or "shift". It works fine.
</p>


<pre class="display">
    <span class="reserved">char</span><span class="plain"> *</span><span class="functiontext">LiteralPatterns::leading_zero_prototype</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">range</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">range</span><span class="plain"> &gt; 1000000000) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"%010d"</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">range</span><span class="plain"> &gt; 100000000) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"%09d"</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">range</span><span class="plain"> &gt; 10000000) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"%08d"</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">range</span><span class="plain"> &gt; 1000000) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"%07d"</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">range</span><span class="plain"> &gt; 100000) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"%06d"</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">range</span><span class="plain"> &gt; 10000) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"%05d"</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">range</span><span class="plain"> &gt; 1000) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"%04d"</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">range</span><span class="plain"> &gt; 100) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"%03d"</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">range</span><span class="plain"> &gt; 10) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"%02d"</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="string">"%d"</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::leading_zero_prototype is used in <a href="#SP25_3">&#167;25.3</a>, <a href="#SP25_3_1">&#167;25.3.1</a>.</p>

<p class="inwebparagraph"><a id="SP27"></a><b>&#167;27. Printing the I6 variable |value| out in an LP's notation at run-time. </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::printing_routine</span><span class="plain">(</span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain">, </span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp_list</span><span class="plain">) {</span>
        <span class="identifier">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="functiontext">Routines::begin</span><span class="plain">(</span><span class="identifier">iname</span><span class="plain">);</span>

        <span class="reserved">literal_pattern_name</span><span class="plain"> *</span><span class="identifier">lpn</span><span class="plain">;</span>
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">k</span><span class="plain">;</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">value_s</span><span class="plain"> = </span><span class="functiontext">LocalVariables::add_named_call_as_symbol</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"value"</span><span class="plain">);</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">which_s</span><span class="plain"> = </span><span class="functiontext">LocalVariables::add_named_call_as_symbol</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"which"</span><span class="plain">);</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">rem_s</span><span class="plain"> = </span><span class="functiontext">LocalVariables::add_internal_local_as_symbol</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"rem"</span><span class="plain">);</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">S_s</span><span class="plain"> = </span><span class="functiontext">LocalVariables::add_internal_local_as_symbol</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"S"</span><span class="plain">);</span>

        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">lpn</span><span class="plain">, </span><span class="reserved">literal_pattern_name</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">lpn</span><span class="plain">-</span><span class="element">&gt;notation_name</span><span class="plain">)) {</span>
                <span class="identifier">k</span><span class="plain"> = 0;</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp_list</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain">)</span>
                    <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;marked_for_printing</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
                <span class="reserved">literal_pattern_name</span><span class="plain"> *</span><span class="identifier">lpn2</span><span class="plain">;</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lpn2</span><span class="plain"> = </span><span class="identifier">lpn</span><span class="plain">; </span><span class="identifier">lpn2</span><span class="plain">; </span><span class="identifier">lpn2</span><span class="plain"> = </span><span class="identifier">lpn2</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)</span>
                    <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp_list</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain">)</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> == </span><span class="identifier">lpn2</span><span class="plain">-</span><span class="element">&gt;can_use_this_lp</span><span class="plain">) {</span>
                            <span class="identifier">k</span><span class="plain">++; </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;marked_for_printing</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                        <span class="plain">}</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">k</span><span class="plain"> &gt; 0) {</span>
                    <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">);</span>
                    <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="string">"The named notation: %W"</span><span class="plain">, </span><span class="identifier">lpn</span><span class="plain">-</span><span class="element">&gt;notation_name</span><span class="plain">);</span>
                    <span class="functiontext">Emit::code_comment</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">);</span>
                    <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">);</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">which_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) (</span><span class="identifier">lpn</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain"> + 1));</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            &lt;<span class="cwebmacro">Compile code to jump to the correct printing pattern</span> <span class="cwebmacronumber">27.2</span>&gt;<span class="plain">;</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>

        &lt;<span class="cwebmacro">Choose which patterns are eligible for printing</span> <span class="cwebmacronumber">27.1</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Compile code to jump to the correct printing pattern</span> <span class="cwebmacronumber">27.2</span>&gt;<span class="plain">;</span>

        <span class="identifier">Produce::rtrue</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp_list</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain">) {</span>
            &lt;<span class="cwebmacro">Print according to this particular literal pattern</span> <span class="cwebmacronumber">27.3</span>&gt;<span class="plain">;</span>
            <span class="identifier">Produce::rtrue</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="plain">}</span>
        <span class="functiontext">Routines::end</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::printing_routine is used in 13/rsfk (<a href="13-rsfk.html#SP24_2">&#167;24.2</a>).</p>

<p class="inwebparagraph"><a id="SP27_1"></a><b>&#167;27.1.  </b>This was at one time a more complicated criterion, which masked bugs in
the sorting measure.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Choose which patterns are eligible for printing</span> <span class="cwebmacronumber">27.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">k</span><span class="plain">=0, </span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp_list</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain">) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">eligible</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;equivalent_unit</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">eligible</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">eligible</span><span class="plain">) </span><span class="identifier">k</span><span class="plain">++;</span>
            <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;marked_for_printing</span><span class="plain"> = </span><span class="identifier">eligible</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP27">&#167;27</a>.</p>

<p class="inwebparagraph"><a id="SP27_2"></a><b>&#167;27.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile code to jump to the correct printing pattern</span> <span class="cwebmacronumber">27.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lpb</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp_list</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;marked_for_printing</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;benchmark</span><span class="plain">)</span>
                    <span class="identifier">lpb</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">lpb</span><span class="plain">) &amp;&amp; (</span><span class="identifier">lpb</span><span class="plain">-</span><span class="element">&gt;singular_form_only</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">value_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">JUMP_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::lab</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">LiteralPatterns::jump_label</span><span class="plain">(</span><span class="identifier">lpb</span><span class="plain">));</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="plain">}</span>

        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">last_lp</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">, *</span><span class="identifier">last_primary</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">, *</span><span class="identifier">last_singular</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">, *</span><span class="identifier">last_plural</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>

        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp_list</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain">; </span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;next_for_this_kind</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;marked_for_printing</span><span class="plain">) {</span>
                <span class="identifier">inter_t</span><span class="plain"> </span><span class="identifier">op</span><span class="plain"> = </span><span class="identifier">GE_BIP</span><span class="plain">; </span><span class="identifier">last_lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;primary_alternative</span><span class="plain">) { </span><span class="identifier">last_primary</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">; }</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;singular_form_only</span><span class="plain">) { </span><span class="identifier">last_singular</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">; </span><span class="identifier">op</span><span class="plain"> = </span><span class="identifier">EQ_BIP</span><span class="plain">; }</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;plural_form_only</span><span class="plain">) { </span><span class="identifier">last_plural</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">; </span><span class="identifier">op</span><span class="plain"> = </span><span class="identifier">GT_BIP</span><span class="plain">; }</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Kinds::Scalings::compile_threshold_test</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">, </span><span class="identifier">value_s</span><span class="plain">, </span><span class="identifier">op</span><span class="plain">);</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">JUMP_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::lab</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">LiteralPatterns::jump_label</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">));</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="plain">}</span>
        <span class="plain">}</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">last_primary</span><span class="plain">) </span><span class="identifier">last_lp</span><span class="plain"> = </span><span class="identifier">last_primary</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">last_lp</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">last_lp</span><span class="plain">-</span><span class="element">&gt;singular_form_only</span><span class="plain">) &amp;&amp;</span>
                <span class="plain">(</span><span class="identifier">last_plural</span><span class="plain">) &amp;&amp;</span>
                <span class="plain">(</span><span class="identifier">Kinds::Scalings::compare</span><span class="plain">(</span><span class="identifier">last_plural</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">, </span><span class="identifier">last_lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">) == 0)) {</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">JUMP_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::lab</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">LiteralPatterns::jump_label</span><span class="plain">(</span><span class="identifier">last_plural</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="plain">}</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">JUMP_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::lab</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">LiteralPatterns::jump_label</span><span class="plain">(</span><span class="identifier">last_lp</span><span class="plain">));</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP27">&#167;27</a> (twice).</p>

<p class="inwebparagraph"><a id="SP27_3"></a><b>&#167;27.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Print according to this particular literal pattern</span> <span class="cwebmacronumber">27.3</span>&gt; =
</code></p>


<pre class="displaydefn">

        <span class="functiontext">LiteralPatterns::comment_use_of_lp</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">);</span>
        <span class="identifier">Produce::place_label</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">LiteralPatterns::jump_label</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">));</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">ec</span><span class="plain">=0, </span><span class="identifier">oc</span><span class="plain">=0;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">tc</span><span class="plain">=0; </span><span class="identifier">tc</span><span class="plain">&lt;</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_tokens</span><span class="plain">; </span><span class="identifier">tc</span><span class="plain">++) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">ec</span><span class="plain">]</span><span class="element">.preamble_optional</span><span class="plain">)</span>
                &lt;<span class="cwebmacro">Truncate the printed form here if subsequent numerical parts are zero</span> <span class="cwebmacronumber">27.3.4</span>&gt;<span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">tc</span><span class="plain">&gt;0) &amp;&amp; (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.new_word_at</span><span class="plain">)) {</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINT_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_text</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">I</span><span class="string">" "</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="plain">}</span>
            <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.lpt_type</span><span class="plain">) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">WORD_LPT</span><span class="plain">: </span>&lt;<span class="cwebmacro">Compile I6 code to print a fixed word token within a literal pattern</span> <span class="cwebmacronumber">27.3.1</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">CHARACTER_LPT</span><span class="plain">: </span>&lt;<span class="cwebmacro">Compile I6 code to print a character token within a literal pattern</span> <span class="cwebmacronumber">27.3.2</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">ELEMENT_LPT</span><span class="plain">: </span>&lt;<span class="cwebmacro">Compile I6 code to print an element token within a literal pattern</span> <span class="cwebmacronumber">27.3.3</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">default</span><span class="plain">: </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"unknown literal pattern token type"</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP27">&#167;27</a>.</p>

<p class="inwebparagraph"><a id="SP27_3_1"></a><b>&#167;27.3.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile I6 code to print a fixed word token within a literal pattern</span> <span class="cwebmacronumber">27.3.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">);</span>
        <span class="functiontext">CompiledText::from_wide_string</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">Lexer::word_raw_text</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.token_wn</span><span class="plain">), </span><span class="constant">CT_RAW</span><span class="plain">);</span>
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINT_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::val_text</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">T</span><span class="plain">);</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP27_3">&#167;27.3</a>.</p>

<p class="inwebparagraph"><a id="SP27_3_2"></a><b>&#167;27.3.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile I6 code to print a character token within a literal pattern</span> <span class="cwebmacronumber">27.3.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">);</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">tiny_string</span><span class="plain">);</span>
        <span class="identifier">PUT_TO</span><span class="plain">(</span><span class="identifier">tiny_string</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.token_char</span><span class="plain">);</span>
        <span class="functiontext">CompiledText::from_stream</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">tiny_string</span><span class="plain">, </span><span class="constant">CT_RAW</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">tiny_string</span><span class="plain">);</span>
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINT_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::val_text</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">T</span><span class="plain">);</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP27_3">&#167;27.3</a>.</p>

<p class="inwebparagraph"><a id="SP27_3_3"></a><b>&#167;27.3.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile I6 code to print an element token within a literal pattern</span> <span class="cwebmacronumber">27.3.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">literal_pattern_element</span><span class="plain"> *</span><span class="identifier">lpe</span><span class="plain"> = &amp;(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">ec</span><span class="plain">]);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_optional</span><span class="plain">)</span>
            &lt;<span class="cwebmacro">Truncate the printed form here if subsequent numerical parts are zero</span> <span class="cwebmacronumber">27.3.4</span>&gt;<span class="plain">;</span>
        <span class="identifier">oc</span><span class="plain"> = </span><span class="identifier">ec</span><span class="plain"> + 1;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_elements</span><span class="plain"> == 1) {</span>
            <span class="identifier">Kinds::Scalings::compile_print_in_quanta</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">, </span><span class="identifier">value_s</span><span class="plain">, </span><span class="identifier">rem_s</span><span class="plain">, </span><span class="identifier">S_s</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ec</span><span class="plain"> == 0) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;number_signed</span><span class="plain">) {</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">AND_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LT_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">value_s</span><span class="plain">);</span>
                                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">DIVIDE_BIP</span><span class="plain">);</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">value_s</span><span class="plain">);</span>
                                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) (</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_multiplier</span><span class="plain">));</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINT_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::val_text</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">I</span><span class="string">"-"</span><span class="plain">);</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="plain">}</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINTNUMBER_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">DIVIDE_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">value_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) (</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_multiplier</span><span class="plain">));</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;number_signed</span><span class="plain">) {</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LT_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">value_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">value_s</span><span class="plain">);</span>
                                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">MINUS_BIP</span><span class="plain">);</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">value_s</span><span class="plain">);</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="plain">}</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">]</span><span class="element">.new_word_at</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp;</span>
                    <span class="plain">(</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;without_leading_zeros</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
                    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">pow</span><span class="plain"> = 1;</span>
                    <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">pow</span><span class="plain"> = 1000000000; </span><span class="identifier">pow</span><span class="plain">&gt;1; </span><span class="identifier">pow</span><span class="plain"> = </span><span class="identifier">pow</span><span class="plain">/10)</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_range</span><span class="plain"> &gt; </span><span class="identifier">pow</span><span class="plain">) {</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">LT_BIP</span><span class="plain">);</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">MODULO_BIP</span><span class="plain">);</span>
                                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">DIVIDE_BIP</span><span class="plain">);</span>
                                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">value_s</span><span class="plain">);</span>
                                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) (</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_multiplier</span><span class="plain">));</span>
                                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) (</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_range</span><span class="plain">));</span>
                                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) (</span><span class="identifier">pow</span><span class="plain">));</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINT_BIP</span><span class="plain">);</span>
                                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                        <span class="identifier">Produce::val_text</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">I</span><span class="string">"0"</span><span class="plain">);</span>
                                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

                        <span class="plain">}</span>
                <span class="plain">}</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINTNUMBER_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">MODULO_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">DIVIDE_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">value_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) (</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_multiplier</span><span class="plain">));</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) (</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_range</span><span class="plain">));</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="identifier">ec</span><span class="plain">++;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP27_3">&#167;27.3</a>.</p>

<p class="inwebparagraph"><a id="SP27_3_4"></a><b>&#167;27.3.4.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Truncate the printed form here if subsequent numerical parts are zero</span> <span class="cwebmacronumber">27.3.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">oc</span><span class="plain"> == </span><span class="identifier">ec</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ec</span><span class="plain"> == 0) {</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">DIVIDE_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">value_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">ec</span><span class="plain">]</span><span class="element">.element_multiplier</span><span class="plain">));</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::rtrue</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">MODULO_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">DIVIDE_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">value_s</span><span class="plain">);</span>
                                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">ec</span><span class="plain">]</span><span class="element">.element_multiplier</span><span class="plain">));</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">ec</span><span class="plain">]</span><span class="element">.element_range</span><span class="plain">));</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::rtrue</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="plain">}</span>
            <span class="identifier">oc</span><span class="plain"> = </span><span class="identifier">ec</span><span class="plain"> + 1;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP27_3">&#167;27.3</a>, <a href="#SP27_3_3">&#167;27.3.3</a>.</p>

<p class="inwebparagraph"><a id="SP28"></a><b>&#167;28.  </b></p>


<pre class="display">
    <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="functiontext">LiteralPatterns::jump_label</span><span class="plain">(</span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;jump_label</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">N</span><span class="plain">);</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">N</span><span class="plain">, </span><span class="string">".Use_LP_%d"</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain">);</span>
            <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;jump_label</span><span class="plain"> = </span><span class="identifier">Produce::reserve_label</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">N</span><span class="plain">);</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">N</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;jump_label</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::jump_label is used in <a href="#SP27_2">&#167;27.2</a>, <a href="#SP27_3">&#167;27.3</a>.</p>

<p class="inwebparagraph"><a id="SP29"></a><b>&#167;29.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::comment_use_of_lp</span><span class="plain">(</span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">) {</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="string">"%W, "</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;prototype_text</span><span class="plain">);</span>
        <span class="identifier">Kinds::Scalings::describe</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">);</span>
        <span class="functiontext">Emit::code_comment</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::comment_use_of_lp is used in <a href="#SP19">&#167;19</a>, <a href="#SP27_3">&#167;27.3</a>, <a href="#SP30">&#167;30</a>.</p>

<p class="inwebparagraph"><a id="SP30"></a><b>&#167;30.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::log_lp_debugging_data</span><span class="plain">(</span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">) {</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="string">"%s %s LP%d: primary %d, s/p: %d/%d\</span><span class="plain">n</span><span class="string">"</span><span class="plain">,</span>
            <span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;benchmark</span><span class="plain">)?</span><span class="string">"***"</span><span class="plain">:</span><span class="string">"---"</span><span class="plain">,</span>
            <span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;equivalent_unit</span><span class="plain">)?</span><span class="string">"equiv"</span><span class="plain">:</span><span class="string">"new  "</span><span class="plain">,</span>
            <span class="identifier">lp</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;primary_alternative</span><span class="plain">,</span>
            <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;singular_form_only</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;plural_form_only</span><span class="plain">);</span>
        <span class="functiontext">Emit::code_comment</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="functiontext">LiteralPatterns::comment_use_of_lp</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::log_lp_debugging_data appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP31"></a><b>&#167;31. Creating new literal patterns. </b>We create new LPs during traverse 1 of the parse tree. This imposes two
timing constraints:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(a) The specification sentence must come after the sentence creating the
kind of value being specified; but
</li><li>(b) It must come before any sentences using constants written in this
notation.
</li></ul>
<p class="inwebparagraph">In practice both constraints seem to be accepted by users as reasonable,
and this causes no trouble.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::specifies_SMF</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">NPs</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[0]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[1]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ACCEPT_SMFT</span><span class="plain">: </span>    <span class="comment">"10'23 specifies a running time."</span>
                <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">alternative</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">)) {</span>
                    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">S</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">)) {</span>
                        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">O</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                        <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">S</span><span class="plain">; </span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">O</span><span class="plain">;</span>
                        <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="constant">SPECIAL_MEANING_VB</span><span class="plain">);</span>
                        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TRAVERSE1_SMFT</span><span class="plain">:</span>
                <span class="functiontext">LiteralPatterns::new_literal_specification_list</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::new_literal_specification</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">) {</span>
        <span class="functiontext">LiteralPatterns::new_literal_specification_list</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::specifies_SMF is used in 6/nv (<a href="6-nv.html#SP16">&#167;16</a>).</p>

<p class="endnote">The function LiteralPatterns::new_literal_specification appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP32"></a><b>&#167;32.  </b>One can define LPs with a list of alternatives, of which the first is the
"primary alternative" and said to be the "owner" of the rest. For instance:
</p>

<blockquote>
    <p>1 tonne (in metric units, in tonnes, singular) or 2 tonnes (in metric units,</p>

</blockquote>

<p class="inwebparagraph">in tonnes, plural) specifies a mass scaled up by 1000.
</p>

<p class="inwebparagraph">Here we call <code class="display"><span class="extract">LiteralPatterns::new_literal_specification_list</span></code> on "1 tonne" with no owner,
and then on "2 tonnes" with the "1 tonne" LP as its owner.
</p>


<pre class="display">
    <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="functiontext">LiteralPatterns::new_literal_specification_list</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">q</span><span class="plain">,</span>
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp_main</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">) == </span><span class="identifier">AND_NT</span><span class="plain">) {</span>
            <span class="identifier">lp_main</span><span class="plain"> = </span><span class="functiontext">LiteralPatterns::new_literal_specification_list</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">, </span><span class="identifier">q</span><span class="plain">, </span><span class="identifier">lp_main</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::new_literal_specification_list</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">q</span><span class="plain">, </span><span class="identifier">lp_main</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::new_literal_specification_inner</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">q</span><span class="plain">, </span><span class="identifier">lp_main</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::new_literal_specification_list is used in <a href="#SP31">&#167;31</a>.</p>

<p class="inwebparagraph"><a id="SP33"></a><b>&#167;33.  </b>The grammars for the specify sentence are quite complicated, but aren't used
recursively. So it's more convenient to have them set global variables than to
form a big parse subtree and extract the data from that; these are what they
set.
</p>


<pre class="display">
    <span class="reserved">double</span><span class="plain"> </span><span class="identifier">LP_real_offset</span><span class="plain"> = 0.0, </span><span class="identifier">LP_real_equivalent</span><span class="plain"> = 0.0, </span><span class="identifier">LP_real_scaling_amount</span><span class="plain"> = 0.0;</span>
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">LP_scaling</span><span class="plain">, </span><span class="identifier">LP_scaling_amount</span><span class="plain">, </span><span class="identifier">LP_to_real</span><span class="plain">;</span>
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">LP_equivalent</span><span class="plain">; </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">LP_equivalent_value</span><span class="plain">;</span>
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">LP_offset_value</span><span class="plain">;</span>
    <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">LP_left_kind</span><span class="plain">, *</span><span class="identifier">LP_right_kind</span><span class="plain">; </span>    <span class="comment">used only for dimensional rules</span>
    <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">LP_kind_specified</span><span class="plain">; </span>    <span class="comment">what kind this sentence specifies</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP34"></a><b>&#167;34.  </b>So this is where we handle a typical specification:
</p>


<pre class="display">
    <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="functiontext">LiteralPatterns::new_literal_specification_inner</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">q</span><span class="plain">,</span>
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">owner</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">scaled</span><span class="plain"> = 1, </span><span class="identifier">scaled_dir</span><span class="plain"> = </span><span class="identifier">LP_SCALED_UP</span><span class="plain">, </span><span class="identifier">offset</span><span class="plain"> = 0, </span><span class="identifier">integer_scaling</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">part_np_list</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">what we will create, if all goes well</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">notation_options</span><span class="plain"> = 0; </span><span class="reserved">literal_pattern_name</span><span class="plain"> *</span><span class="identifier">notation_groups</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SPW</span><span class="plain"> = </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>

        &lt;<span class="cwebmacro">Parse the subject noun phrase of the specifies sentence</span> <span class="cwebmacronumber">34.2</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Parse the object noun phrase of the specifies sentence</span> <span class="cwebmacronumber">34.3</span>&gt;<span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::FloatingPoint::uses_floating_point</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">)) </span><span class="identifier">integer_scaling</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">LP_to_real</span><span class="plain">) &amp;&amp; (</span><span class="identifier">integer_scaling</span><span class="plain">))</span>
            &lt;<span class="cwebmacro">Issue problem message warning that real arithmetic is needed</span> <span class="cwebmacronumber">34.6</span>&gt;<span class="plain">;</span>

        &lt;<span class="cwebmacro">Deal with the case where a dimensionality rule is being specified</span> <span class="cwebmacronumber">34.7</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Check that the new notation does not overlap with that of any existing LP</span> <span class="cwebmacronumber">34.5</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Check that the kind is acceptable as the owner of a LP</span> <span class="cwebmacronumber">34.8</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Check that any other value mentioned as an equivalent or scaled equivalent has the right kind</span> <span class="cwebmacronumber">34.4</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Create the new literal pattern structure</span> <span class="cwebmacronumber">34.9</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Break down the specification text into tokens and elements</span> <span class="cwebmacronumber">34.10</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Adopt real arithmetic if this is called for</span> <span class="cwebmacronumber">34.11</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Calculate the multipliers for packing the elements into a single integer</span> <span class="cwebmacronumber">34.12</span>&gt;<span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">LiteralPatterns::list_of_literal_forms</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">) == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;benchmark</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="functiontext">LiteralPatterns::add_literal_pattern</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">part_np_list</span><span class="plain">) {</span>
            &lt;<span class="cwebmacro">Work through parts text to assign names to the individual elements</span> <span class="cwebmacronumber">34.13</span>&gt;<span class="plain">;</span>
            &lt;<span class="cwebmacro">Check that any notes to do with optional elements are mutually compatible</span> <span class="cwebmacronumber">34.14</span>&gt;<span class="plain">;</span>
            <span class="functiontext">LiteralPatterns::define_packing_phrases</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">);</span>
        <span class="plain">}</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">owner</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">owner</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">;</span>
        <span class="reserved">else</span><span class="plain"> </span>&lt;<span class="cwebmacro">Add this new alternative to the list belonging to our owner</span> <span class="cwebmacronumber">34.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function LiteralPatterns::new_literal_specification_inner is used in <a href="#SP32">&#167;32</a>.</p>

<p class="inwebparagraph"><a id="SP34_1"></a><b>&#167;34.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Add this new alternative to the list belonging to our owner</span> <span class="cwebmacronumber">34.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">alt</span><span class="plain"> = </span><span class="identifier">owner</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">alt</span><span class="plain">) &amp;&amp; (</span><span class="identifier">alt</span><span class="plain">-</span><span class="element">&gt;next_alternative_lp</span><span class="plain">)) </span><span class="identifier">alt</span><span class="plain"> = </span><span class="identifier">alt</span><span class="plain">-</span><span class="element">&gt;next_alternative_lp</span><span class="plain">;</span>
        <span class="identifier">alt</span><span class="plain">-</span><span class="element">&gt;next_alternative_lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP34">&#167;34</a>.</p>

<p class="inwebparagraph"><a id="SP34_2"></a><b>&#167;34.2.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">PARTS_LPC</span><span class="plain"> 1</span>
    <span class="definitionkeyword">define</span> <span class="constant">SCALING_LPC</span><span class="plain"> 2</span>
    <span class="definitionkeyword">define</span> <span class="constant">OFFSET_LPC</span><span class="plain"> 3</span>
    <span class="definitionkeyword">define</span> <span class="constant">EQUIVALENT_LPC</span><span class="plain"> 4</span>
    <span class="definitionkeyword">define</span> <span class="constant">OPTIONAL_LSO</span><span class="plain"> 1</span>
    <span class="definitionkeyword">define</span> <span class="constant">PREAMBLE_OPTIONAL_LSO</span><span class="plain"> 2</span>
    <span class="definitionkeyword">define</span> <span class="constant">WITHOUT_LEADING_ZEROS_LSO</span><span class="plain"> 4</span>
    <span class="definitionkeyword">define</span> <span class="constant">SINGULAR_LPN</span><span class="plain"> 1</span>
    <span class="definitionkeyword">define</span> <span class="constant">PLURAL_LPN</span><span class="plain"> 2</span>
    <span class="definitionkeyword">define</span> <span class="constant">IN_LPN</span><span class="plain"> 4</span>
    <span class="definitionkeyword">define</span> <span class="constant">TIMES_LPN</span><span class="plain"> 8</span>
    <span class="definitionkeyword">define</span> <span class="constant">ABANDON_LPN</span><span class="plain"> 16</span>

    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Parse the subject noun phrase of the specifies sentence</span> <span class="cwebmacronumber">34.2</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="identifier">LP_scaling</span><span class="plain"> = </span><span class="identifier">LP_SCALED_UP</span><span class="plain">; </span><span class="identifier">LP_scaling_amount</span><span class="plain"> = 1; </span><span class="identifier">LP_real_scaling_amount</span><span class="plain"> = 1.0;</span>
            <span class="identifier">LP_real_equivalent</span><span class="plain"> = 0.0; </span><span class="identifier">LP_equivalent_value</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="identifier">LP_real_offset</span><span class="plain"> = 0.0; </span><span class="identifier">LP_offset_value</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="identifier">LP_to_real</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>

            <span class="plain">&lt;</span><span class="identifier">specifies</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt;(</span><span class="identifier">SPW</span><span class="plain">);</span>
            <span class="identifier">SPW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">specifies</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt;, 1);</span>
            <span class="identifier">notation_options</span><span class="plain"> = &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">notation_options</span><span class="plain"> &amp; </span><span class="constant">ABANDON_LPN</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">;</span>
            <span class="identifier">notation_groups</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">notation_options</span><span class="plain">) </span><span class="identifier">notation_groups</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP34">&#167;34</a>.</p>

    <p class="inwebparagraph"><a id="SP35"></a><b>&#167;35.  </b>The following grammar is used to parse the new literal patterns defined
    in a "specifies" sentence.
    </p>

    <blockquote>
        <p>1 tonne (in metric units, in tonnes, singular) or 2 tonnes (in metric units, in tonnes, plural) specifies a mass scaled up by 1000.</p>

    </blockquote>

    <p class="inwebparagraph">The subject nounphrase has already been converted into a list of alternatives,
    divided by "or", and the following grammar removes the optional list of
    groups to which the notation begins. So, for example, &lt;specifies-sentence-subject&gt;
    is used on "1 tonne (in metric units, in tonnes, singular)". "In metric
    units" and "in tonnes" are names for groups of literal patterns; note
    that in English, these names always begin with "in".
    </p>

    <p class="inwebparagraph">However, note that a "specifies" sentence can also be used for a quite
    different purpose:
    </p>

    <blockquote>
        <p>A length times a length specifies an area.</p>

    </blockquote>

    <p class="inwebparagraph">This gives dimensional instructions about kinds, and doesn't have anything to
    do with literals and their notation. It's a slightly unhappy ambiguity, but
    the potential for confusion is very low. Nobody who defines a literal pattern
    with the word "times" in can expect good results anyway, given that "times"
    will usually be interpreted as multiplication when Inform eventually parses
    such a literal. Still, to minimise clashes, we respond to "times" here only
    when there is meaningful text on either side of it.
    </p>

    <p class="inwebparagraph">Formally, the subject noun phrase of a "specifies" sentence must be a list
    of alternatives each of which matches the following:
    </p>


    <pre class="display">
        <span class="plain">&lt;</span><span class="identifier">specifies</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt; ::=</span>
            <span class="plain">... ( {&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">group</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt;} ) |				==&gt; </span><span class="identifier">R</span><span class="plain">[1]; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
            <span class="plain">&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">articled</span><span class="plain">&gt; </span><span class="identifier">times</span><span class="plain"> &lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">articled</span><span class="plain">&gt; |				==&gt; </span><span class="constant">TIMES_LPN</span><span class="plain">; </span><span class="identifier">LP_left_kind</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]; </span><span class="identifier">LP_right_kind</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2];</span>
            <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">&gt; </span><span class="identifier">times</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">&gt; |	==&gt; </span>&lt;<span class="cwebmacro">Issue PM_MultiplyingNonKOVs problem</span> <span class="cwebmacronumber">35.2</span>&gt;
            <span class="plain">...														==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span>

        <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">group</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; ::=</span>
            <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">group</span><span class="plain">&gt; &lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">group</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; |	==&gt; </span><span class="identifier">R</span><span class="plain">[1] | </span><span class="identifier">R</span><span class="plain">[2]; </span>&lt;<span class="cwebmacro">Compose LPG lists</span> <span class="cwebmacronumber">35.1</span>&gt;<span class="plain">;</span>
            <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">group</span><span class="plain">&gt;						==&gt; </span><span class="identifier">R</span><span class="plain">[1]; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>

        <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">group</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; ::=</span>
            <span class="plain">, </span><span class="identifier">and</span><span class="plain"> &lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">group</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; |		==&gt; </span><span class="identifier">R</span><span class="plain">[1]; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
            <span class="plain">,/</span><span class="identifier">and</span><span class="plain"> &lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">group</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt;			==&gt; </span><span class="identifier">R</span><span class="plain">[1]; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>

        <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">group</span><span class="plain">&gt; ::=</span>
            <span class="identifier">singular</span><span class="plain"> |									==&gt; </span><span class="constant">SINGULAR_LPN</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="identifier">plural</span><span class="plain"> |									==&gt; </span><span class="constant">PLURAL_LPN</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">group</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |				==&gt; </span><span class="constant">IN_LPN</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">LiteralPatterns::new_lpn</span><span class="plain">(</span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="identifier">RP</span><span class="plain">[1]);</span>
            <span class="identifier">in</span><span class="plain"> ...... |									==&gt; </span><span class="constant">IN_LPN</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">LiteralPatterns::new_lpn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
            <span class="plain">......										==&gt; </span>&lt;<span class="cwebmacro">Issue PM_BadLPNameOption problem</span> <span class="cwebmacronumber">35.3</span>&gt;
    </pre>

    <p class="inwebparagraph"></p>

    <p class="inwebparagraph"><a id="SP35_1"></a><b>&#167;35.1.  </b><code class="display">
    &lt;<span class="cwebmacrodefn">Compose LPG lists</span> <span class="cwebmacronumber">35.1</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">RP</span><span class="plain">[1] == </span><span class="identifier">NULL</span><span class="plain">) *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2];</span>
            <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">RP</span><span class="plain">[2]) ((</span><span class="reserved">literal_pattern_name</span><span class="plain"> *) </span><span class="identifier">RP</span><span class="plain">[1])-</span><span class="element">&gt;next_with_rp</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2];</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP35">&#167;35</a>.</p>

    <p class="inwebparagraph"><a id="SP35_2"></a><b>&#167;35.2.  </b><code class="display">
    &lt;<span class="cwebmacrodefn">Issue PM_MultiplyingNonKOVs problem</span> <span class="cwebmacronumber">35.2</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">ABANDON_LPN</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">preform_lookahead_mode</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_MultiplyingNonKOVs</span><span class="plain">),</span>
                    <span class="string">"only kinds of value can be multiplied here"</span><span class="plain">,</span>
                    <span class="string">"and only in a sentence like 'A length times a length specifies an area.'"</span><span class="plain">);</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP35">&#167;35</a>.</p>

    <p class="inwebparagraph"><a id="SP35_3"></a><b>&#167;35.3.  </b><code class="display">
    &lt;<span class="cwebmacrodefn">Issue PM_BadLPNameOption problem</span> <span class="cwebmacronumber">35.3</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">ABANDON_LPN</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">preform_lookahead_mode</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BadLPNameOption</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"In the specification %1, I was expecting that '%2' would be an optional "</span>
                    <span class="string">"note about one of the notations: it should have been one of 'singular', "</span>
                    <span class="string">"'plural' or 'in ...'."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP35">&#167;35</a>.</p>

    <p class="inwebparagraph"><a id="SP34_3"></a><b>&#167;34.3.  </b><code class="display">
    &lt;<span class="cwebmacrodefn">Parse the object noun phrase of the specifies sentence</span> <span class="cwebmacronumber">34.3</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="identifier">LP_offset_value</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="plain">&lt;</span><span class="identifier">specifies</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">q</span><span class="plain">));</span>
            <span class="reserved">switch</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">PARTS_LPC</span><span class="plain">: </span><span class="identifier">part_np_list</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">SCALING_LPC</span><span class="plain">: </span><span class="identifier">scaled</span><span class="plain"> = </span><span class="identifier">LP_scaling_amount</span><span class="plain">; </span><span class="identifier">scaled_dir</span><span class="plain"> = </span><span class="identifier">LP_scaling</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="identifier">K</span><span class="plain"> = </span><span class="identifier">LP_kind_specified</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">;</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP34">&#167;34</a>.</p>

    <p class="inwebparagraph"><a id="SP36"></a><b>&#167;36.  </b>The object noun phrase of a "specifies" sentence is required to match
    the following grammar. Note that the tails are mutually exclusive; you
    can't set both scaling and an equivalent, for instance.
    </p>


    <pre class="display">
        <span class="plain">&lt;</span><span class="identifier">specifies</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt; ::=</span>
            <span class="plain">&lt;</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">specified</span><span class="plain">&gt; &lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">specification</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; |	==&gt; </span><span class="identifier">R</span><span class="plain">[2]; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2]</span>
            <span class="plain">&lt;</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">specified</span><span class="plain">&gt;										==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span>

        <span class="plain">&lt;</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">specified</span><span class="plain">&gt; ::=</span>
            <span class="plain">&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">articled</span><span class="plain">&gt; |										==&gt; 0; </span><span class="identifier">LP_kind_specified</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
            <span class="plain">...														==&gt; </span>&lt;<span class="cwebmacro">Issue PM_LPNotKOV problem</span> <span class="cwebmacronumber">36.1</span>&gt;

        <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">specification</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; ::=</span>
            <span class="identifier">with</span><span class="plain"> </span><span class="identifier">parts</span><span class="plain"> &lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; |	==&gt; </span><span class="constant">PARTS_LPC</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
            <span class="plain">&lt;</span><span class="identifier">scaling</span><span class="plain">-</span><span class="identifier">instruction</span><span class="plain">&gt; |						==&gt; </span><span class="constant">SCALING_LPC</span>
            <span class="plain">&lt;</span><span class="identifier">scaling</span><span class="plain">-</span><span class="identifier">instruction</span><span class="plain">&gt; </span><span class="identifier">offset</span><span class="plain"> </span><span class="identifier">by</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">literal</span><span class="plain">&gt; |	==&gt; </span><span class="constant">SCALING_LPC</span><span class="plain">; </span><span class="identifier">LP_real_offset</span><span class="plain"> = </span><span class="identifier">latest_constructed_real</span><span class="plain">; </span><span class="identifier">LP_offset_value</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2];</span>
            <span class="identifier">offset</span><span class="plain"> </span><span class="identifier">by</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">literal</span><span class="plain">&gt; |						==&gt; </span><span class="constant">OFFSET_LPC</span><span class="plain">; </span><span class="identifier">LP_real_offset</span><span class="plain"> = </span><span class="identifier">latest_constructed_real</span><span class="plain">; </span><span class="identifier">LP_offset_value</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
            <span class="identifier">equivalent</span><span class="plain"> </span><span class="identifier">to</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">literal</span><span class="plain">&gt;						==&gt; </span><span class="constant">EQUIVALENT_LPC</span><span class="plain">; </span><span class="identifier">LP_real_equivalent</span><span class="plain"> = </span><span class="identifier">latest_constructed_real</span><span class="plain">; </span><span class="identifier">LP_equivalent_value</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>

        <span class="plain">&lt;</span><span class="identifier">scaling</span><span class="plain">-</span><span class="identifier">instruction</span><span class="plain">&gt; ::=</span>
            <span class="identifier">scaled</span><span class="plain"> </span><span class="identifier">up</span><span class="plain"> </span><span class="identifier">by</span><span class="plain"> &lt;</span><span class="identifier">cardinal</span><span class="plain">-</span><span class="identifier">number</span><span class="plain">&gt; |			==&gt; </span><span class="constant">SCALING_LPC</span><span class="plain">; </span><span class="identifier">LP_scaling</span><span class="plain"> = </span><span class="identifier">LP_SCALED_UP</span><span class="plain">; </span><span class="identifier">LP_scaling_amount</span><span class="plain"> = </span><span class="identifier">R</span><span class="plain">[1]; </span><span class="identifier">LP_real_scaling_amount</span><span class="plain"> = (</span><span class="reserved">double</span><span class="plain">) </span><span class="identifier">LP_scaling_amount</span><span class="plain">;</span>
            <span class="identifier">scaled</span><span class="plain"> </span><span class="identifier">up</span><span class="plain"> </span><span class="identifier">by</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">real</span><span class="plain">-</span><span class="identifier">number</span><span class="plain">&gt; |		==&gt; </span><span class="constant">SCALING_LPC</span><span class="plain">; </span><span class="identifier">LP_scaling</span><span class="plain"> = </span><span class="identifier">LP_SCALED_UP</span><span class="plain">; </span><span class="identifier">LP_scaling_amount</span><span class="plain"> = 1; </span><span class="identifier">LP_real_scaling_amount</span><span class="plain"> = </span><span class="identifier">latest_constructed_real</span><span class="plain">; </span><span class="identifier">LP_to_real</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="identifier">scaled</span><span class="plain"> </span><span class="identifier">down</span><span class="plain"> </span><span class="identifier">by</span><span class="plain"> &lt;</span><span class="identifier">cardinal</span><span class="plain">-</span><span class="identifier">number</span><span class="plain">&gt; |			==&gt; </span><span class="constant">SCALING_LPC</span><span class="plain">; </span><span class="identifier">LP_scaling</span><span class="plain"> = </span><span class="identifier">LP_SCALED_DOWN</span><span class="plain">; </span><span class="identifier">LP_scaling_amount</span><span class="plain"> = </span><span class="identifier">R</span><span class="plain">[1]; </span><span class="identifier">LP_real_scaling_amount</span><span class="plain"> = (</span><span class="reserved">double</span><span class="plain">) </span><span class="identifier">LP_scaling_amount</span><span class="plain">;</span>
            <span class="identifier">scaled</span><span class="plain"> </span><span class="identifier">down</span><span class="plain"> </span><span class="identifier">by</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">real</span><span class="plain">-</span><span class="identifier">number</span><span class="plain">&gt; |	==&gt; </span><span class="constant">SCALING_LPC</span><span class="plain">; </span><span class="identifier">LP_scaling</span><span class="plain"> = </span><span class="identifier">LP_SCALED_DOWN</span><span class="plain">; </span><span class="identifier">LP_scaling_amount</span><span class="plain"> = 1; </span><span class="identifier">LP_real_scaling_amount</span><span class="plain"> = </span><span class="identifier">latest_constructed_real</span><span class="plain">; </span><span class="identifier">LP_to_real</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="identifier">scaled</span><span class="plain"> </span><span class="identifier">at</span><span class="plain"> &lt;</span><span class="identifier">cardinal</span><span class="plain">-</span><span class="identifier">number</span><span class="plain">&gt;	|				==&gt; </span><span class="constant">SCALING_LPC</span><span class="plain">; </span><span class="identifier">LP_scaling</span><span class="plain"> = </span><span class="identifier">LP_SCALED_AT</span><span class="plain">; </span><span class="identifier">LP_scaling_amount</span><span class="plain"> = </span><span class="identifier">R</span><span class="plain">[1]; </span><span class="identifier">LP_real_scaling_amount</span><span class="plain"> = (</span><span class="reserved">double</span><span class="plain">) </span><span class="identifier">LP_scaling_amount</span><span class="plain">;</span>
            <span class="identifier">scaled</span><span class="plain"> </span><span class="identifier">at</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">real</span><span class="plain">-</span><span class="identifier">number</span><span class="plain">&gt;			==&gt; </span><span class="constant">SCALING_LPC</span><span class="plain">; </span><span class="identifier">LP_scaling</span><span class="plain"> = </span><span class="identifier">LP_SCALED_AT</span><span class="plain">; </span><span class="identifier">LP_scaling_amount</span><span class="plain"> = 1; </span><span class="identifier">LP_real_scaling_amount</span><span class="plain"> = </span><span class="identifier">latest_constructed_real</span><span class="plain">; </span><span class="identifier">LP_to_real</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="inwebparagraph"><a id="SP36_1"></a><b>&#167;36.1.  </b><code class="display">
    &lt;<span class="cwebmacrodefn">Issue PM_LPNotKOV problem</span> <span class="cwebmacronumber">36.1</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">preform_lookahead_mode</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPNotKOV</span><span class="plain">),</span>
                    <span class="string">"you can only specify ways to write kinds of value"</span><span class="plain">,</span>
                    <span class="string">"as created with sentences like 'A weight is a kind of value.'"</span><span class="plain">);</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP36">&#167;36</a>.</p>

    <p class="inwebparagraph"><a id="SP37"></a><b>&#167;37.  </b>Of the optional tails, the only tricky one is the part list, which has the
    following rather extensive grammar. This handles text like:
    </p>

    <blockquote>
        <p>dollars and cents (optional, preamble optional)</p>

    </blockquote>

    <p class="inwebparagraph">The text is a list of part-names, each of which can optionally be followed
    by a bracketed list of up to three options in any order.
    </p>


    <pre class="display">
        <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; ::=</span>
            <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">&gt; , </span><span class="identifier">and</span><span class="plain"> &lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; |	==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]; </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">RP</span><span class="plain">[1]) ((</span><span class="identifier">parse_node</span><span class="plain"> *) </span><span class="identifier">RP</span><span class="plain">[1])-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2];</span>
            <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">&gt; , &lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; |	==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]; </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">RP</span><span class="plain">[1]) ((</span><span class="identifier">parse_node</span><span class="plain"> *) </span><span class="identifier">RP</span><span class="plain">[1])-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2];</span>
            <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">&gt; </span><span class="identifier">and</span><span class="plain"> &lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; |	==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]; </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">RP</span><span class="plain">[1]) ((</span><span class="identifier">parse_node</span><span class="plain"> *) </span><span class="identifier">RP</span><span class="plain">[1])-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2];</span>
            <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">&gt;						==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>

        <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">&gt; ::=</span>
            <span class="plain">&lt;</span><span class="identifier">np</span><span class="plain">-</span><span class="identifier">balanced</span><span class="plain">&gt; ( &lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">-</span><span class="identifier">option</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; ) |	==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]; </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">RP</span><span class="plain">[1]) </span><span class="identifier">ParseTree::annotate_int</span><span class="plain">(*</span><span class="identifier">XP</span><span class="plain">, </span><span class="constant">lpe_options_ANNOT</span><span class="plain">, </span><span class="identifier">R</span><span class="plain">[2]);</span>
            <span class="plain">&lt;</span><span class="identifier">np</span><span class="plain">-</span><span class="identifier">balanced</span><span class="plain">&gt;								==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>

        <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">-</span><span class="identifier">option</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; ::=</span>
            <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">-</span><span class="identifier">option</span><span class="plain">&gt; &lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">-</span><span class="identifier">option</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; |	==&gt; </span><span class="identifier">R</span><span class="plain">[1] | </span><span class="identifier">R</span><span class="plain">[2]</span>
            <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">-</span><span class="identifier">option</span><span class="plain">&gt;				==&gt; </span><span class="identifier">R</span><span class="plain">[1]</span>

        <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">-</span><span class="identifier">option</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; ::=</span>
            <span class="plain">, </span><span class="identifier">and</span><span class="plain"> &lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">-</span><span class="identifier">option</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; |	==&gt; </span><span class="identifier">R</span><span class="plain">[1]</span>
            <span class="plain">,/</span><span class="identifier">and</span><span class="plain"> &lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">-</span><span class="identifier">option</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt;	==&gt; </span><span class="identifier">R</span><span class="plain">[1]</span>

        <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">part</span><span class="plain">-</span><span class="identifier">option</span><span class="plain">&gt; ::=</span>
            <span class="identifier">optional</span><span class="plain"> |									==&gt; </span><span class="constant">OPTIONAL_LSO</span>
            <span class="identifier">preamble</span><span class="plain"> </span><span class="identifier">optional</span><span class="plain"> |							==&gt; </span><span class="constant">PREAMBLE_OPTIONAL_LSO</span>
            <span class="identifier">without</span><span class="plain"> </span><span class="identifier">leading</span><span class="plain"> </span><span class="identifier">zeros</span><span class="plain"> |						==&gt; </span><span class="constant">WITHOUT_LEADING_ZEROS_LSO</span>
            <span class="plain">......										==&gt; </span>&lt;<span class="cwebmacro">Issue PM_BadLPPartOption problem</span> <span class="cwebmacronumber">37.1</span>&gt;
    </pre>

    <p class="inwebparagraph"></p>

    <p class="inwebparagraph"><a id="SP37_1"></a><b>&#167;37.1.  </b><code class="display">
    &lt;<span class="cwebmacrodefn">Issue PM_BadLPPartOption problem</span> <span class="cwebmacronumber">37.1</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = 0;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">preform_lookahead_mode</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BadLPPartOption</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"In the specification %1, I was expecting that '%2' would be an optional "</span>
                    <span class="string">"note about one of the parts: it should have been one of 'optional', "</span>
                    <span class="string">"'preamble optional' or 'without leading zeros'."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP37">&#167;37</a>.</p>

    <p class="inwebparagraph"><a id="SP34_4"></a><b>&#167;34.4.  </b>That's it for syntax: now back to semantics.
    </p>


    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Check that any other value mentioned as an equivalent or scaled equivalent has the right kind</span> <span class="cwebmacronumber">34.4</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">LP_equivalent_value</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Rvalues::is_CONSTANT_of_kind</span><span class="plain">(</span><span class="identifier">LP_equivalent_value</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">)) {</span>
                    <span class="identifier">scaled_dir</span><span class="plain"> = </span><span class="identifier">LP_SCALED_UP</span><span class="plain">; </span><span class="identifier">scaled</span><span class="plain"> = </span><span class="functiontext">Rvalues::to_encoded_notation</span><span class="plain">(</span><span class="identifier">LP_equivalent_value</span><span class="plain">);</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="identifier">Problems::Issue::sentence_problem_with_note</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BadLPEquivalent</span><span class="plain">),</span>
                        <span class="string">"the equivalent value needs to be a constant of the same kind "</span>
                        <span class="string">"of value as you are specifying"</span><span class="plain">,</span>
                        <span class="string">"and this seems not to be."</span><span class="plain">,</span>
                        <span class="string">"Note that you can only use notations specified in sentences "</span>
                        <span class="string">"before the current one."</span><span class="plain">);</span>
                <span class="plain">}</span>
            <span class="plain">}</span>

            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">LP_offset_value</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Rvalues::is_CONSTANT_of_kind</span><span class="plain">(</span><span class="identifier">LP_offset_value</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">)) {</span>
                    <span class="identifier">offset</span><span class="plain"> = </span><span class="functiontext">Rvalues::to_encoded_notation</span><span class="plain">(</span><span class="identifier">LP_offset_value</span><span class="plain">);</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="identifier">Problems::Issue::sentence_problem_with_note</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BadLPOffset</span><span class="plain">),</span>
                        <span class="string">"the offset value needs to be a constant of the same kind "</span>
                        <span class="string">"of value as you are specifying"</span><span class="plain">,</span>
                        <span class="string">"and this seems not to be."</span><span class="plain">,</span>
                        <span class="string">"Note that you can only use notations specified in sentences "</span>
                        <span class="string">"before the current one."</span><span class="plain">);</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP34">&#167;34</a>.</p>

    <p class="inwebparagraph"><a id="SP34_5"></a><b>&#167;34.5.  </b>We parse the specification text as if it were a constant value, hoping
    for the result <code class="display"><span class="extract">NULL</span></code> &mdash; so that it doesn't already mean something else.
    During this process, we waive checking of numerical overflows in matching
    an LP: this is done so that
    </p>

    <blockquote>
        <p>3/13 specifies a bar. 2/19 specifies a foo.</p>

    </blockquote>

    <p class="inwebparagraph">reports "2/19" as a duplicate using the following problem message, but
    does not throw a problem message as being a bar which is out of range
    (because in the bar notation, the number after the slash can be at most
    13, so that 19 is illegal).
    </p>


    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Check that the new notation does not overlap with that of any existing LP</span> <span class="cwebmacronumber">34.5</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="identifier">waive_lp_overflows</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">literal</span><span class="plain">&gt;(</span><span class="identifier">SPW</span><span class="plain">)) </span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">Rvalues::to_kind</span><span class="plain">(&lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;);</span>
            <span class="identifier">waive_lp_overflows</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain">) {</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="functiontext">Problems::quote_kind</span><span class="plain">(2, </span><span class="identifier">K</span><span class="plain">);</span>
                <span class="identifier">Problems::quote_wording</span><span class="plain">(3, </span><span class="identifier">SPW</span><span class="plain">);</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_DuplicateUnitSpec</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"In the sentence %1, it looks as if you intend to give a new meaning "</span>
                    <span class="string">"to expressions like '%3', but this is already something I "</span>
                    <span class="string">"recognise - specifying %2 - so a more distinctive specification "</span>
                    <span class="string">"must be chosen."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">;</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP34">&#167;34</a>.</p>

    <p class="inwebparagraph"><a id="SP34_6"></a><b>&#167;34.6.  </b><code class="display">
    &lt;<span class="cwebmacrodefn">Issue problem message warning that real arithmetic is needed</span> <span class="cwebmacronumber">34.6</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
            <span class="functiontext">Problems::quote_kind</span><span class="plain">(2, </span><span class="identifier">K</span><span class="plain">);</span>
            <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPNeedsReal</span><span class="plain">));</span>
            <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                <span class="string">"In the sentence %1, it looks as if you intend to give a real "</span>
                <span class="string">"number as a scale factor for values of %2. However, as you've "</span>
                <span class="string">"defined it here, %2 uses only whole numbers, so this wouldn't "</span>
                <span class="string">"work. %PYou can probably fix this by making the example "</span>
                <span class="string">"amount a real number too - say, writing '1.0 rel specifies...' "</span>
                <span class="string">"instead of '1 rel specifies...'."</span><span class="plain">);</span>
            <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">;</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP34">&#167;34</a>.</p>

    <p class="inwebparagraph"><a id="SP34_7"></a><b>&#167;34.7.  </b>Note that we don't create a new LP structure if the following happens:
    </p>


    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Deal with the case where a dimensionality rule is being specified</span> <span class="cwebmacronumber">34.7</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">notation_options</span><span class="plain"> == </span><span class="constant">TIMES_LPN</span><span class="plain">) {</span>
                <span class="identifier">Kinds::Dimensions::dim_set_multiplication</span><span class="plain">(</span><span class="identifier">LP_left_kind</span><span class="plain">, </span><span class="identifier">LP_right_kind</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">;</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP34">&#167;34</a>.</p>

    <p class="inwebparagraph"><a id="SP34_8"></a><b>&#167;34.8.  </b>This checking did not apply to the dimensionality rules case, which looks
    after itself.
    </p>


    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Check that the kind is acceptable as the owner of a LP</span> <span class="cwebmacronumber">34.8</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Behaviour::is_built_in</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Behaviour::get_index_priority</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">) == 0)</span>
                    <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPBuiltInKOVHidden</span><span class="plain">),</span>
                        <span class="string">"you can only specify ways to write new kinds of value"</span><span class="plain">,</span>
                        <span class="string">"as created with sentences like 'A weight is a kind of value.', "</span>
                        <span class="string">"and not the built-in ones like 'number' or 'time'. (This one is "</span>
                        <span class="string">"a kind used behind the scenes by Inform, so it's reserved "</span>
                        <span class="string">"for Inform's own use, and you can't do much else with it.)"</span><span class="plain">);</span>
                <span class="reserved">else</span>
                    <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPBuiltInKOV</span><span class="plain">),</span>
                        <span class="string">"you can only specify ways to write new kinds of value"</span><span class="plain">,</span>
                        <span class="string">"as created with sentences like 'A weight is a kind of value.', "</span>
                        <span class="string">"and not the built-in ones like 'number' or 'time'."</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Behaviour::convert_to_unit</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPEnumeration</span><span class="plain">),</span>
                    <span class="string">"this is a kind of value which already has named values"</span><span class="plain">,</span>
                    <span class="string">"so it can't have a basically numerical form as well."</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">;</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP34">&#167;34</a>.</p>

    <p class="inwebparagraph"><a id="SP34_9"></a><b>&#167;34.9.  </b>All the hard work here was done during parsing.
    </p>


    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Create the new literal pattern structure</span> <span class="cwebmacronumber">34.9</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="identifier">lp</span><span class="plain"> = </span><span class="functiontext">LiteralPatterns::lp_new</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">SPW</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">LP_equivalent_value</span><span class="plain">) </span><span class="identifier">LP_real_scaling_amount</span><span class="plain"> = </span><span class="identifier">LP_real_equivalent</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">scaled</span><span class="plain"> &lt;= 0) {</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPNonpositiveScaling</span><span class="plain">),</span>
                    <span class="string">"you can only scale by a positive multiple"</span><span class="plain">,</span>
                    <span class="string">"so something like 'scaled up by -1' is not allowed."</span><span class="plain">);</span>
                <span class="identifier">scaled</span><span class="plain"> = 1;</span>
            <span class="plain">}</span>
            <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain"> = </span><span class="identifier">Kinds::Scalings::new</span><span class="plain">(</span><span class="identifier">integer_scaling</span><span class="plain">, </span><span class="identifier">scaled_dir</span><span class="plain">,</span>
                <span class="identifier">scaled</span><span class="plain">, </span><span class="identifier">LP_real_scaling_amount</span><span class="plain">, </span><span class="identifier">offset</span><span class="plain">, </span><span class="identifier">LP_real_offset</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">scaled_dir</span><span class="plain"> == </span><span class="identifier">LP_SCALED_DOWN</span><span class="plain">) &amp;&amp; (</span><span class="identifier">scaled</span><span class="plain"> == 0)) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"Oooops"</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">owner</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;primary_alternative</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">LP_equivalent_value</span><span class="plain">) </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;equivalent_unit</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">notation_options</span><span class="plain"> &amp; </span><span class="constant">SINGULAR_LPN</span><span class="plain">) </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;singular_form_only</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">notation_options</span><span class="plain"> &amp; </span><span class="constant">PLURAL_LPN</span><span class="plain">) </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;plural_form_only</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">notation_options</span><span class="plain"> &amp; </span><span class="constant">IN_LPN</span><span class="plain">) {</span>
                <span class="reserved">literal_pattern_name</span><span class="plain"> *</span><span class="identifier">lpn</span><span class="plain">;</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lpn</span><span class="plain"> = </span><span class="identifier">notation_groups</span><span class="plain">; </span><span class="identifier">lpn</span><span class="plain">; </span><span class="identifier">lpn</span><span class="plain"> = </span><span class="identifier">lpn</span><span class="plain">-</span><span class="element">&gt;next_with_rp</span><span class="plain">)</span>
                    <span class="identifier">lpn</span><span class="plain">-</span><span class="element">&gt;can_use_this_lp</span><span class="plain"> = </span><span class="identifier">lp</span><span class="plain">;</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP34">&#167;34</a>.</p>

    <p class="inwebparagraph"><a id="SP34_10"></a><b>&#167;34.10.  </b>Each word is either a whole token in itself, or a stream of tokens representing
    alphabetic vs numeric pieces of a word:
    </p>


    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Break down the specification text into tokens and elements</span> <span class="cwebmacronumber">34.10</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">j</span><span class="plain">, </span><span class="identifier">tc</span><span class="plain">, </span><span class="identifier">ec</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">=0, </span><span class="identifier">tc</span><span class="plain">=0, </span><span class="identifier">ec</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">SPW</span><span class="plain">); </span><span class="identifier">i</span><span class="plain">++) {</span>
                <span class="reserved">literal_pattern_token</span><span class="plain"> </span><span class="identifier">new_token</span><span class="plain">;</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">digit_found</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
                <span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">text_of_word</span><span class="plain"> = </span><span class="identifier">Lexer::word_raw_text</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">SPW</span><span class="plain">)+</span><span class="identifier">i</span><span class="plain">);</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">j</span><span class="plain">=0; </span><span class="identifier">text_of_word</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">]; </span><span class="identifier">j</span><span class="plain">++) </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Characters::isdigit</span><span class="plain">(</span><span class="identifier">text_of_word</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">])) </span><span class="identifier">digit_found</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">digit_found</span><span class="plain">)</span>
                    &lt;<span class="cwebmacro">Break up the word into at least one element token, and perhaps also character tokens</span> <span class="cwebmacronumber">34.10.1</span>&gt;
                <span class="reserved">else</span><span class="plain"> {</span>
                    <span class="identifier">new_token</span><span class="plain"> = </span><span class="functiontext">LiteralPatterns::lpt_new</span><span class="plain">(</span><span class="constant">WORD_LPT</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
                    <span class="identifier">new_token</span><span class="element">.token_wn</span><span class="plain"> = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">SPW</span><span class="plain">)+</span><span class="identifier">i</span><span class="plain">;</span>
                    &lt;<span class="cwebmacro">Add new token to LP</span> <span class="cwebmacronumber">34.10.2</span>&gt;<span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_tokens</span><span class="plain"> = </span><span class="identifier">tc</span><span class="plain">;</span>
            <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_elements</span><span class="plain"> = </span><span class="identifier">ec</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_elements</span><span class="plain"> == 0) {</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPWithoutElement</span><span class="plain">),</span>
                    <span class="string">"a way to specify a kind of value must involve numbers"</span><span class="plain">,</span>
                    <span class="string">"so '10kg specifies a weight' is allowed, but not 'tonne "</span>
                    <span class="string">"specifies a weight'."</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">;</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP34">&#167;34</a>.</p>

    <p class="inwebparagraph"><a id="SP34_10_1"></a><b>&#167;34.10.1.  </b>Bounds checking is easier here since we know that a LP specification will
    not ever need to create the maximum conceivable value which a C integer can
    hold &mdash; so we need not fool around with long long ints.
    </p>


    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Break up the word into at least one element token, and perhaps also character tokens</span> <span class="cwebmacronumber">34.10.1</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">j</span><span class="plain">, </span><span class="identifier">sgn</span><span class="plain"> = 1, </span><span class="identifier">next_token_begins_word</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">j</span><span class="plain">=0; </span><span class="identifier">text_of_word</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">]; </span><span class="identifier">j</span><span class="plain">++) {</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">tot</span><span class="plain"> = 0, </span><span class="identifier">digit_found</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">point_found</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">text_of_word</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">] == </span><span class="character">'-'</span><span class="plain">) &amp;&amp; (</span><span class="identifier">Characters::isdigit</span><span class="plain">(</span><span class="identifier">text_of_word</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">+1])) &amp;&amp; (</span><span class="identifier">ec</span><span class="plain"> == 0)) {</span>
                    <span class="identifier">sgn</span><span class="plain"> = -1; </span><span class="reserved">continue</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">while</span><span class="plain"> (</span><span class="identifier">Characters::isdigit</span><span class="plain">(</span><span class="identifier">text_of_word</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">++])) {</span>
                    <span class="identifier">digit_found</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">tot</span><span class="plain"> &gt; 999999999) {</span>
                        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPElementTooLarge</span><span class="plain">),</span>
                            <span class="string">"that specification contains numbers that are too large"</span><span class="plain">,</span>
                            <span class="string">"and would construct values which could not sensibly "</span>
                            <span class="string">"be stored at run-time."</span><span class="plain">);</span>
                        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">;</span>
                    <span class="plain">}</span>
                    <span class="identifier">tot</span><span class="plain"> = 10*</span><span class="identifier">tot</span><span class="plain"> + (</span><span class="identifier">text_of_word</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">-1]-</span><span class="character">'0'</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="identifier">j</span><span class="plain">--;</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">text_of_word</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">] == </span><span class="character">'.'</span><span class="plain">) &amp;&amp; (</span><span class="identifier">text_of_word</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">+1] == </span><span class="character">'0'</span><span class="plain">) &amp;&amp; (</span><span class="identifier">ec</span><span class="plain"> == 0)) {</span>
                    <span class="identifier">j</span><span class="plain"> += 2; </span><span class="identifier">point_found</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">digit_found</span><span class="plain">) {</span>
                    <span class="reserved">literal_pattern_element</span><span class="plain"> </span><span class="identifier">new_element</span><span class="plain"> = </span><span class="functiontext">LiteralPatterns::lpe_new</span><span class="plain">(</span><span class="identifier">ec</span><span class="plain">, </span><span class="identifier">tot</span><span class="plain">+1, </span><span class="identifier">sgn</span><span class="plain">);</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ec</span><span class="plain"> &gt;= </span><span class="constant">MAX_ELEMENTS_PER_LITERAL</span><span class="plain">) {</span>
                        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPTooManyElements</span><span class="plain">),</span>
                            <span class="string">"that specification contains too many numerical elements"</span><span class="plain">,</span>
                            <span class="string">"and is too complicated for Inform to handle."</span><span class="plain">);</span>
                        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">;</span>
                    <span class="plain">}</span>
                    <span class="identifier">new_element</span><span class="element">.is_real</span><span class="plain"> = </span><span class="identifier">point_found</span><span class="plain">;</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">point_found</span><span class="plain">) </span><span class="identifier">integer_scaling</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
                    <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">ec</span><span class="plain">++] = </span><span class="identifier">new_element</span><span class="plain">;</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sgn</span><span class="plain"> == -1) </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;number_signed</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                    <span class="identifier">new_token</span><span class="plain"> = </span><span class="functiontext">LiteralPatterns::lpt_new</span><span class="plain">(</span><span class="constant">ELEMENT_LPT</span><span class="plain">, </span><span class="identifier">next_token_begins_word</span><span class="plain">);</span>
                    &lt;<span class="cwebmacro">Add new token to LP</span> <span class="cwebmacronumber">34.10.2</span>&gt;<span class="plain">;</span>
                    <span class="identifier">j</span><span class="plain">--;</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="identifier">new_token</span><span class="plain"> = </span><span class="functiontext">LiteralPatterns::lpt_new</span><span class="plain">(</span><span class="constant">CHARACTER_LPT</span><span class="plain">, </span><span class="identifier">next_token_begins_word</span><span class="plain">);</span>
                    <span class="identifier">new_token</span><span class="element">.token_char</span><span class="plain"> = </span><span class="identifier">text_of_word</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">];</span>
                    &lt;<span class="cwebmacro">Add new token to LP</span> <span class="cwebmacronumber">34.10.2</span>&gt;<span class="plain">;</span>
                <span class="plain">}</span>
                <span class="identifier">sgn</span><span class="plain"> = 1; </span><span class="identifier">next_token_begins_word</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP34_10">&#167;34.10</a>.</p>

    <p class="inwebparagraph"><a id="SP34_10_2"></a><b>&#167;34.10.2.  </b>In fact counting tokens is not necessarily a good way to measure the
    complexity of an LP, since any long run of characters in a word which
    also contains a number will splurge the number of tokens. So
    <code class="display"><span class="extract">MAX_TOKENS_PER_LITERAL</span></code> is set to a high enough value that this will
    not really distort matters.
    </p>


    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Add new token to LP</span> <span class="cwebmacronumber">34.10.2</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">tc</span><span class="plain"> &gt;= </span><span class="constant">MAX_TOKENS_PER_LITERAL</span><span class="plain">) {</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPTooComplicated</span><span class="plain">),</span>
                    <span class="string">"that specification is too complicated"</span><span class="plain">,</span>
                    <span class="string">"and will have to be shortened."</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_tokens</span><span class="plain">[</span><span class="identifier">tc</span><span class="plain">++] = </span><span class="identifier">new_token</span><span class="plain">;</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP34_10">&#167;34.10</a>, <a href="#SP34_10_1">&#167;34.10.1</a> (twice).</p>

    <p class="inwebparagraph"><a id="SP34_11"></a><b>&#167;34.11.  </b><code class="display">
    &lt;<span class="cwebmacrodefn">Adopt real arithmetic if this is called for</span> <span class="cwebmacronumber">34.11</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">integer_scaling</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="identifier">Kinds::Behaviour::convert_to_real</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
                <span class="identifier">Kinds::Scalings::convert_to_real</span><span class="plain">(&amp;(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;scaling</span><span class="plain">));</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP34">&#167;34</a>.</p>

    <p class="inwebparagraph"><a id="SP34_12"></a><b>&#167;34.12.  </b>The elements are created in parsing order, that is, left to right. But
    the multipliers can only be calculated by working from right to left, so
    this is deferred until all elements exist, at which point we &mdash;
    </p>


    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Calculate the multipliers for packing the elements into a single integer</span> <span class="cwebmacronumber">34.12</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">m</span><span class="plain"> = 1;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">=</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_elements</span><span class="plain">-1; </span><span class="identifier">i</span><span class="plain">&gt;=0; </span><span class="identifier">i</span><span class="plain">--) {</span>
                <span class="reserved">literal_pattern_element</span><span class="plain"> *</span><span class="identifier">lpe</span><span class="plain"> = &amp;(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]);</span>
                <span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_multiplier</span><span class="plain"> = </span><span class="identifier">m</span><span class="plain">;</span>
                <span class="identifier">m</span><span class="plain"> = </span><span class="identifier">m</span><span class="plain">*(</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_range</span><span class="plain">);</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP34">&#167;34</a>.</p>

    <p class="inwebparagraph"><a id="SP34_13"></a><b>&#167;34.13.  </b>Today, we have naming of parts:
    </p>


    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Work through parts text to assign names to the individual elements</span> <span class="cwebmacronumber">34.13</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">;</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">=0, </span><span class="identifier">p</span><span class="plain">=</span><span class="identifier">part_np_list</span><span class="plain">; (</span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_elements</span><span class="plain">) &amp;&amp; (</span><span class="identifier">p</span><span class="plain">); </span><span class="identifier">i</span><span class="plain">++, </span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">) {</span>
                <span class="reserved">literal_pattern_element</span><span class="plain"> *</span><span class="identifier">lpe</span><span class="plain"> = &amp;(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]);</span>
                <span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_name</span><span class="plain"> = </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">O</span><span class="plain"> = </span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="constant">lpe_options_ANNOT</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">O</span><span class="plain"> &amp; </span><span class="constant">OPTIONAL_LSO</span><span class="plain">) </span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_optional</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">O</span><span class="plain"> &amp; </span><span class="constant">PREAMBLE_OPTIONAL_LSO</span><span class="plain">) {</span>
                    <span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_optional</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;preamble_optional</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">O</span><span class="plain"> &amp; </span><span class="constant">WITHOUT_LEADING_ZEROS_LSO</span><span class="plain">) </span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;without_leading_zeros</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">i</span><span class="plain"> == </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_elements</span><span class="plain"> - 1) &amp;&amp; (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)) {</span>
                    <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPTooManyPartNames</span><span class="plain">),</span>
                        <span class="string">"this gives names for too many parts"</span><span class="plain">,</span>
                        <span class="string">"that is, for more parts than there are in the pattern."</span><span class="plain">);</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">j</span><span class="plain"> = 0; </span><span class="identifier">j</span><span class="plain">&lt;</span><span class="identifier">i</span><span class="plain">; </span><span class="identifier">j</span><span class="plain">++)</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::match</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]</span><span class="element">.element_name</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">]</span><span class="element">.element_name</span><span class="plain">))</span>
                        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPRepeatedPartNames</span><span class="plain">),</span>
                            <span class="string">"this repeats a part name"</span><span class="plain">,</span>
                            <span class="string">"that is, it uses the same name for two different parts "</span>
                            <span class="string">"of the pattern."</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">i</span><span class="plain"> &gt; 0) &amp;&amp; (</span><span class="identifier">i</span><span class="plain"> != </span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_elements</span><span class="plain">)) {</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPNotAllNamed</span><span class="plain">),</span>
                    <span class="string">"you must supply names for all the parts"</span><span class="plain">,</span>
                    <span class="string">"if for any"</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">;</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP34">&#167;34</a>.</p>

    <p class="inwebparagraph"><a id="SP34_14"></a><b>&#167;34.14.  </b>In fact, the test is a simple one: there can be only one element declared
    optional, and it must not be the first.
    </p>


    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Check that any notes to do with optional elements are mutually compatible</span> <span class="cwebmacronumber">34.14</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">opt_count</span><span class="plain"> = 0;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_elements</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]</span><span class="element">.element_optional</span><span class="plain">) {</span>
                <span class="identifier">opt_count</span><span class="plain">++;</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain"> == 0) {</span>
                    <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPFirstOptional</span><span class="plain">),</span>
                        <span class="string">"the first part is not allowed to be optional"</span><span class="plain">,</span>
                        <span class="string">"since it is needed to identify the value."</span><span class="plain">);</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">opt_count</span><span class="plain"> &gt;= 2) {</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPMultipleOptional</span><span class="plain">),</span>
                    <span class="string">"only one part can be called optional"</span><span class="plain">,</span>
                    <span class="string">"since if any part is omitted then so are all subsequent parts."</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">owner</span><span class="plain">;</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP34">&#167;34</a>.</p>

    <p class="inwebparagraph"><a id="SP38"></a><b>&#167;38.  </b>Group names are created when first seen (in production (d)
    of &lt;literal-pattern-group&gt;): the following recognises one which has been
    seen before.
    </p>


    <pre class="display">
        <span class="plain">&lt;</span><span class="identifier">literal</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">group</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
            <span class="reserved">literal_pattern_name</span><span class="plain"> *</span><span class="identifier">lpn</span><span class="plain">;</span>
            <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">lpn</span><span class="plain">, </span><span class="reserved">literal_pattern_name</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::match</span><span class="plain">(</span><span class="identifier">lpn</span><span class="plain">-</span><span class="element">&gt;notation_name</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)) {</span>
                    <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">lpn</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="inwebparagraph"><a id="SP39"></a><b>&#167;39.  </b>And this is the routine which does the creation. The text will actually be
    empty where there's an existing literal pattern name. (For instance, each
    time we see a literal pattern given as "in Imperial units", we create a
    fresh LPN structure, but only the first one to be created contains the
    wording.)
    </p>


    <pre class="display">
        <span class="reserved">literal_pattern_name</span><span class="plain"> *</span><span class="functiontext">LiteralPatterns::new_lpn</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">literal_pattern_name</span><span class="plain"> *</span><span class="identifier">existing</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">preform_lookahead_mode</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">literal_pattern_name</span><span class="plain"> *</span><span class="identifier">new</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">literal_pattern_name</span><span class="plain">);</span>
            <span class="identifier">new</span><span class="plain">-</span><span class="element">&gt;notation_name</span><span class="plain"> = </span><span class="identifier">W</span><span class="plain">;</span>
            <span class="identifier">new</span><span class="plain">-</span><span class="element">&gt;can_use_this_lp</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="identifier">new</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="identifier">new</span><span class="plain">-</span><span class="element">&gt;next_with_rp</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">existing</span><span class="plain">) {</span>
                <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">existing</span><span class="plain">) &amp;&amp; (</span><span class="identifier">existing</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)) </span><span class="identifier">existing</span><span class="plain"> = </span><span class="identifier">existing</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
                <span class="identifier">existing</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">new</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">new</span><span class="plain">;</span>
        <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">The function LiteralPatterns::new_lpn is used in <a href="#SP35">&#167;35</a>.</p>

    <p class="inwebparagraph"><a id="SP40"></a><b>&#167;40. I7 phrases to print values in specified ways. </b>When an LP has a name, it's a notation which the source text can request
    to be used in saying a value. This is where the corresponding text substitutions
    are declared.
    </p>


    <pre class="display">
        <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::define_named_phrases</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
            <span class="reserved">literal_pattern_name</span><span class="plain"> *</span><span class="identifier">lpn</span><span class="plain">;</span>
            <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">lpn</span><span class="plain">, </span><span class="reserved">literal_pattern_name</span><span class="plain">)</span>
                <span class="identifier">lpn</span><span class="plain">-</span><span class="element">&gt;lpn_compiled_already</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">lpn</span><span class="plain">, </span><span class="reserved">literal_pattern_name</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">lpn</span><span class="plain">-</span><span class="element">&gt;notation_name</span><span class="plain">)) {</span>
                    <span class="reserved">literal_pattern_name</span><span class="plain"> *</span><span class="identifier">lpn2</span><span class="plain">;</span>
                    <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lpn2</span><span class="plain"> = </span><span class="identifier">lpn</span><span class="plain">; </span><span class="identifier">lpn2</span><span class="plain">; </span><span class="identifier">lpn2</span><span class="plain"> = </span><span class="identifier">lpn2</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lpn2</span><span class="plain">-</span><span class="element">&gt;lpn_compiled_already</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)</span>
                            &lt;<span class="cwebmacro">Compile the printing phrase for this and perhaps subsequent LPs</span> <span class="cwebmacronumber">40.1</span>&gt;<span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="functiontext">Sentences::RuleSubtrees::register_recently_lexed_phrases</span><span class="plain">();</span>
        <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">The function LiteralPatterns::define_named_phrases is used in 1/mr (<a href="1-mr.html#SP4_14">&#167;4.14</a>).</p>

    <p class="inwebparagraph"><a id="SP40_1"></a><b>&#167;40.1.  </b>These text substitutions correspond exactly neither to the LPs nor to the
    names. For instance, "in tonnes" produces a text substitution which takes
    in both the LP for "1 tonne" and for "2 tonnes", deciding at run-time
    which to use. And on the other hand, "in metric units" may produce text
    substitutions for many different kinds, distinguished by type-checking:
    </p>

    <blockquote>
        <p>To say (val - mass) in metric units: ...</p>

    </blockquote>

    <blockquote>
        <p>To say (val - length) in metric units: ...</p>

    </blockquote>

    <p class="inwebparagraph">The following creates one text substitution for each different kind among
    the LPs under each named possibility.
    </p>


    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Compile the printing phrase for this and perhaps subsequent LPs</span> <span class="cwebmacronumber">40.1</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">lpn2</span><span class="plain">-</span><span class="element">&gt;can_use_this_lp</span><span class="plain">-</span><span class="element">&gt;kind_specified</span><span class="plain">;</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">TEMP</span><span class="plain">);</span>
            <span class="identifier">Kinds::Textual::write</span><span class="plain">(</span><span class="identifier">TEMP</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">);</span>

            <span class="identifier">feed_t</span><span class="plain"> </span><span class="identifier">id</span><span class="plain"> = </span><span class="identifier">Feeds::begin</span><span class="plain">();</span>
            <span class="identifier">Feeds::feed_text</span><span class="plain">(</span><span class="identifier">L</span><span class="string">"To say ( val - "</span><span class="plain">);</span>
            <span class="identifier">Feeds::feed_stream</span><span class="plain">(</span><span class="identifier">TEMP</span><span class="plain">);</span>
            <span class="identifier">Feeds::feed_text</span><span class="plain">(</span><span class="identifier">L</span><span class="string">" ) "</span><span class="plain">);</span>
            <span class="identifier">Feeds::feed_wording</span><span class="plain">(</span><span class="identifier">lpn</span><span class="plain">-</span><span class="element">&gt;notation_name</span><span class="plain">);</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">Feeds::end</span><span class="plain">(</span><span class="identifier">id</span><span class="plain">);</span>
            <span class="identifier">Sentences::make_node</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">, </span><span class="character">':'</span><span class="plain">);</span>

            <span class="identifier">id</span><span class="plain"> = </span><span class="identifier">Feeds::begin</span><span class="plain">();</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">);</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">, </span><span class="string">" (- {-printing-routine:%S"</span><span class="plain">, </span><span class="identifier">TEMP</span><span class="plain">);</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">, </span><span class="string">"}({val}, %d); -) "</span><span class="plain">, </span><span class="identifier">lpn</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain"> + 1);</span>
            <span class="identifier">Feeds::feed_stream</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">);</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">);</span>
            <span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">Feeds::end</span><span class="plain">(</span><span class="identifier">id</span><span class="plain">);</span>
            <span class="identifier">Sentences::make_node</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">, </span><span class="character">'.'</span><span class="plain">);</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">TEMP</span><span class="plain">);</span>

            <span class="reserved">literal_pattern_name</span><span class="plain"> *</span><span class="identifier">lpn3</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">lpn3</span><span class="plain"> = </span><span class="identifier">lpn2</span><span class="plain">; </span><span class="identifier">lpn3</span><span class="plain">; </span><span class="identifier">lpn3</span><span class="plain"> = </span><span class="identifier">lpn3</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::eq</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">lpn3</span><span class="plain">-</span><span class="element">&gt;can_use_this_lp</span><span class="plain">-</span><span class="element">&gt;kind_specified</span><span class="plain">))</span>
                    <span class="identifier">lpn3</span><span class="plain">-</span><span class="element">&gt;lpn_compiled_already</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP40">&#167;40</a>.</p>

    <p class="inwebparagraph"><a id="SP41"></a><b>&#167;41. I7 phrases to pack and unpack the value. </b>Creating a LP implicitly defines further I7 source text, as follows.
    </p>


    <pre class="display">
        <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::define_packing_phrases</span><span class="plain">(</span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">TEMP</span><span class="plain">);</span>
            <span class="identifier">Kinds::Textual::write</span><span class="plain">(</span><span class="identifier">TEMP</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">);</span>
            &lt;<span class="cwebmacro">Define phrases to convert from a packed value to individual parts</span> <span class="cwebmacronumber">41.1</span>&gt;<span class="plain">;</span>
            &lt;<span class="cwebmacro">Define a phrase to convert from numerical parts to a packed value</span> <span class="cwebmacronumber">41.2</span>&gt;<span class="plain">;</span>
            <span class="functiontext">Sentences::RuleSubtrees::register_recently_lexed_phrases</span><span class="plain">();</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">TEMP</span><span class="plain">);</span>
        <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">The function LiteralPatterns::define_packing_phrases is used in <a href="#SP34">&#167;34</a>.</p>

    <p class="inwebparagraph"><a id="SP41_1"></a><b>&#167;41.1.  </b>First, we automatically create n phrases to unpack the elements given the value.
    For instance, defining:
    </p>

    <blockquote>
        <p>\$10.99 specifies a price with parts dollars and cents.</p>

    </blockquote>

    <p class="inwebparagraph">automatically generates:
    </p>

    <blockquote>
        <p>To define which number is dollars part of ( full - price ) :</p>

    </blockquote>

    <p class="inwebparagraph">		<code class="display"><span class="extract">(- ({full}/100) -)</span></code>.
    </p>

    <blockquote>
        <p>To define which number is cents part of ( full - price ) :</p>

    </blockquote>

    <p class="inwebparagraph">		<code class="display"><span class="extract">(- ({full}%100) -)</span></code>.
    </p>


    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Define phrases to convert from a packed value to individual parts</span> <span class="cwebmacronumber">41.1</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_elements</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) {</span>
                <span class="reserved">literal_pattern_element</span><span class="plain"> *</span><span class="identifier">lpe</span><span class="plain"> = &amp;(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]);</span>

                <span class="identifier">feed_t</span><span class="plain"> </span><span class="identifier">id</span><span class="plain"> = </span><span class="identifier">Feeds::begin</span><span class="plain">();</span>
                <span class="identifier">Feeds::feed_text</span><span class="plain">(</span><span class="identifier">L</span><span class="string">"To decide which number is "</span><span class="plain">);</span>
                <span class="identifier">Feeds::feed_wording</span><span class="plain">(</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_name</span><span class="plain">);</span>
                <span class="identifier">Feeds::feed_text</span><span class="plain">(</span><span class="identifier">L</span><span class="string">" part of ( full - "</span><span class="plain">);</span>
                <span class="identifier">Feeds::feed_stream</span><span class="plain">(</span><span class="identifier">TEMP</span><span class="plain">);</span>
                <span class="identifier">Feeds::feed_text</span><span class="plain">(</span><span class="identifier">L</span><span class="string">" ) "</span><span class="plain">);</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">Feeds::end</span><span class="plain">(</span><span class="identifier">id</span><span class="plain">);</span>
                <span class="identifier">Sentences::make_node</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">, </span><span class="character">':'</span><span class="plain">);</span>

                <span class="identifier">id</span><span class="plain"> = </span><span class="identifier">Feeds::begin</span><span class="plain">();</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">==0)</span>
                    <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">, </span><span class="string">" (- ({full}/%d) -) "</span><span class="plain">, </span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_multiplier</span><span class="plain">);</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_multiplier</span><span class="plain"> &gt; 1)</span>
                    <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">, </span><span class="string">" (- (({full}/%d)%%%d) -) "</span><span class="plain">,</span>
                        <span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_multiplier</span><span class="plain">, </span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_range</span><span class="plain">);</span>
                <span class="reserved">else</span>
                    <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">, </span><span class="string">" (- ({full}%%%d) -) "</span><span class="plain">, </span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_range</span><span class="plain">);</span>
                <span class="identifier">Feeds::feed_stream</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">);</span>
                <span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">Feeds::end</span><span class="plain">(</span><span class="identifier">id</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::phrasual_length</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">) &gt;= </span><span class="constant">MAX_WORDS_PER_PHRASE</span><span class="plain"> + 5)</span>
                    &lt;<span class="cwebmacro">Issue a problem for overly long part names</span> <span class="cwebmacronumber">41.1.1</span>&gt;
                <span class="reserved">else</span>
                    <span class="identifier">Sentences::make_node</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">, </span><span class="character">'.'</span><span class="plain">);</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">);</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP41">&#167;41</a>.</p>

    <p class="inwebparagraph"><a id="SP41_2"></a><b>&#167;41.2.  </b>And similarly, a packing phrase to calculate the value given its elements.
    For instance, the dollars-and-cents example compiles:
    </p>

    <blockquote>
        <p>To decide which price is price with dollars part ( part0 - a number ) cents part ( part1 - a number) :</p>

    </blockquote>

    <p class="inwebparagraph">		<code class="display"><span class="extract">(- ({part0}*100+{part1}) -).</span></code>
    </p>


    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Define a phrase to convert from numerical parts to a packed value</span> <span class="cwebmacronumber">41.2</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_elements</span><span class="plain"> &gt; 0) {</span>
                <span class="identifier">feed_t</span><span class="plain"> </span><span class="identifier">id</span><span class="plain"> = </span><span class="identifier">Feeds::begin</span><span class="plain">();</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">);</span>
                <span class="identifier">Feeds::feed_text</span><span class="plain">(</span><span class="identifier">L</span><span class="string">"To decide which "</span><span class="plain">);</span>
                <span class="identifier">Feeds::feed_stream</span><span class="plain">(</span><span class="identifier">TEMP</span><span class="plain">);</span>
                <span class="identifier">Feeds::feed_text</span><span class="plain">(</span><span class="identifier">L</span><span class="string">" is "</span><span class="plain">);</span>
                <span class="identifier">Feeds::feed_stream</span><span class="plain">(</span><span class="identifier">TEMP</span><span class="plain">);</span>
                <span class="identifier">Feeds::feed_text</span><span class="plain">(</span><span class="identifier">L</span><span class="string">" with "</span><span class="plain">);</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_elements</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) {</span>
                    <span class="reserved">literal_pattern_element</span><span class="plain"> *</span><span class="identifier">lpe</span><span class="plain"> = &amp;(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]);</span>
                    <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">, </span><span class="string">" part%d "</span><span class="plain">, </span><span class="identifier">i</span><span class="plain">);</span>
                    <span class="identifier">Feeds::feed_wording</span><span class="plain">(</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_name</span><span class="plain">);</span>
                    <span class="identifier">Feeds::feed_text</span><span class="plain">(</span><span class="identifier">L</span><span class="string">" part ( "</span><span class="plain">);</span>
                    <span class="identifier">Feeds::feed_stream</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">);</span>
                    <span class="identifier">Feeds::feed_text</span><span class="plain">(</span><span class="identifier">L</span><span class="string">" - a number ) "</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">Feeds::end</span><span class="plain">(</span><span class="identifier">id</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::phrasual_length</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">) &gt;= </span><span class="constant">MAX_WORDS_PER_PHRASE</span><span class="plain"> + 5)</span>
                    &lt;<span class="cwebmacro">Issue a problem for overly long part names</span> <span class="cwebmacronumber">41.1.1</span>&gt;
                <span class="reserved">else</span><span class="plain"> {</span>
                    <span class="identifier">Sentences::make_node</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">, </span><span class="character">':'</span><span class="plain">);</span>
                    <span class="identifier">id</span><span class="plain"> = </span><span class="identifier">Feeds::begin</span><span class="plain">();</span>
                    <span class="identifier">Str::clear</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">);</span>
                    <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">, </span><span class="string">" (- ("</span><span class="plain">);</span>
                    <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;no_lp_elements</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) {</span>
                        <span class="reserved">literal_pattern_element</span><span class="plain"> *</span><span class="identifier">lpe</span><span class="plain"> = &amp;(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;lp_elements</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]);</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">&gt;0) </span><span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">, </span><span class="string">"+"</span><span class="plain">);</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_multiplier</span><span class="plain"> != 1)</span>
                            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">, </span><span class="string">"%d*"</span><span class="plain">, </span><span class="identifier">lpe</span><span class="plain">-</span><span class="element">&gt;element_multiplier</span><span class="plain">);</span>
                        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">, </span><span class="string">"{part%d}"</span><span class="plain">, </span><span class="identifier">i</span><span class="plain">);</span>
                    <span class="plain">}</span>
                    <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">, </span><span class="string">") -) "</span><span class="plain">);</span>
                    <span class="identifier">Feeds::feed_stream</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">);</span>
                    <span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">Feeds::end</span><span class="plain">(</span><span class="identifier">id</span><span class="plain">);</span>
                    <span class="identifier">Sentences::make_node</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">, </span><span class="character">'.'</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">print_rule_buff</span><span class="plain">);</span>
            <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP41">&#167;41</a>.</p>

    <p class="inwebparagraph"><a id="SP41_1_1"></a><b>&#167;41.1.1.  </b><code class="display">
    &lt;<span class="cwebmacrodefn">Issue a problem for overly long part names</span> <span class="cwebmacronumber">41.1.1</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPPartNamesTooLong</span><span class="plain">),</span>
                <span class="string">"the names for these parts are too long"</span><span class="plain">,</span>
                <span class="string">"and will have to be cut down."</span><span class="plain">);</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP41_1">&#167;41.1</a>, <a href="#SP41_2">&#167;41.2</a>.</p>

    <p class="inwebparagraph"><a id="SP42"></a><b>&#167;42. The kind's list. </b>On reading "5 feet 4 inches specifies a height", Inform parses
    "5 feet 4 inches" into a <code class="display"><span class="extract">literal_pattern</span></code> structure and then calls this
    routine to attach it to the kind "height". (Multiple patterns can be
    attached to the same kind, and they become alternative syntaxes.)
    </p>


    <pre class="display">
        <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">LiteralPatterns::add_literal_pattern</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">, </span><span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="identifier">lp</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"can't add LP to null kind"</span><span class="plain">);</span>
            <span class="identifier">K</span><span class="plain">-</span><span class="element">&gt;construct</span><span class="plain">-&gt;</span><span class="identifier">ways_to_write_literals</span><span class="plain"> =</span>
                <span class="functiontext">LiteralPatterns::list_add</span><span class="plain">(</span>
                    <span class="identifier">K</span><span class="plain">-</span><span class="element">&gt;construct</span><span class="plain">-&gt;</span><span class="identifier">ways_to_write_literals</span><span class="plain">, </span><span class="identifier">lp</span><span class="plain">,</span>
                    <span class="identifier">Kinds::FloatingPoint::uses_floating_point</span><span class="plain">(</span><span class="identifier">lp</span><span class="plain">-</span><span class="element">&gt;kind_specified</span><span class="plain">));</span>
        <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">The function LiteralPatterns::add_literal_pattern is used in <a href="#SP34">&#167;34</a>.</p>

    <p class="inwebparagraph"><a id="SP43"></a><b>&#167;43.  </b>And here we find the list of such notations.
    </p>


    <pre class="display">
        <span class="reserved">literal_pattern</span><span class="plain"> *</span><span class="functiontext">LiteralPatterns::list_of_literal_forms</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">K</span><span class="plain">-</span><span class="element">&gt;construct</span><span class="plain">-&gt;</span><span class="identifier">ways_to_write_literals</span><span class="plain">;</span>
        <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">The function LiteralPatterns::list_of_literal_forms is used in <a href="#SP2">&#167;2</a>, <a href="#SP34">&#167;34</a>, 13/rsfk (<a href="13-rsfk.html#SP24_2">&#167;24.2</a>), 13/ki (<a href="13-ki.html#SP1_8">&#167;1.8</a>, <a href="13-ki.html#SP5_1_1">&#167;5.1.1</a>).</p>

    <hr class="tocbar">
    <ul class="toc"><li><i>(This section begins Chapter 5: Nouns.)</i></li><li><a href="5-tod.html">Continue with 'Times of Day'</a></li></ul><hr class="tocbar">
    <!--End of weave-->
    	</body>
    </html>

