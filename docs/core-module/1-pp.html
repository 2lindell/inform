<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>1/cm</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '1/pp' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#1">Chapter 1: Configuration and Control</a></li><li><b>Progress Percentages</b></li></ul><p class="purpose">This tiny section, the Lichtenstein of Inform, prints percentage of completion estimates onto |stderr| so that the host application can intercept them and update its graphical progress bar.</p>

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1.  </b>Clearly we can only estimate how far Inform has progressed. While we could in
principle measure the number of CPU-seconds it has run for, we don't know
how many more it will need. Instead, we rely on experience to suggest that
its run can be broken down into the following five stages, which a given
percentage of time spent in each stage: thus, for instance, semantic
analysis takes up about ten percent of every run in which problems do
not cause an early halt. Within each stage, we have a reasonable measure
of how far we have got: what proportion of the phrases have been compiled,
for instance, tells us how far "generating code" has got. The result is
that (if the relevant command line setting has been set, so that
<code class="display"><span class="extract">show_progress_indicator</span></code> is true) Inform prints about thirty lines like this
one to <code class="display"><span class="extract">stderr</span></code>:
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">++ 32% (Binding rulebooks)</span></code>
</p>

<p class="inwebparagraph">The Inform application can intercept and parse these lines to display a
progress bar with a rubric beneath it.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">last_progress_pc</span><span class="plain"> = -100;</span>
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">progress_stage_from</span><span class="plain">[] = { 0, 5, 15, 20, 40, 100 };</span>
    <span class="reserved">char</span><span class="plain"> *</span><span class="identifier">progress_stage_name</span><span class="plain">[] = {</span>
        <span class="string">"Reading text"</span><span class="plain">,</span>
        <span class="string">"Analysing sentences"</span><span class="plain">,</span>
        <span class="string">"Drawing inferences"</span><span class="plain">,</span>
        <span class="string">"Binding rulebooks"</span><span class="plain">,</span>
        <span class="string">"Generating code"</span>
    <span class="plain">};</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ProgressBar::update_progress_bar</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">stage</span><span class="plain">, </span><span class="reserved">float</span><span class="plain"> </span><span class="identifier">proportion</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">r1</span><span class="plain"> = </span><span class="identifier">progress_stage_from</span><span class="plain">[</span><span class="identifier">stage</span><span class="plain">], </span><span class="identifier">r2</span><span class="plain"> = </span><span class="identifier">progress_stage_from</span><span class="plain">[</span><span class="identifier">stage</span><span class="plain">+1];</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">pc</span><span class="plain"> = </span><span class="identifier">r1</span><span class="plain"> + ((</span><span class="reserved">int</span><span class="plain">) (</span><span class="identifier">proportion</span><span class="plain">*(</span><span class="identifier">r2</span><span class="plain">-</span><span class="identifier">r1</span><span class="plain">)));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">show_progress_indicator</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pc</span><span class="plain">-</span><span class="identifier">last_progress_pc</span><span class="plain"> &lt; 3) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">STDERR</span><span class="plain">, </span><span class="string">"++ %d%% (%s)\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">pc</span><span class="plain">, </span><span class="identifier">progress_stage_name</span><span class="plain">[</span><span class="identifier">stage</span><span class="plain">]);</span>
        <span class="identifier">STREAM_FLUSH</span><span class="plain">(</span><span class="identifier">STDERR</span><span class="plain">);</span>
        <span class="identifier">last_progress_pc</span><span class="plain"> = </span><span class="identifier">pc</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ProgressBar::final_state_of_progress_bar</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">show_progress_indicator</span><span class="plain">) {</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">STDERR</span><span class="plain">, </span><span class="string">"++ 100%% (Finishing work)\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
            <span class="identifier">STREAM_FLUSH</span><span class="plain">(</span><span class="identifier">STDERR</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ProgressBar::update_progress_bar is used in 1/mr (<a href="1-mr.html#SP4_8">&#167;4.8</a>, <a href="1-mr.html#SP4_9">&#167;4.9</a>, <a href="1-mr.html#SP4_10">&#167;4.10</a>, <a href="1-mr.html#SP4_13">&#167;4.13</a>, <a href="1-mr.html#SP4_14">&#167;4.14</a>), 22/cs (<a href="22-cs.html#SP4">&#167;4</a>), 22/ph (<a href="22-ph.html#SP12_1">&#167;12.1</a>).</p>

<p class="endnote">The function ProgressBar::final_state_of_progress_bar is used in 2/up (<a href="2-up.html#SP2_3">&#167;2.3</a>).</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>Finally, the following sends a pithy summary back to the app to use as
a final status indicator.
</p>


<pre class="display">
    <span class="identifier">text_stream</span><span class="plain"> *</span><span class="functiontext">ProgressBar::begin_outcome</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">show_progress_indicator</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">STDERR</span><span class="plain">, </span><span class="string">"++ Ended: "</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">STDERR</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ProgressBar::end_outcome</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">show_progress_indicator</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">STDERR</span><span class="plain">, </span><span class="string">"\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
        <span class="identifier">STREAM_FLUSH</span><span class="plain">(</span><span class="identifier">STDERR</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ProgressBar::begin_outcome is used in 2/up (<a href="2-up.html#SP2_2">&#167;2.2</a>, <a href="2-up.html#SP2_3">&#167;2.3</a>).</p>

<p class="endnote">The function ProgressBar::end_outcome is used in 2/up (<a href="2-up.html#SP2_2">&#167;2.2</a>, <a href="2-up.html#SP2_3">&#167;2.3</a>).</p>

<hr class="tocbar">
<ul class="toc"><li><a href="1-cm.html">Back to 'Core Module'</a></li><li><a href="1-wel.html">Continue with 'Where Everything Lives'</a></li></ul><hr class="tocbar">
<!--End of weave: 68 lines from a web of 94125-->
	</body>
</html>

