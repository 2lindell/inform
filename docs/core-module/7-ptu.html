<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>6/nv</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '7/ptu' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#7">Chapter 7: Sentences</a></li><li><b>Parse Tree Usage</b></li></ul><p class="purpose">Shims for the parse tree.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP16">&#167;16. The assertion-maker's invariant</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>Access routines will be needed for some of these, and the following
constructs them:
</p>


<pre class="display">
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">adjectival_phrase</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">condition_tense</span><span class="plain">, </span><span class="identifier">time_period</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_activity</span><span class="plain">,</span><span class="reserved"> activity</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_binary_predicate</span><span class="plain">, </span><span class="reserved">binary_predicate</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_constant_phrase</span><span class="plain">, </span><span class="reserved">constant_phrase</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_equation</span><span class="plain">, </span><span class="reserved">equation</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_instance</span><span class="plain">, </span><span class="reserved">instance</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_local_variable</span><span class="plain">, </span><span class="reserved">local_variable</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_named_rulebook_outcome</span><span class="plain">, </span><span class="reserved">named_rulebook_outcome</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_nonlocal_variable</span><span class="plain">, </span><span class="reserved">nonlocal_variable</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_property</span><span class="plain">, </span><span class="reserved">property</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_rule</span><span class="plain">, </span><span class="reserved">rule</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_rulebook</span><span class="plain">, </span><span class="reserved">rulebook</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_table_column</span><span class="plain">, </span><span class="reserved">table_column</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_table</span><span class="plain">, </span><span class="reserved">table</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_text</span><span class="plain">, </span><span class="identifier">text_stream</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_use_option</span><span class="plain">, </span><span class="reserved">use_option</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_verb_form</span><span class="plain">, </span><span class="identifier">verb_form</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">control_structure_used</span><span class="plain">, </span><span class="reserved">control_structure_phrase</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">creation_proposition</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">defn_language</span><span class="plain">, </span><span class="reserved">natural_language</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">embodying_heading</span><span class="plain">, </span><span class="reserved">heading</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">end_control_structure_used</span><span class="plain">, </span><span class="reserved">control_structure_phrase</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">evaluation</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">explicit_vh</span><span class="plain">, </span><span class="identifier">value_holster</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">grammar_token_relation</span><span class="plain">, </span><span class="reserved">binary_predicate</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">grammar_value</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">implicit_in_creation_of</span><span class="plain">, </span><span class="reserved">inference_subject</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">interpretation_of_subject</span><span class="plain">, </span><span class="reserved">inference_subject</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">kind_of_new_variable</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">kind_of_value</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">kind_required_by_context</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">kind_resulting</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">kind_variable_declarations</span><span class="plain">, </span><span class="identifier">kind_variable_declaration</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">explicit_iname</span><span class="plain">, </span><span class="identifier">inter_name</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">modal_verb</span><span class="plain">, </span><span class="identifier">verb_conjugation</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">module</span><span class="plain">, </span><span class="identifier">compilation_module</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">new_relation_here</span><span class="plain">, </span><span class="reserved">binary_predicate</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">phrase_invoked</span><span class="plain">, </span><span class="reserved">phrase</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">phrase_options_invoked</span><span class="plain">, </span><span class="reserved">invocation_options</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">proposition</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">prep</span><span class="plain">, </span><span class="identifier">preposition_identity</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">quant</span><span class="plain">, </span><span class="identifier">quantifier</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">relationship</span><span class="plain">, </span><span class="reserved">binary_predicate</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">say_adjective</span><span class="plain">, </span><span class="identifier">adjectival_phrase</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">say_verb</span><span class="plain">, </span><span class="identifier">verb_conjugation</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">subject_term</span><span class="plain">, </span><span class="reserved">pcalc_term</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">subject</span><span class="plain">, </span><span class="reserved">inference_subject</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">token_as_parsed</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">token_check_to_do</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">token_to_be_parsed_against</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain">)</span>
    <span class="identifier">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">, </span><span class="identifier">verb_usage</span><span class="plain">)</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>So we itemise the pointer-valued annotations below, and the macro expands
to provide their get and set functions:
</p>


<pre class="display">
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">adjectival_phrase</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">condition_tense</span><span class="plain">, </span><span class="identifier">time_period</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_activity</span><span class="plain">,</span><span class="reserved"> activity</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_binary_predicate</span><span class="plain">, </span><span class="reserved">binary_predicate</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_constant_phrase</span><span class="plain">, </span><span class="reserved">constant_phrase</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_equation</span><span class="plain">, </span><span class="reserved">equation</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_instance</span><span class="plain">, </span><span class="reserved">instance</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_local_variable</span><span class="plain">, </span><span class="reserved">local_variable</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_named_rulebook_outcome</span><span class="plain">, </span><span class="reserved">named_rulebook_outcome</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_nonlocal_variable</span><span class="plain">, </span><span class="reserved">nonlocal_variable</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_property</span><span class="plain">, </span><span class="reserved">property</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_rule</span><span class="plain">, </span><span class="reserved">rule</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_rulebook</span><span class="plain">, </span><span class="reserved">rulebook</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_table_column</span><span class="plain">, </span><span class="reserved">table_column</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_table</span><span class="plain">, </span><span class="reserved">table</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_text</span><span class="plain">, </span><span class="identifier">text_stream</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_use_option</span><span class="plain">, </span><span class="reserved">use_option</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">constant_verb_form</span><span class="plain">, </span><span class="identifier">verb_form</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">control_structure_used</span><span class="plain">, </span><span class="reserved">control_structure_phrase</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">creation_proposition</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">defn_language</span><span class="plain">, </span><span class="reserved">natural_language</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">embodying_heading</span><span class="plain">, </span><span class="reserved">heading</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">end_control_structure_used</span><span class="plain">, </span><span class="reserved">control_structure_phrase</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">evaluation</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">explicit_vh</span><span class="plain">, </span><span class="identifier">value_holster</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">grammar_token_relation</span><span class="plain">, </span><span class="reserved">binary_predicate</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">grammar_value</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">implicit_in_creation_of</span><span class="plain">, </span><span class="reserved">inference_subject</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">interpretation_of_subject</span><span class="plain">, </span><span class="reserved">inference_subject</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">kind_of_new_variable</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">kind_of_value</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">kind_required_by_context</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">kind_resulting</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">kind_variable_declarations</span><span class="plain">, </span><span class="identifier">kind_variable_declaration</span><span class="plain">)</span>
    <span class="comment">see codegen module for (explicit_iname, inter_name)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">modal_verb</span><span class="plain">, </span><span class="identifier">verb_conjugation</span><span class="plain">)</span>
    <span class="comment">see codegen module for (module, compilation_module)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">new_relation_here</span><span class="plain">, </span><span class="reserved">binary_predicate</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">phrase_invoked</span><span class="plain">, </span><span class="reserved">phrase</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">phrase_options_invoked</span><span class="plain">, </span><span class="reserved">invocation_options</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">proposition</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">prep</span><span class="plain">, </span><span class="identifier">preposition_identity</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">quant</span><span class="plain">, </span><span class="identifier">quantifier</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">relationship</span><span class="plain">, </span><span class="reserved">binary_predicate</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">say_adjective</span><span class="plain">, </span><span class="identifier">adjectival_phrase</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">say_verb</span><span class="plain">, </span><span class="identifier">verb_conjugation</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">subject_term</span><span class="plain">, </span><span class="reserved">pcalc_term</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">subject</span><span class="plain">, </span><span class="reserved">inference_subject</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">token_as_parsed</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">token_check_to_do</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">token_to_be_parsed_against</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain">)</span>
    <span class="identifier">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">, </span><span class="identifier">verb_usage</span><span class="plain">)</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">PARSE_TREE_COPIER</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::copy_annotations</span>
</pre>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::copy_annotations</span><span class="plain">(</span><span class="identifier">parse_node_annotation</span><span class="plain"> *</span><span class="identifier">to</span><span class="plain">, </span><span class="identifier">parse_node_annotation</span><span class="plain"> *</span><span class="identifier">from</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">from</span><span class="plain">-&gt;</span><span class="identifier">kind_of_annotation</span><span class="plain"> == </span><span class="constant">proposition_ANNOT</span><span class="plain">)</span>
            <span class="identifier">to</span><span class="plain">-&gt;</span><span class="identifier">annotation_pointer</span><span class="plain"> =</span>
                <span class="identifier">STORE_POINTER_pcalc_prop</span><span class="plain">(</span>
                    <span class="functiontext">Calculus::Propositions::copy</span><span class="plain">(</span>
                        <span class="identifier">RETRIEVE_POINTER_pcalc_prop</span><span class="plain">(</span>
                            <span class="identifier">from</span><span class="plain">-&gt;</span><span class="identifier">annotation_pointer</span><span class="plain">)));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ParseTreeUsage::copy_annotations appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">enum</span> <span class="constant">BIBLIOGRAPHIC_NT</span><span class="plain">     			</span>    <span class="comment">For the initial title sentence</span>
    <span class="definitionkeyword">enum</span> <span class="constant">ROUTINE_NT</span><span class="plain">           			</span>    <span class="comment">"Instead of taking something, ..."</span>
    <span class="definitionkeyword">enum</span> <span class="constant">INFORM6CODE_NT</span><span class="plain">       			</span>    <span class="comment">"Include (- ... -)</span>
    <span class="definitionkeyword">enum</span> <span class="constant">TABLE_NT</span><span class="plain">             			</span>    <span class="comment">"Table 1 - Counties of England"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">EQUATION_NT</span><span class="plain">          			</span>    <span class="comment">"Equation 2 - Newton's Second Law"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">TRACE_NT</span><span class="plain">             			</span>    <span class="comment">A sentence consisting of an asterisk and optional quoted text</span>
    <span class="definitionkeyword">enum</span> <span class="constant">ALLOWED_NT</span><span class="plain">           			</span>    <span class="comment">"An animal is allowed to have a description"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">EVERY_NT</span><span class="plain">             			</span>    <span class="comment">"every container"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">COMMON_NOUN_NT</span><span class="plain">       			</span>    <span class="comment">"a container"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">ACTION_NT</span><span class="plain">            			</span>    <span class="comment">"taking something closed"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">ADJECTIVE_NT</span><span class="plain">         			</span>    <span class="comment">"open"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">PROPERTYCALLED_NT</span><span class="plain">    			</span>    <span class="comment">"A man has a number called age"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">X_OF_Y_NT</span><span class="plain">            			</span>    <span class="comment">"description of the painting"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">CREATED_NT</span><span class="plain">           			</span>    <span class="comment">"a vehicle called Sarah Jane's car"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">TOKEN_NT</span><span class="plain">             			</span>    <span class="comment">Used for tokens in grammar</span>
    <span class="definitionkeyword">enum</span> <span class="constant">CODE_BLOCK_NT</span><span class="plain">       			</span>    <span class="comment">Holds a block of source material</span>
    <span class="definitionkeyword">enum</span> <span class="constant">INVOCATION_LIST_NT</span><span class="plain">   		    </span>    <span class="comment">Single invocation of a (possibly compound) phrase</span>
    <span class="definitionkeyword">enum</span> <span class="constant">INVOCATION_LIST_SAY_NT</span><span class="plain">		</span>    <span class="comment">Single thing to be said</span>
    <span class="definitionkeyword">enum</span> <span class="constant">INVOCATION_NT</span><span class="plain">      			</span>    <span class="comment">Usage of a phrase</span>
    <span class="definitionkeyword">enum</span> <span class="constant">VOID_CONTEXT_NT</span><span class="plain">  				</span>    <span class="comment">When a void phrase is required</span>
    <span class="definitionkeyword">enum</span> <span class="constant">RVALUE_CONTEXT_NT</span><span class="plain">  			</span>    <span class="comment">Arguments, in effect</span>
    <span class="definitionkeyword">enum</span> <span class="constant">LVALUE_CONTEXT_NT</span><span class="plain"> 			</span>    <span class="comment">Named storage location</span>
    <span class="definitionkeyword">enum</span> <span class="constant">LVALUE_TR_CONTEXT_NT</span><span class="plain"> 			</span>    <span class="comment">Table reference</span>
    <span class="definitionkeyword">enum</span> <span class="constant">SPECIFIC_RVALUE_CONTEXT_NT</span><span class="plain"> 	</span>    <span class="comment">Argument must be an exact value</span>
    <span class="definitionkeyword">enum</span> <span class="constant">MATCHING_RVALUE_CONTEXT_NT</span><span class="plain"> 	</span>    <span class="comment">Argument must match a description</span>
    <span class="definitionkeyword">enum</span> <span class="constant">NEW_LOCAL_CONTEXT_NT</span><span class="plain">			</span>    <span class="comment">Argument which creates a local</span>
    <span class="definitionkeyword">enum</span> <span class="constant">LVALUE_LOCAL_CONTEXT_NT</span><span class="plain">		</span>    <span class="comment">Argument which names a local</span>
    <span class="definitionkeyword">enum</span> <span class="constant">CONDITION_CONTEXT_NT</span><span class="plain">          </span>    <span class="comment">Used for "now" conditions</span>
</pre>
<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>Next we enumerate the specification node types, beginning with the one which
signifies that text has no known meaning &mdash; either because we tried to make
sense of it and failed, or because we are choosing not to parse it until
later on, and are representing it as unknown until then.
</p>


<pre class="definitions">
    <span class="definitionkeyword">enum</span> <span class="constant">UNKNOWN_NT</span><span class="plain">					</span>    <span class="comment">"arfle barfle gloop"</span>
</pre>
<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>The next specification nodes are the rvalues. These express I6 values &mdash;
numbers, objects, text and so on &mdash; but cannot be assigned to, so that in an
assignment of the form "change L to R" they can be used only as R, not L. This
is not the same thing as a constant: for instance, "location of the player"
evaluates differently at different times, but cannot be changed in an
assignment.
</p>


<pre class="definitions">
    <span class="definitionkeyword">enum</span> <span class="constant">CONSTANT_NT</span><span class="plain">					</span>    <span class="comment">"7", "the can't lock a locked door rule", etc.</span>
    <span class="definitionkeyword">enum</span> <span class="constant">PHRASE_TO_DECIDE_VALUE_NT</span><span class="plain">		</span>    <span class="comment">"holder of the black box"</span>
</pre>
<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>Lvalue nodes represent stored I6 data at run-time, which means that they can
be assigned to. (The traditional terms "lvalue" and "rvalue" refer to the left
and right hand side of assignment statements written <code class="display"><span class="extract">A = B</span></code>.) For instance, a
table entry qualifies as an lvalue because it can be both read and changed. To
qualify as an lvalue, text must exactly specify the storage location referred
to: "Table of Corvettes" only indicates a table, not an entry in a table, so
is merely an rvalue. Similarly, "carrying capacity" (as a property name not
indicating an owner) is a mere rvalue.
</p>


<pre class="definitions">
    <span class="definitionkeyword">enum</span> <span class="constant">LOCAL_VARIABLE_NT</span><span class="plain">				</span>    <span class="comment">"the running total", say</span>
    <span class="definitionkeyword">enum</span> <span class="constant">NONLOCAL_VARIABLE_NT</span><span class="plain">			</span>    <span class="comment">"the location"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">PROPERTY_VALUE_NT</span><span class="plain">				</span>    <span class="comment">"the carrying capacity of the cedarwood box"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">TABLE_ENTRY_NT</span><span class="plain">				</span>    <span class="comment">"tonnage in row X of the Table of Corvettes"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">LIST_ENTRY_NT</span><span class="plain">					</span>    <span class="comment">"item 4 in L"</span>
</pre>
<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>Condition nodes represent atomic conditions, and also Boolean operations on
them. It's convenient to represent these operations as nodes in their own right
rather than as (for example) phrases: this reduces parsing ambiguities, but
also makes it easier for us to manipulate the results.
</p>


<pre class="definitions">
    <span class="definitionkeyword">enum</span> <span class="constant">LOGICAL_NOT_NT</span><span class="plain">				</span>    <span class="comment">"not A"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">LOGICAL_TENSE_NT</span><span class="plain">				</span>    <span class="comment">in the past, A</span>
    <span class="definitionkeyword">enum</span> <span class="constant">LOGICAL_AND_NT</span><span class="plain">				</span>    <span class="comment">"A and B"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">LOGICAL_OR_NT</span><span class="plain">					</span>    <span class="comment">"A or B"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">TEST_PROPOSITION_NT</span><span class="plain">			</span>    <span class="comment">if "the cat is on the mat"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">TEST_PHRASE_OPTION_NT</span><span class="plain">			</span>    <span class="comment">"giving full details", say</span>
    <span class="definitionkeyword">enum</span> <span class="constant">TEST_VALUE_NT</span><span class="plain">					</span>    <span class="comment">when a value is used as a condition</span>
</pre>
<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>This is a little like itemising the baubles on a Christmas tree, but here
goes. The annotations used are identified by nonzero ID numbers, as follows:
</p>


<pre class="definitions">
    <span class="definitionkeyword">enum</span> <span class="constant">action_meaning_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">action_pattern</span></code>: meaning in parse tree when used as noun</span>
    <span class="definitionkeyword">enum</span> <span class="constant">aph_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">adjectival_phrase</span></code>: which adjective is asserted</span>
    <span class="definitionkeyword">enum</span> <span class="constant">category_of_I6_translation_ANNOT</span><span class="plain"> </span>    <span class="comment">int: what sort of "translates into I6" sentence this is</span>
    <span class="definitionkeyword">enum</span> <span class="constant">clears_pronouns_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: this sentence erases the current value of "it"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">colon_block_command_ANNOT</span><span class="plain"> </span>    <span class="comment">int: this COMMAND uses the ":" not begin/end syntax</span>
    <span class="definitionkeyword">enum</span> <span class="constant">condition_tense_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">time_period</span></code>: for specification nodes</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_action_name_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">action_name</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_action_pattern_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">action_pattern</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_activity_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">activity</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_binary_predicate_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">binary_predicate</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_constant_phrase_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">constant_phrase</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_enumeration_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: which one from an enumerated kind</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_equation_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">equation</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_grammar_verb_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">grammar_verb</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_instance_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">instance</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_local_variable_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">local_variable</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_named_action_pattern_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">named_action_pattern</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_named_rulebook_outcome_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">named_rulebook_outcome</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_nonlocal_variable_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">nonlocal_variable</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_number_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: which integer this is</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_property_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">property</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_rule_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">rule</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_rulebook_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">rulebook</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_scene_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">scene</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_table_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">table</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_table_column_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">table_column</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_text_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">text_stream</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_use_option_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">use_option</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">constant_verb_form_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">verb_form</span></code>: for constant values</span>
    <span class="definitionkeyword">enum</span> <span class="constant">control_structure_used_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">control_structure_phrase</span></code>: for CODE BLOCK nodes only</span>
    <span class="definitionkeyword">enum</span> <span class="constant">converted_SN_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: marking descriptions</span>
    <span class="definitionkeyword">enum</span> <span class="constant">creation_proposition_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">pcalc_prop</span></code>: proposition which newly created value satisfies</span>
    <span class="definitionkeyword">enum</span> <span class="constant">creation_site_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: whether an instance was created from this node</span>
    <span class="definitionkeyword">enum</span> <span class="constant">defn_language_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">natural_language</span></code>: what language this definition is in</span>
    <span class="definitionkeyword">enum</span> <span class="constant">embodying_heading_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">heading</span></code>: for parse nodes of headings</span>
    <span class="definitionkeyword">enum</span> <span class="constant">end_control_structure_used_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">control_structure_phrase</span></code>: for CODE BLOCK nodes only</span>
    <span class="definitionkeyword">enum</span> <span class="constant">epistemological_status_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: a bitmap of results from checking an ambiguous reading</span>
    <span class="definitionkeyword">enum</span> <span class="constant">evaluation_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">parse_node</span></code>: result of evaluating the text</span>
    <span class="definitionkeyword">enum</span> <span class="constant">examine_for_ofs_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: mark this as a possible site for removing "of" tree breaks</span>
    <span class="definitionkeyword">enum</span> <span class="constant">explicit_iname_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">inter_name</span></code>: is this value explicitly an iname?</span>
    <span class="definitionkeyword">enum</span> <span class="constant">explicit_literal_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: my value is an explicit integer or text</span>
    <span class="definitionkeyword">enum</span> <span class="constant">explicit_vh_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">value_holster</span></code>: used for compiling I6-level properties</span>
    <span class="definitionkeyword">enum</span> <span class="constant">from_text_substitution_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: whether this is an implicit say invocation</span>
    <span class="definitionkeyword">enum</span> <span class="constant">grammar_token_code_ANNOT</span><span class="plain"> </span>    <span class="comment">int: used to identify grammar tokens</span>
    <span class="definitionkeyword">enum</span> <span class="constant">grammar_token_literal_ANNOT</span><span class="plain"> </span>    <span class="comment">int: for grammar tokens which are literal words</span>
    <span class="definitionkeyword">enum</span> <span class="constant">grammar_token_relation_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">binary_predicate</span></code>: for relation tokens</span>
    <span class="definitionkeyword">enum</span> <span class="constant">grammar_value_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">parse_node</span></code>: used as a marker when evaluating Understand grammar</span>
    <span class="definitionkeyword">enum</span> <span class="constant">imperative_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: marking definitions of imperative verbs</span>
    <span class="definitionkeyword">enum</span> <span class="constant">implicit_in_creation_of_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">inference_subject</span></code>: for assemblies</span>
    <span class="definitionkeyword">enum</span> <span class="constant">implicitness_count_ANNOT</span><span class="plain"> </span>    <span class="comment">int: keeping track of recursive assemblies</span>
    <span class="definitionkeyword">enum</span> <span class="constant">indentation_level_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: for routines written with Pythonesque indentation</span>
    <span class="definitionkeyword">enum</span> <span class="constant">interpretation_of_subject_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">inference_subject</span></code>: subject, during passes</span>
    <span class="definitionkeyword">enum</span> <span class="constant">is_phrase_option_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: this unparsed text is a phrase option</span>
    <span class="definitionkeyword">enum</span> <span class="constant">kind_of_new_variable_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">kind</span></code>: what if anything is returned</span>
    <span class="definitionkeyword">enum</span> <span class="constant">kind_of_value_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">kind</span></code>: for specification nodes</span>
    <span class="definitionkeyword">enum</span> <span class="constant">kind_required_by_context_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">kind</span></code>: what if anything is expected here</span>
    <span class="definitionkeyword">enum</span> <span class="constant">kind_resulting_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">kind</span></code>: what if anything is returned</span>
    <span class="definitionkeyword">enum</span> <span class="constant">kind_variable_declarations_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">kind_variable_declaration</span></code>: and of these</span>
    <span class="definitionkeyword">enum</span> <span class="constant">listing_sense_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: are we listing a rule into something, or out of it?</span>
    <span class="definitionkeyword">enum</span> <span class="constant">log_inclusion_sense_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: should we include or exclude this from the debugging log?</span>
    <span class="definitionkeyword">enum</span> <span class="constant">lpe_options_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: options set for a literal pattern part</span>
    <span class="definitionkeyword">enum</span> <span class="constant">modal_verb_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">verb_conjugation</span></code>: relevant only for that: e.g., "might"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">module_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">compilation_module</span></code>: set only for headings, routines and sentences</span>
    <span class="definitionkeyword">enum</span> <span class="constant">multiplicity_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: e.g., 5 for "five gold rings"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">negated_boolean_ANNOT</span><span class="plain"> </span>    <span class="comment">int: set if adjective/verb meant negatively</span>
    <span class="definitionkeyword">enum</span> <span class="constant">new_relation_here_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">binary_predicate</span></code>: new relation as subject of "relates" sentence</span>
    <span class="definitionkeyword">enum</span> <span class="constant">nothing_object_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: this represents <code class="display"><span class="extract">nothing</span></code> at run-time</span>
    <span class="definitionkeyword">enum</span> <span class="constant">nowhere_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: used by the spatial plugin to show this represents "nowhere"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">phrase_invoked_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">phrase</span></code>: the phrase believed to be invoked...</span>
    <span class="definitionkeyword">enum</span> <span class="constant">phrase_option_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: 2^i where i is the option number, 0&lt;= i&lt;16</span>
    <span class="definitionkeyword">enum</span> <span class="constant">phrase_options_invoked_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">invocation_options</span></code>: details of any options used</span>
    <span class="definitionkeyword">enum</span> <span class="constant">property_name_used_as_noun_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: in ambiguous cases such as "open"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">proposition_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">pcalc_prop</span></code>: for specification nodes</span>
    <span class="definitionkeyword">enum</span> <span class="constant">prep_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">preposition_identity</span></code>: for e.g. "is on"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">quant_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">quantifier</span></code>: for quantified excerpts like "three baskets"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">quantification_parameter_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: e.g., 3 for "three baskets"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">record_as_self_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: record recipient as <code class="display"><span class="extract">self</span></code> when writing this</span>
    <span class="definitionkeyword">enum</span> <span class="constant">relationship_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">binary_predicate</span></code>: for RELATIONSHIP nodes</span>
    <span class="definitionkeyword">enum</span> <span class="constant">resolved_ANNOT</span><span class="plain"> </span>    <span class="comment">int: temp storage when resolving NPs</span>
    <span class="definitionkeyword">enum</span> <span class="constant">response_code_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: for responses only</span>
    <span class="definitionkeyword">enum</span> <span class="constant">results_from_splitting_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: node in a routine's parse tree from comma block notation</span>
    <span class="definitionkeyword">enum</span> <span class="constant">row_amendable_ANNOT</span><span class="plain"> </span>    <span class="comment">int: a candidate row for a table amendment</span>
    <span class="definitionkeyword">enum</span> <span class="constant">save_self_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: this invocation must save and preserve <code class="display"><span class="extract">self</span></code> at run-time</span>
    <span class="definitionkeyword">enum</span> <span class="constant">say_adjective_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">adjectival_phrase</span></code>: ...or the adjective to be agreed with by "say"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">say_verb_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">verb_conjugation</span></code>: ...or the verb to be conjugated by "say"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">say_verb_negated_ANNOT</span><span class="plain"> </span>    <span class="comment">relevant only for that</span>
    <span class="definitionkeyword">enum</span> <span class="constant">self_object_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: this represents <code class="display"><span class="extract">self</span></code> at run-time</span>
    <span class="definitionkeyword">enum</span> <span class="constant">slash_class_ANNOT</span><span class="plain"> </span>    <span class="comment">int: used when partitioning grammar tokens</span>
    <span class="definitionkeyword">enum</span> <span class="constant">slash_dash_dash_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: used when partitioning grammar tokens</span>
    <span class="definitionkeyword">enum</span> <span class="constant">ssp_closing_segment_wn_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: identifier for the last of these, or <code class="display"><span class="extract">-1</span></code></span>
    <span class="definitionkeyword">enum</span> <span class="constant">ssp_segment_count_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: number of subsequent complex-say phrases in stream</span>
    <span class="definitionkeyword">enum</span> <span class="constant">subject_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">inference_subject</span></code>: what this node describes</span>
    <span class="definitionkeyword">enum</span> <span class="constant">subject_term_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">pcalc_term</span></code>: what the subject of the subtree was</span>
    <span class="definitionkeyword">enum</span> <span class="constant">suppress_heading_dependencies_ANNOT</span><span class="plain"> </span>    <span class="comment">int: ignore extension dependencies on this heading node</span>
    <span class="definitionkeyword">enum</span> <span class="constant">suppress_newlines_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: whether the next say term runs on</span>
    <span class="definitionkeyword">enum</span> <span class="constant">table_cell_unspecified_ANNOT</span><span class="plain"> </span>    <span class="comment">int: used to mark table entries as unset</span>
    <span class="definitionkeyword">enum</span> <span class="constant">text_unescaped_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: flag used only for literal texts</span>
    <span class="definitionkeyword">enum</span> <span class="constant">token_as_parsed_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">parse_node</span></code>: what if anything is returned</span>
    <span class="definitionkeyword">enum</span> <span class="constant">token_check_to_do_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">parse_node</span></code>: what if anything is returned</span>
    <span class="definitionkeyword">enum</span> <span class="constant">token_to_be_parsed_against_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">parse_node</span></code>: what if anything is returned</span>
    <span class="definitionkeyword">enum</span> <span class="constant">turned_already_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: aliasing like "player" to "yourself" performed already</span>
    <span class="definitionkeyword">enum</span> <span class="constant">unproven_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: this invocation needs run-time typechecking</span>
    <span class="definitionkeyword">enum</span> <span class="constant">verb_id_ANNOT</span><span class="plain"> </span>    <span class="comment">int: identifying what kind of VERB node</span>
    <span class="definitionkeyword">enum</span> <span class="constant">verb_problem_issued_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: has a problem message about the primary verb been issued already?</span>
    <span class="definitionkeyword">enum</span> <span class="constant">vu_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">verb_usage</span></code>: for e.g. "does not carry"</span>
    <span class="definitionkeyword">enum</span> <span class="constant">you_can_ignore_ANNOT</span><span class="plain"> </span>    <span class="comment"><code class="display"><span class="extract">int</span></code>: for assertions now drained of meaning</span>
</pre>
<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">enum</span> <span class="constant">L4_NCAT</span>
    <span class="definitionkeyword">enum</span> <span class="constant">UNKNOWN_NCAT</span>
    <span class="definitionkeyword">enum</span> <span class="constant">LVALUE_NCAT</span>
    <span class="definitionkeyword">enum</span> <span class="constant">RVALUE_NCAT</span>
    <span class="definitionkeyword">enum</span> <span class="constant">COND_NCAT</span>
    <span class="definitionkeyword">define</span> <span class="constant">PHRASAL_NFLAG</span><span class="plain">        	0</span><span class="identifier">x00000004</span><span class="plain"> </span>    <span class="comment">compiles to a function call</span>
</pre>
<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">PARSE_TREE_METADATA_SETUP</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::md</span>
</pre>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::md</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="comment">first, the structural nodes:</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">BIBLIOGRAPHIC_NT</span><span class="plain">, </span><span class="string">"BIBLIOGRAPHIC_NT"</span><span class="plain">,    					0, 0,		</span><span class="identifier">L2_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">ROUTINE_NT</span><span class="plain">, </span><span class="string">"ROUTINE_NT"</span><span class="plain">, 			   					0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="identifier">L2_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">INFORM6CODE_NT</span><span class="plain">, </span><span class="string">"INFORM6CODE_NT"</span><span class="plain">,		   					0, 0,		</span><span class="identifier">L2_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">TABLE_NT</span><span class="plain">, </span><span class="string">"TABLE_NT"</span><span class="plain">,					   					0, 0,		</span><span class="identifier">L2_NCAT</span><span class="plain">, </span><span class="identifier">TABBED_CONTENT_NFLAG</span><span class="plain"> });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">EQUATION_NT</span><span class="plain">, </span><span class="string">"EQUATION_NT"</span><span class="plain">,			   					0, 0,		</span><span class="identifier">L2_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">TRACE_NT</span><span class="plain">, </span><span class="string">"TRACE_NT"</span><span class="plain">,					   					0, 0,		</span><span class="identifier">L2_NCAT</span><span class="plain">, 0 });</span>

        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">ALLOWED_NT</span><span class="plain">, </span><span class="string">"ALLOWED_NT"</span><span class="plain">,				   					1, 1,		</span><span class="identifier">L3_NCAT</span><span class="plain">, </span><span class="identifier">ASSERT_NFLAG</span><span class="plain"> });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">EVERY_NT</span><span class="plain">, </span><span class="string">"EVERY_NT"</span><span class="plain">, 				   					0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="identifier">L3_NCAT</span><span class="plain">, </span><span class="identifier">ASSERT_NFLAG</span><span class="plain"> });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">COMMON_NOUN_NT</span><span class="plain">, </span><span class="string">"COMMON_NOUN_NT"</span><span class="plain">,		   					0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="identifier">L3_NCAT</span><span class="plain">, </span><span class="identifier">ASSERT_NFLAG</span><span class="plain"> });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">ACTION_NT</span><span class="plain">, </span><span class="string">"ACTION_NT"</span><span class="plain">,				   					0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="identifier">L3_NCAT</span><span class="plain">, </span><span class="identifier">ASSERT_NFLAG</span><span class="plain"> });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">ADJECTIVE_NT</span><span class="plain">, </span><span class="string">"ADJECTIVE_NT"</span><span class="plain">,			   					0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="identifier">L3_NCAT</span><span class="plain">, </span><span class="identifier">ASSERT_NFLAG</span><span class="plain"> });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">PROPERTYCALLED_NT</span><span class="plain">, </span><span class="string">"PROPERTYCALLED_NT"</span><span class="plain">,  					2, 2,		</span><span class="identifier">L3_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">TOKEN_NT</span><span class="plain">, </span><span class="string">"TOKEN_NT"</span><span class="plain">,					   					0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="identifier">L3_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">X_OF_Y_NT</span><span class="plain">, </span><span class="string">"X_OF_Y_NT"</span><span class="plain">,				   					2, 2,		</span><span class="identifier">L3_NCAT</span><span class="plain">, </span><span class="identifier">ASSERT_NFLAG</span><span class="plain"> });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">CREATED_NT</span><span class="plain">, </span><span class="string">"CREATED_NT"</span><span class="plain">,				  					0, 0,		</span><span class="identifier">L3_NCAT</span><span class="plain">, </span><span class="identifier">ASSERT_NFLAG</span><span class="plain"> });</span>

        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">CODE_BLOCK_NT</span><span class="plain">, </span><span class="string">"CODE_BLOCK_NT"</span><span class="plain">,	       					0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="constant">L4_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">INVOCATION_LIST_NT</span><span class="plain">, </span><span class="string">"INVOCATION_LIST_NT"</span><span class="plain">,		   			0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="constant">L4_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">INVOCATION_LIST_SAY_NT</span><span class="plain">, </span><span class="string">"INVOCATION_LIST_SAY_NT"</span><span class="plain">,		    0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="constant">L4_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">INVOCATION_NT</span><span class="plain">, </span><span class="string">"INVOCATION_NT"</span><span class="plain">,		   					0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="constant">L4_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">VOID_CONTEXT_NT</span><span class="plain">, </span><span class="string">"VOID_CONTEXT_NT"</span><span class="plain">, 						0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="constant">L4_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">RVALUE_CONTEXT_NT</span><span class="plain">, </span><span class="string">"RVALUE_CONTEXT_NT"</span><span class="plain">, 					0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="constant">L4_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">LVALUE_CONTEXT_NT</span><span class="plain">, </span><span class="string">"LVALUE_CONTEXT_NT"</span><span class="plain">, 					0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="constant">L4_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">LVALUE_TR_CONTEXT_NT</span><span class="plain">, </span><span class="string">"LVALUE_TR_CONTEXT_NT"</span><span class="plain">, 			0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="constant">L4_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">SPECIFIC_RVALUE_CONTEXT_NT</span><span class="plain">, </span><span class="string">"SPECIFIC_RVALUE_CONTEXT_NT"</span><span class="plain">,	0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="constant">L4_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">MATCHING_RVALUE_CONTEXT_NT</span><span class="plain">, </span><span class="string">"MATCHING_RVALUE_CONTEXT_NT"</span><span class="plain">,	0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="constant">L4_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">NEW_LOCAL_CONTEXT_NT</span><span class="plain">, </span><span class="string">"NEW_LOCAL_CONTEXT_NT"</span><span class="plain">,				0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="constant">L4_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">LVALUE_LOCAL_CONTEXT_NT</span><span class="plain">, </span><span class="string">"LVALUE_LOCAL_CONTEXT_NT"</span><span class="plain">,	0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="constant">L4_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">CONDITION_CONTEXT_NT</span><span class="plain">, </span><span class="string">"CONDITION_CONTEXT_NT"</span><span class="plain">,				0, </span><span class="identifier">INFTY</span><span class="plain">,	</span><span class="constant">L4_NCAT</span><span class="plain">, 0 });</span>

        <span class="comment">now the specification nodes:</span>

        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">UNKNOWN_NT</span><span class="plain">, </span><span class="string">"UNKNOWN_NT"</span><span class="plain">, 								0, 0,		</span><span class="constant">UNKNOWN_NCAT</span><span class="plain">, 0 });</span>

        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="string">"CONSTANT_NT"</span><span class="plain">, 							0, 0,		</span><span class="constant">RVALUE_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">PHRASE_TO_DECIDE_VALUE_NT</span><span class="plain">, </span><span class="string">"PHRASE_TO_DECIDE_VALUE_NT"</span><span class="plain">,	1, 1,		</span><span class="constant">RVALUE_NCAT</span><span class="plain">, </span><span class="constant">PHRASAL_NFLAG</span><span class="plain"> });</span>

        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">LOCAL_VARIABLE_NT</span><span class="plain">, </span><span class="string">"LOCAL_VARIABLE_NT"</span><span class="plain">, 				0, 0,		</span><span class="constant">LVALUE_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">NONLOCAL_VARIABLE_NT</span><span class="plain">, </span><span class="string">"NONLOCAL_VARIABLE_NT"</span><span class="plain">, 			0, 0,		</span><span class="constant">LVALUE_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">PROPERTY_VALUE_NT</span><span class="plain">, </span><span class="string">"PROPERTY_VALUE_NT"</span><span class="plain">, 				2, 2,		</span><span class="constant">LVALUE_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">TABLE_ENTRY_NT</span><span class="plain">, </span><span class="string">"TABLE_ENTRY_NT"</span><span class="plain">, 						1, 4,		</span><span class="constant">LVALUE_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">LIST_ENTRY_NT</span><span class="plain">, </span><span class="string">"LIST_ENTRY_NT"</span><span class="plain">, 						2, 2,		</span><span class="constant">LVALUE_NCAT</span><span class="plain">, 0 });</span>

        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">LOGICAL_NOT_NT</span><span class="plain">, </span><span class="string">"LOGICAL_NOT_NT"</span><span class="plain">, 						1, 1,		</span><span class="constant">COND_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">LOGICAL_TENSE_NT</span><span class="plain">, </span><span class="string">"LOGICAL_TENSE_NT"</span><span class="plain">, 					1, 1,		</span><span class="constant">COND_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">LOGICAL_AND_NT</span><span class="plain">, </span><span class="string">"LOGICAL_AND_NT"</span><span class="plain">, 						2, 2,		</span><span class="constant">COND_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">LOGICAL_OR_NT</span><span class="plain">, </span><span class="string">"LOGICAL_OR_NT"</span><span class="plain">, 						2, 2,		</span><span class="constant">COND_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">TEST_PROPOSITION_NT</span><span class="plain">, </span><span class="string">"TEST_PROPOSITION_NT"</span><span class="plain">, 			0, 0,		</span><span class="constant">COND_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">TEST_PHRASE_OPTION_NT</span><span class="plain">, </span><span class="string">"TEST_PHRASE_OPTION_NT"</span><span class="plain">, 		0, 0, 		</span><span class="constant">COND_NCAT</span><span class="plain">, 0 });</span>
        <span class="identifier">ParseTree::md</span><span class="plain">((</span><span class="identifier">parse_tree_node_type</span><span class="plain">) { </span><span class="constant">TEST_VALUE_NT</span><span class="plain">, </span><span class="string">"TEST_VALUE_NT"</span><span class="plain">, 						1, 1,		</span><span class="constant">COND_NCAT</span><span class="plain">, 0 });</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ParseTreeUsage::md appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">ANNOTATION_PERMISSIONS_WRITER</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::write_permissions</span>
</pre>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::write_permissions</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="identifier">L2_NCAT</span><span class="plain">][</span><span class="identifier">L3_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="identifier">L3_NCAT</span><span class="plain">][</span><span class="identifier">L3_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="identifier">L2_NCAT</span><span class="plain">][</span><span class="constant">L4_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">L4_NCAT</span><span class="plain">][</span><span class="constant">L4_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">L4_NCAT</span><span class="plain">][</span><span class="constant">UNKNOWN_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>

        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">L4_NCAT</span><span class="plain">][</span><span class="constant">LVALUE_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">L4_NCAT</span><span class="plain">][</span><span class="constant">RVALUE_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">L4_NCAT</span><span class="plain">][</span><span class="constant">COND_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>

        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">LVALUE_NCAT</span><span class="plain">][</span><span class="constant">UNKNOWN_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">RVALUE_NCAT</span><span class="plain">][</span><span class="constant">UNKNOWN_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">COND_NCAT</span><span class="plain">][</span><span class="constant">UNKNOWN_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">LVALUE_NCAT</span><span class="plain">][</span><span class="constant">LVALUE_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">RVALUE_NCAT</span><span class="plain">][</span><span class="constant">LVALUE_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">COND_NCAT</span><span class="plain">][</span><span class="constant">LVALUE_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">LVALUE_NCAT</span><span class="plain">][</span><span class="constant">RVALUE_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">RVALUE_NCAT</span><span class="plain">][</span><span class="constant">RVALUE_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">COND_NCAT</span><span class="plain">][</span><span class="constant">RVALUE_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">LVALUE_NCAT</span><span class="plain">][</span><span class="constant">COND_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">RVALUE_NCAT</span><span class="plain">][</span><span class="constant">COND_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parentage_allowed</span><span class="plain">[</span><span class="constant">COND_NCAT</span><span class="plain">][</span><span class="constant">COND_NCAT</span><span class="plain">] = </span><span class="identifier">TRUE</span><span class="plain">;</span>

        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="identifier">L1_NCAT</span><span class="plain">, </span><span class="constant">clears_pronouns_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">HEADING_NT</span><span class="plain">, </span><span class="constant">embodying_heading_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">HEADING_NT</span><span class="plain">, </span><span class="constant">interpretation_of_subject_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">HEADING_NT</span><span class="plain">, </span><span class="constant">suppress_heading_dependencies_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="identifier">L1_NCAT</span><span class="plain">, </span><span class="constant">module_ANNOT</span><span class="plain">);</span>

        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="identifier">L2_NCAT</span><span class="plain">, </span><span class="constant">clears_pronouns_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="identifier">L2_NCAT</span><span class="plain">, </span><span class="constant">interpretation_of_subject_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="identifier">L2_NCAT</span><span class="plain">, </span><span class="identifier">sentence_unparsed_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="identifier">L2_NCAT</span><span class="plain">, </span><span class="constant">verb_problem_issued_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">ROUTINE_NT</span><span class="plain">, </span><span class="constant">indentation_level_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">SENTENCE_NT</span><span class="plain">, </span><span class="constant">implicit_in_creation_of_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">SENTENCE_NT</span><span class="plain">, </span><span class="constant">implicitness_count_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">SENTENCE_NT</span><span class="plain">, </span><span class="constant">you_can_ignore_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="identifier">L2_NCAT</span><span class="plain">, </span><span class="constant">module_ANNOT</span><span class="plain">);</span>
        <span class="identifier">LOOP_OVER_NODE_TYPES</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::test_flag</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">, </span><span class="identifier">ASSERT_NFLAG</span><span class="plain">))</span>
                <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">, </span><span class="constant">resolved_ANNOT</span><span class="plain">);</span>

        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="identifier">L3_NCAT</span><span class="plain">, </span><span class="constant">module_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="identifier">L3_NCAT</span><span class="plain">, </span><span class="constant">creation_proposition_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="identifier">L3_NCAT</span><span class="plain">, </span><span class="constant">evaluation_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="identifier">L3_NCAT</span><span class="plain">, </span><span class="constant">subject_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">ACTION_NT</span><span class="plain">, </span><span class="constant">action_meaning_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">ADJECTIVE_NT</span><span class="plain">, </span><span class="constant">aph_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">ADJECTIVE_NT</span><span class="plain">, </span><span class="constant">negated_boolean_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">ADJECTIVE_NT</span><span class="plain">, </span><span class="identifier">nounphrase_article_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">AVERB_NT</span><span class="plain">, </span><span class="constant">log_inclusion_sense_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">AVERB_NT</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">AVERB_NT</span><span class="plain">, </span><span class="constant">imperative_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">AVERB_NT</span><span class="plain">, </span><span class="constant">examine_for_ofs_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">AVERB_NT</span><span class="plain">, </span><span class="constant">listing_sense_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">COMMON_NOUN_NT</span><span class="plain">, </span><span class="constant">action_meaning_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">COMMON_NOUN_NT</span><span class="plain">, </span><span class="constant">creation_site_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">COMMON_NOUN_NT</span><span class="plain">, </span><span class="identifier">implicitly_refers_to_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">COMMON_NOUN_NT</span><span class="plain">, </span><span class="constant">multiplicity_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">COMMON_NOUN_NT</span><span class="plain">, </span><span class="constant">quant_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">COMMON_NOUN_NT</span><span class="plain">, </span><span class="constant">quantification_parameter_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">, </span><span class="constant">aph_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">, </span><span class="constant">category_of_I6_translation_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">, </span><span class="constant">creation_site_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">, </span><span class="constant">defn_language_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">, </span><span class="constant">log_inclusion_sense_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">, </span><span class="constant">lpe_options_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">, </span><span class="constant">multiplicity_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">, </span><span class="constant">negated_boolean_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">, </span><span class="constant">new_relation_here_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">, </span><span class="constant">nowhere_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">, </span><span class="constant">quant_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">, </span><span class="constant">quantification_parameter_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">, </span><span class="constant">row_amendable_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">, </span><span class="constant">slash_dash_dash_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">, </span><span class="constant">table_cell_unspecified_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">, </span><span class="constant">turned_already_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">PROPERTY_LIST_NT</span><span class="plain">, </span><span class="identifier">nounphrase_article_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="identifier">RELATIONSHIP_NT</span><span class="plain">, </span><span class="constant">relationship_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">TOKEN_NT</span><span class="plain">, </span><span class="constant">grammar_token_literal_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">TOKEN_NT</span><span class="plain">, </span><span class="constant">grammar_token_relation_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">TOKEN_NT</span><span class="plain">, </span><span class="constant">grammar_value_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">TOKEN_NT</span><span class="plain">, </span><span class="constant">slash_class_ANNOT</span><span class="plain">);</span>

        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">L4_NCAT</span><span class="plain">, </span><span class="constant">colon_block_command_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">L4_NCAT</span><span class="plain">, </span><span class="constant">control_structure_used_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">L4_NCAT</span><span class="plain">, </span><span class="constant">end_control_structure_used_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">L4_NCAT</span><span class="plain">, </span><span class="constant">evaluation_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">L4_NCAT</span><span class="plain">, </span><span class="constant">indentation_level_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">L4_NCAT</span><span class="plain">, </span><span class="constant">kind_of_new_variable_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">L4_NCAT</span><span class="plain">, </span><span class="constant">kind_required_by_context_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">L4_NCAT</span><span class="plain">, </span><span class="constant">results_from_splitting_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">L4_NCAT</span><span class="plain">, </span><span class="constant">token_as_parsed_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">L4_NCAT</span><span class="plain">, </span><span class="constant">token_check_to_do_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">L4_NCAT</span><span class="plain">, </span><span class="constant">token_to_be_parsed_against_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">L4_NCAT</span><span class="plain">, </span><span class="constant">verb_problem_issued_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">L4_NCAT</span><span class="plain">, </span><span class="identifier">problem_falls_under_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">L4_NCAT</span><span class="plain">, </span><span class="constant">module_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CODE_BLOCK_NT</span><span class="plain">, </span><span class="identifier">sentence_unparsed_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_LIST_NT</span><span class="plain">, </span><span class="constant">from_text_substitution_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_LIST_NT</span><span class="plain">, </span><span class="identifier">sentence_unparsed_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_LIST_SAY_NT</span><span class="plain">, </span><span class="identifier">sentence_unparsed_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_LIST_SAY_NT</span><span class="plain">, </span><span class="constant">suppress_newlines_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_NT</span><span class="plain">, </span><span class="constant">epistemological_status_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_NT</span><span class="plain">, </span><span class="constant">kind_resulting_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_NT</span><span class="plain">, </span><span class="constant">kind_variable_declarations_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_NT</span><span class="plain">, </span><span class="constant">modal_verb_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_NT</span><span class="plain">, </span><span class="constant">phrase_invoked_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_NT</span><span class="plain">, </span><span class="constant">phrase_options_invoked_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_NT</span><span class="plain">, </span><span class="constant">say_adjective_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_NT</span><span class="plain">, </span><span class="constant">say_verb_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_NT</span><span class="plain">, </span><span class="constant">say_verb_negated_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_NT</span><span class="plain">, </span><span class="constant">ssp_closing_segment_wn_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_NT</span><span class="plain">, </span><span class="constant">ssp_segment_count_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_NT</span><span class="plain">, </span><span class="constant">suppress_newlines_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_NT</span><span class="plain">, </span><span class="constant">save_self_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">INVOCATION_NT</span><span class="plain">, </span><span class="constant">unproven_ANNOT</span><span class="plain">);</span>

        <span class="functiontext">ParseTreeUsage::allow_annotation_to_specification</span><span class="plain">(</span><span class="constant">converted_SN_ANNOT</span><span class="plain">);</span>
        <span class="functiontext">ParseTreeUsage::allow_annotation_to_specification</span><span class="plain">(</span><span class="constant">subject_term_ANNOT</span><span class="plain">);</span>
        <span class="functiontext">ParseTreeUsage::allow_annotation_to_specification</span><span class="plain">(</span><span class="constant">epistemological_status_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_action_name_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_action_pattern_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_activity_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_binary_predicate_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_constant_phrase_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_enumeration_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_equation_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_grammar_verb_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_instance_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_named_action_pattern_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_named_rulebook_outcome_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_number_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_property_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_rule_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_rulebook_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_scene_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_table_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_table_column_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_text_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_use_option_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">constant_verb_form_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">explicit_literal_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">explicit_vh_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">grammar_token_code_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">kind_of_value_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">nothing_object_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">property_name_used_as_noun_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">proposition_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">response_code_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">self_object_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">, </span><span class="constant">text_unescaped_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">LOCAL_VARIABLE_NT</span><span class="plain">, </span><span class="constant">constant_local_variable_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">LOCAL_VARIABLE_NT</span><span class="plain">, </span><span class="constant">kind_of_value_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">LOGICAL_TENSE_NT</span><span class="plain">, </span><span class="constant">condition_tense_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">NONLOCAL_VARIABLE_NT</span><span class="plain">, </span><span class="constant">constant_nonlocal_variable_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">NONLOCAL_VARIABLE_NT</span><span class="plain">, </span><span class="constant">kind_of_value_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">PROPERTY_VALUE_NT</span><span class="plain">, </span><span class="constant">record_as_self_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">TEST_PHRASE_OPTION_NT</span><span class="plain">, </span><span class="constant">phrase_option_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">TEST_PROPOSITION_NT</span><span class="plain">, </span><span class="constant">proposition_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">UNKNOWN_NT</span><span class="plain">, </span><span class="constant">prep_ANNOT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">UNKNOWN_NT</span><span class="plain">, </span><span class="constant">vu_ANNOT</span><span class="plain">);</span>
    <span class="plain">}</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::allow_annotation_to_specification</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">annot</span><span class="plain">) {</span>
        <span class="identifier">ParseTree::allow_annotation</span><span class="plain">(</span><span class="constant">UNKNOWN_NT</span><span class="plain">, </span><span class="identifier">annot</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">LVALUE_NCAT</span><span class="plain">, </span><span class="identifier">annot</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">RVALUE_NCAT</span><span class="plain">, </span><span class="identifier">annot</span><span class="plain">);</span>
        <span class="identifier">ParseTree::allow_annotation_to_category</span><span class="plain">(</span><span class="constant">COND_NCAT</span><span class="plain">, </span><span class="identifier">annot</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ParseTreeUsage::write_permissions appears nowhere else.</p>

<p class="endnote">The function ParseTreeUsage::allow_annotation_to_specification appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">PARENTAGE_EXCEPTIONS</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::parentage_exceptions</span>
</pre>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::parentage_exceptions</span><span class="plain">(</span><span class="identifier">node_type_t</span><span class="plain"> </span><span class="identifier">t_parent</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">cat_parent</span><span class="plain">,</span>
        <span class="identifier">node_type_t</span><span class="plain"> </span><span class="identifier">t_child</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">cat_child</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">t_parent</span><span class="plain"> == </span><span class="identifier">HEADING_NT</span><span class="plain">) &amp;&amp; (</span><span class="identifier">cat_child</span><span class="plain"> == </span><span class="identifier">L2_NCAT</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">t_parent</span><span class="plain"> == </span><span class="constant">PHRASE_TO_DECIDE_VALUE_NT</span><span class="plain">) &amp;&amp; (</span><span class="identifier">t_child</span><span class="plain"> == </span><span class="constant">INVOCATION_LIST_NT</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ParseTreeUsage::parentage_exceptions appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b>Further classification:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">IMMUTABLE_NODE</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::immutable</span>
    <span class="definitionkeyword">define</span> <span class="constant">SENTENCE_NODE</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::second_level</span>
</pre>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::second_level</span><span class="plain">(</span><span class="identifier">node_type_t</span><span class="plain"> </span><span class="identifier">t</span><span class="plain">) {</span>
        <span class="identifier">parse_tree_node_type</span><span class="plain"> *</span><span class="identifier">metadata</span><span class="plain"> = </span><span class="identifier">ParseTree::node_metadata</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">metadata</span><span class="plain">) &amp;&amp; (</span><span class="identifier">metadata</span><span class="plain">-&gt;</span><span class="identifier">category</span><span class="plain"> == </span><span class="identifier">L2_NCAT</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::immutable</span><span class="plain">(</span><span class="identifier">node_type_t</span><span class="plain"> </span><span class="identifier">t</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">ParseTreeUsage::is_specification_node_type</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::is_specification_node_type</span><span class="plain">(</span><span class="identifier">node_type_t</span><span class="plain"> </span><span class="identifier">t</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">t</span><span class="plain"> == </span><span class="constant">UNKNOWN_NT</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parse_tree_node_type</span><span class="plain"> *</span><span class="identifier">metadata</span><span class="plain"> = </span><span class="identifier">ParseTree::node_metadata</span><span class="plain">(</span><span class="identifier">t</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">metadata</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">((</span><span class="identifier">metadata</span><span class="plain">-&gt;</span><span class="identifier">category</span><span class="plain"> == </span><span class="constant">RVALUE_NCAT</span><span class="plain">) ||</span>
            <span class="plain">(</span><span class="identifier">metadata</span><span class="plain">-&gt;</span><span class="identifier">category</span><span class="plain"> == </span><span class="constant">LVALUE_NCAT</span><span class="plain">) ||</span>
            <span class="plain">(</span><span class="identifier">metadata</span><span class="plain">-&gt;</span><span class="identifier">category</span><span class="plain"> == </span><span class="constant">COND_NCAT</span><span class="plain">))) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::is_lvalue</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">) {</span>
        <span class="identifier">parse_tree_node_type</span><span class="plain"> *</span><span class="identifier">metadata</span><span class="plain"> = </span><span class="identifier">ParseTree::node_metadata</span><span class="plain">(</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">metadata</span><span class="plain">) &amp;&amp; (</span><span class="identifier">metadata</span><span class="plain">-&gt;</span><span class="identifier">category</span><span class="plain"> == </span><span class="constant">LVALUE_NCAT</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::is_rvalue</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">) {</span>
        <span class="identifier">parse_tree_node_type</span><span class="plain"> *</span><span class="identifier">metadata</span><span class="plain"> = </span><span class="identifier">ParseTree::node_metadata</span><span class="plain">(</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">metadata</span><span class="plain">) &amp;&amp; (</span><span class="identifier">metadata</span><span class="plain">-&gt;</span><span class="identifier">category</span><span class="plain"> == </span><span class="constant">RVALUE_NCAT</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::is_value</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">) {</span>
        <span class="identifier">parse_tree_node_type</span><span class="plain"> *</span><span class="identifier">metadata</span><span class="plain"> = </span><span class="identifier">ParseTree::node_metadata</span><span class="plain">(</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">metadata</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">((</span><span class="identifier">metadata</span><span class="plain">-&gt;</span><span class="identifier">category</span><span class="plain"> == </span><span class="constant">LVALUE_NCAT</span><span class="plain">) || (</span><span class="identifier">metadata</span><span class="plain">-&gt;</span><span class="identifier">category</span><span class="plain"> == </span><span class="constant">RVALUE_NCAT</span><span class="plain">)))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::is_condition</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">) {</span>
        <span class="identifier">parse_tree_node_type</span><span class="plain"> *</span><span class="identifier">metadata</span><span class="plain"> = </span><span class="identifier">ParseTree::node_metadata</span><span class="plain">(</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">metadata</span><span class="plain">) &amp;&amp; (</span><span class="identifier">metadata</span><span class="plain">-&gt;</span><span class="identifier">category</span><span class="plain"> == </span><span class="constant">COND_NCAT</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::is_phrasal</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::test_flag</span><span class="plain">(</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">), </span><span class="constant">PHRASAL_NFLAG</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ParseTreeUsage::second_level appears nowhere else.</p>

<p class="endnote">The function ParseTreeUsage::immutable appears nowhere else.</p>

<p class="endnote">The function ParseTreeUsage::is_specification_node_type appears nowhere else.</p>

<p class="endnote">The function ParseTreeUsage::is_lvalue is used in <a href="#SP17_1">&#167;17.1</a>, 12/dtd (<a href="12-dtd.html#SP16">&#167;16</a>, <a href="12-dtd.html#SP23">&#167;23</a>), 14/sp (<a href="14-sp.html#SP1">&#167;1</a>, <a href="14-sp.html#SP6">&#167;6</a>), 14/lv (<a href="14-lv.html#SP7">&#167;7</a>), 14/cfs (<a href="14-cfs.html#SP7">&#167;7</a>), 14/ds2 (<a href="14-ds2.html#SP10_1_1_3_1">&#167;10.1.1.3.1</a>, <a href="14-ds2.html#SP11_2">&#167;11.2</a>, <a href="14-ds2.html#SP19_5_4">&#167;19.5.4</a>), 25/cii (<a href="25-cii.html#SP3_1_1_2">&#167;3.1.1.2</a>).</p>

<p class="endnote">The function ParseTreeUsage::is_rvalue is used in <a href="#SP17_1">&#167;17.1</a>, 4/am (<a href="4-am.html#SP25">&#167;25</a>), 11/sm (<a href="11-sm.html#SP10_4">&#167;10.4</a>), 14/sp (<a href="14-sp.html#SP1">&#167;1</a>, <a href="14-sp.html#SP6">&#167;6</a>), 14/cfs (<a href="14-cfs.html#SP7">&#167;7</a>), 22/prcd (<a href="22-prcd.html#SP6">&#167;6</a>).</p>

<p class="endnote">The function ParseTreeUsage::is_value is used in 9/pk (<a href="9-pk.html#SP4">&#167;4</a>), 14/sp (<a href="14-sp.html#SP7_5">&#167;7.5</a>), 14/ds2 (<a href="14-ds2.html#SP10_1_1_3_1">&#167;10.1.1.3.1</a>, <a href="14-ds2.html#SP19_6_1">&#167;19.6.1</a>), 25/ci (<a href="25-ci.html#SP3_2_3_4_1_1_1">&#167;3.2.3.4.1.1.1</a>).</p>

<p class="endnote">The function ParseTreeUsage::is_condition is used in <a href="#SP17_1">&#167;17.1</a>, 4/am (<a href="4-am.html#SP25">&#167;25</a>), 14/sp (<a href="14-sp.html#SP6">&#167;6</a>), 14/cn (<a href="14-cn.html#SP15">&#167;15</a>), 14/cfs (<a href="14-cfs.html#SP7">&#167;7</a>), 14/ds2 (<a href="14-ds2.html#SP19_6_2">&#167;19.6.2</a>), 25/cp (<a href="25-cp.html#SP5_3_2">&#167;5.3.2</a>).</p>

<p class="endnote">The function ParseTreeUsage::is_phrasal is used in 11/tr (<a href="11-tr.html#SP10">&#167;10</a>), 11/bas (<a href="11-bas.html#SP19">&#167;19</a>), 12/cad (<a href="12-cad.html#SP6">&#167;6</a>), 24/lv (<a href="24-lv.html#SP34">&#167;34</a>).</p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16. The assertion-maker's invariant. </b>Hmm: "The Assertion-Maker's Invariant" might make a good magic-realism
novel, in which an enigmatic wise man of Samarkand builds an ingenious box
from camphor-wood in which he traps the dreams of the people, who &mdash; However.
When assertions are processed, the subtrees being compared will be required to
be such that their head nodes each pass this test:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::allow_in_assertions</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">) {</span>
        <span class="identifier">ParseTree::verify_structure</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::test_flag</span><span class="plain">(</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">), </span><span class="identifier">ASSERT_NFLAG</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ParseTreeUsage::allow_in_assertions is used in 9/ma (<a href="9-ma.html#SP2">&#167;2</a>).</p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">PARSE_TREE_LOGGER</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::log_node</span>
</pre>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::log_node</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_meaning</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">)) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"$M"</span><span class="plain">, </span><span class="identifier">ParseTree::get_meaning</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">));</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"$N"</span><span class="plain">, </span><span class="identifier">pn</span><span class="plain">-&gt;</span><span class="identifier">node_type</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">))) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"'%W'"</span><span class="plain">, </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">));</span>

        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">pn</span><span class="plain">-&gt;</span><span class="identifier">node_type</span><span class="plain"> &gt;= </span><span class="constant">UNKNOWN_NT</span><span class="plain">) &amp;&amp; (</span><span class="identifier">pn</span><span class="plain">-&gt;</span><span class="identifier">node_type</span><span class="plain"> &lt;= </span><span class="constant">TEST_VALUE_NT</span><span class="plain">))</span>
            &lt;<span class="cwebmacro">Log annotations of specification nodes</span> <span class="cwebmacronumber">17.1</span>&gt;
        <span class="reserved">else</span>
            &lt;<span class="cwebmacro">Log annotations of structural nodes</span> <span class="cwebmacronumber">17.2</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ParseTreeUsage::log_node appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP17_1"></a><b>&#167;17.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Log annotations of specification nodes</span> <span class="cwebmacronumber">17.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_kind_of_value</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">)) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"-$u"</span><span class="plain">, </span><span class="identifier">ParseTree::get_kind_of_value</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">ParseTreeUsage::is_lvalue</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">)) </span><span class="functiontext">Lvalues::log</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">ParseTreeUsage::is_rvalue</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">)) </span><span class="functiontext">Rvalues::log</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">ParseTreeUsage::is_condition</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">)) </span><span class="functiontext">Conditions::log</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_vu</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">)) { </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"-vu:"</span><span class="plain">); </span><span class="functiontext">NewVerbs::log</span><span class="plain">(</span><span class="identifier">ParseTree::get_vu</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">)); }</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_prep</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">)) { </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"-prep:$p"</span><span class="plain">, </span><span class="identifier">ParseTree::get_prep</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">)); }</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP17">&#167;17</a>.</p>

<p class="inwebparagraph"><a id="SP17_2"></a><b>&#167;17.2.  </b>We do not log every annotation: only the few which are most illuminating.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Log annotations of structural nodes</span> <span class="cwebmacronumber">17.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">show_eval</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">show_refers</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="constant">creation_site_ANNOT</span><span class="plain">))</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" (created here)"</span><span class="plain">);</span>
        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">-&gt;</span><span class="identifier">node_type</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">ADJECTIVE_NT</span><span class="plain">: </span><span class="identifier">show_eval</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">HEADING_NT</span><span class="plain">: </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" (level %d)"</span><span class="plain">, </span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">heading_level_ANNOT</span><span class="plain">)); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">COMMON_NOUN_NT</span><span class="plain">: </span><span class="identifier">show_refers</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">KIND_NT</span><span class="plain">: </span><span class="identifier">show_refers</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">RELATIONSHIP_NT</span><span class="plain">:</span>
                <span class="identifier">Diagrams::log_node</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">pn</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">:</span>
                <span class="identifier">Diagrams::log_node</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">pn</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="constant">multiplicity_ANNOT</span><span class="plain">))</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" (x%d)"</span><span class="plain">, </span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="constant">multiplicity_ANNOT</span><span class="plain">));</span>
                <span class="identifier">show_refers</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">AVERB_NT</span><span class="plain">:</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" ($V)"</span><span class="plain">, </span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">));</span>
                <span class="identifier">Diagrams::log_node</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">pn</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TOKEN_NT</span><span class="plain">: </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" [%d/%d]"</span><span class="plain">, </span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="constant">slash_class_ANNOT</span><span class="plain">),</span>
                <span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="constant">slash_dash_dash_ANNOT</span><span class="plain">)); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">INVOCATION_LIST_NT</span><span class="plain">:</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">CODE_BLOCK_NT</span><span class="plain">: {</span>
                <span class="reserved">control_structure_phrase</span><span class="plain"> *</span><span class="identifier">csp</span><span class="plain"> = </span><span class="identifier">ParseTree::get_control_structure_used</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"  "</span><span class="plain">); </span><span class="functiontext">Sentences::RuleSubtrees::log_control_structure</span><span class="plain">(</span><span class="identifier">csp</span><span class="plain">); </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" "</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pn</span><span class="plain">-&gt;</span><span class="identifier">node_type</span><span class="plain"> == </span><span class="constant">INVOCATION_LIST_NT</span><span class="plain">)</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%d"</span><span class="plain">, </span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="constant">indentation_level_ANNOT</span><span class="plain">));</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" "</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"  "</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_kind_required_by_context</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">))</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" requires:$u"</span><span class="plain">, </span><span class="identifier">ParseTree::get_kind_required_by_context</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">));</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">show_refers</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_subject</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">)) { </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" refers:$j"</span><span class="plain">, </span><span class="identifier">ParseTree::get_subject</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">)); }</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_evaluation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">)) { </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" eval:$P"</span><span class="plain">, </span><span class="identifier">ParseTree::get_evaluation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">)); }</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">implicitly_refers_to_ANNOT</span><span class="plain">)) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" (implicit)"</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">show_eval</span><span class="plain">) &amp;&amp; (</span><span class="identifier">ParseTree::get_evaluation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">))) {</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" eval:$P"</span><span class="plain">, </span><span class="identifier">ParseTree::get_evaluation</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">));</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_defn_language</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">))</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" language:$J"</span><span class="plain">, </span><span class="identifier">ParseTree::get_defn_language</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_creation_proposition</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">))</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" (creation $D)"</span><span class="plain">, </span><span class="identifier">ParseTree::get_creation_proposition</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">));</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP17">&#167;17</a>.</p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::write_to_file</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">ParseTree::write_to_file</span><span class="plain">(</span><span class="identifier">filename_of_parse_tree</span><span class="plain">);</span>
    <span class="plain">}</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::plant_parse_tree</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">ParseTree::plant_parse_tree</span><span class="plain">();</span>
    <span class="plain">}</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::verify</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">ParseTree::verify</span><span class="plain">();</span>
    <span class="plain">}</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ParseTreeUsage::write_main_source_to_log</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">ParseTree::write_main_source_to_log</span><span class="plain">();</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ParseTreeUsage::write_to_file appears nowhere else.</p>

<p class="endnote">The function ParseTreeUsage::plant_parse_tree is used in 1/mr (<a href="1-mr.html#SP4_10">&#167;4.10</a>).</p>

<p class="endnote">The function ParseTreeUsage::verify is used in 1/mr (<a href="1-mr.html#SP4_10">&#167;4.10</a>).</p>

<p class="endnote">The function ParseTreeUsage::write_main_source_to_log is used in 1/mr (<a href="1-mr.html#SP4_18">&#167;4.18</a>).</p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">PARSE_TREE_TRAVERSE_TYPE</span><span class="plain"> </span><span class="reserved">instance</span>
</pre>
<hr class="tocbar">
<ul class="toc"><li><i>(This section begins Chapter 7: Sentences.)</i></li><li><a href="7-ss.html">Continue with 'Structural Sentences'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

