<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Verbal and Relative Clauses</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Preform-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../compiler.html">compiler tools</a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul><h2>Compiler Webs</h2><ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul><h2>Inbuild Modules</h2><ul>
<li><a href="../supervisor-module/index.html">supervisor</a></li>
</ul><h2>Inform7 Modules</h2><ul>
<li><a href="index.html"><span class="selectedlink">core</span></a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul><h2>Inter Modules</h2><ul>
<li><a href="../bytecode-module/index.html">bytecode</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul><h2>Services</h2><ul>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../html-module/index.html">html</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Verbal and Relative Clauses' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../compiler.html">Inform7 Modules</a></li><li><a href="index.html">core</a></li><li><a href="index.html#10">Chapter 10: The S-Parser</a></li><li><b>Verbal and Relative Clauses</b></li></ul></div>
<p class="purpose">To break down an excerpt into NP and VP-like clauses, perhaps with a primary verb (to make a sentence), perhaps only a relative clause (to make a more complex NP).</p>

<ul class="toc"><li><a href="10-varc.html#SP1">&#167;1. Definitions</a></li><li><a href="10-varc.html#SP3">&#167;3. The top level of the S-grammar</a></li><li><a href="10-varc.html#SP9">&#167;9. Tidying up a sentence subtree</a></li><li><a href="10-varc.html#SP10">&#167;10. Values as noun phrases</a></li><li><a href="10-varc.html#SP13">&#167;13. Junction</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="commentary firstcommentary"><a id="SP2"></a><b>&#167;2.  </b>This is a global mode for the S-parser: see below.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">force_all_SP_noun_phrases_to_be_physical</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP3"></a><b>&#167;3. The top level of the S-grammar. </b>English is an SVO language, where the main parts of the sentence occur in the
order subject, verb, object. The following grammar parses that crucial division,
and note that it can be used either to form a complete sentence, where there
is an active verb &mdash;
</p>

<blockquote>
    <p>now the silver bars are in the Hall of Mists;</p>
</blockquote>

<p class="commentary">or alternatively to make a more elaborate noun phrase, using a relative clause,
where there is no active verb:
</p>

<blockquote>
    <p>a woman who carries the silver bars;</p>
</blockquote>

<p class="commentary">We sometimes also have to deal with English's use of "there" as a meaningless
placeholder to stand for a missing noun phrase:
</p>

<blockquote>
    <p>there is an open door</p>
</blockquote>

<p class="commentary firstcommentary"><a id="SP4"></a><b>&#167;4.  </b>The following parses a sentence with an active verb.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-sentence&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-existential-np&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-existential-verb-tail&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-varc.html#SP4_2" class="named-paragraph-link"><span class="named-paragraph">Make SV provided object is descriptive</span><span class="named-paragraph-number">4.2</span></a></span><span class="Preform-constant-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-noun-phrase&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-general-verb-tail&gt;</span><span class="Preform-plain-syntax">			</span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-varc.html#SP4_1" class="named-paragraph-link"><span class="named-paragraph">Make SV</span><span class="named-paragraph-number">4.1</span></a></span><span class="Preform-constant-syntax">;</span>

<span class="Preform-function-syntax">&lt;s-existential-verb-tail&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;copular-verb&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-noun-phrase-nounless&gt;</span><span class="Preform-plain-syntax">			</span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> ExParser::Subtrees::verb_marker(RP[1], NULL, RP[2])</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP4_1"></a><b>&#167;4.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make SV</span><span class="named-paragraph-number">4.1</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><a href="10-varc.html#SP9" class="function-link"><span class="function-syntax">ExParser::Subtrees::correct_for_adjectives</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]);</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">XP</span><span class="plain-syntax"> = </span><a href="10-varc.html#SP13" class="function-link"><span class="function-syntax">ExParser::Subtrees::to_specification</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-varc.html#SP4">&#167;4</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP4_2"></a><b>&#167;4.2.  </b>An ugly trick, invisible from the grammar itself, is that we forbid the
object to be a value. This removes cases like "if there is 21", but in fact
we do it to avoid problem messages whenever a table column exists with the
name "there". (Because of the unfortunately worded phrase "there is T"
for a table reference; the phrase should never have been called something
so ambiguous &mdash; a bad decision in about 2003.)
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make SV provided object is descriptive</span><span class="named-paragraph-number">4.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">op</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2];</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">test</span><span class="plain-syntax"> = </span><span class="identifier-syntax">op</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">test</span><span class="plain-syntax">, </span><span class="identifier-syntax">AMBIGUITY_NT</span><span class="plain-syntax">)) </span><span class="identifier-syntax">test</span><span class="plain-syntax"> = </span><span class="identifier-syntax">test</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="14-sp.html#SP3" class="function-link"><span class="function-syntax">Specifications::is_description_like</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">test</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FAIL_NONTERMINAL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">XP</span><span class="plain-syntax"> = </span><a href="10-varc.html#SP13" class="function-link"><span class="function-syntax">ExParser::Subtrees::to_specification</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">op</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-varc.html#SP4">&#167;4</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP5"></a><b>&#167;5.  </b>More generally, the tail syntax splits according to the verb in question. The
copular verb "to be" has special syntactic rules for its object phrase (for
Inform, at least: linguists would probably analyse this slightly differently).
We've just seen one special point: "to be" can take the placeholder
"there", which no other verb can. (English does allow this, for archaic or
dramatic purposes: "There lurks a mysterious invisible force." Inform
doesn't, and it also doesn't read the mathematical usage "there exists",
though this caused the author a certain pang of regret.) The verb "to be" is
considered "copular" because it acts to combine its subject and object: "X
is 5", "Y is blue", and so on, refer to just one thing but make a statement
about its nature or identity. Other verbs &mdash; "to carry", say &mdash; normally
refer to two different things, at least in their most general forms: "X
carries the briefcase". Therefore:
</p>

<blockquote>
    <p>Mr Cogito is in the Dining Room.</p>
</blockquote>

<p class="commentary">should be parsed, but
</p>

<blockquote>
    <p>Mr Cogito carries in the Dining Room.</p>
</blockquote>

<p class="commentary">should not. One can debate whether this is a difference of syntax or semantics,
but for Inform, it's handled at the syntax level.
</p>

<p class="commentary">The universal verb "to relate" needs a special syntax in order to
handle its extra object: see below.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-general-verb-tail&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;universal-verb&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-universal-relation-term&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> ExParser::Subtrees::verb_marker(RP[1], NULL, RP[2])</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;meaningful-nonimperative-verb&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;permitted-preposition&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-noun-phrase&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> ExParser::Subtrees::verb_marker(RP[1], RP[2], RP[3])</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;meaningful-nonimperative-verb&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-noun-phrase&gt;</span><span class="Preform-plain-syntax">								</span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> ExParser::Subtrees::verb_marker(RP[1], NULL, RP[2])</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP6"></a><b>&#167;6.  </b>The verb marker is a temporary node used just to store the verb or preposition
usage; it's attached to the tree only briefly before sentence conversion
removes it again.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">ExParser::Subtrees::verb_marker</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">ExParser::Subtrees::verb_marker</span></span>:<br/><a href="10-varc.html#SP4">&#167;4</a>, <a href="10-varc.html#SP5">&#167;5</a>, <a href="10-varc.html#SP8">&#167;8</a>, <a href="10-varc.html#SP13_1">&#167;13.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">verb_usage</span><span class="plain-syntax"> *</span><span class="identifier-syntax">vu</span><span class="plain-syntax">, </span><span class="identifier-syntax">preposition_identity</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prep</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">np</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">VP_part</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">UNKNOWN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_vu</span><span class="plain-syntax">(</span><span class="identifier-syntax">VP_part</span><span class="plain-syntax">, </span><span class="identifier-syntax">vu</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_prep</span><span class="plain-syntax">(</span><span class="identifier-syntax">VP_part</span><span class="plain-syntax">, </span><span class="identifier-syntax">prep</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">VP_part</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">np</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">VP_part</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP7"></a><b>&#167;7.  </b>The following catches the "Y to Z" right-hand term of the universal relation,
</p>

<blockquote>
    <p>X relates Y to Z</p>
</blockquote>

<p class="commentary">where Y and Z must somehow be folded into a single noun phrase. Conceptually it
would be neatest to represent this as a combination kind, but that might lead
us to require the presence of the heap, since combinations are stored on the
heap; and that would effectively make "relates" of limited use on Z-machine
works.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-universal-relation-term&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-noun-phrase&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">to</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-noun-phrase&gt;</span><span class="Preform-plain-syntax">	</span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> ExParser::val(Rvalues::from_pair(RP[1], RP[2]), W)</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP8"></a><b>&#167;8.  </b>The following parses a noun phrase with a relative clause, which is
syntactically very similar to the case of a sentence. Sometimes the verb is
explicit, as here:
</p>

<blockquote>
    <p>a woman who does not carry an animal</p>
</blockquote>

<p class="commentary">in which case "who", acting as a marker of the relative clause, is the
only way this differs from a sentence; but sometimes it is implicit:
</p>

<blockquote>
    <p>a woman not in the Hall of Mists</p>
</blockquote>

<p class="commentary">In this case the verb is implicitly the copular verb "to be" and our
grammar has to differ from the sentence grammar above.
</p>

<p class="commentary">Some prepositions imply the player as object: "carried", in the sense of
"to be carried", for instance &mdash; "The briefcase is carried". We fill the
relevant noun subtree with a representation of the player-object for those.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-np-with-relative-clause&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-noun-phrase-nounless&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-implied-relative-verb-tail&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-varc.html#SP8_1" class="named-paragraph-link"><span class="named-paragraph">Make SN</span><span class="named-paragraph-number">8.1</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-noun-phrase&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-relative-verb-tail&gt;</span><span class="Preform-plain-syntax">												</span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-varc.html#SP8_1" class="named-paragraph-link"><span class="named-paragraph">Make SN</span><span class="named-paragraph-number">8.1</span></a></span>

<span class="Preform-function-syntax">&lt;s-implied-relative-verb-tail&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;copular-preposition&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-noun-phrase-nounless&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> ExParser::Subtrees::verb_marker(regular_to_be, RP[1], RP[2])</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">not</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;copular-preposition&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-noun-phrase-nounless&gt;</span><span class="Preform-plain-syntax">									</span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> ExParser::Subtrees::verb_marker(negated_to_be, RP[1], RP[2])</span>

<span class="Preform-function-syntax">&lt;s-relative-verb-tail&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;relative-clause-marker&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;universal-verb&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-universal-relation-term&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> ExParser::Subtrees::verb_marker(RP[2], NULL, RP[3])</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;relative-clause-marker&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;meaningful-nonimperative-verb&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;permitted-preposition&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-noun-phrase&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> ExParser::Subtrees::verb_marker(RP[2], RP[3], RP[4])</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;relative-clause-marker&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;meaningful-nonimperative-verb&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-noun-phrase&gt;</span><span class="Preform-plain-syntax"> 							</span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> ExParser::Subtrees::verb_marker(RP[2], NULL, RP[3])</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP8_1"></a><b>&#167;8.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make SN</span><span class="named-paragraph-number">8.1</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">MATCHING</span><span class="plain-syntax">, </span><span class="string-syntax">"So uncorrectedly RP[1] = $T\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">MATCHING</span><span class="plain-syntax">, </span><span class="string-syntax">"and uncorrectedly RP[2] = $T\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]);</span>
<span class="plain-syntax">    </span><a href="10-varc.html#SP9" class="function-link"><span class="function-syntax">ExParser::Subtrees::correct_for_adjectives</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]);</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">XP</span><span class="plain-syntax"> = </span><a href="10-varc.html#SP13" class="function-link"><span class="function-syntax">ExParser::Subtrees::to_specification</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-varc.html#SP8">&#167;8</a> (twice).</li></ul>
<p class="commentary firstcommentary"><a id="SP9"></a><b>&#167;9. Tidying up a sentence subtree. </b>This checks, in a paranoid sort of way, that a subtree is properly formed,
and also makes one useful correction when it sees a wrong guess as to whether
an adjective is meant as a noun.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">ExParser::Subtrees::correct_for_adjectives</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">ExParser::Subtrees::correct_for_adjectives</span></span>:<br/><a href="10-varc.html#SP4_1">&#167;4.1</a>, <a href="10-varc.html#SP8_1">&#167;8.1</a>, <a href="10-varc.html#SP13_1">&#167;13.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">B</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">subject_phrase_subtree</span><span class="plain-syntax">, *</span><span class="identifier-syntax">object_phrase_subtree</span><span class="plain-syntax">, *</span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">A</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"SV childless"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">subject_phrase_subtree</span><span class="plain-syntax"> = </span><span class="identifier-syntax">A</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax"> = </span><span class="identifier-syntax">B</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"SV childless"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">object_phrase_subtree</span><span class="plain-syntax"> = </span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="10-varc.html#SP9_1" class="named-paragraph-link"><span class="named-paragraph">Modify the object from a noun to an adjective if the subject is also a noun</span><span class="named-paragraph-number">9.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9_1"></a><b>&#167;9.1.  </b>The following is used to correct the SV-subtree for something like "painting
is orange" so that "orange" will be used not as a noun but as an adjective.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Modify the object from a noun to an adjective if the subject is also a noun</span><span class="named-paragraph-number">9.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><a href="14-rv.html#SP3" class="function-link"><span class="function-syntax">Rvalues::to_instance</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">object_phrase_subtree</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">subject_phrase_subtree</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><a href="14-sp.html#SP3" class="function-link"><span class="function-syntax">Specifications::is_description_like</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">subject_phrase_subtree</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">adjq</span><span class="plain-syntax"> = </span><span class="identifier-syntax">object_phrase_subtree</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax"> = </span><a href="14-rv.html#SP3" class="function-link"><span class="function-syntax">Rvalues::to_instance</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">adjq</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="5-ins.html#SP35" class="function-link"><span class="function-syntax">Instances::get_adjective</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">adjective_usage</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ale</span><span class="plain-syntax"> = </span><span class="identifier-syntax">AdjectiveUsages::new</span><span class="plain-syntax">(</span><a href="5-ins.html#SP35" class="function-link"><span class="function-syntax">Instances::get_adjective</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="14-ds.html#SP1" class="function-link"><span class="function-syntax">Descriptions::from_proposition</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">adjq</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><a href="14-ds.html#SP8" class="function-link"><span class="function-syntax">Descriptions::add_to_adjective_list</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">ale</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">spec</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-varc.html#SP9">&#167;9</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP10"></a><b>&#167;10. Values as noun phrases. </b>It is very nearly true that the subject and object noun phrases are parsed
by &lt;s-value&gt;, which was given in "Type Expressions and Values". But there
is a technicality: for reasons to do with ambiguities, &lt;s-value&gt; needs to
be able to try descriptions which involve only physical objects at one stage,
and then later to try other descriptions.
</p>

<p class="commentary">Note that &lt;s-purely-physical-description&gt; calls &lt;s-description&gt; which in
turn may, if there's a relative clause, call &lt;s-np-with-relative-clause&gt; and thus
&lt;s-noun-phrase&gt;. Rather than passing endless copies of a flag down the call
stack, we simply give &lt;s-noun-phrase&gt; a global mode of operation.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-purely-physical-description&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">int</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">s</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">force_all_SP_noun_phrases_to_be_physical</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">force_all_SP_noun_phrases_to_be_physical</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">NULL</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-function-syntax">&lt;s-description&gt;</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">)) </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">force_all_SP_noun_phrases_to_be_physical</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">s</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">) { *</span><span class="Preform-identifier-syntax">XP</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">; </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">; }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">FALSE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">}</span>

<span class="Preform-function-syntax">&lt;if-forced-physical&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">0</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">force_all_SP_noun_phrases_to_be_physical</span><span class="Preform-plain-syntax">) </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">FALSE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP11"></a><b>&#167;11.  </b>The upshot of this is that &lt;s-noun-phrase&gt; is only ever called in "purely
physical mode" when it will later be called outside that mode in any event,
and that therefore the set of excerpts matched by &lt;s-noun-phrase&gt; genuinely
is the same as that matched by &lt;s-value&gt;.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-noun-phrase&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;if-forced-physical&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-variable-as-value&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> RP[2]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;if-forced-physical&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-description&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> RP[2]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">^&lt;if-forced-physical&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-value-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> RP[2]</span>

<span class="Preform-function-syntax">&lt;s-noun-phrase-nounless&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;if-forced-physical&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-variable-as-value&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> RP[2]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;if-forced-physical&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-description-nounless&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> RP[2]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">^&lt;if-forced-physical&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-value-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> RP[2]</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP12"></a><b>&#167;12.  </b>Finally, the following is needed for conditions ("if fixed in place
scenery, ...") where the object referred to is understood from context.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-descriptive-np&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">(</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-descriptive-np&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">)</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> RP[1]</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;cardinal-number&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-varc.html#SP12_1" class="named-paragraph-link"><span class="named-paragraph">Reject a bare number as descriptive</span><span class="named-paragraph-number">12.1</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-description&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-varc.html#SP12_2" class="named-paragraph-link"><span class="named-paragraph">Construct a descriptive SN subtree</span><span class="named-paragraph-number">12.2</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-adjective-list-as-desc&gt;</span><span class="Preform-plain-syntax">	</span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-varc.html#SP12_2" class="named-paragraph-link"><span class="named-paragraph">Construct a descriptive SN subtree</span><span class="named-paragraph-number">12.2</span></a></span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP12_1"></a><b>&#167;12.1.  </b>The reason a literal number is explicitly not allowed to be a condition is
that if something is created called (say) "Room 62" then "62" might be read
by &lt;s-description&gt; as an abbreviated reference to that room. (This doesn't
happen with non-descriptive NPs because then literal values are tried earlier,
pre-empting descriptions.)
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Reject a bare number as descriptive</span><span class="named-paragraph-number">12.1</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FAIL_NONTERMINAL</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-varc.html#SP12">&#167;12</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP12_2"></a><b>&#167;12.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Construct a descriptive SN subtree</span><span class="named-paragraph-number">12.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sn</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1];</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">sn</span><span class="plain-syntax">, </span><span class="constant-syntax">converted_SN_ANNOT</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        *</span><span class="identifier-syntax">XP</span><span class="plain-syntax"> = </span><span class="identifier-syntax">sn</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        *</span><span class="identifier-syntax">XP</span><span class="plain-syntax"> = </span><a href="10-varc.html#SP13" class="function-link"><span class="function-syntax">ExParser::Subtrees::to_specification</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pn</span><span class="plain-syntax"> = *</span><span class="identifier-syntax">XP</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">pn</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-varc.html#SP12">&#167;12</a> (twice).</li></ul>
<p class="commentary firstcommentary"><a id="SP13"></a><b>&#167;13. Junction. </b>At this point we need to join two subtrees, called <span class="extract"><span class="extract-syntax">A</span></span> and <span class="extract"><span class="extract-syntax">B</span></span>. <span class="extract"><span class="extract-syntax">A</span></span> is the
subject of the sentence phrase, <span class="extract"><span class="extract-syntax">B</span></span> contains the verb marker and also the
object.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">PM_DescLocalPast_location</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>

<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">ExParser::Subtrees::to_specification</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">ExParser::Subtrees::to_specification</span></span>:<br/><a href="10-varc.html#SP4_1">&#167;4.1</a>, <a href="10-varc.html#SP4_2">&#167;4.2</a>, <a href="10-varc.html#SP8_1">&#167;8.1</a>, <a href="10-varc.html#SP12_2">&#167;12.2</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">B</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">R</span><span class="plain-syntax"> = </span><a href="10-varc.html#SP13" class="function-link"><span class="function-syntax">ExParser::Subtrees::to_specification_inner</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">B</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">R</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">ExParser::Subtrees::to_specification_inner</span><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">B</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">subject_noun_phrase</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, *</span><span class="identifier-syntax">verb_phrase</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">verb_usage</span><span class="plain-syntax"> *</span><span class="identifier-syntax">vu</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="identifier-syntax">preposition_identity</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prep</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">verb_phrase_negated</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">AMBIGUITY_NT</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">amb</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">poss</span><span class="plain-syntax"> = </span><span class="identifier-syntax">A</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">; </span><span class="identifier-syntax">poss</span><span class="plain-syntax">; </span><span class="identifier-syntax">poss</span><span class="plain-syntax"> = </span><span class="identifier-syntax">poss</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_alternative</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">one</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">poss</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">one</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_alternative</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">new_poss</span><span class="plain-syntax"> = </span><a href="10-varc.html#SP13" class="function-link"><span class="function-syntax">ExParser::Subtrees::to_specification</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">one</span><span class="plain-syntax">, </span><span class="identifier-syntax">B</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (!(</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">new_poss</span><span class="plain-syntax">, </span><span class="identifier-syntax">UNKNOWN_NT</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">amb</span><span class="plain-syntax"> = </span><span class="identifier-syntax">SyntaxTree::add_reading</span><span class="plain-syntax">(</span><span class="identifier-syntax">amb</span><span class="plain-syntax">, </span><span class="identifier-syntax">new_poss</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">amb</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">amb</span><span class="plain-syntax"> = </span><a href="14-sp.html#SP8" class="function-link"><span class="function-syntax">Specifications::new_UNKNOWN</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">amb</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">B</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">B</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">B</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">, </span><span class="identifier-syntax">AMBIGUITY_NT</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">amb</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">poss</span><span class="plain-syntax"> = </span><span class="identifier-syntax">B</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">; </span><span class="identifier-syntax">poss</span><span class="plain-syntax">; </span><span class="identifier-syntax">poss</span><span class="plain-syntax"> = </span><span class="identifier-syntax">poss</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_alternative</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">hmm</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">B</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">hmm</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">poss</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">hmm</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_alternative</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">new_poss</span><span class="plain-syntax"> = </span><a href="10-varc.html#SP13" class="function-link"><span class="function-syntax">ExParser::Subtrees::to_specification</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">hmm</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (!(</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">new_poss</span><span class="plain-syntax">, </span><span class="identifier-syntax">UNKNOWN_NT</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">amb</span><span class="plain-syntax"> = </span><span class="identifier-syntax">SyntaxTree::add_reading</span><span class="plain-syntax">(</span><span class="identifier-syntax">amb</span><span class="plain-syntax">, </span><span class="identifier-syntax">new_poss</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">amb</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">amb</span><span class="plain-syntax"> = </span><a href="14-sp.html#SP8" class="function-link"><span class="function-syntax">Specifications::new_UNKNOWN</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">amb</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="10-varc.html#SP13_1" class="named-paragraph-link"><span class="named-paragraph">Reconstruct a bare description as a sentence with an implied absent subject</span><span class="named-paragraph-number">13.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="10-varc.html#SP13_2" class="named-paragraph-link"><span class="named-paragraph">Check that the top structure of the tree is in order, and obtain the verb</span><span class="named-paragraph-number">13.2</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">subj</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">subj</span><span class="plain-syntax"> = </span><a href="11-tr.html#SP4" class="function-link"><span class="function-syntax">Calculus::Terms::new_constant</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="10-varc.html#SP13_3" class="named-paragraph-link"><span class="named-paragraph">Convert an SV subtree</span><span class="named-paragraph-number">13.3</span></a></span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-varc.html#SP13_4" class="named-paragraph-link"><span class="named-paragraph">Convert an SN subtree</span><span class="named-paragraph-number">13.4</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">spec</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP13_1"></a><b>&#167;13.1.  </b>For instance, "if an open door" can contain a valid condition generating
an SV-subtree: the implied subject is whatever is being discussed (the I6 <span class="extract"><span class="extract-syntax">self</span></span>
object, in practice) and the implied verb is "is", in the present tense.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Reconstruct a bare description as a sentence with an implied absent subject</span><span class="named-paragraph-number">13.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">A</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">B</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">B</span><span class="plain-syntax"> = </span><a href="10-varc.html#SP6" class="function-link"><span class="function-syntax">ExParser::Subtrees::verb_marker</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">regular_to_be</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">A</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">A</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">UNKNOWN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><a href="10-varc.html#SP9" class="function-link"><span class="function-syntax">ExParser::Subtrees::correct_for_adjectives</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">B</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-varc.html#SP13">&#167;13</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP13_2"></a><b>&#167;13.2.  </b>Having performed that manoeuvre, we can be certain that the top of the tree
has the standard form, but we check it anyway.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Check that the top structure of the tree is in order, and obtain the verb</span><span class="named-paragraph-number">13.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">subject_noun_phrase</span><span class="plain-syntax"> = </span><span class="identifier-syntax">A</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">verb_phrase</span><span class="plain-syntax"> = </span><span class="identifier-syntax">B</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">verb_phrase</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">down</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">StandardProblems::s_subtree_error</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="string-syntax">"VP childless"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">verb_phrase</span><span class="plain-syntax">) != </span><span class="identifier-syntax">UNKNOWN_NT</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::s_subtree_error</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="string-syntax">"VP not a VP"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">vu</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_vu</span><span class="plain-syntax">(</span><span class="identifier-syntax">verb_phrase</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">vu</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">StandardProblems::s_subtree_error</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="string-syntax">"verb null"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">verb_phrase_negated</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">VerbUsages::is_used_negatively</span><span class="plain-syntax">(</span><span class="identifier-syntax">vu</span><span class="plain-syntax">))?</span><span class="identifier-syntax">TRUE:FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">prep</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_prep</span><span class="plain-syntax">(</span><span class="identifier-syntax">verb_phrase</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-varc.html#SP13">&#167;13</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP13_3"></a><b>&#167;13.3.  </b>There's a delicate little manoeuvre here. We have to be careful because
the tense and negation operators do not commute with each other: consider
the difference between "it was true that X is not Y" and "it is not true
that X was Y". It's therefore essential to apply these operators in the
correct order. What complicates this is that we have two ways to represent
the negation of an SV: "X is not Y" can be written as the negation operator
applied to "X is Y", which we'll call explicit negation, or as a direct
test of the proposition "not(X is Y)", which is implicit. Explicit negation
is essential if we need a non-present tense, because the tense operator
has to come between the negation operator and the test. So it might seem
that we should always use explicit negation. It makes no difference to
testing propositions, but it does make a difference to the "now" phrase,
because the asserting machinery can't take as wide a range of conditions
as the testing one: so, in general, a condition destined to be used in
a "now" must have implicit negation. Unfortunately, we can't know its
destiny yet. What saves the day is that "now" can only accept present
tense conditions anyway. We therefore adopt explicit negation only when
using a tense other than the present, and all is well.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Convert an SV subtree</span><span class="named-paragraph-number">13.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">pass</span><span class="plain-syntax"> = </span><span class="identifier-syntax">verb_phrase_negated</span><span class="plain-syntax">, </span><span class="identifier-syntax">explicit_negation</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">VerbUsages::is_used_negatively</span><span class="plain-syntax">(</span><span class="identifier-syntax">vu</span><span class="plain-syntax">)) &amp;&amp; (</span><span class="identifier-syntax">VerbUsages::get_tense_used</span><span class="plain-syntax">(</span><span class="identifier-syntax">vu</span><span class="plain-syntax">) != </span><span class="identifier-syntax">IS_TENSE</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">explicit_negation</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">; </span><span class="identifier-syntax">pass</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="14-cn.html#SP8" class="function-link"><span class="function-syntax">Conditions::new_TEST_PROPOSITION</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><a href="11-sc.html#SP1" class="function-link"><span class="function-syntax">Calculus::Propositions::FromSentences::S_subtree</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">B</span><span class="plain-syntax">, </span><span class="identifier-syntax">subj</span><span class="plain-syntax">, </span><span class="identifier-syntax">pass</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_subject_term</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">subj</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) </span><span class="identifier-syntax">Node::set_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">VerbUsages::get_tense_used</span><span class="plain-syntax">(</span><span class="identifier-syntax">vu</span><span class="plain-syntax">) != </span><span class="identifier-syntax">IS_TENSE</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="11-bas.html#SP19" class="function-link"><span class="function-syntax">Calculus::Variables::detect_locals</span></a><span class="plain-syntax">(</span><a href="14-sp.html#SP3" class="function-link"><span class="function-syntax">Specifications::to_proposition</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">), </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="10-varc.html#SP13_3_1" class="named-paragraph-link"><span class="named-paragraph">Issue a problem for referring to temporary values at a time when they did not exist</span><span class="named-paragraph-number">13.3.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="14-cn.html#SP11" class="function-link"><span class="function-syntax">Conditions::attach_tense</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">VerbUsages::get_tense_used</span><span class="plain-syntax">(</span><span class="identifier-syntax">vu</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">explicit_negation</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="14-cn.html#SP7" class="function-link"><span class="function-syntax">Conditions::negate</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-varc.html#SP13">&#167;13</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP13_3_1"></a><b>&#167;13.3.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue a problem for referring to temporary values at a time when they did not exist</span><span class="named-paragraph-number">13.3.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">PM_DescLocalPast_location</span><span class="plain-syntax"> != </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_DescLocalPast</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"conditions written in the past tense cannot refer to "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"temporary values"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"because they have no past. For instance, the name given in a "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"'repeat...' can't be talked about as having existed before, and "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"similarly the pronoun 'it' changes its meaning often, so we can't "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"safely talk about 'it' in the past."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PM_DescLocalPast_location</span><span class="plain-syntax"> = </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-varc.html#SP13_3">&#167;13.3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP13_4"></a><b>&#167;13.4.  </b>This is easier, because tenses don't arise.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Convert an SN subtree</span><span class="named-paragraph-number">13.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="14-ds.html#SP1" class="function-link"><span class="function-syntax">Descriptions::from_proposition</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><a href="11-sc.html#SP1" class="function-link"><span class="function-syntax">Calculus::Propositions::FromSentences::S_subtree</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">B</span><span class="plain-syntax">, </span><span class="identifier-syntax">subj</span><span class="plain-syntax">, </span><span class="identifier-syntax">verb_phrase_negated</span><span class="plain-syntax">), </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_subject_term</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">subj</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="constant-syntax">converted_SN_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">A</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="10-varc.html#SP13_4_1" class="named-paragraph-link"><span class="named-paragraph">Veto certain cases where text was misunderstood as a description</span><span class="named-paragraph-number">13.4.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">VerbUsages::get_tense_used</span><span class="plain-syntax">(</span><span class="identifier-syntax">vu</span><span class="plain-syntax">) != </span><span class="identifier-syntax">IS_TENSE</span><span class="plain-syntax">) </span><a href="10-varc.html#SP14" class="function-link"><span class="function-syntax">ExParser::Subtrees::throw_past_problem</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-varc.html#SP13">&#167;13</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP13_4_1"></a><b>&#167;13.4.1.  </b>This is a little inelegant, but it catches awkward phrases such as "going
south in the Home" which might be read otherwise as "going south" (an action
pattern) plus "in the Home" (a description).
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Veto certain cases where text was misunderstood as a description</span><span class="named-paragraph-number">13.4.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (!((</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="constant-syntax">CONSTANT_NT</span><span class="plain-syntax">)) ||</span>
<span class="plain-syntax">        (</span><a href="14-sp.html#SP3" class="function-link"><span class="function-syntax">Specifications::is_description</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">)) ||</span>
<span class="plain-syntax">        (</span><a href="14-lv.html#SP7" class="function-link"><span class="function-syntax">Lvalues::get_storage_form</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">) == </span><span class="constant-syntax">LOCAL_VARIABLE_NT</span><span class="plain-syntax">) ||</span>
<span class="plain-syntax">        (</span><a href="14-lv.html#SP7" class="function-link"><span class="function-syntax">Lvalues::get_storage_form</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">) == </span><span class="constant-syntax">NONLOCAL_VARIABLE_NT</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="14-sp.html#SP8" class="function-link"><span class="function-syntax">Specifications::new_UNKNOWN</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-varc.html#SP13_4">&#167;13.4</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP14"></a><b>&#167;14.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">ExParser::Subtrees::throw_past_problem</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">ExParser::Subtrees::throw_past_problem</span></span>:<br/><a href="10-varc.html#SP13_4">&#167;13.4</a><br/>Sentence Conversions - <a href="11-sc.html#SP1_4_1">&#167;1.4.1</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">desc</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">PM_PastSubordinate_issued_at</span><span class="plain-syntax"> != </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">PM_PastSubordinate_issued_at</span><span class="plain-syntax"> = </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_PastSubordinate</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                </span><span class="string-syntax">"subordinate clauses have to be in the present tense"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="string-syntax">"so 'the Black Door was open' is fine, but not 'something which "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"was open'. Only the main verb can be in the past tense."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="10-teav.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-cm.html">1</a></li><li class="progresschapter"><a href="2-up.html">2</a></li><li class="progresschapter"><a href="3-nl.html">3</a></li><li class="progresschapter"><a href="4-its.html">4</a></li><li class="progresschapter"><a href="5-lp.html">5</a></li><li class="progresschapter"><a href="6-bp.html">6</a></li><li class="progresschapter"><a href="7-ptu.html">7</a></li><li class="progresschapter"><a href="8-ef.html">8</a></li><li class="progresschapter"><a href="9-ita.html">9</a></li><li class="progresscurrentchapter">10</li><li class="progresssection"><a href="10-aots.html">aots</a></li><li class="progresssection"><a href="10-pl.html">pl</a></li><li class="progresssection"><a href="10-cad.html">cad</a></li><li class="progresssection"><a href="10-teav.html">teav</a></li><li class="progresscurrent">varc</li><li class="progresssection"><a href="10-cap.html">cap</a></li><li class="progresschapter"><a href="11-itpc.html">11</a></li><li class="progresschapter"><a href="12-ter.html">12</a></li><li class="progresschapter"><a href="13-kak.html">13</a></li><li class="progresschapter"><a href="14-sp.html">14</a></li><li class="progresschapter"><a href="15-pr.html">15</a></li><li class="progresschapter"><a href="16-is.html">16</a></li><li class="progresschapter"><a href="17-tl.html">17</a></li><li class="progresschapter"><a href="18-lc.html">18</a></li><li class="progresschapter"><a href="19-tc.html">19</a></li><li class="progresschapter"><a href="20-eq.html">20</a></li><li class="progresschapter"><a href="21-rl.html">21</a></li><li class="progresschapter"><a href="22-itp.html">22</a></li><li class="progresschapter"><a href="23-ad.html">23</a></li><li class="progresschapter"><a href="24-lv.html">24</a></li><li class="progresschapter"><a href="25-in.html">25</a></li><li class="progresschapter"><a href="26-fc.html">26</a></li><li class="progresschapter"><a href="27-hr.html">27</a></li><li class="progressnext"><a href="10-cap.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

