<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>10/teav</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '10/varc' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#10">Chapter 10: The S-Parser</a></li><li><b>Verbal and Relative Clauses</b></li></ul><p class="purpose">To break down an excerpt into NP and VP-like clauses, perhaps with a primary verb (to make a sentence), perhaps only a relative clause (to make a more complex NP).</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP3">&#167;3. The top level of the S-grammar</a></li><li><a href="#SP9">&#167;9. Tidying up a sentence subtree</a></li><li><a href="#SP10">&#167;10. Values as noun phrases</a></li><li><a href="#SP13">&#167;13. Junction</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>This is a global mode for the S-parser: see below.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">force_all_SP_noun_phrases_to_be_physical</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. The top level of the S-grammar. </b>English is an SVO language, where the main parts of the sentence occur in the
order subject, verb, object. The following grammar parses that crucial division,
and note that it can be used either to form a complete sentence, where there
is an active verb &mdash;
</p>

<blockquote>
    <p>now the silver bars are in the Hall of Mists;</p>

</blockquote>

<p class="inwebparagraph">or alternatively to make a more elaborate noun phrase, using a relative clause,
where there is no active verb:
</p>

<blockquote>
    <p>a woman who carries the silver bars;</p>

</blockquote>

<p class="inwebparagraph">We sometimes also have to deal with English's use of "there" as a meaningless
placeholder to stand for a missing noun phrase:
</p>

<blockquote>
    <p>there is an open door</p>

</blockquote>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>The following parses a sentence with an active verb.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">existential</span><span class="plain">-</span><span class="identifier">np</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">existential</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; |	==&gt; </span>&lt;<span class="cwebmacro">Make SV provided object is descriptive</span> <span class="cwebmacronumber">4.2</span>&gt;<span class="plain">;</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">noun</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">general</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt;			==&gt; </span>&lt;<span class="cwebmacro">Make SV</span> <span class="cwebmacronumber">4.1</span>&gt;<span class="plain">;</span>

    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">existential</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">copular</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">noun</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">nounless</span><span class="plain">&gt;			==&gt; </span><span class="functiontext">ExParser::Subtrees::verb_marker</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">RP</span><span class="plain">[2])</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4_1"></a><b>&#167;4.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make SV</span> <span class="cwebmacronumber">4.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="functiontext">ExParser::Subtrees::correct_for_adjectives</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">RP</span><span class="plain">[2]);</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">ExParser::Subtrees::to_specification</span><span class="plain">(</span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">RP</span><span class="plain">[2]);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP4">&#167;4</a>.</p>

<p class="inwebparagraph"><a id="SP4_2"></a><b>&#167;4.2.  </b>An ugly trick, invisible from the grammar itself, is that we forbid the
object to be a value. This removes cases like "if there is 21", but in fact
we do it to avoid problem messages whenever a table column exists with the
name "there". (Because of the unfortunately worded phrase "there is T"
for a table reference; the phrase should never have been called something
so ambiguous &mdash; a bad decision in about 2003.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Make SV provided object is descriptive</span> <span class="cwebmacronumber">4.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">op</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2];</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">test</span><span class="plain"> = </span><span class="identifier">op</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">test</span><span class="plain">, </span><span class="identifier">AMBIGUITY_NT</span><span class="plain">)) </span><span class="identifier">test</span><span class="plain"> = </span><span class="identifier">test</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Specifications::is_description_like</span><span class="plain">(</span><span class="identifier">test</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FAIL_NONTERMINAL</span><span class="plain">;</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">ExParser::Subtrees::to_specification</span><span class="plain">(</span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">op</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP4">&#167;4</a>.</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>More generally, the tail syntax splits according to the verb in question. The
copular verb "to be" has special syntactic rules for its object phrase (for
Inform, at least: linguists would probably analyse this slightly differently).
We've just seen one special point: "to be" can take the placeholder
"there", which no other verb can. (English does allow this, for archaic or
dramatic purposes: "There lurks a mysterious invisible force." Inform
doesn't, and it also doesn't read the mathematical usage "there exists",
though this caused the author a certain pang of regret.) The verb "to be" is
considered "copular" because it acts to combine its subject and object: "X
is 5", "Y is blue", and so on, refer to just one thing but make a statement
about its nature or identity. Other verbs &mdash; "to carry", say &mdash; normally
refer to two different things, at least in their most general forms: "X
carries the briefcase". Therefore:
</p>

<blockquote>
    <p>Mr Cogito is in the Dining Room.</p>

</blockquote>

<p class="inwebparagraph">should be parsed, but
</p>

<blockquote>
    <p>Mr Cogito carries in the Dining Room.</p>

</blockquote>

<p class="inwebparagraph">should not. One can debate whether this is a difference of syntax or semantics,
but for Inform, it's handled at the syntax level.
</p>

<p class="inwebparagraph">The universal verb "to relate" needs a special syntax in order to
handle its extra object: see below.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">general</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">universal</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">universal</span><span class="plain">-</span><span class="identifier">relation</span><span class="plain">-</span><span class="identifier">term</span><span class="plain">&gt; |								==&gt; </span><span class="functiontext">ExParser::Subtrees::verb_marker</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">RP</span><span class="plain">[2])</span>
        <span class="plain">&lt;</span><span class="identifier">meaningful</span><span class="plain">-</span><span class="identifier">nonimperative</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; &lt;</span><span class="identifier">permitted</span><span class="plain">-</span><span class="identifier">preposition</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">noun</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">&gt; |	==&gt; </span><span class="functiontext">ExParser::Subtrees::verb_marker</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">RP</span><span class="plain">[2], </span><span class="identifier">RP</span><span class="plain">[3])</span>
        <span class="plain">&lt;</span><span class="identifier">meaningful</span><span class="plain">-</span><span class="identifier">nonimperative</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">noun</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">&gt;								==&gt; </span><span class="functiontext">ExParser::Subtrees::verb_marker</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">RP</span><span class="plain">[2])</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>The verb marker is a temporary node used just to store the verb or preposition
usage; it's attached to the tree only briefly before sentence conversion
removes it again.
</p>


<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">ExParser::Subtrees::verb_marker</span><span class="plain">(</span><span class="identifier">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">, </span><span class="identifier">preposition_identity</span><span class="plain"> *</span><span class="identifier">prep</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">np</span><span class="plain">) {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">VP_part</span><span class="plain"> = </span><span class="identifier">ParseTree::new</span><span class="plain">(</span><span class="constant">UNKNOWN_NT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::set_vu</span><span class="plain">(</span><span class="identifier">VP_part</span><span class="plain">, </span><span class="identifier">vu</span><span class="plain">);</span>
        <span class="identifier">ParseTree::set_prep</span><span class="plain">(</span><span class="identifier">VP_part</span><span class="plain">, </span><span class="identifier">prep</span><span class="plain">);</span>
        <span class="identifier">VP_part</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> = </span><span class="identifier">np</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">VP_part</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ExParser::Subtrees::verb_marker is used in <a href="#SP4">&#167;4</a>, <a href="#SP5">&#167;5</a>, <a href="#SP8">&#167;8</a>, <a href="#SP13_1">&#167;13.1</a>.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>The following catches the "Y to Z" right-hand term of the universal relation,
</p>

<blockquote>
    <p>X relates Y to Z</p>

</blockquote>

<p class="inwebparagraph">where Y and Z must somehow be folded into a single noun phrase. Conceptually it
would be neatest to represent this as a combination kind, but that might lead
us to require the presence of the heap, since combinations are stored on the
heap; and that would effectively make "relates" of limited use on Z-machine
works.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">universal</span><span class="plain">-</span><span class="identifier">relation</span><span class="plain">-</span><span class="identifier">term</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">noun</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">&gt; </span><span class="identifier">to</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">noun</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">&gt;	==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="functiontext">Rvalues::from_pair</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">RP</span><span class="plain">[2]), </span><span class="identifier">W</span><span class="plain">)</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>The following parses a noun phrase with a relative clause, which is
syntactically very similar to the case of a sentence. Sometimes the verb is
explicit, as here:
</p>

<blockquote>
    <p>a woman who does not carry an animal</p>

</blockquote>

<p class="inwebparagraph">in which case "who", acting as a marker of the relative clause, is the
only way this differs from a sentence; but sometimes it is implicit:
</p>

<blockquote>
    <p>a woman not in the Hall of Mists</p>

</blockquote>

<p class="inwebparagraph">In this case the verb is implicitly the copular verb "to be" and our
grammar has to differ from the sentence grammar above.
</p>

<p class="inwebparagraph">Some prepositions imply the player as object: "carried", in the sense of
"to be carried", for instance &mdash; "The briefcase is carried". We fill the
relevant noun subtree with a representation of the player-object for those.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">np</span><span class="plain">-</span><span class="identifier">with</span><span class="plain">-</span><span class="identifier">relative</span><span class="plain">-</span><span class="identifier">clause</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">noun</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">nounless</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">implied</span><span class="plain">-</span><span class="identifier">relative</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; |							==&gt; </span>&lt;<span class="cwebmacro">Make SN</span> <span class="cwebmacronumber">8.1</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">noun</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">relative</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt;												==&gt; </span>&lt;<span class="cwebmacro">Make SN</span> <span class="cwebmacronumber">8.1</span>&gt;

    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">implied</span><span class="plain">-</span><span class="identifier">relative</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">copular</span><span class="plain">-</span><span class="identifier">preposition</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">noun</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">nounless</span><span class="plain">&gt; |									==&gt; </span><span class="functiontext">ExParser::Subtrees::verb_marker</span><span class="plain">(</span><span class="identifier">regular_to_be</span><span class="plain">, </span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">RP</span><span class="plain">[2])</span>
        <span class="identifier">not</span><span class="plain"> &lt;</span><span class="identifier">copular</span><span class="plain">-</span><span class="identifier">preposition</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">noun</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">nounless</span><span class="plain">&gt;									==&gt; </span><span class="functiontext">ExParser::Subtrees::verb_marker</span><span class="plain">(</span><span class="identifier">negated_to_be</span><span class="plain">, </span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">RP</span><span class="plain">[2])</span>

    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">relative</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">relative</span><span class="plain">-</span><span class="identifier">clause</span><span class="plain">-</span><span class="identifier">marker</span><span class="plain">&gt; &lt;</span><span class="identifier">universal</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">universal</span><span class="plain">-</span><span class="identifier">relation</span><span class="plain">-</span><span class="identifier">term</span><span class="plain">&gt; |				==&gt; </span><span class="functiontext">ExParser::Subtrees::verb_marker</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[2], </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">RP</span><span class="plain">[3])</span>
        <span class="plain">&lt;</span><span class="identifier">relative</span><span class="plain">-</span><span class="identifier">clause</span><span class="plain">-</span><span class="identifier">marker</span><span class="plain">&gt; &lt;</span><span class="identifier">meaningful</span><span class="plain">-</span><span class="identifier">nonimperative</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; &lt;</span><span class="identifier">permitted</span><span class="plain">-</span><span class="identifier">preposition</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">noun</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">&gt; |	==&gt; </span><span class="functiontext">ExParser::Subtrees::verb_marker</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[2], </span><span class="identifier">RP</span><span class="plain">[3], </span><span class="identifier">RP</span><span class="plain">[4])</span>
        <span class="plain">&lt;</span><span class="identifier">relative</span><span class="plain">-</span><span class="identifier">clause</span><span class="plain">-</span><span class="identifier">marker</span><span class="plain">&gt; &lt;</span><span class="identifier">meaningful</span><span class="plain">-</span><span class="identifier">nonimperative</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">noun</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">&gt; 							==&gt; </span><span class="functiontext">ExParser::Subtrees::verb_marker</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[2], </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">RP</span><span class="plain">[3])</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8_1"></a><b>&#167;8.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make SN</span> <span class="cwebmacronumber">8.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">MATCHING</span><span class="plain">, </span><span class="string">"So uncorrectedly RP[1] = $T\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">RP</span><span class="plain">[1]);</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">MATCHING</span><span class="plain">, </span><span class="string">"and uncorrectedly RP[2] = $T\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">RP</span><span class="plain">[2]);</span>
        <span class="functiontext">ExParser::Subtrees::correct_for_adjectives</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">RP</span><span class="plain">[2]);</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">ExParser::Subtrees::to_specification</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">RP</span><span class="plain">[2]);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a> (twice).</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Tidying up a sentence subtree. </b>This checks, in a paranoid sort of way, that a subtree is properly formed,
and also makes one useful correction when it sees a wrong guess as to whether
an adjective is meant as a noun.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ExParser::Subtrees::correct_for_adjectives</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">A</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">B</span><span class="plain">) {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">subject_phrase_subtree</span><span class="plain">, *</span><span class="identifier">object_phrase_subtree</span><span class="plain">, *</span><span class="identifier">verb_phrase_subtree</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">A</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"SV childless"</span><span class="plain">);</span>

        <span class="identifier">subject_phrase_subtree</span><span class="plain"> = </span><span class="identifier">A</span><span class="plain">;</span>
        <span class="identifier">verb_phrase_subtree</span><span class="plain"> = </span><span class="identifier">B</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">verb_phrase_subtree</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"SV childless"</span><span class="plain">);</span>

        <span class="identifier">object_phrase_subtree</span><span class="plain"> = </span><span class="identifier">verb_phrase_subtree</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">;</span>
        &lt;<span class="cwebmacro">Modify the object from a noun to an adjective if the subject is also a noun</span> <span class="cwebmacronumber">9.1</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ExParser::Subtrees::correct_for_adjectives is used in <a href="#SP4_1">&#167;4.1</a>, <a href="#SP8_1">&#167;8.1</a>, <a href="#SP13_1">&#167;13.1</a>.</p>

<p class="inwebparagraph"><a id="SP9_1"></a><b>&#167;9.1.  </b>The following is used to correct the SV-subtree for something like "painting
is orange" so that "orange" will be used not as a noun but as an adjective.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Modify the object from a noun to an adjective if the subject is also a noun</span> <span class="cwebmacronumber">9.1</span>&gt; =
</code></p>


<pre class="displaydefn">

        <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">Rvalues::to_instance</span><span class="plain">(</span><span class="identifier">object_phrase_subtree</span><span class="plain">)) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">subject_phrase_subtree</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="functiontext">Specifications::is_description_like</span><span class="plain">(</span><span class="identifier">subject_phrase_subtree</span><span class="plain">))) {</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">adjq</span><span class="plain"> = </span><span class="identifier">object_phrase_subtree</span><span class="plain">;</span>
            <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain"> = </span><span class="functiontext">Rvalues::to_instance</span><span class="plain">(</span><span class="identifier">adjq</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Instances::get_adjectival_phrase</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">)) {</span>
                <span class="identifier">adjective_usage</span><span class="plain"> *</span><span class="identifier">ale</span><span class="plain"> = </span><span class="identifier">AdjectiveUsages::new</span><span class="plain">(</span><span class="functiontext">Instances::get_adjectival_phrase</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">), </span><span class="identifier">TRUE</span><span class="plain">);</span>
                <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Descriptions::from_proposition</span><span class="plain">(</span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">adjq</span><span class="plain">));</span>
                <span class="functiontext">Descriptions::add_to_adjective_list</span><span class="plain">(</span><span class="identifier">ale</span><span class="plain">, </span><span class="identifier">spec</span><span class="plain">);</span>
                <span class="identifier">verb_phrase_subtree</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP9">&#167;9</a>.</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Values as noun phrases. </b>It is very nearly true that the subject and object noun phrases are parsed
by &lt;s-value&gt;, which was given in "Type Expressions and Values". But there
is a technicality: for reasons to do with ambiguities, &lt;s-value&gt; needs to
be able to try descriptions which involve only physical objects at one stage,
and then later to try other descriptions.
</p>

<p class="inwebparagraph">Note that &lt;s-purely-physical-description&gt; calls &lt;s-description&gt; which in
turn may, if there's a relative clause, call &lt;s-np-with-relative-clause&gt; and thus
&lt;s-noun-phrase&gt;. Rather than passing endless copies of a flag down the call
stack, we simply give &lt;s-noun-phrase&gt; a global mode of operation.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">purely</span><span class="plain">-</span><span class="identifier">physical</span><span class="plain">-</span><span class="identifier">description</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">s</span><span class="plain"> = </span><span class="identifier">force_all_SP_noun_phrases_to_be_physical</span><span class="plain">;</span>
        <span class="identifier">force_all_SP_noun_phrases_to_be_physical</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">description</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) </span><span class="identifier">p</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
        <span class="identifier">force_all_SP_noun_phrases_to_be_physical</span><span class="plain"> = </span><span class="identifier">s</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">) { *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">; }</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">forced</span><span class="plain">-</span><span class="identifier">physical</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> 0 {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">force_all_SP_noun_phrases_to_be_physical</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b>The upshot of this is that &lt;s-noun-phrase&gt; is only ever called in "purely
physical mode" when it will later be called outside that mode in any event,
and that therefore the set of excerpts matched by &lt;s-noun-phrase&gt; genuinely
is the same as that matched by &lt;s-value&gt;.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">noun</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">forced</span><span class="plain">-</span><span class="identifier">physical</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">&gt; |		==&gt; </span><span class="identifier">RP</span><span class="plain">[2]</span>
        <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">forced</span><span class="plain">-</span><span class="identifier">physical</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">description</span><span class="plain">&gt; |				==&gt; </span><span class="identifier">RP</span><span class="plain">[2]</span>
        <span class="plain">^&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">forced</span><span class="plain">-</span><span class="identifier">physical</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt; |			==&gt; </span><span class="identifier">RP</span><span class="plain">[2]</span>

    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">noun</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">nounless</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">forced</span><span class="plain">-</span><span class="identifier">physical</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">&gt; |		==&gt; </span><span class="identifier">RP</span><span class="plain">[2]</span>
        <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">forced</span><span class="plain">-</span><span class="identifier">physical</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">description</span><span class="plain">-</span><span class="identifier">nounless</span><span class="plain">&gt; |		==&gt; </span><span class="identifier">RP</span><span class="plain">[2]</span>
        <span class="plain">^&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">forced</span><span class="plain">-</span><span class="identifier">physical</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt; |			==&gt; </span><span class="identifier">RP</span><span class="plain">[2]</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b>Finally, the following is needed for conditions ("if fixed in place
scenery, ...") where the object referred to is understood from context.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">descriptive</span><span class="plain">-</span><span class="identifier">np</span><span class="plain">&gt; ::=</span>
        <span class="plain">( &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">descriptive</span><span class="plain">-</span><span class="identifier">np</span><span class="plain">&gt; ) |	==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">cardinal</span><span class="plain">-</span><span class="identifier">number</span><span class="plain">&gt; |			==&gt; </span>&lt;<span class="cwebmacro">Reject a bare number as descriptive</span> <span class="cwebmacronumber">12.1</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">description</span><span class="plain">&gt; |			==&gt; </span>&lt;<span class="cwebmacro">Construct a descriptive SN subtree</span> <span class="cwebmacronumber">12.2</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">desc</span><span class="plain">&gt;	==&gt; </span>&lt;<span class="cwebmacro">Construct a descriptive SN subtree</span> <span class="cwebmacronumber">12.2</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP12_1"></a><b>&#167;12.1.  </b>The reason a literal number is explicitly not allowed to be a condition is
that if something is created called (say) "Room 62" then "62" might be read
by &lt;s-description&gt; as an abbreviated reference to that room. (This doesn't
happen with non-descriptive NPs because then literal values are tried earlier,
pre-empting descriptions.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Reject a bare number as descriptive</span> <span class="cwebmacronumber">12.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FAIL_NONTERMINAL</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP12_2"></a><b>&#167;12.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Construct a descriptive SN subtree</span> <span class="cwebmacronumber">12.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">sn</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">sn</span><span class="plain">, </span><span class="constant">converted_SN_ANNOT</span><span class="plain">)) {</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">sn</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">ExParser::Subtrees::to_specification</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain"> = *</span><span class="identifier">XP</span><span class="plain">;</span>
        <span class="identifier">ParseTree::set_text</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a> (twice).</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. Junction. </b>At this point we need to join two subtrees, called <code class="display"><span class="extract">A</span></code> and <code class="display"><span class="extract">B</span></code>. <code class="display"><span class="extract">A</span></code> is the
subject of the sentence phrase, <code class="display"><span class="extract">B</span></code> contains the verb marker and also the
object.
</p>


<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">PM_DescLocalPast_location</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>

    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">ExParser::Subtrees::to_specification</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">SV_not_SN</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">A</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">B</span><span class="plain">) {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">R</span><span class="plain"> = </span><span class="functiontext">ExParser::Subtrees::to_specification_inner</span><span class="plain">(</span><span class="identifier">SV_not_SN</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">A</span><span class="plain">, </span><span class="identifier">B</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">R</span><span class="plain">;</span>
    <span class="plain">}</span>
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">ExParser::Subtrees::to_specification_inner</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">SV_not_SN</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">A</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">B</span><span class="plain">) {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">;</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">subject_noun_phrase</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">, *</span><span class="identifier">verb_phrase</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="identifier">preposition_identity</span><span class="plain"> *</span><span class="identifier">prep</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">verb_phrase_negated</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">A</span><span class="plain">, </span><span class="identifier">AMBIGUITY_NT</span><span class="plain">)) {</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">amb</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">poss</span><span class="plain"> = </span><span class="identifier">A</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">; </span><span class="identifier">poss</span><span class="plain">; </span><span class="identifier">poss</span><span class="plain"> = </span><span class="identifier">poss</span><span class="plain">-&gt;</span><span class="identifier">next_alternative</span><span class="plain">) {</span>
                <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">one</span><span class="plain"> = </span><span class="identifier">ParseTree::duplicate</span><span class="plain">(</span><span class="identifier">poss</span><span class="plain">);</span>
                <span class="identifier">one</span><span class="plain">-&gt;</span><span class="identifier">next_alternative</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
                <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">new_poss</span><span class="plain"> = </span><span class="functiontext">ExParser::Subtrees::to_specification</span><span class="plain">(</span><span class="identifier">SV_not_SN</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">one</span><span class="plain">, </span><span class="identifier">B</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (!(</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">new_poss</span><span class="plain">, </span><span class="constant">UNKNOWN_NT</span><span class="plain">)))</span>
                    <span class="identifier">amb</span><span class="plain"> = </span><span class="identifier">ParseTree::add_possible_reading</span><span class="plain">(</span><span class="identifier">amb</span><span class="plain">, </span><span class="identifier">new_poss</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">amb</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">amb</span><span class="plain"> = </span><span class="functiontext">Specifications::new_UNKNOWN</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">amb</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">B</span><span class="plain">) &amp;&amp; (</span><span class="identifier">B</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">) &amp;&amp; (</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">B</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">, </span><span class="identifier">AMBIGUITY_NT</span><span class="plain">))) {</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">amb</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">poss</span><span class="plain"> = </span><span class="identifier">B</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">; </span><span class="identifier">poss</span><span class="plain">; </span><span class="identifier">poss</span><span class="plain"> = </span><span class="identifier">poss</span><span class="plain">-&gt;</span><span class="identifier">next_alternative</span><span class="plain">) {</span>
                <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">hmm</span><span class="plain"> = </span><span class="identifier">ParseTree::duplicate</span><span class="plain">(</span><span class="identifier">B</span><span class="plain">);</span>
                <span class="identifier">hmm</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> = </span><span class="identifier">ParseTree::duplicate</span><span class="plain">(</span><span class="identifier">poss</span><span class="plain">);</span>
                <span class="identifier">hmm</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-&gt;</span><span class="identifier">next_alternative</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
                <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">new_poss</span><span class="plain"> = </span><span class="functiontext">ExParser::Subtrees::to_specification</span><span class="plain">(</span><span class="identifier">SV_not_SN</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">A</span><span class="plain">, </span><span class="identifier">hmm</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (!(</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">new_poss</span><span class="plain">, </span><span class="constant">UNKNOWN_NT</span><span class="plain">)))</span>
                    <span class="identifier">amb</span><span class="plain"> = </span><span class="identifier">ParseTree::add_possible_reading</span><span class="plain">(</span><span class="identifier">amb</span><span class="plain">, </span><span class="identifier">new_poss</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">amb</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">amb</span><span class="plain"> = </span><span class="functiontext">Specifications::new_UNKNOWN</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">amb</span><span class="plain">;</span>
        <span class="plain">}</span>
        &lt;<span class="cwebmacro">Reconstruct a bare description as a sentence with an implied absent subject</span> <span class="cwebmacronumber">13.1</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Check that the top structure of the tree is in order, and obtain the verb</span> <span class="cwebmacronumber">13.2</span>&gt;<span class="plain">;</span>

        <span class="reserved">pcalc_term</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">pcalc_term</span><span class="plain">);</span>
        <span class="plain">*</span><span class="identifier">subj</span><span class="plain"> = </span><span class="functiontext">Calculus::Terms::new_constant</span><span class="plain">(</span><span class="identifier">NULL</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">SV_not_SN</span><span class="plain">) </span>&lt;<span class="cwebmacro">Convert an SV subtree</span> <span class="cwebmacronumber">13.3</span>&gt;
        <span class="reserved">else</span><span class="plain"> </span>&lt;<span class="cwebmacro">Convert an SN subtree</span> <span class="cwebmacronumber">13.4</span>&gt;<span class="plain">;</span>

        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">spec</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ExParser::Subtrees::to_specification is used in <a href="#SP4_1">&#167;4.1</a>, <a href="#SP4_2">&#167;4.2</a>, <a href="#SP8_1">&#167;8.1</a>, <a href="#SP12_2">&#167;12.2</a>.</p>

<p class="endnote">The function ExParser::Subtrees::to_specification_inner appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP13_1"></a><b>&#167;13.1.  </b>For instance, "if an open door" can contain a valid condition generating
an SV-subtree: the implied subject is whatever is being discussed (the I6 <code class="display"><span class="extract">self</span></code>
object, in practice) and the implied verb is "is", in the present tense.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Reconstruct a bare description as a sentence with an implied absent subject</span> <span class="cwebmacronumber">13.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">A</span><span class="plain">) &amp;&amp; (</span><span class="identifier">B</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)) {</span>
            <span class="identifier">B</span><span class="plain"> = </span><span class="functiontext">ExParser::Subtrees::verb_marker</span><span class="plain">(</span><span class="identifier">regular_to_be</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">A</span><span class="plain">);</span>
            <span class="identifier">A</span><span class="plain"> = </span><span class="identifier">ParseTree::new</span><span class="plain">(</span><span class="constant">UNKNOWN_NT</span><span class="plain">);</span>
            <span class="identifier">SV_not_SN</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="functiontext">ExParser::Subtrees::correct_for_adjectives</span><span class="plain">(</span><span class="identifier">A</span><span class="plain">, </span><span class="identifier">B</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP13">&#167;13</a>.</p>

<p class="inwebparagraph"><a id="SP13_2"></a><b>&#167;13.2.  </b>Having performed that manoeuvre, we can be certain that the top of the tree
has the standard form, but we check it anyway.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Check that the top structure of the tree is in order, and obtain the verb</span> <span class="cwebmacronumber">13.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">subject_noun_phrase</span><span class="plain"> = </span><span class="identifier">A</span><span class="plain">;</span>
        <span class="identifier">verb_phrase</span><span class="plain"> = </span><span class="identifier">B</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">verb_phrase</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">Problems::Issue::s_subtree_error</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="string">"VP childless"</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">verb_phrase</span><span class="plain">) != </span><span class="constant">UNKNOWN_NT</span><span class="plain">)</span>
            <span class="identifier">Problems::Issue::s_subtree_error</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="string">"VP not a VP"</span><span class="plain">);</span>

        <span class="identifier">vu</span><span class="plain"> = </span><span class="identifier">ParseTree::get_vu</span><span class="plain">(</span><span class="identifier">verb_phrase</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vu</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">Problems::Issue::s_subtree_error</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="string">"verb null"</span><span class="plain">);</span>
        <span class="identifier">verb_phrase_negated</span><span class="plain"> = (</span><span class="identifier">VerbUsages::is_used_negatively</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">))?</span><span class="identifier">TRUE</span><span class="plain">:</span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">prep</span><span class="plain"> = </span><span class="identifier">ParseTree::get_prep</span><span class="plain">(</span><span class="identifier">verb_phrase</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP13">&#167;13</a>.</p>

<p class="inwebparagraph"><a id="SP13_3"></a><b>&#167;13.3.  </b>There's a delicate little manoeuvre here. We have to be careful because
the tense and negation operators do not commute with each other: consider
the difference between "it was true that X is not Y" and "it is not true
that X was Y". It's therefore essential to apply these operators in the
correct order. What complicates this is that we have two ways to represent
the negation of an SV: "X is not Y" can be written as the negation operator
applied to "X is Y", which we'll call explicit negation, or as a direct
test of the proposition "not(X is Y)", which is implicit. Explicit negation
is essential if we need a non-present tense, because the tense operator
has to come between the negation operator and the test. So it might seem
that we should always use explicit negation. It makes no difference to
testing propositions, but it does make a difference to the "now" phrase,
because the asserting machinery can't take as wide a range of conditions
as the testing one: so, in general, a condition destined to be used in
a "now" must have implicit negation. Unfortunately, we can't know its
destiny yet. What saves the day is that "now" can only accept present
tense conditions anyway. We therefore adopt explicit negation only when
using a tense other than the present, and all is well.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Convert an SV subtree</span> <span class="cwebmacronumber">13.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">pass</span><span class="plain"> = </span><span class="identifier">verb_phrase_negated</span><span class="plain">, </span><span class="identifier">explicit_negation</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">VerbUsages::is_used_negatively</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">VerbUsages::get_tense_used</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">) != </span><span class="identifier">IS_TENSE</span><span class="plain">)) {</span>
            <span class="identifier">explicit_negation</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="identifier">pass</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Conditions::new_TEST_PROPOSITION</span><span class="plain">(</span>
            <span class="functiontext">Calculus::Propositions::FromSentences::S_subtree</span><span class="plain">(</span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">A</span><span class="plain">, </span><span class="identifier">B</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">pass</span><span class="plain">));</span>
        <span class="identifier">ParseTree::set_subject_term</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="identifier">ParseTree::set_text</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">VerbUsages::get_tense_used</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">) != </span><span class="identifier">IS_TENSE</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Variables::detect_locals</span><span class="plain">(</span><span class="functiontext">Specifications::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">), </span><span class="identifier">NULL</span><span class="plain">) &gt; 0)</span>
                &lt;<span class="cwebmacro">Issue a problem for referring to temporary values at a time when they did not exist</span> <span class="cwebmacronumber">13.3.1</span>&gt;<span class="plain">;</span>
            <span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Conditions::attach_tense</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">VerbUsages::get_tense_used</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">));</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">explicit_negation</span><span class="plain">)</span>
            <span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Conditions::negate</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP13">&#167;13</a>.</p>

<p class="inwebparagraph"><a id="SP13_3_1"></a><b>&#167;13.3.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue a problem for referring to temporary values at a time when they did not exist</span> <span class="cwebmacronumber">13.3.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">PM_DescLocalPast_location</span><span class="plain"> != </span><span class="identifier">current_sentence</span><span class="plain">)</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_DescLocalPast</span><span class="plain">),</span>
                <span class="string">"conditions written in the past tense cannot refer to "</span>
                <span class="string">"temporary values"</span><span class="plain">,</span>
                <span class="string">"because they have no past. For instance, the name given in a "</span>
                <span class="string">"'repeat...' can't be talked about as having existed before, and "</span>
                <span class="string">"similarly the pronoun 'it' changes its meaning often, so we can't "</span>
                <span class="string">"safely talk about 'it' in the past."</span><span class="plain">);</span>
        <span class="identifier">PM_DescLocalPast_location</span><span class="plain"> = </span><span class="identifier">current_sentence</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP13_3">&#167;13.3</a>.</p>

<p class="inwebparagraph"><a id="SP13_4"></a><b>&#167;13.4.  </b>This is easier, because tenses don't arise.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Convert an SN subtree</span> <span class="cwebmacronumber">13.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Descriptions::from_proposition</span><span class="plain">(</span>
            <span class="functiontext">Calculus::Propositions::FromSentences::S_subtree</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">A</span><span class="plain">, </span><span class="identifier">B</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">, </span><span class="identifier">verb_phrase_negated</span><span class="plain">), </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">ParseTree::set_subject_term</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">subj</span><span class="plain">);</span>
        <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="constant">converted_SN_ANNOT</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">A</span><span class="plain">) </span>&lt;<span class="cwebmacro">Veto certain cases where text was misunderstood as a description</span> <span class="cwebmacronumber">13.4.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">VerbUsages::get_tense_used</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">) != </span><span class="identifier">IS_TENSE</span><span class="plain">) </span><span class="functiontext">ExParser::Subtrees::throw_past_problem</span><span class="plain">(</span><span class="identifier">TRUE</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP13">&#167;13</a>.</p>

<p class="inwebparagraph"><a id="SP13_4_1"></a><b>&#167;13.4.1.  </b>This is a little inelegant, but it catches awkward phrases such as "going
south in the Home" which might be read otherwise as "going south" (an action
pattern) plus "in the Home" (a description).
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Veto certain cases where text was misunderstood as a description</span> <span class="cwebmacronumber">13.4.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (!((</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">A</span><span class="plain">, </span><span class="constant">CONSTANT_NT</span><span class="plain">)) ||</span>
            <span class="plain">(</span><span class="functiontext">Specifications::is_description</span><span class="plain">(</span><span class="identifier">A</span><span class="plain">)) ||</span>
            <span class="plain">(</span><span class="functiontext">Lvalues::get_storage_form</span><span class="plain">(</span><span class="identifier">A</span><span class="plain">) == </span><span class="constant">LOCAL_VARIABLE_NT</span><span class="plain">) ||</span>
            <span class="plain">(</span><span class="functiontext">Lvalues::get_storage_form</span><span class="plain">(</span><span class="identifier">A</span><span class="plain">) == </span><span class="constant">NONLOCAL_VARIABLE_NT</span><span class="plain">)))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Specifications::new_UNKNOWN</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP13_4">&#167;13.4</a>.</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ExParser::Subtrees::throw_past_problem</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">desc</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">PM_PastSubordinate_issued_at</span><span class="plain"> != </span><span class="identifier">current_sentence</span><span class="plain">) {</span>
            <span class="identifier">PM_PastSubordinate_issued_at</span><span class="plain"> = </span><span class="identifier">current_sentence</span><span class="plain">;</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_PastSubordinate</span><span class="plain">),</span>
                    <span class="string">"subordinate clauses have to be in the present tense"</span><span class="plain">,</span>
                    <span class="string">"so 'the Black Door was open' is fine, but not 'something which "</span>
                    <span class="string">"was open'. Only the main verb can be in the past tense."</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ExParser::Subtrees::throw_past_problem is used in <a href="#SP13_4">&#167;13.4</a>, 11/sc (<a href="11-sc.html#SP1_4_1">&#167;1.4.1</a>).</p>

<hr class="tocbar">
<ul class="toc"><li><a href="10-teav.html">Back to 'Type Expressions and Values'</a></li><li><a href="10-cap.html">Continue with 'Conditions and Phrases'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

