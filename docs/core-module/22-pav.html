<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>22/po</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '22/pav' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#22">Chapter 22: Phrases</a></li><li><b>Phrases as Values</b></li></ul><p class="purpose">To provide the names of phrases as first-class values.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>A few "To..." phrases have names, and can therefore be used as values in their
own right, a functional-programming sort of device. For example:
</p>

<blockquote>
    <p>To decide what number is double (N - a number) (this is doubling):</p>

</blockquote>

<p class="inwebparagraph">has the name "doubling". Such a name is recorded here:
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">constant_phrase</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">noun</span><span class="plain"> *</span><span class="identifier">name</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">phrase</span><span class="plain"> *</span><span class="identifier">phrase_meant</span><span class="plain">; </span>    <span class="comment">if known at this point</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">cphr_kind</span><span class="plain">; </span>    <span class="comment">ditto</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">cphr_iname</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">associated_preamble_text</span><span class="plain">;</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">constant_phrase</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure constant_phrase is accessed in 2/sq, 2/si, 5/ins, 5/nv, 8/ed2, 9/ma, 9/pk, 11/sm, 14/lv, 14/ds2, 15/pr, 15/ep, 15/vp, 15/spr, 16/in, 16/cmw, 17/rs, 19/tc, 19/tb, 19/tod, 20/eq, 21/rl, 21/rl2, 21/fao, 21/rps, 21/sv, 21/ac, 22/pu, 22/dptd, 22/po, 25/cii, 26/uo, 26/ts and here.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>Here we create a new named phrase ("doubling", say):
</p>


<pre class="display">
    <span class="reserved">constant_phrase</span><span class="plain"> *</span><span class="functiontext">Phrases::Constants::create</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">NW</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">RW</span><span class="plain">) {</span>
        <span class="reserved">constant_phrase</span><span class="plain"> *</span><span class="identifier">cphr</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">constant_phrase</span><span class="plain">);</span>
        <span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;phrase_meant</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">we won't know until later</span>
        <span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;cphr_kind</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">nor this</span>
        <span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;associated_preamble_text</span><span class="plain"> = </span><span class="identifier">RW</span><span class="plain">;</span>
        <span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain"> = </span><span class="identifier">Nouns::new_proper_noun</span><span class="plain">(</span><span class="identifier">NW</span><span class="plain">, </span><span class="identifier">NEUTER_GENDER</span><span class="plain">,</span>
            <span class="identifier">REGISTER_SINGULAR_NTOPT</span><span class="plain"> + </span><span class="identifier">PARSE_EXACTLY_NTOPT</span><span class="plain">,</span>
            <span class="constant">PHRASE_CONSTANT_MC</span><span class="plain">, </span><span class="functiontext">Rvalues::from_constant_phrase</span><span class="plain">(</span><span class="identifier">cphr</span><span class="plain">));</span>
        <span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;cphr_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">cphr</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::Constants::create is used in 22/pu (<a href="22-pu.html#SP10_2_1">&#167;10.2.1</a>).</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>...and parse for an existing one:
</p>


<pre class="display">
    <span class="reserved">constant_phrase</span><span class="plain"> *</span><span class="functiontext">Phrases::Constants::parse</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">NW</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">&gt;(</span><span class="identifier">NW</span><span class="plain">)) {</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Rvalues::is_CONSTANT_construction</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">CON_phrase</span><span class="plain">)) {</span>
                <span class="reserved">constant_phrase</span><span class="plain"> *</span><span class="identifier">cphr</span><span class="plain"> = </span><span class="functiontext">Rvalues::to_constant_phrase</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
                <span class="functiontext">Phrases::Constants::kind</span><span class="plain">(</span><span class="identifier">cphr</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">cphr</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::Constants::parse is used in 22/pu (<a href="22-pu.html#SP10_2_1">&#167;10.2.1</a>).</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>As often happens with Inform constants, the kind of a constant phrase can't
be known when its name first comes up, and must be filled in later. (In
particular, before the second traverse many kinds do not yet exist.) So
the following takes a patch-it-later approach.
</p>


<pre class="display">
    <span class="identifier">kind</span><span class="plain"> *</span><span class="functiontext">Phrases::Constants::kind</span><span class="plain">(</span><span class="reserved">constant_phrase</span><span class="plain"> *</span><span class="identifier">cphr</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">cphr</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">traverse</span><span class="plain"> &lt; 2) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">Kinds::binary_construction</span><span class="plain">(</span><span class="identifier">CON_phrase</span><span class="plain">, </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">K_value</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;cphr_kind</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
            <span class="reserved">ph_type_data</span><span class="plain"> </span><span class="identifier">phtd</span><span class="plain"> = </span><span class="functiontext">Phrases::TypeData::new</span><span class="plain">();</span>
            <span class="functiontext">Phrases::TypeData::Textual::parse</span><span class="plain">(&amp;</span><span class="identifier">phtd</span><span class="plain">,</span>
                <span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;associated_preamble_text</span><span class="plain">, &amp;</span><span class="identifier">OW</span><span class="plain">);</span>
            <span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;cphr_kind</span><span class="plain"> = </span><span class="functiontext">Phrases::TypeData::kind</span><span class="plain">(&amp;</span><span class="identifier">phtd</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;cphr_kind</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::Constants::kind is used in <a href="#SP4">&#167;4</a>, <a href="#SP7">&#167;7</a>, <a href="#SP8">&#167;8</a>, <a href="#SP8_1">&#167;8.1</a>, 14/rv (<a href="14-rv.html#SP23_6">&#167;23.6</a>).</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>And similarly for the <code class="display"><span class="extract">phrase</span></code> structure this name corresponds to.
</p>


<pre class="display">
    <span class="reserved">phrase</span><span class="plain"> *</span><span class="functiontext">Phrases::Constants::as_phrase</span><span class="plain">(</span><span class="reserved">constant_phrase</span><span class="plain"> *</span><span class="identifier">cphr</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">cphr</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"null cphr"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;phrase_meant</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="reserved">phrase</span><span class="plain"> *</span><span class="identifier">ph</span><span class="plain">;</span>
            <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">ph</span><span class="plain">, </span><span class="reserved">phrase</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ph</span><span class="plain">-</span><span class="element">&gt;usage_data.constant_phrase_holder</span><span class="plain"> == </span><span class="identifier">cphr</span><span class="plain">) {</span>
                    <span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;phrase_meant</span><span class="plain"> = </span><span class="identifier">ph</span><span class="plain">;</span>
                    <span class="reserved">break</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;phrase_meant</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::Constants::as_phrase is used in <a href="#SP7">&#167;7</a>, <a href="#SP8">&#167;8</a>, 22/pu (<a href="22-pu.html#SP10_2_1">&#167;10.2.1</a>).</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>So much for setting up constant phrases. Now we come to compilation, and
a surprise. It might be expected that a constant phrase compiles simply to
an I6 routine name, but no: it compiles to a small array called a "closure".
</p>


<pre class="display">
    <span class="reserved">inter_name</span><span class="plain"> *</span><span class="functiontext">Phrases::Constants::compile</span><span class="plain">(</span><span class="reserved">constant_phrase</span><span class="plain"> *</span><span class="identifier">cphr</span><span class="plain">) {</span>
        <span class="reserved">phrase</span><span class="plain"> *</span><span class="identifier">ph</span><span class="plain"> = </span><span class="functiontext">Phrases::Constants::as_phrase</span><span class="plain">(</span><span class="identifier">cphr</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ph</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"cannot reconstruct phrase from cphr"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Phrases::compiled_inline</span><span class="plain">(</span><span class="identifier">ph</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)</span>
            <span class="functiontext">Routines::ToPhrases::make_request</span><span class="plain">(</span><span class="identifier">ph</span><span class="plain">,</span>
                <span class="functiontext">Phrases::Constants::kind</span><span class="plain">(</span><span class="identifier">cphr</span><span class="plain">), </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Phrases::Constants::iname</span><span class="plain">(</span><span class="identifier">cphr</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">inter_name</span><span class="plain"> *</span><span class="functiontext">Phrases::Constants::iname</span><span class="plain">(</span><span class="reserved">constant_phrase</span><span class="plain"> *</span><span class="identifier">cphr</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;cphr_iname</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="reserved">phrase</span><span class="plain"> *</span><span class="identifier">ph</span><span class="plain"> = </span><span class="functiontext">Phrases::Constants::as_phrase</span><span class="plain">(</span><span class="identifier">cphr</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ph</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"cannot reconstruct phrase from cphr"</span><span class="plain">);</span>
            <span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">closure_package</span><span class="plain"> =</span>
                <span class="functiontext">Packaging::request</span><span class="plain">(</span><span class="functiontext">Packaging::supply_iname</span><span class="plain">(</span><span class="identifier">ph</span><span class="plain">-</span><span class="element">&gt;requests_package</span><span class="plain">, </span><span class="constant">CLOSURE_PR_COUNTER</span><span class="plain">), </span><span class="identifier">ph</span><span class="plain">-</span><span class="element">&gt;requests_package</span><span class="plain">, </span><span class="identifier">closure_ptype</span><span class="plain">);</span>
            <span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;cphr_iname</span><span class="plain"> = </span><span class="functiontext">InterNames::one_off</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"closure_data"</span><span class="plain">, </span><span class="identifier">closure_package</span><span class="plain">);</span>
            <span class="identifier">Inter::Symbols::set_flag</span><span class="plain">(</span><span class="functiontext">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;cphr_iname</span><span class="plain">), </span><span class="identifier">MAKE_NAME_UNIQUE</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;cphr_iname</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::Constants::compile is used in 14/rv (<a href="14-rv.html#SP24_3">&#167;24.3</a>).</p>

<p class="endnote">The function Phrases::Constants::iname is used in <a href="#SP8_1">&#167;8.1</a>.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>And this is where those arrays are made:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Phrases::Constants::compile_closures</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">constant_phrase</span><span class="plain"> *</span><span class="identifier">cphr</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">cphr</span><span class="plain">, </span><span class="reserved">constant_phrase</span><span class="plain">) {</span>
            <span class="reserved">phrase</span><span class="plain"> *</span><span class="identifier">ph</span><span class="plain"> = </span><span class="functiontext">Phrases::Constants::as_phrase</span><span class="plain">(</span><span class="identifier">cphr</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ph</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"cannot reconstruct phrase from cphr"</span><span class="plain">);</span>
            <span class="functiontext">Phrases::Constants::kind</span><span class="plain">(</span><span class="identifier">cphr</span><span class="plain">);</span>
            &lt;<span class="cwebmacro">Compile the closure array for this constant phrase</span> <span class="cwebmacronumber">8.1</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::Constants::compile_closures is used in 1/mr (<a href="1-mr.html#SP4_14">&#167;4.14</a>).</p>

<p class="inwebparagraph"><a id="SP8_1"></a><b>&#167;8.1.  </b>The closure array consists of three words: the strong kind ID, the address
of the routine, and the text of the name. (The latter enables us to print
phrase values efficiently.) Note that we make a compilation request for the
phrase in order to make sure somebody has actually compiled it: this is in
case the phrase occurs as a constant but is never explicitly invoked.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Compile the closure array for this constant phrase</span> <span class="cwebmacronumber">8.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="functiontext">Phrases::Constants::iname</span><span class="plain">(</span><span class="identifier">cphr</span><span class="plain">);</span>
        <span class="reserved">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="functiontext">Packaging::enter_home_of</span><span class="plain">(</span><span class="identifier">iname</span><span class="plain">);</span>
        <span class="functiontext">Emit::named_array_begin</span><span class="plain">(</span><span class="identifier">iname</span><span class="plain">, </span><span class="identifier">K_value</span><span class="plain">);</span>

        <span class="functiontext">Kinds::RunTime::emit_strong_id</span><span class="plain">(</span><span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;cphr_kind</span><span class="plain">);</span>

        <span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">RS</span><span class="plain"> = </span><span class="functiontext">Routines::ToPhrases::make_iname</span><span class="plain">(</span><span class="identifier">ph</span><span class="plain">,</span>
            <span class="functiontext">Phrases::Constants::kind</span><span class="plain">(</span><span class="identifier">cphr</span><span class="plain">));</span>
        <span class="functiontext">Emit::array_iname_entry</span><span class="plain">(</span><span class="identifier">RS</span><span class="plain">);</span>

        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">name</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">name</span><span class="plain">, </span><span class="string">"%W"</span><span class="plain">, </span><span class="identifier">Nouns::nominative</span><span class="plain">(</span><span class="identifier">cphr</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain">));</span>
        <span class="functiontext">Emit::array_text_entry</span><span class="plain">(</span><span class="identifier">name</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">name</span><span class="plain">);</span>

        <span class="functiontext">Emit::array_end</span><span class="plain">();</span>
        <span class="functiontext">Packaging::exit</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>Now we come to something trickier. We want default values for kinds of phrases,
because otherwise we can't have variables holding phrases unless they are
always initialised explicitly, and so on. Clearly the default value for a
phrase to nothing is one that does nothing, and for a phrase to some kind K
is one that returns the default value of kind K. For example, the default
value of
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">phrase (text, time) -&gt; number</span>
</pre>

<p class="inwebparagraph">is the function which takes any pair of a text and a time, does nothing with
them, and always returns 0. But this means we need to actually compile such
routines. Since there are in principle an infinite number of distinct phrase
kinds, we will only compile them for the phrase kinds which arise during
compilation.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Phrases::Constants::compile_default_closure</span><span class="plain">(</span><span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">closure_identifier</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain"> = </span><span class="functiontext">Kinds::RunTime::package</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
        <span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">rname</span><span class="plain"> = </span><span class="functiontext">Packaging::function</span><span class="plain">(</span><span class="functiontext">InterNames::one_off</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"default_closure_fn"</span><span class="plain">, </span><span class="identifier">P</span><span class="plain">), </span><span class="identifier">P</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="identifier">Inter::Symbols::set_flag</span><span class="plain">(</span><span class="functiontext">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">rname</span><span class="plain">), </span><span class="identifier">MAKE_NAME_UNIQUE</span><span class="plain">);</span>

        &lt;<span class="cwebmacro">Compile the default routine</span> <span class="cwebmacronumber">9.2</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Compile the default closure</span> <span class="cwebmacronumber">9.1</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::Constants::compile_default_closure is used in 13/rsfk (<a href="13-rsfk.html#SP16_2">&#167;16.2</a>).</p>

<p class="inwebparagraph"><a id="SP9_1"></a><b>&#167;9.1.  </b>This must have exactly the same three-word form as the closure arrays
made above.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Compile the default closure</span> <span class="cwebmacronumber">9.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="functiontext">Emit::named_array_begin</span><span class="plain">(</span><span class="identifier">closure_identifier</span><span class="plain">, </span><span class="identifier">K_value</span><span class="plain">);</span>
        <span class="functiontext">Kinds::RunTime::emit_strong_id</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
        <span class="functiontext">Emit::array_iname_entry</span><span class="plain">(</span><span class="identifier">rname</span><span class="plain">);</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">DVT</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">DVT</span><span class="plain">, </span><span class="string">"default value of "</span><span class="plain">); </span><span class="identifier">Kinds::Textual::write</span><span class="plain">(</span><span class="identifier">DVT</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">);</span>
        <span class="functiontext">Emit::array_text_entry</span><span class="plain">(</span><span class="identifier">DVT</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">DVT</span><span class="plain">);</span>
        <span class="functiontext">Emit::array_end</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP9">&#167;9</a>.</p>

<p class="inwebparagraph"><a id="SP9_2"></a><b>&#167;9.2.  </b>And here is the function that refers to:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Compile the default routine</span> <span class="cwebmacronumber">9.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="functiontext">Routines::begin</span><span class="plain">(</span><span class="identifier">rname</span><span class="plain">);</span>
        <span class="functiontext">LocalVariables::add_named_call</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"a"</span><span class="plain">);</span>
        <span class="functiontext">LocalVariables::add_named_call</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"b"</span><span class="plain">);</span>
        <span class="functiontext">LocalVariables::add_named_call</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"c"</span><span class="plain">);</span>
        <span class="functiontext">LocalVariables::add_named_call</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"d"</span><span class="plain">);</span>
        <span class="functiontext">LocalVariables::add_named_call</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"e"</span><span class="plain">);</span>
        <span class="functiontext">LocalVariables::add_named_call</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"f"</span><span class="plain">);</span>
        <span class="functiontext">LocalVariables::add_named_call</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"g"</span><span class="plain">);</span>
        <span class="functiontext">LocalVariables::add_named_call</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"h"</span><span class="plain">);</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">result</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">Kinds::binary_construction_material</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, &amp;</span><span class="identifier">result</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::get_construct</span><span class="plain">(</span><span class="identifier">result</span><span class="plain">) != </span><span class="identifier">CON_NIL</span><span class="plain">) {</span>
            <span class="functiontext">Emit::inv_primitive</span><span class="plain">(</span><span class="identifier">return_interp</span><span class="plain">);</span>
            <span class="functiontext">Emit::down</span><span class="plain">();</span>

            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Behaviour::uses_pointer_values</span><span class="plain">(</span><span class="identifier">result</span><span class="plain">)) {</span>
                <span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="functiontext">InterNames::extern</span><span class="plain">(</span><span class="constant">BLKVALUECREATE_EXNAMEF</span><span class="plain">);</span>
                <span class="functiontext">Emit::inv_call</span><span class="plain">(</span><span class="functiontext">InterNames::to_symbol</span><span class="plain">(</span><span class="identifier">iname</span><span class="plain">));</span>
                <span class="functiontext">Emit::down</span><span class="plain">();</span>
                <span class="functiontext">Kinds::RunTime::emit_strong_id_as_val</span><span class="plain">(</span><span class="identifier">result</span><span class="plain">);</span>
                <span class="functiontext">Emit::up</span><span class="plain">();</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Kinds::RunTime::emit_default_value_as_val</span><span class="plain">(</span><span class="identifier">result</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">) != </span><span class="identifier">TRUE</span><span class="plain">)</span>
                    <span class="functiontext">Emit::val</span><span class="plain">(</span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
            <span class="plain">}</span>

            <span class="functiontext">Emit::up</span><span class="plain">();</span>
        <span class="plain">}</span>
        <span class="functiontext">Routines::end</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP9">&#167;9</a>.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="22-po.html">Back to 'Phrase Options'</a></li><li><a href="22-tp.html">Continue with 'To Phrases'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

