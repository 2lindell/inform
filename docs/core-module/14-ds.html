<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>14/cn</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../compiler.html"><b>compiler tools</b></a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul>
<h2>Compiler Webs</h2>
<ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul>
<h2>Inbuild Modules</h2>
<ul>
<li><a href="../inbuild-module/index.html">inbuild</a></li>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../html-module/index.html">html</a></li>
</ul>
<h2>Inform7 Modules</h2>
<ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul>
<h2>Inter Modules</h2>
<ul>
<li><a href="../inter-module/index.html">inter</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of '14/ds' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="../compiler.html">Compiler Modules</a></li><li><a href="index.html">core</a></li><li><a href="index.html#14">Chapter 14: Specifications</a></li><li><b>Descriptions</b></li></ul><p class="purpose">Description nodes represent text such as "even numbers", which can either define a set of values or a predicate on them.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Descriptions vs propositions</a></li><li><a href="#SP3">&#167;3. Descriptions vs kinds</a></li><li><a href="#SP5">&#167;5. Descriptions vs instances</a></li><li><a href="#SP6">&#167;6. Descriptions vs constants</a></li><li><a href="#SP7">&#167;7. Testing</a></li><li><a href="#SP8">&#167;8. Adjectives</a></li><li><a href="#SP9">&#167;9. Quantification</a></li><li><a href="#SP10">&#167;10. Callings</a></li><li><a href="#SP11">&#167;11. Pretty-printing</a></li><li><a href="#SP12">&#167;12. Comparing</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Descriptions vs propositions. </b>A description of K-values is stored as a <code class="display"><span class="extract">TEST_VALUE_NT</span></code> node with a constant
node beneath it of kind "description of K":
</p>

<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">Descriptions::from_proposition</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">ParseTree::new_with_words</span><span class="plain">(</span><span class="constant">TEST_VALUE_NT</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">spec</span><span class="plain">-&gt;</span><span class="element">down</span><span class="plain"> = </span><span class="functiontext">Rvalues::constant_description</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">spec</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) </span><span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">-&gt;</span><span class="element">down</span><span class="plain">;</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to extract proposition from non-description"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Rvalues::is_CONSTANT_construction</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">CON_description</span><span class="plain">))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Specifications::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Descriptions::from_proposition is used in <a href="#SP3">&#167;3</a>, <a href="#SP5">&#167;5</a>, 10/cad (<a href="10-cad.html#SP8">&#167;8</a>, <a href="10-cad.html#SP10">&#167;10</a>, <a href="10-cad.html#SP19_1">&#167;19.1</a>), 10/varc (<a href="10-varc.html#SP9_1">&#167;9.1</a>, <a href="10-varc.html#SP13_4">&#167;13.4</a>).</p>

<p class="endnote">The function Descriptions::to_proposition is used in <a href="#SP3">&#167;3</a>, <a href="#SP4">&#167;4</a>, <a href="#SP5">&#167;5</a>, <a href="#SP6">&#167;6</a>, <a href="#SP7">&#167;7</a>, <a href="#SP8">&#167;8</a>, <a href="#SP9">&#167;9</a>, <a href="#SP10">&#167;10</a>, <a href="#SP12_1">&#167;12.1</a>, 11/pr (<a href="11-pr.html#SP35">&#167;35</a>), 14/sp (<a href="14-sp.html#SP3">&#167;3</a>), 14/cn (<a href="14-cn.html#SP13">&#167;13</a>), 14/ds2 (<a href="14-ds2.html#SP25">&#167;25</a>), 22/dptd (<a href="22-dptd.html#SP20_2_3">&#167;20.2.3</a>).</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>We are going to need to edit the proposition, using the following:
</p>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Descriptions::set_proposition</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) </span><span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">-&gt;</span><span class="element">down</span><span class="plain">;</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to set proposition for non-description"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Rvalues::is_CONSTANT_construction</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">CON_description</span><span class="plain">))</span>
            <span class="functiontext">Rvalues::set_constant_description_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"set domain proposition wrongly"</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Descriptions::set_proposition is used in <a href="#SP3">&#167;3</a>, <a href="#SP8">&#167;8</a>, <a href="#SP9">&#167;9</a>, <a href="#SP10">&#167;10</a>.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Descriptions vs kinds. </b>A kind is "composited" if it's derived from a word such as "something",
which implies a quantifier as well as a kind.
</p>

<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">Descriptions::from_kind</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">composited</span><span class="plain">) {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Descriptions::from_proposition</span><span class="plain">(</span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain">) { </span><span class="comment">a test made only for error recovery</span>
            <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">composited</span><span class="plain">)</span>
                <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::KIND_new_composited</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0));</span>
            <span class="reserved">else</span>
                <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::KIND_new</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0));</span>
            <span class="functiontext">Calculus::Propositions::Checker::type_check</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">,</span>
                <span class="functiontext">Calculus::Propositions::Checker::tc_no_problem_reporting</span><span class="plain">());</span>
            <span class="functiontext">Descriptions::set_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">spec</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">kind</span><span class="plain"> *</span><span class="functiontext">Descriptions::to_kind</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Variables::infer_kind_of_variable_0</span><span class="plain">(</span>
            <span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Descriptions::from_kind is used in 10/cad (<a href="10-cad.html#SP22">&#167;22</a>), 14/sp (<a href="14-sp.html#SP1">&#167;1</a>).</p>

<p class="endnote">The function Descriptions::to_kind is used in 14/sp (<a href="14-sp.html#SP1">&#167;1</a>).</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>Some descriptions explicitly name a kind ("even numbers"), others imply
a kind but do so only implicitly ("scenery").
</p>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Descriptions::makes_kind_explicit</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) &amp;&amp;</span>
            <span class="plain">(</span><span class="functiontext">Descriptions::explicit_kind</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">))) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">kind</span><span class="plain"> *</span><span class="functiontext">Descriptions::explicit_kind</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::describes_kind</span><span class="plain">(</span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Descriptions::makes_kind_explicit is used in 9/rpt (<a href="9-rpt.html#SP10_1">&#167;10.1</a>).</p>

<p class="endnote">The function Descriptions::explicit_kind is used in <a href="#SP7">&#167;7</a>, <a href="#SP10">&#167;10</a>, <a href="#SP12_4">&#167;12.4</a>.</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Descriptions vs instances. </b>One is not allowed to form a description such as "the even 22", where
adjectives are applied to a literal. But one is allowed to do so with
a named object or similar, so:
</p>

<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">Descriptions::from_instance</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"description of null instance"</span><span class="plain">);</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">val</span><span class="plain"> = </span><span class="functiontext">Rvalues::from_instance</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::prop_x_is_constant</span><span class="plain">(</span><span class="identifier">val</span><span class="plain">);</span>
        <span class="functiontext">Calculus::Propositions::Checker::type_check</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">,</span>
            <span class="functiontext">Calculus::Propositions::Checker::tc_no_problem_reporting</span><span class="plain">());</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Descriptions::from_proposition</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">instance</span><span class="plain"> *</span><span class="functiontext">Descriptions::to_instance</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) {</span>
            <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">val</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::describes_value</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">val</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Rvalues::to_instance</span><span class="plain">(</span><span class="identifier">val</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Descriptions::from_instance is used in 10/cad (<a href="10-cad.html#SP12">&#167;12</a>).</p>

<p class="endnote">The function Descriptions::to_instance is used in 9/rpt (<a href="9-rpt.html#SP9_7_6_3_1">&#167;9.7.6.3.1</a>, <a href="9-rpt.html#SP9_7_6_5_1">&#167;9.7.6.5.1</a>, <a href="9-rpt.html#SP10_1">&#167;10.1</a>), 12/ap (<a href="12-ap.html#SP12">&#167;12</a>), 12/dtd (<a href="12-dtd.html#SP18">&#167;18</a>), 14/sp (<a href="14-sp.html#SP4">&#167;4</a>), 14/ds2 (<a href="14-ds2.html#SP27">&#167;27</a>).</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Descriptions vs constants. </b>A description such as "even numbers" is normally represented as a description
node, but sometimes we need to think of this as a noun and not a predicate.
If so, we convert to a constant using the following. Note that we remove
a universal quantifier: this is so that "even numbers", if read as "all
even numbers", becomes rather "is an even number".
</p>

<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">Descriptions::to_rvalue</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"not a description"</span><span class="plain">);</span>

        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::copy</span><span class="plain">(</span>
            <span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">) {</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::trim_universal_quantifier</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Variables::number_free</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">) != </span><span class="constant">1</span><span class="plain">)</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">; </span><span class="comment">Specifications::new_UNKNOWN(ParseTree::get_text(spec));</span>
        <span class="plain">}</span>

        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">con</span><span class="plain"> = </span><span class="identifier">ParseTree::new</span><span class="plain">(</span><span class="constant">CONSTANT_NT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::set_kind_of_value</span><span class="plain">(</span><span class="identifier">con</span><span class="plain">,</span>
            <span class="identifier">Kinds::unary_construction</span><span class="plain">(</span><span class="identifier">CON_description</span><span class="plain">,</span>
                <span class="functiontext">Calculus::Variables::infer_kind_of_variable_0</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">)));</span>
        <span class="identifier">ParseTree::set_proposition</span><span class="plain">(</span><span class="identifier">con</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">);</span>
        <span class="identifier">ParseTree::set_text</span><span class="plain">(</span><span class="identifier">con</span><span class="plain">, </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">con</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Descriptions::to_rvalue is used in 14/ds2 (<a href="14-ds2.html#SP19_3_1">&#167;19.3.1</a>, <a href="14-ds2.html#SP19_5_3">&#167;19.5.3</a>).</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Testing. </b>Descriptions are "qualified" when adjectives, or relative clauses, make
them dependent on context. For instance, "a vehicle" is unqualified, but
"an even number" or "a vehicle in Trafalgar Square" are qualified &mdash;
the same value might satisfy the description at some times but not others
during play.
</p>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Descriptions::is_qualified</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) &amp;&amp;</span>
            <span class="plain">((</span><span class="functiontext">Descriptions::is_complex</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) ||</span>
                <span class="plain">(</span><span class="functiontext">Descriptions::number_of_adjectives_applied_to</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">) &gt; </span><span class="constant">0</span><span class="plain">)))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Descriptions::is_kind_like</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) &amp;&amp;</span>
            <span class="plain">(</span><span class="functiontext">Calculus::Propositions::length</span><span class="plain">(</span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) == </span><span class="constant">1</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="functiontext">Descriptions::explicit_kind</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Descriptions::is_complex</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::is_complex</span><span class="plain">(</span>
                <span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Descriptions::is_adjectives_plus_kind</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Descriptions::number_of_adjectives_applied_to</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">) == </span><span class="constant">0</span><span class="plain">)</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">Descriptions::explicit_kind</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Descriptions::is_qualified is used in 4/am (<a href="4-am.html#SP24_5">&#167;24.5</a>), 9/pk (<a href="9-pk.html#SP3">&#167;3</a>), 9/pd (<a href="9-pd.html#SP5_6">&#167;5.6</a>, <a href="9-pd.html#SP5_11_1">&#167;5.11.1</a>), 14/ds2 (<a href="14-ds2.html#SP27">&#167;27</a>), 21/rl2 (<a href="21-rl2.html#SP14">&#167;14</a>).</p>

<p class="endnote">The function Descriptions::is_kind_like is used in 14/sp (<a href="14-sp.html#SP2">&#167;2</a>).</p>

<p class="endnote">The function Descriptions::is_complex is used in <a href="#SP12_1">&#167;12.1</a>, 9/rpt (<a href="9-rpt.html#SP9_7_6_5">&#167;9.7.6.5</a>), 14/ds2 (<a href="14-ds2.html#SP19_4">&#167;19.4</a>, <a href="14-ds2.html#SP19_6_2_1">&#167;19.6.2.1</a>).</p>

<p class="endnote">The function Descriptions::is_adjectives_plus_kind is used in 9/ass (<a href="9-ass.html#SP9_3">&#167;9.3</a>).</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Adjectives. </b>Adjectives occurring in the proposition can be thought of as forming
a list. It's sometimes convenient to loop through this list:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="identifier">LOOP_THROUGH_ADJECTIVE_LIST</span><span class="plain">(</span><span class="identifier">au</span><span class="plain">, </span><span class="identifier">au_prop</span><span class="plain">, </span><span class="identifier">spec</span><span class="plain">)</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">au</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::first_adjective_usage</span><span class="plain">(</span>
            <span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">), &amp;</span><span class="identifier">au_prop</span><span class="plain">);</span>
            <span class="identifier">au</span><span class="plain">;</span>
            <span class="identifier">au</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::next_adjective_usage</span><span class="plain">(&amp;</span><span class="identifier">au_prop</span><span class="plain">))</span>
</pre>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Descriptions::number_of_adjectives_applied_to</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::count_unary_predicates</span><span class="plain">(</span>
            <span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
    <span class="plain">}</span>

    <span class="identifier">adjective_usage</span><span class="plain"> *</span><span class="functiontext">Descriptions::first_adjective_usage</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::first_adjective_usage</span><span class="plain">(</span>
            <span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">), </span><span class="identifier">NULL</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Descriptions::add_to_adjective_list</span><span class="plain">(</span><span class="identifier">adjective_usage</span><span class="plain"> *</span><span class="identifier">au</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain"> = </span><span class="identifier">AdjectiveUsages::get_aph</span><span class="plain">(</span><span class="identifier">au</span><span class="plain">);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">negated</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">AdjectiveUsages::get_parity</span><span class="plain">(</span><span class="identifier">au</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">negated</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::concatenate</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">,</span>
            <span class="functiontext">Calculus::Atoms::unary_PREDICATE_from_aph</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">negated</span><span class="plain">));</span>
        <span class="functiontext">Calculus::Propositions::Checker::type_check</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">,</span>
            <span class="functiontext">Calculus::Propositions::Checker::tc_no_problem_reporting</span><span class="plain">());</span>
        <span class="functiontext">Descriptions::set_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Descriptions::add_to_adjective_list_w</span><span class="plain">(</span><span class="identifier">adjective_usage</span><span class="plain"> *</span><span class="identifier">au</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="identifier">quantifier</span><span class="plain"> *</span><span class="identifier">Q</span><span class="plain"> = </span><span class="functiontext">Descriptions::get_quantifier</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">N</span><span class="plain"> = </span><span class="functiontext">Descriptions::get_quantification_parameter</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Descriptions::get_inner_prop</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain"> = </span><span class="identifier">AdjectiveUsages::get_aph</span><span class="plain">(</span><span class="identifier">au</span><span class="plain">);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">negated</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">AdjectiveUsages::get_parity</span><span class="plain">(</span><span class="identifier">au</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">negated</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::concatenate</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">,</span>
            <span class="functiontext">Calculus::Atoms::unary_PREDICATE_from_aph</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">negated</span><span class="plain">));</span>
        <span class="functiontext">Calculus::Propositions::Checker::type_check</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">,</span>
            <span class="functiontext">Calculus::Propositions::Checker::tc_no_problem_reporting</span><span class="plain">());</span>
        <span class="functiontext">Descriptions::set_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Q</span><span class="plain">) </span><span class="functiontext">Descriptions::quantify</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">Q</span><span class="plain">, </span><span class="identifier">N</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Descriptions::number_of_adjectives_applied_to is used in <a href="#SP7">&#167;7</a>, <a href="#SP12_3">&#167;12.3</a>, 9/rpt (<a href="9-rpt.html#SP9_7_6_3_1">&#167;9.7.6.3.1</a>, <a href="9-rpt.html#SP9_7_6_5_1">&#167;9.7.6.5.1</a>, <a href="9-rpt.html#SP10">&#167;10</a>, <a href="9-rpt.html#SP10_3">&#167;10.3</a>), 9/pk (<a href="9-pk.html#SP3_2">&#167;3.2</a>), 12/dtd (<a href="12-dtd.html#SP18">&#167;18</a>), 14/ds2 (<a href="14-ds2.html#SP11_9_1_1_5_1_2">&#167;11.9.1.1.5.1.2</a>), 21/ac (<a href="21-ac.html#SP8">&#167;8</a>).</p>

<p class="endnote">The function Descriptions::first_adjective_usage is used in 9/rpt (<a href="9-rpt.html#SP10_3">&#167;10.3</a>), 14/ds2 (<a href="14-ds2.html#SP11_9_1_1_5_1_2">&#167;11.9.1.1.5.1.2</a>).</p>

<p class="endnote">The function Descriptions::add_to_adjective_list is used in 10/cad (<a href="10-cad.html#SP10">&#167;10</a>, <a href="10-cad.html#SP11">&#167;11</a>), 10/varc (<a href="10-varc.html#SP9_1">&#167;9.1</a>).</p>

<p class="endnote">The function Descriptions::add_to_adjective_list_w is used in 10/cad (<a href="10-cad.html#SP11">&#167;11</a>).</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Quantification. </b>For example, the "all" in "all of the open doors".
</p>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Descriptions::quantify</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">quantifier</span><span class="plain"> *</span><span class="identifier">q</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">par</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">q</span><span class="plain"> != </span><span class="identifier">exists_quantifier</span><span class="plain">)</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::concatenate</span><span class="plain">(</span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">DOMAIN_OPEN_ATOM</span><span class="plain">), </span><span class="identifier">prop</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::concatenate</span><span class="plain">(</span><span class="functiontext">Calculus::Atoms::QUANTIFIER_new</span><span class="plain">(</span><span class="identifier">q</span><span class="plain">, </span><span class="constant">0</span><span class="plain">, </span><span class="identifier">par</span><span class="plain">), </span><span class="identifier">prop</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">q</span><span class="plain"> != </span><span class="identifier">exists_quantifier</span><span class="plain">)</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::concatenate</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">DOMAIN_CLOSE_ATOM</span><span class="plain">));</span>
        <span class="functiontext">Descriptions::set_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">);</span>
        <span class="functiontext">Calculus::Propositions::Checker::type_check</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="functiontext">Calculus::Propositions::Checker::tc_no_problem_reporting</span><span class="plain">());</span>
    <span class="plain">}</span>

    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Descriptions::get_inner_prop</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">Calculus::Atoms::get_quantifier</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">))) {</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::copy</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">);</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::ungroup_after</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">-&gt;</span><span class="element">next</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::from_spec</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Descriptions::get_quantified_prop</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">Calculus::Atoms::get_quantifier</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">)) &amp;&amp;</span>
            <span class="plain">(</span><span class="functiontext">Calculus::Atoms::get_quantification_parameter</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">) &gt; </span><span class="constant">0</span><span class="plain">)) {</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::copy</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">);</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::ungroup_after</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">-&gt;</span><span class="element">next</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::from_spec</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="identifier">quantifier</span><span class="plain"> *</span><span class="functiontext">Descriptions::get_quantifier</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::get_quantifier</span><span class="plain">(</span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Descriptions::get_quantification_parameter</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::get_quantification_parameter</span><span class="plain">(</span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="constant">0</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Descriptions::quantify is used in <a href="#SP8">&#167;8</a>, 10/cad (<a href="10-cad.html#SP19_3">&#167;19.3</a>, <a href="10-cad.html#SP22">&#167;22</a>).</p>

<p class="endnote">The function Descriptions::get_inner_prop is used in <a href="#SP8">&#167;8</a>.</p>

<p class="endnote">The function Descriptions::get_quantified_prop is used in 9/rpt (<a href="9-rpt.html#SP2">&#167;2</a>).</p>

<p class="endnote">The function Descriptions::get_quantifier is used in <a href="#SP8">&#167;8</a>, 9/rpt (<a href="9-rpt.html#SP9_7_6_3">&#167;9.7.6.3</a>, <a href="9-rpt.html#SP9_7_6_3_1">&#167;9.7.6.3.1</a>), 12/dtd (<a href="12-dtd.html#SP13">&#167;13</a>), 14/ds2 (<a href="14-ds2.html#SP11_9_1_2_3_3">&#167;11.9.1.2.3.3</a>, <a href="14-ds2.html#SP19_5_3">&#167;19.5.3</a>).</p>

<p class="endnote">The function Descriptions::get_quantification_parameter is used in <a href="#SP8">&#167;8</a>, 9/rpt (<a href="9-rpt.html#SP2">&#167;2</a>).</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Callings. </b>For example, "the neighbour" in "a room which is adjacent to a lighted room
(called the neighbour)".
</p>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Descriptions::attach_calling</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">C</span><span class="plain">) {</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">Descriptions::explicit_kind</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::concatenate</span><span class="plain">(</span>
            <span class="identifier">prop</span><span class="plain">,</span>
            <span class="functiontext">Calculus::Atoms::CALLED_new</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0), </span><span class="identifier">K</span><span class="plain">));</span>
        <span class="functiontext">Calculus::Propositions::Checker::type_check</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="functiontext">Calculus::Propositions::Checker::tc_no_problem_reporting</span><span class="plain">());</span>
        <span class="functiontext">Descriptions::set_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">Descriptions::get_calling</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">))</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">pp</span><span class="plain"> = </span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">); </span><span class="identifier">pp</span><span class="plain">; </span><span class="identifier">pp</span><span class="plain"> = </span><span class="identifier">pp</span><span class="plain">-&gt;</span><span class="element">next</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pp</span><span class="plain">-&gt;</span><span class="element">element</span><span class="plain"> == </span><span class="constant">CALLED_ATOM</span><span class="plain">)</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::CALLED_get_name</span><span class="plain">(</span><span class="identifier">pp</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Descriptions::clear_calling</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">spec</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">pp</span><span class="plain">, *</span><span class="identifier">prev_pp</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">pp</span><span class="plain"> = </span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">); </span><span class="identifier">pp</span><span class="plain">; </span><span class="identifier">prev_pp</span><span class="plain"> = </span><span class="identifier">pp</span><span class="plain">, </span><span class="identifier">pp</span><span class="plain"> = </span><span class="identifier">pp</span><span class="plain">-&gt;</span><span class="element">next</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pp</span><span class="plain">-&gt;</span><span class="element">element</span><span class="plain"> == </span><span class="constant">CALLED_ATOM</span><span class="plain">) {</span>
                <span class="functiontext">Descriptions::set_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">,</span>
                    <span class="functiontext">Calculus::Propositions::delete_atom</span><span class="plain">(</span>
                        <span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">), </span><span class="identifier">prev_pp</span><span class="plain">));</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Descriptions::makes_callings</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">spec</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Propositions::contains_callings</span><span class="plain">(</span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)))</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">C</span><span class="plain"> = </span><span class="functiontext">Descriptions::get_calling</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Descriptions::attach_calling is used in 10/cad (<a href="10-cad.html#SP19_2">&#167;19.2</a>).</p>

<p class="endnote">The function Descriptions::get_calling appears nowhere else.</p>

<p class="endnote">The function Descriptions::clear_calling appears nowhere else.</p>

<p class="endnote">The function Descriptions::makes_callings appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Pretty-printing. </b></p>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Descriptions::write_out_in_English</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">Specifications::to_kind</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"a description"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain">) {</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">KW</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_name</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">KW</span><span class="plain">)) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" of %+W"</span><span class="plain">, </span><span class="identifier">KW</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Descriptions::write_out_in_English is used in 14/cn (<a href="14-cn.html#SP12">&#167;12</a>).</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Comparing. </b>Descriptions are used to set out the domain of rules, and rules have to be sorted
in order of narrowness, which means we need a way to tell which is narrower of
two descriptions.
</p>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Descriptions::compare_specificity</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec1</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec2</span><span class="plain">) {</span>
        &lt;<span class="cwebmacro">If either of these two descriptions has a complex proposition, then propositional size decides it</span> <span class="cwebmacronumber">12.1</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">If the typechecker recognises one as properly within the other, then that's the more specific</span> <span class="cwebmacronumber">12.2</span>&gt;<span class="character">;</span>
        &lt;<span class="cwebmacro">If either of these two descriptions have adjectives, adjective count decides it</span> <span class="cwebmacronumber">12.3</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">If both descriptions specify a kind, kind inheritance decides it</span> <span class="cwebmacronumber">12.4</span>&gt;<span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="constant">0</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Descriptions::compare_specificity is used in 14/sp (<a href="14-sp.html#SP7">&#167;7</a>).</p>

<p class="inwebparagraph"><a id="SP12_1"></a><b>&#167;12.1.  </b>Which of two propositions is more specific? To perform that test perfectly,
we would need a way to determine, given two propositions A and B, whether one
implied the other or not. Since predicate calculus is complete, and our
domains are mostly finite, there do in fact exist (slow and difficult)
algorithms which could determine this. But there would be real problems with
larger domains not amenable to model-checking, such as "number", and anyway &mdash;
why not cheat?
</p>

<p class="inwebparagraph">Proposition length is admittedly a crude measure, but because of the fact that
both propositions have come from the same generative algorithm, it does indeed
turn out that A=&gt; B means l(A) &gt;= l(B), where l is
the number of atoms in the proposition. So we simply use it as a sorting key.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">If either of these two descriptions has a complex proposition, then propositional size decides it</span> <span class="cwebmacronumber">12.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">comp1</span><span class="plain"> = </span><span class="functiontext">Descriptions::is_complex</span><span class="plain">(</span><span class="identifier">spec1</span><span class="plain">);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">comp2</span><span class="plain"> = </span><span class="functiontext">Descriptions::is_complex</span><span class="plain">(</span><span class="identifier">spec2</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">comp1</span><span class="plain">) || (</span><span class="identifier">comp2</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">comp2</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">1</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">comp1</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> -1;</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">len1</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::length</span><span class="plain">(</span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec1</span><span class="plain">));</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">len2</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::length</span><span class="plain">(</span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec2</span><span class="plain">));</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">len1</span><span class="plain"> &gt; </span><span class="constant">0</span><span class="plain">) || (</span><span class="identifier">len2</span><span class="plain"> &gt; </span><span class="constant">0</span><span class="plain">)) {</span>
                <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">SPECIFICITIES</span><span class="plain">,</span>
                    <span class="string">"Test %d: Comparing specificity of props:\n(%d) $D\n(%d) $D\n"</span><span class="plain">,</span>
                    <span class="identifier">cco</span><span class="plain">, </span><span class="identifier">len1</span><span class="plain">, </span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec1</span><span class="plain">), </span><span class="identifier">len2</span><span class="plain">, </span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec2</span><span class="plain">));</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">len1</span><span class="plain"> &gt; </span><span class="identifier">len2</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">1</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">len1</span><span class="plain"> &lt; </span><span class="identifier">len2</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> -1;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP12_2"></a><b>&#167;12.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">If the typechecker recognises one as properly within the other, then that's the more specific</span> <span class="cwebmacronumber">12.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Dash::compatible_with_description</span><span class="plain">(</span><span class="identifier">spec1</span><span class="plain">, </span><span class="identifier">spec2</span><span class="plain">) == </span><span class="identifier">ALWAYS_MATCH</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Dash::compatible_with_description</span><span class="plain">(</span><span class="identifier">spec2</span><span class="plain">, </span><span class="identifier">spec1</span><span class="plain">) != </span><span class="identifier">ALWAYS_MATCH</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">1</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Dash::compatible_with_description</span><span class="plain">(</span><span class="identifier">spec2</span><span class="plain">, </span><span class="identifier">spec1</span><span class="plain">) == </span><span class="identifier">ALWAYS_MATCH</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> -1;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP12_3"></a><b>&#167;12.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">If either of these two descriptions have adjectives, adjective count decides it</span> <span class="cwebmacronumber">12.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">count1</span><span class="plain"> = </span><span class="functiontext">Descriptions::number_of_adjectives_applied_to</span><span class="plain">(</span><span class="identifier">spec1</span><span class="plain">);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">count2</span><span class="plain"> = </span><span class="functiontext">Descriptions::number_of_adjectives_applied_to</span><span class="plain">(</span><span class="identifier">spec2</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">count1</span><span class="plain"> &gt; </span><span class="identifier">count2</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">1</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">count1</span><span class="plain"> &lt; </span><span class="identifier">count2</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> -1;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP12_4"></a><b>&#167;12.4.  </b><code class="display">
&lt;<span class="cwebmacrodefn">If both descriptions specify a kind, kind inheritance decides it</span> <span class="cwebmacronumber">12.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">k1</span><span class="plain"> = </span><span class="functiontext">Descriptions::explicit_kind</span><span class="plain">(</span><span class="identifier">spec1</span><span class="plain">);</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">k2</span><span class="plain"> = </span><span class="functiontext">Descriptions::explicit_kind</span><span class="plain">(</span><span class="identifier">spec2</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">k1</span><span class="plain">) &amp;&amp; (</span><span class="identifier">k2</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::lt</span><span class="plain">(</span><span class="identifier">k1</span><span class="plain">, </span><span class="identifier">k2</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">1</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::lt</span><span class="plain">(</span><span class="identifier">k2</span><span class="plain">, </span><span class="identifier">k1</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> -1;</span>
        <span class="plain">}</span>

</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a>.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="14-cn.html">Back to 'Conditions'</a></li><li><a href="14-cfs.html">Continue with 'Compiling from Specifications'</a></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

