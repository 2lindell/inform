<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>12/cdp</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../compiler.html"><b>compiler tools</b></a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul>
<h2>Compiler Webs</h2>
<ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul>
<h2>Inbuild Modules</h2>
<ul>
<li><a href="../inbuild-module/index.html">inbuild</a></li>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../html-module/index.html">html</a></li>
</ul>
<h2>Inform7 Modules</h2>
<ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul>
<h2>Inter Modules</h2>
<ul>
<li><a href="../inter-module/index.html">inter</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of '13/kak' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="../compiler.html">Compiler Modules</a></li><li><a href="index.html">core</a></li><li><a href="index.html#13">Chapter 13: Bridge to Kinds Module</a></li><li><b>Knowledge about Kinds</b></li></ul><p class="purpose">How kinds can be inference subjects.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. </a></li><li><a href="#SP7">&#167;7. Problems with kinds</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1.  </b>In principle every base kind gets its own inference subject, making it possible
to draw inferences from sentences such as:
</p>

<blockquote>
    <p>A scene has a number called the witness count. The witness count of a scene is usually 4.</p>

</blockquote>

<p class="inwebparagraph">In practice we never need inferences for intermediate kinds, since they
don't last enough and aren't visible enough to have properties. We do need
exactly one inference subject per base kind: one for "scene" (as in the
above example), one for "text" and so on.
</p>

<p class="inwebparagraph">Constructed kinds like "list of scenes" have no properties, and no inferences
are drawn about them.
</p>

<pre class="display">
    <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">K</span><span class="plain">-&gt;</span><span class="identifier">construct</span><span class="plain">-&gt;</span><span class="identifier">dt_knowledge</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::set_subject</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">, </span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">K</span><span class="plain">-&gt;</span><span class="element">construct</span><span class="plain">-&gt;</span><span class="identifier">dt_knowledge</span><span class="plain"> = </span><span class="identifier">infs</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="functiontext">Kinds::Knowledge::create_for_constructor</span><span class="plain">(</span><span class="identifier">kind_constructor</span><span class="plain"> *</span><span class="identifier">con</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">InferenceSubjects::new</span><span class="plain">(</span><span class="identifier">global_constants</span><span class="plain">,</span>
            <span class="constant">KIND_SUB</span><span class="plain">, </span><span class="identifier">STORE_POINTER_kind_constructor</span><span class="plain">(</span><span class="identifier">con</span><span class="plain">), </span><span class="identifier">LIKELY_CE</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Kinds::Knowledge::as_subject is used in <a href="#SP5">&#167;5</a>, <a href="#SP6">&#167;6</a>, 4/am (<a href="4-am.html#SP20">&#167;20</a>, <a href="4-am.html#SP21">&#167;21</a>, <a href="4-am.html#SP22">&#167;22</a>), 5/ins (<a href="5-ins.html#SP6_2">&#167;6.2</a>, <a href="5-ins.html#SP19">&#167;19</a>), 5/ipw (<a href="5-ipw.html#SP3_7">&#167;3.7</a>), 6/bp (<a href="6-bp.html#SP20">&#167;20</a>), 6/rlt (<a href="6-rlt.html#SP9_3_1">&#167;9.3.1</a>, <a href="6-rlt.html#SP9_3_8">&#167;9.3.8</a>, <a href="6-rlt.html#SP20_4">&#167;20.4</a>), 9/rpt (<a href="9-rpt.html#SP1">&#167;1</a>, <a href="9-rpt.html#SP9_6">&#167;9.6</a>, <a href="9-rpt.html#SP9_6_1">&#167;9.6.1</a>, <a href="9-rpt.html#SP9_6_2">&#167;9.6.2</a>, <a href="9-rpt.html#SP9_7_6_3_1">&#167;9.7.6.3.1</a>, <a href="9-rpt.html#SP10_1">&#167;10.1</a>), 9/tc (<a href="9-tc.html#SP8_4_1_2">&#167;8.4.1.2</a>), 9/ma (<a href="9-ma.html#SP3_3_25">&#167;3.3.25</a>, <a href="9-ma.html#SP3_3_26">&#167;3.3.26</a>, <a href="9-ma.html#SP3_3_34">&#167;3.3.34</a>, <a href="9-ma.html#SP3_3_39">&#167;3.3.39</a>), 9/pk (<a href="9-pk.html#SP3">&#167;3</a>), 9/imp (<a href="9-imp.html#SP4_2_1">&#167;4.2.1</a>), 9/pd (<a href="9-pd.html#SP5_6">&#167;5.6</a>, <a href="9-pd.html#SP6_1_1">&#167;6.1.1</a>), 12/qr (<a href="12-qr.html#SP3">&#167;3</a>), 12/ap (<a href="12-ap.html#SP9_5_2">&#167;9.5.2</a>, <a href="12-ap.html#SP12">&#167;12</a>), 13/ki (<a href="13-ki.html#SP1_11">&#167;1.11</a>), 14/ds2 (<a href="14-ds2.html#SP11_9_1_2_3">&#167;11.9.1.2.3</a>), 15/ia (<a href="15-ia.html#SP1">&#167;1</a>), 15/tpr (<a href="15-tpr.html#SP7_2">&#167;7.2</a>), 15/spr2 (<a href="15-spr2.html#SP2">&#167;2</a>), 16/is (<a href="16-is.html#SP17">&#167;17</a>), 16/ic (<a href="16-ic.html#SP12_2">&#167;12.2</a>, <a href="16-ic.html#SP12_3">&#167;12.3</a>, <a href="16-ic.html#SP13">&#167;13</a>, <a href="16-ic.html#SP14">&#167;14</a>, <a href="16-ic.html#SP15">&#167;15</a>), 19/tod (<a href="19-tod.html#SP6_4">&#167;6.4</a>), 19/lr (<a href="19-lr.html#SP2">&#167;2</a>).</p>

<p class="endnote">The function Kinds::Knowledge::set_subject appears nowhere else.</p>

<p class="endnote">The function Kinds::Knowledge::create_for_constructor appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>This is one of Inform's sets of inference subjects, and here are the
routines to support them:
</p>

<pre class="display">
    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::get_name_text</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">from</span><span class="plain">) {</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::as_kind</span><span class="plain">(</span><span class="identifier">from</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">Kinds::Behaviour::get_name</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
    <span class="plain">}</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::complete_model</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">) { }</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::check_model</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">) { }</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::emit_element_of_condition</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">, </span><span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">t0_s</span><span class="plain">) {</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::as_kind</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::lt</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)) {</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">OFCLASS_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">t0_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Kinds::RunTime::I6_classname</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">));</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::eq</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)) {</span>
            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">t0_s</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Kinds::Knowledge::get_name_text is used in 16/is (<a href="16-is.html#SP24">&#167;24</a>).</p>

<p class="endnote">The function Kinds::Knowledge::complete_model is used in 16/is (<a href="16-is.html#SP27">&#167;27</a>).</p>

<p class="endnote">The function Kinds::Knowledge::check_model is used in 16/is (<a href="16-is.html#SP28">&#167;28</a>).</p>

<p class="endnote">The function Kinds::Knowledge::emit_element_of_condition is used in 16/is (<a href="16-is.html#SP29">&#167;29</a>).</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>As noted above, a POVS structure is attached to every property permission
concerning our kind.
</p>

<pre class="display">
    <span class="identifier">general_pointer</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::new_permission_granted</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">from</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">STORE_POINTER_property_of_value_storage</span><span class="plain">(</span>
            <span class="functiontext">Properties::OfValues::get_storage</span><span class="plain">());</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Kinds::Knowledge::new_permission_granted is used in 16/is (<a href="16-is.html#SP25">&#167;25</a>).</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>When a property value comes along which might have an adjectival use &mdash; say,
"green" out of a range of possible colour nouns &mdash; the following is called.
We simply pass the request along to the appropriate code.
</p>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::make_adj_const_domain</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">,</span>
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">nc</span><span class="plain">, </span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::as_kind</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">);</span>
        <span class="functiontext">Instances::make_adj_const_domain</span><span class="plain">(</span><span class="identifier">nc</span><span class="plain">, </span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Kinds::Knowledge::make_adj_const_domain is used in 16/is (<a href="16-is.html#SP26">&#167;26</a>).</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>These routines do actually do something big &mdash; they emit the great stream
of Inter commands needed to define the kinds and their properties.
</p>

<p class="inwebparagraph">First, we will call <code class="display"><span class="extract">Properties::Emit::emit_subject</span></code> for all kinds of object,
beginning with object and working downwards through the tree of its subkinds.
After that, we call it for all other kinds able to have properties, in no
particular order.
</p>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::emit_all</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">MAX_WEAK_ID_HL</span><span class="plain">);</span>
        <span class="functiontext">Emit::named_numeric_constant</span><span class="plain">(</span><span class="identifier">iname</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="identifier">next_free_data_type_ID</span><span class="plain">);</span>
        <span class="functiontext">Kinds::Knowledge::emit_recursive</span><span class="plain">(</span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">K_object</span><span class="plain">));</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::emit_recursive</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">within</span><span class="plain">) {</span>
        <span class="functiontext">Properties::Emit::emit_subject</span><span class="plain">(</span><span class="identifier">within</span><span class="plain">);</span>
        <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">subj</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">, </span><span class="reserved">inference_subject</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">InferenceSubjects::narrowest_broader_subject</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">) == </span><span class="identifier">within</span><span class="plain">) &amp;&amp;</span>
                <span class="plain">(</span><span class="functiontext">InferenceSubjects::is_a_kind_of_object</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">))) {</span>
                <span class="functiontext">Kinds::Knowledge::emit_recursive</span><span class="plain">(</span><span class="identifier">subj</span><span class="plain">);</span>
            <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::emit</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">) {</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::as_kind</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Kinds::Behaviour::has_properties</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">)) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">))</span>
            <span class="functiontext">Properties::Emit::emit_subject</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">);</span>
        <span class="functiontext">Properties::OfValues::check_allowable</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Kinds::Knowledge::emit_all is used in 16/is (<a href="16-is.html#SP30">&#167;30</a>).</p>

<p class="endnote">The function Kinds::Knowledge::emit_recursive appears nowhere else.</p>

<p class="endnote">The function Kinds::Knowledge::emit is used in 16/is (<a href="16-is.html#SP30">&#167;30</a>).</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>We use the hierarchy of inference subjects to represent the hierarchy of
kinds:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">KINDS_SUPER</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::super</span>
    <span class="definitionkeyword">define</span> <span class="constant">KINDS_COMPATIBLE</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::compatible</span>
    <span class="definitionkeyword">define</span> <span class="constant">KINDS_TEST_WITHIN</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::test_within</span>
    <span class="definitionkeyword">define</span> <span class="constant">KINDS_MOVE_WITHIN</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::move_within</span>
</pre>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::compatible</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">from</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">to</span><span class="plain">) {</span>
        <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">from_subj</span><span class="plain"> = </span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">from</span><span class="plain">);</span>
        <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">to_subj</span><span class="plain"> = </span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">to</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">InferenceSubjects::is_within</span><span class="plain">(</span><span class="identifier">from_subj</span><span class="plain">, </span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">K_object</span><span class="plain">))) &amp;&amp;</span>
            <span class="plain">(</span><span class="functiontext">InferenceSubjects::is_within</span><span class="plain">(</span><span class="identifier">to_subj</span><span class="plain">, </span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">K_object</span><span class="plain">)))) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">from_subj</span><span class="plain"> == </span><span class="identifier">to_subj</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">ALWAYS_MATCH</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">to_subj</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">ALWAYS_MATCH</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">from_subj</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">SOMETIMES_MATCH</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">InferenceSubjects::is_strictly_within</span><span class="plain">(</span><span class="identifier">from_subj</span><span class="plain">, </span><span class="identifier">to_subj</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">ALWAYS_MATCH</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">InferenceSubjects::is_strictly_within</span><span class="plain">(</span><span class="identifier">to_subj</span><span class="plain">, </span><span class="identifier">from_subj</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">SOMETIMES_MATCH</span><span class="plain">;</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NEVER_MATCH</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NO_DECISION_ON_MATCH</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">kind</span><span class="plain"> *</span><span class="functiontext">Kinds::Knowledge::super</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)) {</span>
            <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain"> = </span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">InferenceSubjects::as_kind</span><span class="plain">(</span><span class="functiontext">InferenceSubjects::narrowest_broader_subject</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">));</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::test_within</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">sub</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">super</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">InferenceSubjects::is_within</span><span class="plain">(</span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">sub</span><span class="plain">), </span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">super</span><span class="plain">));</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::move_within</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">sub</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">super</span><span class="plain">) {</span>
        <span class="functiontext">InferenceSubjects::falls_within</span><span class="plain">(</span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">sub</span><span class="plain">), </span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">super</span><span class="plain">));</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::include_templates_for_kinds</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">Kinds::Interpreter::include_templates_for_kinds</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">());</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Kinds::Knowledge::compatible appears nowhere else.</p>

<p class="endnote">The function Kinds::Knowledge::super appears nowhere else.</p>

<p class="endnote">The function Kinds::Knowledge::test_within appears nowhere else.</p>

<p class="endnote">The function Kinds::Knowledge::move_within appears nowhere else.</p>

<p class="endnote">The function Kinds::Knowledge::include_templates_for_kinds is used in 1/htc (<a href="1-htc.html#SP2_3">&#167;2.3</a>).</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Problems with kinds. </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">KINDS_PROBLEM_HANDLER</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::kinds_problem_handler</span>
</pre>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Kinds::Knowledge::kinds_problem_handler</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">err_no</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K1</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K2</span><span class="plain">) {</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">err_no</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">DimensionRedundant_KINDERROR:</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_DimensionRedundant</span><span class="plain">),</span>
                    <span class="string">"multiplication rules can only be given once"</span><span class="plain">,</span>
                    <span class="string">"and this combination is already established."</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">DimensionNotBaseKOV_KINDERROR:</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_DimensionNotBaseKOV</span><span class="plain">),</span>
                    <span class="string">"multiplication rules can only involve simple kinds of value"</span><span class="plain">,</span>
                    <span class="string">"rather than complicated ones such as lists of other values."</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">NonDimensional_KINDERROR:</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_NonDimensional</span><span class="plain">),</span>
                    <span class="string">"multiplication rules can only be given between kinds of "</span>
                    <span class="string">"value which are known to be numerical"</span><span class="plain">,</span>
                    <span class="string">"and not all of these are. Saying something like 'Pressure is a "</span>
                    <span class="string">"kind of value.' is not enough - you may think 'pressure' ought "</span>
                    <span class="string">"to be numerical, but Inform doesn't know that yet. You need "</span>
                    <span class="string">"to add something like '100 Pa specifies a pressure.' before "</span>
                    <span class="string">"Inform will realise."</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">UnitSequenceOverflow_KINDERROR:</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnitSequenceOverflow</span><span class="plain">),</span>
                    <span class="string">"reading that sentence led me into calculating such a complicated "</span>
                    <span class="string">"kind of value that I ran out of memory"</span><span class="plain">,</span>
                    <span class="string">"which my programmer really didn't expect to happen. I think you "</span>
                    <span class="string">"must have made an awful lot of numerical kinds of value, and "</span>
                    <span class="string">"then specified how they multiply so that one of them became "</span>
                    <span class="string">"weirdly tricky. Can you simplify?"</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">DimensionsInconsistent_KINDERROR:</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_DimensionsInconsistent</span><span class="plain">),</span>
                    <span class="string">"this is inconsistent with what is already known about those kinds of value"</span><span class="plain">,</span>
                    <span class="string">"all three of which already have well-established relationships - see the "</span>
                    <span class="string">"Kinds index for more."</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">KindUnalterable_KINDERROR:</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(2, </span><span class="identifier">pn</span><span class="plain">);</span>
                <span class="functiontext">Problems::quote_kind</span><span class="plain">(3, </span><span class="identifier">K1</span><span class="plain">);</span>
                <span class="functiontext">Problems::quote_kind</span><span class="plain">(4, </span><span class="identifier">K2</span><span class="plain">);</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_KindUnalterable</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"You wrote %1, but that seems to contradict %2, as %3 and %4 "</span>
                    <span class="string">"are incompatible. (If %3 were a kind of %4 or vice versa "</span>
                    <span class="string">"there'd be no problem, but they aren't.)"</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">KindsCircular_KINDERROR:</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(2, </span><span class="identifier">pn</span><span class="plain">);</span>
                <span class="functiontext">Problems::quote_kind</span><span class="plain">(3, </span><span class="identifier">K1</span><span class="plain">);</span>
                <span class="functiontext">Problems::quote_kind</span><span class="plain">(4, </span><span class="identifier">K2</span><span class="plain">);</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_KindsCircular</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"You wrote %1, but that seems to contradict %2, as it would "</span>
                    <span class="string">"make a circularity with %3 and %4 each being kinds of the "</span>
                    <span class="string">"other."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">LPCantScaleYet_KINDERROR:</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPCantScaleYet</span><span class="plain">),</span>
                    <span class="string">"this tries to scale up or down a value which so far has no point of "</span>
                    <span class="string">"reference to scale from"</span><span class="plain">,</span>
                    <span class="string">"which is impossible."</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">LPCantScaleTwice_KINDERROR:</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_LPCantScaleTwice</span><span class="plain">),</span>
                    <span class="string">"this tries to specify the scaling for a kind of value whose "</span>
                    <span class="string">"scaling is already established"</span><span class="plain">,</span>
                    <span class="string">"which is impossible."</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="identifier">default:</span><span class="plain"> </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"unimplemented problem message"</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Kinds::Knowledge::kinds_problem_handler appears nowhere else.</p>

<hr class="tocbar">
<ul class="toc"><li><i>(This section begins Chapter 13: Bridge to Kinds Module.)</i></li><li><a href="13-ca.html">Continue with 'Compile Arithmetic'</a></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

