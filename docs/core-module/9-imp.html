<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>9/ass</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../compiler.html"><b>compiler tools</b></a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul>
<h2>Compiler Webs</h2>
<ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul>
<h2>Inbuild Modules</h2>
<ul>
<li><a href="../inbuild-module/index.html">inbuild</a></li>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../html-module/index.html">html</a></li>
</ul>
<h2>Inform7 Modules</h2>
<ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul>
<h2>Inter Modules</h2>
<ul>
<li><a href="../inter-module/index.html">inter</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of '9/imp' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="../compiler.html">Compiler Modules</a></li><li><a href="index.html">core</a></li><li><a href="index.html#9">Chapter 9: The A-Parser</a></li><li><b>Implications</b></li></ul><p class="purpose">To keep track of a dangerous form of super-assertion called an implication, which is allowed to generalise about properties.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP5">&#167;5. Implication checking</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>Implications are structures are used to store the information in sentences
like "Something worn is usually wearable and initially carried." The
"something worn" part must turn out to be a description of a category of
objects; the "usually" part translates into a level of certainty. We regard
these as implications in the sense of IF condition A, THEN condition B, but
note that A is quite restricted in what it can be: it must be a simple-to-test
description only, whereas B could be any subtree of an assertion.
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">implication</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">if_spec</span><span class="plain">; </span>    <span class="comment">which objects are affected</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">then_pn</span><span class="plain">; </span>    <span class="comment">what assertion is implied about them</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">implied_likelihood</span><span class="plain">; </span>    <span class="comment">with what certainty level</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">implication</span><span class="plain"> *</span><span class="identifier">next_implication</span><span class="plain">; </span>    <span class="comment">in list of implications</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">implication</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure implication is private to this section.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>We also need a little piece of storage attached to each property name:
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">possession_marker</span><span class="plain"> {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">possessed</span><span class="plain">; </span>    <span class="comment">temporary use when checking implications about objects</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">possession_certainty</span><span class="plain">; </span>    <span class="comment">ditto</span>
    <span class="plain">} </span><span class="reserved">possession_marker</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure possession_marker is accessed in 12/ap and here.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>Implications are gathered during the main parse tree traverses, but all we do
is to store them and sit on them.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Assertions::Implications::new</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">px</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">py</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prevailing_mood</span><span class="plain"> == </span><span class="identifier">CERTAIN_CE</span><span class="plain">) </span>&lt;<span class="cwebmacro">Reject implications given with certainty</span> <span class="cwebmacronumber">4.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">py</span><span class="plain">) == </span><span class="identifier">AND_NT</span><span class="plain">) {</span>
            <span class="functiontext">Assertions::Implications::new</span><span class="plain">(</span><span class="identifier">px</span><span class="plain">, </span><span class="identifier">py</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">);</span>
            <span class="functiontext">Assertions::Implications::new</span><span class="plain">(</span><span class="identifier">px</span><span class="plain">, </span><span class="identifier">py</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        &lt;<span class="cwebmacro">Actually create a single implication</span> <span class="cwebmacronumber">4.2</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Assertions::Implications::new is used in 9/ma (<a href="9-ma.html#SP3_3_2">&#167;3.3.2</a>, <a href="9-ma.html#SP3_3_22">&#167;3.3.22</a>).</p>

<p class="inwebparagraph"><a id="SP4_1"></a><b>&#167;4.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Reject implications given with certainty</span> <span class="cwebmacronumber">4.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ImplicationCertain</span><span class="plain">),</span>
            <span class="string">"that's an implication which is too certain for me"</span><span class="plain">,</span>
            <span class="string">"since a sentence like this talks about a generality of things in terms of "</span>
            <span class="string">"one either/or property implying another, and I can only handle those as "</span>
            <span class="string">"likelihoods. You should probably add 'usually' somewhere: e.g., 'An open "</span>
            <span class="string">"door is usually openable'. (But implications can have unpredictable "</span>
            <span class="string">"consequences: best to avoid them altogether where possible.)"</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP4">&#167;4</a>.</p>

<p class="inwebparagraph"><a id="SP4_2"></a><b>&#167;4.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Actually create a single implication</span> <span class="cwebmacronumber">4.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">premiss_kind</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">premiss</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        &lt;<span class="cwebmacro">Find the premiss kind and specification</span> <span class="cwebmacronumber">4.2.1</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Check that the premiss involves only either/or properties and/or a kind</span> <span class="cwebmacronumber">4.2.2</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Check that the conclusion involves only a single either/or property</span> <span class="cwebmacronumber">4.2.3</span>&gt;<span class="plain">;</span>

        <span class="reserved">implication</span><span class="plain"> *</span><span class="identifier">imp</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">implication</span><span class="plain">);</span>
        <span class="identifier">imp</span><span class="plain">-</span><span class="element">&gt;if_spec</span><span class="plain"> = </span><span class="identifier">premiss</span><span class="plain">;</span>
        <span class="identifier">imp</span><span class="plain">-</span><span class="element">&gt;then_pn</span><span class="plain"> = </span><span class="identifier">py</span><span class="plain">;</span>
        <span class="identifier">imp</span><span class="plain">-</span><span class="element">&gt;implied_likelihood</span><span class="plain"> = </span><span class="identifier">prevailing_mood</span><span class="plain">;</span>

        <span class="identifier">imp</span><span class="plain">-</span><span class="element">&gt;next_implication</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::get_implications</span><span class="plain">(</span><span class="identifier">premiss_kind</span><span class="plain">);</span>
        <span class="functiontext">InferenceSubjects::set_implications</span><span class="plain">(</span><span class="identifier">premiss_kind</span><span class="plain">, </span><span class="identifier">imp</span><span class="plain">);</span>

        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">IMPLICATIONS</span><span class="plain">, </span><span class="string">"Forming implication for $j: $D implies\</span><span class="plain">n</span><span class="string">  $T"</span><span class="plain">,</span>
            <span class="identifier">premiss_kind</span><span class="plain">, </span><span class="identifier">imp</span><span class="plain">-</span><span class="element">&gt;if_spec</span><span class="plain">, </span><span class="identifier">imp</span><span class="plain">-</span><span class="element">&gt;then_pn</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP4">&#167;4</a>.</p>

<p class="inwebparagraph"><a id="SP4_2_1"></a><b>&#167;4.2.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Find the premiss kind and specification</span> <span class="cwebmacronumber">4.2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">loc</span><span class="plain"> = </span><span class="identifier">px</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">loc</span><span class="plain">) == </span><span class="identifier">WITH_NT</span><span class="plain">) </span><span class="identifier">loc</span><span class="plain"> = </span><span class="identifier">loc</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">;</span>
        <span class="identifier">premiss_kind</span><span class="plain"> = </span><span class="identifier">ParseTree::get_subject</span><span class="plain">(</span><span class="identifier">loc</span><span class="plain">);</span>
        <span class="identifier">premiss</span><span class="plain"> = </span><span class="identifier">ParseTree::get_creation_proposition</span><span class="plain">(</span><span class="identifier">loc</span><span class="plain">);</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">premiss_kind</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">premiss_kind</span><span class="plain"> = </span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">K_thing</span><span class="plain">);</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="plain">#</span><span class="identifier">ifndef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">premiss_kind</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">premiss_kind</span><span class="plain"> = </span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">K_object</span><span class="plain">);</span>
        <span class="plain">#</span><span class="identifier">endif</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP4_2">&#167;4.2</a>.</p>

<p class="inwebparagraph"><a id="SP4_2_2"></a><b>&#167;4.2.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Check that the premiss involves only either/or properties and/or a kind</span> <span class="cwebmacronumber">4.2.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Propositions::Assert::testable_at_compile_time</span><span class="plain">(</span><span class="identifier">premiss</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BadImplicationDomain</span><span class="plain">),</span>
                <span class="string">"that's an implication where the condition to qualify is not "</span>
                <span class="string">"one that I can determine in advance of the start of play"</span><span class="plain">,</span>
                <span class="string">"since it involves more than simple either/or properties "</span>
                <span class="string">"plus a kind. (For example, adjectives like 'adjacent' or "</span>
                <span class="string">"'visible' here are too difficult to determine.)"</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP4_2">&#167;4.2</a>.</p>

<p class="inwebparagraph"><a id="SP4_2_3"></a><b>&#167;4.2.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Check that the conclusion involves only a single either/or property</span> <span class="cwebmacronumber">4.2.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::has_EORP_meaning</span><span class="plain">(</span><span class="identifier">ParseTree::get_aph</span><span class="plain">(</span><span class="identifier">py</span><span class="plain">), </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prn</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ImplicationValueProperty</span><span class="plain">),</span>
                <span class="string">"that's an implication where the outcome is an adjective other than "</span>
                <span class="string">"a simple either/or property"</span><span class="plain">,</span>
                <span class="string">"which is the only form of implication I can handle."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP4_2">&#167;4.2</a>.</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Implication checking. </b>The checking of implications happens all at once, during model completion,
so that all inferences arising directly from the source text have already
been drawn.
</p>

<p class="inwebparagraph">For instance, if there is an inference asserting that object X is worn, and
there is an implication that what is worn is usually also wearable, then we
must generate an inference that X is wearable: in effect, this is a deduction
from a syllogism. We should however not generate such an inference if we
already have definite knowledge that X is not wearable. We do this for each
object X individually.
</p>

<p class="inwebparagraph">We begin by checking implications associated with X and applying to X,
but in fact because <code class="display"><span class="extract">Assertions::Implications::check_implications_of</span></code> recurses depth-first through
the kinds, a typical object X &mdash; a container, say &mdash; will first have
implications associated with "thing" applied to it, then with
those associated with "container", and only then its own implications.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Assertions::Implications::consider_all</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">InferenceSubjects::domain</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">ongoing</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> (</span><span class="identifier">ongoing</span><span class="plain">) {</span>
            &lt;<span class="cwebmacro">Erase all of the possession markers</span> <span class="cwebmacronumber">5.1</span>&gt;<span class="plain">;</span>
            <span class="functiontext">Assertions::Implications::set_possessed_flags</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">);</span>
            <span class="identifier">ongoing</span><span class="plain"> = </span><span class="functiontext">Assertions::Implications::check_implications_of</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">, </span><span class="identifier">infs</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Assertions::Implications::consider_all is used in 16/cmw (<a href="16-cmw.html#SP1_1">&#167;1.1</a>).</p>

<p class="inwebparagraph"><a id="SP5_1"></a><b>&#167;5.1.  </b>We are going to need to examine which either/or properties are held by X.
We don't want to store all of the properties of everything in memory at once,
so we keep just a single set of "possession markers", one for each property.
Here we erase these markers ready for use with X.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Erase all of the possession markers</span> <span class="cwebmacronumber">5.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">, </span><span class="reserved">property</span><span class="plain">) {</span>
            <span class="reserved">possession_marker</span><span class="plain"> *</span><span class="identifier">pom</span><span class="plain"> = </span><span class="functiontext">Properties::get_possession_marker</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">);</span>
            <span class="identifier">pom</span><span class="plain">-</span><span class="element">&gt;possessed</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="identifier">pom</span><span class="plain">-</span><span class="element">&gt;possession_certainty</span><span class="plain"> = </span><span class="identifier">UNKNOWN_CE</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP5">&#167;5</a>.</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>This is the recursive routine which sets the possession markers for X on the
basis of the inferences so far drawn about it.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Assertions::Implications::set_possessed_flags</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">) {</span>
        <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">k</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::narrowest_broader_subject</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">k</span><span class="plain">) </span><span class="functiontext">Assertions::Implications::set_possessed_flags</span><span class="plain">(</span><span class="identifier">k</span><span class="plain">);</span>

        <span class="reserved">inference</span><span class="plain"> *</span><span class="identifier">inf</span><span class="plain">;</span>
        <span class="identifier">KNOWLEDGE_LOOP</span><span class="plain">(</span><span class="identifier">inf</span><span class="plain">, </span><span class="identifier">infs</span><span class="plain">, </span><span class="constant">PROPERTY_INF</span><span class="plain">) {</span>
            <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain"> = </span><span class="functiontext">World::Inferences::get_property</span><span class="plain">(</span><span class="identifier">inf</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">Properties::is_either_or</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">)) &amp;&amp; (</span><span class="functiontext">World::Inferences::get_certainty</span><span class="plain">(</span><span class="identifier">inf</span><span class="plain">) != </span><span class="identifier">UNKNOWN_CE</span><span class="plain">))</span>
                &lt;<span class="cwebmacro">See what we can get out of this inference</span> <span class="cwebmacronumber">6.1</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Assertions::Implications::set_possessed_flags is used in <a href="#SP5">&#167;5</a>.</p>

<p class="inwebparagraph"><a id="SP6_1"></a><b>&#167;6.1.  </b>Note that where there are antonyms such as open/closed, we have to mark
both of them, because an inference of being closed is as good as an inference
of not being open, and vice versa.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">See what we can get out of this inference</span> <span class="cwebmacronumber">6.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">truth_state</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">certainty</span><span class="plain"> = </span><span class="functiontext">World::Inferences::get_certainty</span><span class="plain">(</span><span class="identifier">inf</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">certainty</span><span class="plain"> &lt; 0) { </span><span class="identifier">certainty</span><span class="plain"> = -</span><span class="identifier">certainty</span><span class="plain">; </span><span class="identifier">truth_state</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">; }</span>

        <span class="reserved">possession_marker</span><span class="plain"> *</span><span class="identifier">pom</span><span class="plain"> = </span><span class="functiontext">Properties::get_possession_marker</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">Mark this property if its possession is not already equally certainly known</span> <span class="cwebmacronumber">6.1.1</span>&gt;<span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Properties::EitherOr::get_negation</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">)) {</span>
            <span class="identifier">prn</span><span class="plain"> = </span><span class="functiontext">Properties::EitherOr::get_negation</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">);</span>
            <span class="identifier">pom</span><span class="plain"> = </span><span class="functiontext">Properties::get_possession_marker</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">);</span>
            <span class="identifier">truth_state</span><span class="plain"> = (</span><span class="identifier">truth_state</span><span class="plain">)?</span><span class="identifier">FALSE</span><span class="plain">:</span><span class="identifier">TRUE</span><span class="plain">;</span>
            &lt;<span class="cwebmacro">Mark this property if its possession is not already equally certainly known</span> <span class="cwebmacronumber">6.1.1</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_1_1"></a><b>&#167;6.1.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Mark this property if its possession is not already equally certainly known</span> <span class="cwebmacronumber">6.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pom</span><span class="plain">-</span><span class="element">&gt;possession_certainty</span><span class="plain"> &lt; </span><span class="identifier">certainty</span><span class="plain">) {</span>
            <span class="identifier">pom</span><span class="plain">-</span><span class="element">&gt;possessed</span><span class="plain"> = </span><span class="identifier">truth_state</span><span class="plain">;</span>
            <span class="identifier">pom</span><span class="plain">-</span><span class="element">&gt;possession_certainty</span><span class="plain"> = </span><span class="identifier">certainty</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6_1">&#167;6.1</a> (twice).</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>Lastly, then, the routine actually checking and applying implications.
Our aim is to find and act upon the first implication which makes a difference,
and return <code class="display"><span class="extract">TRUE</span></code>; but if no implication can be acted on, to return <code class="display"><span class="extract">FALSE</span></code>.
</p>

<p class="inwebparagraph">This cannot act twice on the same candidate with the same implication, since
the act results in creating inferences about the property. An attempt at
repetition results in redundancy, since the inferences it would make have
no better a certainty level.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Assertions::Implications::check_implications_of</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">domain</span><span class="plain">, </span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">candidate</span><span class="plain">) {</span>
        <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">k</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::narrowest_broader_subject</span><span class="plain">(</span><span class="identifier">domain</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">k</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">Assertions::Implications::check_implications_of</span><span class="plain">(</span><span class="identifier">k</span><span class="plain">, </span><span class="identifier">candidate</span><span class="plain">))) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">InferenceSubjects::get_implications</span><span class="plain">(</span><span class="identifier">domain</span><span class="plain">))</span>
            <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">IMPLICATIONS</span><span class="plain">, </span><span class="string">"Considering implications about $j as they apply to $j:\</span><span class="plain">n</span><span class="string">"</span><span class="plain">,</span>
                <span class="identifier">domain</span><span class="plain">, </span><span class="identifier">candidate</span><span class="plain">);</span>

        <span class="reserved">implication</span><span class="plain"> *</span><span class="identifier">imp</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">imp</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::get_implications</span><span class="plain">(</span><span class="identifier">domain</span><span class="plain">); </span><span class="identifier">imp</span><span class="plain">; </span><span class="identifier">imp</span><span class="plain"> = </span><span class="identifier">imp</span><span class="plain">-</span><span class="element">&gt;next_implication</span><span class="plain">)</span>
            &lt;<span class="cwebmacro">Consider this individual implication as it applies to the candidate</span> <span class="cwebmacronumber">7.1</span>&gt;<span class="plain">;</span>

        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Assertions::Implications::check_implications_of is used in <a href="#SP5">&#167;5</a>.</p>

<p class="inwebparagraph"><a id="SP7_1"></a><b>&#167;7.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Consider this individual implication as it applies to the candidate</span> <span class="cwebmacronumber">7.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">conclusion_state</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">imp</span><span class="plain">-</span><span class="element">&gt;then_pn</span><span class="plain">, </span><span class="constant">negated_boolean_ANNOT</span><span class="plain">)) </span><span class="identifier">conclusion_state</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">imp</span><span class="plain">-</span><span class="element">&gt;implied_likelihood</span><span class="plain"> &lt; 0) </span><span class="identifier">conclusion_state</span><span class="plain"> = (</span><span class="identifier">conclusion_state</span><span class="plain">)?</span><span class="identifier">FALSE</span><span class="plain">:</span><span class="identifier">TRUE</span><span class="plain">;</span>

        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">IMPLICATIONS</span><span class="plain">, </span><span class="string">"$D =&gt; $T (certainty %d; changed state %d)\</span><span class="plain">n</span><span class="string">"</span><span class="plain">,</span>
            <span class="identifier">imp</span><span class="plain">-</span><span class="element">&gt;if_spec</span><span class="plain">, </span><span class="identifier">imp</span><span class="plain">-</span><span class="element">&gt;then_pn</span><span class="plain">, </span><span class="identifier">imp</span><span class="plain">-</span><span class="element">&gt;implied_likelihood</span><span class="plain">, </span><span class="identifier">conclusion_state</span><span class="plain">);</span>

        <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">conclusion_prop</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::has_EORP_meaning</span><span class="plain">(</span><span class="identifier">ParseTree::get_aph</span><span class="plain">(</span><span class="identifier">imp</span><span class="plain">-</span><span class="element">&gt;then_pn</span><span class="plain">), </span><span class="identifier">NULL</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">Check that the conclusion is not impossible</span> <span class="cwebmacronumber">7.1.1</span>&gt;<span class="plain">;</span>

        <span class="reserved">possession_marker</span><span class="plain"> *</span><span class="identifier">pom</span><span class="plain"> = </span><span class="functiontext">Properties::get_possession_marker</span><span class="plain">(</span><span class="identifier">conclusion_prop</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">Check that the conclusion is not redundant or irrelevant</span> <span class="cwebmacronumber">7.1.2</span>&gt;<span class="plain">;</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">candidate_qualifies</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::Assert::test_at_compile_time</span><span class="plain">(</span><span class="identifier">imp</span><span class="plain">-</span><span class="element">&gt;if_spec</span><span class="plain">, </span><span class="identifier">candidate</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">candidate_qualifies</span><span class="plain">) {</span>
            <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">IMPLICATIONS</span><span class="plain">, </span><span class="string">"PASS: changing property $Y of $j\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">conclusion_prop</span><span class="plain">, </span><span class="identifier">candidate</span><span class="plain">);</span>
            &lt;<span class="cwebmacro">Apply the conclusion to the candidate</span> <span class="cwebmacronumber">7.1.3</span>&gt;<span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">IMPLICATIONS</span><span class="plain">, </span><span class="string">"FAIL: take no action\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7">&#167;7</a>.</p>

<p class="inwebparagraph"><a id="SP7_1_1"></a><b>&#167;7.1.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Check that the conclusion is not impossible</span> <span class="cwebmacronumber">7.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">conclusion_prop</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) ||</span>
            <span class="plain">(</span><span class="functiontext">World::Permissions::find</span><span class="plain">(</span><span class="identifier">candidate</span><span class="plain">, </span><span class="identifier">conclusion_prop</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">) == </span><span class="identifier">NULL</span><span class="plain">)) {</span>
            <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">IMPLICATIONS</span><span class="plain">, </span><span class="string">"IMPOSSIBLE: property not provided\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
            <span class="reserved">continue</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7_1">&#167;7.1</a>.</p>

<p class="inwebparagraph"><a id="SP7_1_2"></a><b>&#167;7.1.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Check that the conclusion is not redundant or irrelevant</span> <span class="cwebmacronumber">7.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">IMPLICATIONS</span><span class="plain">, </span><span class="string">"Possession marker has (certainty %d; possessed state %d)\</span><span class="plain">n</span><span class="string">"</span><span class="plain">,</span>
            <span class="identifier">pom</span><span class="plain">-</span><span class="element">&gt;possession_certainty</span><span class="plain">, </span><span class="identifier">pom</span><span class="plain">-</span><span class="element">&gt;possessed</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pom</span><span class="plain">-</span><span class="element">&gt;possessed</span><span class="plain"> == </span><span class="identifier">conclusion_state</span><span class="plain">) {</span>
            <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">IMPLICATIONS</span><span class="plain">, </span><span class="string">"REDUNDANT: property already correct\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
            <span class="reserved">continue</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pom</span><span class="plain">-</span><span class="element">&gt;possession_certainty</span><span class="plain"> == </span><span class="identifier">CERTAIN_CE</span><span class="plain">) {</span>
            <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">IMPLICATIONS</span><span class="plain">, </span><span class="string">"IRRELEVANT: property already settled\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
            <span class="reserved">continue</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7_1">&#167;7.1</a>.</p>

<p class="inwebparagraph"><a id="SP7_1_3"></a><b>&#167;7.1.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Apply the conclusion to the candidate</span> <span class="cwebmacronumber">7.1.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain"> = </span><span class="functiontext">Properties::EitherOr::get_aph</span><span class="plain">(</span><span class="identifier">conclusion_prop</span><span class="plain">);</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::KIND_new</span><span class="plain">(</span><span class="functiontext">InferenceSubjects::domain</span><span class="plain">(</span><span class="identifier">domain</span><span class="plain">), </span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">conclusion_state</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::concatenate</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">NEGATION_OPEN_ATOM</span><span class="plain">));</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::concatenate</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="functiontext">Calculus::Atoms::unary_PREDICATE_from_aph</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">));</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::concatenate</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">NEGATION_CLOSE_ATOM</span><span class="plain">));</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::concatenate</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="functiontext">Calculus::Atoms::unary_PREDICATE_from_aph</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">));</span>
        <span class="plain">}</span>
        <span class="functiontext">Calculus::Propositions::Assert::assert_true_about</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">candidate</span><span class="plain">, </span><span class="identifier">CERTAIN_CE</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7_1">&#167;7.1</a>.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="9-ass.html">Back to 'Assemblies'</a></li><li><a href="9-pd.html">Continue with 'Property Declarations'</a></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

