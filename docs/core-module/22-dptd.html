<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>22/ptd</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '22/dptd' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#22">Chapter 22: Phrases</a></li><li><b>Describing Phrase Type Data</b></li></ul><p class="purpose">To convert phrase type data to and from text.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Logging</a></li><li><a href="#SP3">&#167;3. HTML forms</a></li><li><a href="#SP4">&#167;4. Problem messages</a></li><li><a href="#SP5">&#167;5. Indexing</a></li><li><a href="#SP7">&#167;7. Comments in compiled code</a></li><li><a href="#SP8">&#167;8. Parsing a PHTD</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Logging. </b>We begin with the problem of printing out a textual description of a PHTD.
The debugging log is simple:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Phrases::TypeData::Textual::log</span><span class="plain">(</span><span class="reserved">ph_type_data</span><span class="plain"> *</span><span class="identifier">phtd</span><span class="plain">) {</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"  PHTD: register as &lt;%W&gt;\</span><span class="plain">n</span><span class="string">  %s\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;registration_text</span><span class="plain">,</span>
            <span class="functiontext">Phrases::TypeData::describe_manner_of_return</span><span class="plain">(</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;manner_of_return</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;manner_of_return</span><span class="plain"> == </span><span class="constant">DECIDES_VALUE_MOR</span><span class="plain">)</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"  decides value of kind $u\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;return_kind</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">Log the word sequence</span> <span class="cwebmacronumber">1.1</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Log the token sequence</span> <span class="cwebmacronumber">1.2</span>&gt;<span class="plain">;</span>
        <span class="functiontext">Phrases::TypeData::log_inline_details</span><span class="plain">(</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;as_inline</span><span class="plain">);</span>
        <span class="functiontext">Phrases::TypeData::log_say_details</span><span class="plain">(</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;as_say</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::TypeData::Textual::log is used in 1/cm (<a href="1-cm.html#SP5">&#167;5</a>, <a href="1-cm.html#SP6_6">&#167;6.6</a>).</p>

<p class="inwebparagraph"><a id="SP1_1"></a><b>&#167;1.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Log the word sequence</span> <span class="cwebmacronumber">1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"  "</span><span class="plain">);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;no_words</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;word_sequence</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] &lt; </span><span class="constant">MAX_TOKENS_PER_PHRASE</span><span class="plain">)</span>
                <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"#%d "</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;word_sequence</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]);</span>
            <span class="reserved">else</span>
                <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"%N "</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;word_sequence</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]);</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"(%d words)\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;no_words</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1">&#167;1</a>.</p>

<p class="inwebparagraph"><a id="SP1_2"></a><b>&#167;1.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Log the token sequence</span> <span class="cwebmacronumber">1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;no_tokens</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++)</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"  #%d: \</span><span class="plain">"</span><span class="string">%W\</span><span class="plain">"</span><span class="string"> = $P\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">i</span><span class="plain">,</span>
                <span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;token_sequence</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]</span><span class="element">.token_name</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;token_sequence</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]</span><span class="element">.to_match</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1">&#167;1</a>.</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>Abbreviatedly:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Phrases::TypeData::Textual::log_briefly</span><span class="plain">(</span><span class="reserved">ph_type_data</span><span class="plain"> *</span><span class="identifier">phtd</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phtd</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) { </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"NULL-PHTD"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain">; }</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"\</span><span class="plain">"</span><span class="string">%W\</span><span class="plain">"</span><span class="string">"</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;registration_text</span><span class="plain">);</span>
        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;manner_of_return</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">DECIDES_CONDITION_MOR</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"(=condition)"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">DECIDES_VALUE_MOR</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"(=$u)"</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;return_kind</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::TypeData::Textual::log_briefly is used in 22/ph (<a href="22-ph.html#SP9">&#167;9</a>).</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. HTML forms. </b>But the debugging log isn't the only place we want to write out the phrase
type to: it also gets written to HTML, not just openly but also in the
Javascript pasted form. One reason for this is to write entries in the
Phrasebook Index, but another is to show what Inform was trying to do when
issuing a Problem message: usually it has managed partially to match up the
tokens in a phrase, and has a mostly-formed but incorrect invocation as
a result. If such an invocation <code class="display"><span class="extract">inv</span></code> is supplied here, than the attempted
match is shown.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">PASTE_PHRASE_FORMAT</span><span class="plain"> 1 </span>    <span class="comment">in the insert-to-source text pasted by a button in the Index</span>
    <span class="definitionkeyword">define</span> <span class="constant">INDEX_PHRASE_FORMAT</span><span class="plain"> 2 </span>    <span class="comment">a simpler version good enough for most purposes</span>
</pre>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Phrases::TypeData::Textual::write_HTML_representation</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">,</span>
        <span class="reserved">ph_type_data</span><span class="plain"> *</span><span class="identifier">phtd</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">paste_format</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">inv</span><span class="plain">) {</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">seq_from</span><span class="plain"> = 0, </span><span class="identifier">seq_to</span><span class="plain"> = </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;no_words</span><span class="plain">;</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">writing_a_say</span><span class="plain"> = </span><span class="functiontext">Phrases::TypeData::preface_for_say_HTML</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;as_say</span><span class="plain">, </span><span class="identifier">paste_format</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">writing_a_say</span><span class="plain"> == </span><span class="identifier">NOT_APPLICABLE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">writing_a_say</span><span class="plain">) </span><span class="identifier">seq_from</span><span class="plain"> = 1; </span>    <span class="comment">skip the first word, which is necessarily "say" in this case</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;as_inline.block_follows</span><span class="plain">) </span><span class="identifier">seq_to</span><span class="plain">--; </span>    <span class="comment">skip the last word, which is a block marker</span>

        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">paste_format</span><span class="plain"> == </span><span class="constant">PASTE_PHRASE_FORMAT</span><span class="plain">) &amp;&amp; (</span><span class="identifier">writing_a_say</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;word_sequence</span><span class="plain">[0] &lt; </span><span class="constant">MAX_TOKENS_PER_PHRASE</span><span class="plain">) </span><span class="identifier">seq_from</span><span class="plain">++;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;word_sequence</span><span class="plain">[</span><span class="identifier">seq_to</span><span class="plain">-1] &lt; </span><span class="constant">MAX_TOKENS_PER_PHRASE</span><span class="plain">) &amp;&amp;</span>
                <span class="plain">(</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;as_inline.block_follows</span><span class="plain"> == </span><span class="constant">NO_BLOCK_FOLLOWS</span><span class="plain">)) </span><span class="identifier">seq_to</span><span class="plain">--;</span>
        <span class="plain">}</span>
        &lt;<span class="cwebmacro">Describe the word sequence</span> <span class="cwebmacronumber">3.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;as_inline.block_follows</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">paste_format</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">":\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
            <span class="reserved">else</span><span class="plain"> {</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">":"</span><span class="plain">);</span>
                <span class="identifier">HTML_TAG</span><span class="plain">(</span><span class="string">"br"</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&amp;nbsp;&amp;nbsp;&amp;nbsp;"</span><span class="plain">);</span>
                <span class="identifier">HTML_OPEN</span><span class="plain">(</span><span class="string">"i"</span><span class="plain">);</span>
                <span class="identifier">HTML::begin_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"ff4040"</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"phrases"</span><span class="plain">);</span>
                <span class="identifier">HTML::end_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">);</span>
                <span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"i"</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>

        <span class="functiontext">Phrases::TypeData::epilogue_for_say_HTML</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;as_say</span><span class="plain">, </span><span class="identifier">paste_format</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::TypeData::Textual::write_HTML_representation is used in <a href="#SP4">&#167;4</a>, 22/ph (<a href="22-ph.html#SP10">&#167;10</a>).</p>

<p class="inwebparagraph"><a id="SP3_1"></a><b>&#167;3.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Describe the word sequence</span> <span class="cwebmacronumber">3.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">j</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">j</span><span class="plain">=</span><span class="identifier">seq_from</span><span class="plain">; </span><span class="identifier">j</span><span class="plain">&lt;</span><span class="identifier">seq_to</span><span class="plain">; </span><span class="identifier">j</span><span class="plain">++) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">j</span><span class="plain"> &gt; </span><span class="identifier">seq_from</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" "</span><span class="plain">);</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">ix</span><span class="plain"> = </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;word_sequence</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">];</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ix</span><span class="plain"> &lt; </span><span class="constant">MAX_TOKENS_PER_PHRASE</span><span class="plain">)</span>
                &lt;<span class="cwebmacro">Describe a token in the word sequence</span> <span class="cwebmacronumber">3.1.2</span>&gt;
            <span class="reserved">else</span>
                &lt;<span class="cwebmacro">Describe a fixed word in the word sequence</span> <span class="cwebmacronumber">3.1.1</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP3">&#167;3</a>.</p>

<p class="inwebparagraph"><a id="SP3_1_1"></a><b>&#167;3.1.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Describe a fixed word in the word sequence</span> <span class="cwebmacronumber">3.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">Lexer::word_raw_text</span><span class="plain">(</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;word_sequence</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">]);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">tinted</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">p</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]; </span><span class="identifier">i</span><span class="plain">++) {</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">p</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] == </span><span class="character">'/'</span><span class="plain">) &amp;&amp; (</span><span class="identifier">tinted</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
                <span class="identifier">tinted</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">paste_format</span><span class="plain"> == </span><span class="constant">PASTE_PHRASE_FORMAT</span><span class="plain">) </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="identifier">HTML::begin_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"808080"</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%c"</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]);</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">paste_format</span><span class="plain"> != </span><span class="constant">PASTE_PHRASE_FORMAT</span><span class="plain">) &amp;&amp; (</span><span class="identifier">tinted</span><span class="plain">)) </span><span class="identifier">HTML::end_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP3_1">&#167;3.1</a>.</p>

<p class="inwebparagraph"><a id="SP3_1_2"></a><b>&#167;3.1.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Describe a token in the word sequence</span> <span class="cwebmacronumber">3.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">paste_format</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">INDEX_PHRASE_FORMAT</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">writing_a_say</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"("</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">inv</span><span class="plain">) {</span>
                    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">found</span><span class="plain"> = </span><span class="functiontext">Invocations::get_token_as_parsed</span><span class="plain">(</span><span class="identifier">inv</span><span class="plain">, </span><span class="identifier">ix</span><span class="plain">);</span>
                    <span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">col</span><span class="plain"> = </span><span class="identifier">I</span><span class="string">"008000"</span><span class="plain">;</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">found</span><span class="plain">, </span><span class="constant">UNKNOWN_NT</span><span class="plain">)) </span><span class="identifier">col</span><span class="plain"> = </span><span class="identifier">I</span><span class="string">"800000"</span><span class="plain">;</span>
                    <span class="identifier">HTML::begin_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">col</span><span class="plain">);</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%W"</span><span class="plain">, </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">found</span><span class="plain">));</span>
                    <span class="identifier">HTML::end_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">);</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" - "</span><span class="plain">);</span>
                    <span class="functiontext">Dash::note_inv_token_text</span><span class="plain">(</span><span class="identifier">found</span><span class="plain">,</span>
                        <span class="plain">(</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;token_sequence</span><span class="plain">[</span><span class="identifier">ix</span><span class="plain">]</span><span class="element">.construct</span><span class="plain"> == </span><span class="constant">NEW_LOCAL_PT_CONSTRUCT</span><span class="plain">)?</span><span class="identifier">TRUE</span><span class="plain">:</span><span class="identifier">FALSE</span><span class="plain">);</span>
                <span class="plain">}</span>
                &lt;<span class="cwebmacro">Describe what the token matches</span> <span class="cwebmacronumber">3.1.2.1</span>&gt;<span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">writing_a_say</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">")"</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">PASTE_PHRASE_FORMAT</span><span class="plain">:</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"..."</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP3_1">&#167;3.1</a>.</p>

<p class="inwebparagraph"><a id="SP3_1_2_1"></a><b>&#167;3.1.2.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Describe what the token matches</span> <span class="cwebmacronumber">3.1.2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;token_sequence</span><span class="plain">[</span><span class="identifier">ix</span><span class="plain">]</span><span class="element">.construct</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">STANDARD_PT_CONSTRUCT</span><span class="plain">: {</span>
                <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;token_sequence</span><span class="plain">[</span><span class="identifier">ix</span><span class="plain">]</span><span class="element">.to_match</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Specifications::is_kind_like</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">)) {</span>
                    <span class="identifier">HTML::begin_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"4040ff"</span><span class="plain">);</span>
                    <span class="identifier">Kinds::Textual::write</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="functiontext">Specifications::to_kind</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
                    <span class="identifier">HTML::end_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">);</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="constant">CONSTANT_NT</span><span class="plain">)) ||</span>
                        <span class="plain">(</span><span class="functiontext">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">))) {</span>
                    <span class="identifier">HTML::begin_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"4040ff"</span><span class="plain">);</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%W"</span><span class="plain">, </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
                    <span class="identifier">HTML::end_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">);</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="identifier">HTML_OPEN</span><span class="plain">(</span><span class="string">"i"</span><span class="plain">);</span>
                    <span class="identifier">HTML::begin_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"ff4040"</span><span class="plain">);</span>
                    <span class="functiontext">Specifications::write_out_in_English</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">spec</span><span class="plain">);</span>
                    <span class="identifier">HTML::end_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">);</span>
                    <span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"i"</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NEW_LOCAL_PT_CONSTRUCT</span><span class="plain">:</span>
                <span class="identifier">HTML::begin_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"E00060"</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"a new name"</span><span class="plain">);</span>
                <span class="identifier">HTML::end_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">EXISTING_LOCAL_PT_CONSTRUCT</span><span class="plain">:</span>
                <span class="identifier">HTML::begin_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"E00060"</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"a temporary named value"</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;token_sequence</span><span class="plain">[</span><span class="identifier">ix</span><span class="plain">]</span><span class="element">.token_kind</span><span class="plain">) &amp;&amp;</span>
                    <span class="plain">(</span><span class="identifier">Kinds::Compare::eq</span><span class="plain">(</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;token_sequence</span><span class="plain">[</span><span class="identifier">ix</span><span class="plain">]</span><span class="element">.token_kind</span><span class="plain">, </span><span class="identifier">K_value</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" holding "</span><span class="plain">);</span>
                    <span class="identifier">Kinds::Textual::write_articled</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;token_sequence</span><span class="plain">[</span><span class="identifier">ix</span><span class="plain">]</span><span class="element">.token_kind</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="identifier">HTML::end_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">CONDITION_PT_CONSTRUCT</span><span class="plain">:</span>
                <span class="identifier">HTML::begin_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"E00060"</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"a condition"</span><span class="plain">);</span>
                <span class="identifier">HTML::end_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">STORAGE_PT_CONSTRUCT</span><span class="plain">:</span>
                <span class="identifier">HTML::begin_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"E00060"</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"a stored value"</span><span class="plain">);</span>
                <span class="identifier">HTML::end_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TABLE_REFERENCE_PT_CONSTRUCT</span><span class="plain">:</span>
                <span class="identifier">HTML::begin_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"E00060"</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"a table entry"</span><span class="plain">);</span>
                <span class="identifier">HTML::end_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">KIND_NAME_PT_CONSTRUCT</span><span class="plain">:</span>
                <span class="identifier">HTML::begin_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"E00060"</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"name of kind"</span><span class="plain">);</span>
                <span class="identifier">HTML::end_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">VOID_PT_CONSTRUCT</span><span class="plain">:</span>
                <span class="identifier">HTML::begin_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"E00060"</span><span class="plain">);</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"a phrase"</span><span class="plain">);</span>
                <span class="identifier">HTML::end_colour</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP3_1_2">&#167;3.1.2</a>.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Problem messages. </b>Which enables this rather cool depiction used in Problem messages:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Phrases::TypeData::Textual::inv_write_HTML_representation</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">inv</span><span class="plain">) {</span>
        <span class="reserved">phrase</span><span class="plain"> *</span><span class="identifier">ph</span><span class="plain"> = </span><span class="identifier">ParseTree::get_phrase_invoked</span><span class="plain">(</span><span class="identifier">inv</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ph</span><span class="plain">) {</span>
            <span class="reserved">ph_type_data</span><span class="plain"> *</span><span class="identifier">phtd</span><span class="plain"> = &amp;(</span><span class="identifier">ph</span><span class="plain">-</span><span class="element">&gt;type_data</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">ph</span><span class="plain">-</span><span class="element">&gt;ph_documentation_symbol</span><span class="plain">)) {</span>
                <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">pds</span><span class="plain">);</span>
                <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">pds</span><span class="plain">, </span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">Wordings::one_word</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ph</span><span class="plain">-</span><span class="element">&gt;ph_documentation_symbol</span><span class="plain">)));</span>
                <span class="identifier">Index::DocReferences::link_to</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">pds</span><span class="plain">, -1);</span>
                <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">pds</span><span class="plain">);</span>
            <span class="plain">} </span><span class="reserved">else</span>
                <span class="identifier">Index::link_to</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">ph</span><span class="plain">-</span><span class="element">&gt;declaration_node</span><span class="plain">)), </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" "</span><span class="plain">);</span>
            <span class="functiontext">Phrases::TypeData::Textual::write_HTML_representation</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">, </span><span class="constant">INDEX_PHRASE_FORMAT</span><span class="plain">, </span><span class="identifier">inv</span><span class="plain">);</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" "</span><span class="plain">);</span>
            <span class="reserved">switch</span><span class="plain"> (</span><span class="functiontext">Dash::reading_passed</span><span class="plain">(</span><span class="identifier">inv</span><span class="plain">)) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">: </span><span class="identifier">HTML_TAG_WITH</span><span class="plain">(</span><span class="string">"img"</span><span class="plain">, </span><span class="string">"border=0 src=inform:/doc_images/tick.png"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">: </span><span class="identifier">HTML_TAG_WITH</span><span class="plain">(</span><span class="string">"img"</span><span class="plain">, </span><span class="string">"border=0 src=inform:/doc_images/cross.png"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">default</span><span class="plain">: </span><span class="identifier">HTML_TAG_WITH</span><span class="plain">(</span><span class="string">"img"</span><span class="plain">, </span><span class="string">"border=0 src=inform:/doc_images/greytick.png"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::TypeData::Textual::inv_write_HTML_representation is used in 2/sq (<a href="2-sq.html#SP2">&#167;2</a>).</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Indexing. </b>And also this rather fine presentation in the Phrasebook index:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Phrases::TypeData::Textual::write_index_representation</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">ph_type_data</span><span class="plain"> *</span><span class="identifier">phtd</span><span class="plain">, </span><span class="reserved">phrase</span><span class="plain"> *</span><span class="identifier">ph</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;manner_of_return</span><span class="plain"> == </span><span class="constant">DECIDES_CONDITION_MOR</span><span class="plain">)</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;i&gt;if&lt;/i&gt; "</span><span class="plain">);</span>
        <span class="functiontext">Phrases::write_HTML_representation</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">ph</span><span class="plain">, </span><span class="constant">INDEX_PHRASE_FORMAT</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;return_kind</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;manner_of_return</span><span class="plain"> == </span><span class="constant">DECIDES_CONDITION_MOR</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;i&gt;:&lt;/i&gt;"</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" ... &lt;i&gt;"</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Behaviour::definite</span><span class="plain">(</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;return_kind</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"value"</span><span class="plain">);</span>
            <span class="reserved">else</span><span class="plain"> </span><span class="identifier">Kinds::Textual::write</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;return_kind</span><span class="plain">);</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;/i&gt;"</span><span class="plain">);</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="functiontext">Phrases::Usage::get_equation_form</span><span class="plain">(&amp;(</span><span class="identifier">ph</span><span class="plain">-</span><span class="element">&gt;usage_data</span><span class="plain">));</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;i&gt;y&lt;/i&gt;&amp;nbsp;=&amp;nbsp;&lt;b&gt;%+W&lt;/b&gt;(&lt;i&gt;x&lt;/i&gt;)"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::TypeData::Textual::write_index_representation is used in <a href="#SP6">&#167;6</a>, 22/pi (<a href="22-pi.html#SP1_3">&#167;1.3</a>).</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>In the Phrasebook index, listings are marked with plus sign buttons which,
when clicked, expand an otherwise hidden box of details about the phrase.
This is the routine which prints those details.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Phrases::TypeData::Textual::write_reveal_box</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">ph_type_data</span><span class="plain"> *</span><span class="identifier">phtd</span><span class="plain">, </span><span class="reserved">phrase</span><span class="plain"> *</span><span class="identifier">ph</span><span class="plain">) {</span>
        <span class="identifier">HTML_OPEN</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">Present a paste button containing the text of the phrase</span> <span class="cwebmacronumber">6.1</span>&gt;<span class="plain">;</span>
        <span class="functiontext">Phrases::TypeData::Textual::write_index_representation</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">, </span><span class="identifier">ph</span><span class="plain">);</span>
        <span class="functiontext">Phrases::Options::index</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, &amp;(</span><span class="identifier">ph</span><span class="plain">-</span><span class="element">&gt;options_data</span><span class="plain">));</span>
        &lt;<span class="cwebmacro">Quote from and reference to the documentation, where possible</span> <span class="cwebmacronumber">6.2</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Present the equation form of the phrase, if it has one</span> <span class="cwebmacronumber">6.3</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Present the name of the phrase regarded as a value, if it has one</span> <span class="cwebmacronumber">6.4</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Present the kind of the phrase</span> <span class="cwebmacronumber">6.5</span>&gt;<span class="plain">;</span>
        <span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">Warn about deprecation, where necessary</span> <span class="cwebmacronumber">6.6</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::TypeData::Textual::write_reveal_box is used in 22/pi (<a href="22-pi.html#SP1_3">&#167;1.3</a>).</p>

<p class="inwebparagraph"><a id="SP6_1"></a><b>&#167;6.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Present a paste button containing the text of the phrase</span> <span class="cwebmacronumber">6.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">TEMP</span><span class="plain">);</span>
        <span class="functiontext">Phrases::write_HTML_representation</span><span class="plain">(</span><span class="identifier">TEMP</span><span class="plain">, </span><span class="identifier">ph</span><span class="plain">, </span><span class="constant">PASTE_PHRASE_FORMAT</span><span class="plain">);</span>
        <span class="identifier">HTML::Javascript::paste_stream</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">TEMP</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">TEMP</span><span class="plain">);</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&amp;nbsp;"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_2"></a><b>&#167;6.2.  </b>This is only possible for phrases mentioned in the built-in manuals,
of course.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Quote from and reference to the documentation, where possible</span> <span class="cwebmacronumber">6.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">ph</span><span class="plain">-</span><span class="element">&gt;ph_documentation_symbol</span><span class="plain">)) {</span>
            <span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">pds</span><span class="plain">);</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">pds</span><span class="plain">, </span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">Wordings::one_word</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ph</span><span class="plain">-</span><span class="element">&gt;ph_documentation_symbol</span><span class="plain">)));</span>
            <span class="identifier">Index::DocReferences::doc_fragment</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">pds</span><span class="plain">);</span>
            <span class="identifier">HTML_OPEN</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">); </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;b&gt;See&lt;/b&gt; "</span><span class="plain">);</span>
            <span class="identifier">Index::DocReferences::fully_link</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">pds</span><span class="plain">);</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">pds</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_3"></a><b>&#167;6.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Present the equation form of the phrase, if it has one</span> <span class="cwebmacronumber">6.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="functiontext">Phrases::Usage::get_equation_form</span><span class="plain">(&amp;(</span><span class="identifier">ph</span><span class="plain">-</span><span class="element">&gt;usage_data</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
            <span class="identifier">HTML_OPEN</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;b&gt;In equations:&lt;/b&gt; write as "</span><span class="plain">);</span>
            <span class="identifier">HTML::Javascript::paste_W</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&amp;nbsp;%+W()"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_4"></a><b>&#167;6.4.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Present the name of the phrase regarded as a value, if it has one</span> <span class="cwebmacronumber">6.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ph</span><span class="plain">-</span><span class="element">&gt;usage_data.constant_phrase_holder</span><span class="plain">) {</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Nouns::nominative</span><span class="plain">(</span><span class="identifier">ph</span><span class="plain">-</span><span class="element">&gt;usage_data.constant_phrase_holder</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain">);</span>
            <span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
            <span class="identifier">HTML_OPEN</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;b&gt;Name:&lt;/b&gt; "</span><span class="plain">);</span>
            <span class="identifier">HTML::Javascript::paste_W</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&amp;nbsp;%+W"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_5"></a><b>&#167;6.5.  </b>"Say" phrases are never used functionally and don't have interesting kinds,
so we won't list them here.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Present the kind of the phrase</span> <span class="cwebmacronumber">6.5</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Phrases::TypeData::is_a_say_phrase</span><span class="plain">(</span><span class="identifier">ph</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
            <span class="identifier">HTML_OPEN</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;b&gt;Kind:&lt;/b&gt; "</span><span class="plain">);</span>
            <span class="identifier">Kinds::Textual::write</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="functiontext">Phrases::TypeData::kind</span><span class="plain">(</span><span class="identifier">phtd</span><span class="plain">));</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_6"></a><b>&#167;6.6.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Warn about deprecation, where necessary</span> <span class="cwebmacronumber">6.6</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Phrases::TypeData::deprecated</span><span class="plain">(&amp;(</span><span class="identifier">ph</span><span class="plain">-</span><span class="element">&gt;type_data</span><span class="plain">))) {</span>
            <span class="identifier">HTML_OPEN</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;b&gt;Warning:&lt;/b&gt; "</span><span class="plain">);</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"This phrase is now deprecated! It will probably be withdrawn in "</span>
                <span class="string">"future builds of Inform, and even the present build will reject it "</span>
                <span class="string">"if the 'Use no deprecated features' option is set. If you're using "</span>
                <span class="string">"it now, try following the documentation link above for advice on "</span>
                <span class="string">"what to write instead."</span><span class="plain">);</span>
            <span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Comments in compiled code. </b>That's it for indexing. There's one last piece of describing to do: a
convenient comment to go into the compiled I6 code, just above the routine
a phrase has been compiled into:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Phrases::TypeData::Textual::phtd_write_I6_comment_describing</span><span class="plain">(</span><span class="reserved">ph_type_data</span><span class="plain"> *</span><span class="identifier">phtd</span><span class="plain">, </span><span class="identifier">OUTPUT_STREAM</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">j</span><span class="plain">;</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"! "</span><span class="plain">);</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">j</span><span class="plain">=0; </span><span class="identifier">j</span><span class="plain">&lt;</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;no_words</span><span class="plain">; </span><span class="identifier">j</span><span class="plain">++) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;word_sequence</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">] &lt; </span><span class="constant">MAX_TOKENS_PER_PHRASE</span><span class="plain">)</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"#%d "</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;word_sequence</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">]);</span>
            <span class="reserved">else</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%N "</span><span class="plain">, </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;word_sequence</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">]);</span>
        <span class="plain">}</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">":\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::TypeData::Textual::phtd_write_I6_comment_describing appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Parsing a PHTD. </b>And now the reverse process: given a preamble in the source text such as
</p>

<blockquote>
    <p>To decide which room is room (D - direction) from/of (R1 - room): ...</p>

</blockquote>

<p class="inwebparagraph">we want to turn it into a PHTD for its phrase. We only do this for "To..."
phrases; as we've seen, rules have PHRCDs instead.
</p>

<p class="inwebparagraph">When this routine is called, the word range supplied is the whole preamble &mdash;
in this example, it's from "To" to the ")" just before the colon. If we
detect phrase options, after a comma, we pass the word range for them back.
The PHTD we write to is factory-fresh except that it has the "inline" flag
correctly set.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Phrases::TypeData::Textual::parse</span><span class="plain">(</span><span class="reserved">ph_type_data</span><span class="plain"> *</span><span class="identifier">phtd</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">XW</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">OW</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">say_flag</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">; </span>    <span class="comment">is this going to be a "say" phrase?</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">)) </span><span class="identifier">XW</span><span class="plain"> = </span><span class="functiontext">Phrases::TypeData::Textual::phtd_parse_return_data</span><span class="plain">(</span><span class="identifier">phtd</span><span class="plain">, </span><span class="identifier">XW</span><span class="plain">); 			</span>    <span class="comment">trim return data from the front</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">)) </span><span class="identifier">Index::DocReferences::position_of_symbol</span><span class="plain">(&amp;</span><span class="identifier">XW</span><span class="plain">); </span>    <span class="comment">trim documentation ref from the back</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">)) </span><span class="identifier">XW</span><span class="plain"> = </span><span class="functiontext">Phrases::TypeData::Textual::phtd_parse_doodads</span><span class="plain">(</span><span class="identifier">phtd</span><span class="plain">, </span><span class="identifier">XW</span><span class="plain">, &amp;</span><span class="identifier">say_flag</span><span class="plain">); 	</span>    <span class="comment">and other doodads from the back</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">cw</span><span class="plain"> = -1; </span>    <span class="comment">word number of first comma</span>
        &lt;<span class="cwebmacro">Find the first comma outside of parentheses, if any exists</span> <span class="cwebmacronumber">8.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">cw</span><span class="plain"> &gt;= 0) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">comma_presages_options</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            &lt;<span class="cwebmacro">Does this comma presage phrase options?</span> <span class="cwebmacronumber">8.2</span>&gt;<span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">comma_presages_options</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">say_flag</span><span class="plain">) </span>&lt;<span class="cwebmacro">Issue a problem: say phrases aren't allowed options</span> <span class="cwebmacronumber">8.3</span>&gt;<span class="character">;</span>
                <span class="plain">*</span><span class="identifier">OW</span><span class="plain"> = </span><span class="identifier">Wordings::from</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">, </span><span class="identifier">cw</span><span class="plain"> + 1);</span>
                <span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">Wordings::up_to</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">, </span><span class="identifier">cw</span><span class="plain"> - 1); </span>    <span class="comment">trim the preamble range to to the text before the comma</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;registration_text</span><span class="plain"> = </span><span class="identifier">XW</span><span class="plain">;</span>
        <span class="functiontext">Phrases::TypeData::Textual::phtd_parse_word_sequence</span><span class="plain">(</span><span class="identifier">phtd</span><span class="plain">, </span><span class="identifier">XW</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::TypeData::Textual::parse is used in 22/ph (<a href="22-ph.html#SP6_3">&#167;6.3</a>), 22/pav (<a href="22-pav.html#SP5">&#167;5</a>).</p>

<p class="inwebparagraph"><a id="SP8_1"></a><b>&#167;8.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Find the first comma outside of parentheses, if any exists</span> <span class="cwebmacronumber">8.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">bl</span><span class="plain"> = 0;</span>
        <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">XW</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Lexer::word</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">) == </span><span class="identifier">OPENBRACE_V</span><span class="plain">) || (</span><span class="identifier">Lexer::word</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">) == </span><span class="identifier">OPENBRACKET_V</span><span class="plain">)) </span><span class="identifier">bl</span><span class="plain">++;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Lexer::word</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">) == </span><span class="identifier">CLOSEBRACE_V</span><span class="plain">) || (</span><span class="identifier">Lexer::word</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">) == </span><span class="identifier">CLOSEBRACKET_V</span><span class="plain">)) </span><span class="identifier">bl</span><span class="plain">--;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Lexer::word</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">) == </span><span class="identifier">COMMA_V</span><span class="plain">) &amp;&amp; (</span><span class="identifier">bl</span><span class="plain"> == 0) &amp;&amp;</span>
                <span class="plain">(</span><span class="identifier">i</span><span class="plain">&gt;</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">))) { </span><span class="identifier">cw</span><span class="plain"> = </span><span class="identifier">i</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">; }</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP8_2"></a><b>&#167;8.2.  </b>In some control structures, comma is implicitly a sort of "then".
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Does this comma presage phrase options?</span> <span class="cwebmacronumber">8.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((&lt;</span><span class="identifier">control</span><span class="plain">-</span><span class="identifier">structure</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">&gt;(</span><span class="identifier">XW</span><span class="plain">)) &amp;&amp;</span>
            <span class="plain">(</span><span class="functiontext">Sentences::RuleSubtrees::comma_possible</span><span class="plain">(&lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;)))</span>
            <span class="identifier">comma_presages_options</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP8_3"></a><b>&#167;8.3.  </b>If you find the explanation in this message unconvincing, you're not alone.
To be honest my preferred fix would be to delete phrase options from the
language altogether, but there we are; spilt milk.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Issue a problem: say phrases aren't allowed options</span> <span class="cwebmacronumber">8.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_SayWithPhraseOptions</span><span class="plain">),</span>
            <span class="string">"phrase options are not allowed for 'say' phrases"</span><span class="plain">,</span>
            <span class="string">"because the commas would lead to ambiguous sentences, and because the "</span>
            <span class="string">"content of a substitution is intended to be something conceptually simple "</span>
            <span class="string">"and not needing clarification."</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>We will need some constants for the annotations which the Preform grammar
below will make. First, for the main phrase structure:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">NO_ANN</span><span class="plain"> 0</span>
    <span class="definitionkeyword">define</span> <span class="constant">SAY_ANN</span><span class="plain"> 1</span>
    <span class="definitionkeyword">define</span> <span class="constant">LET_ANN</span><span class="plain"> 2</span>
    <span class="definitionkeyword">define</span> <span class="constant">BLOCK_ANN</span><span class="plain"> 3</span>
    <span class="definitionkeyword">define</span> <span class="constant">IN_LOOP_ANN</span><span class="plain"> 4</span>
    <span class="definitionkeyword">define</span> <span class="constant">IN_ANN</span><span class="plain"> 5</span>
    <span class="definitionkeyword">define</span> <span class="constant">CONDITIONAL_ANN</span><span class="plain"> 6</span>
    <span class="definitionkeyword">define</span> <span class="constant">LOOP_ANN</span><span class="plain"> 7</span>
</pre>
<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>And these are for the specialised "say" phrase grammar:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">NO_SANN</span><span class="plain"> 1</span>
    <span class="definitionkeyword">define</span> <span class="constant">CONTROL_SANN</span><span class="plain"> 2</span>
    <span class="definitionkeyword">define</span> <span class="constant">BEGIN_SANN</span><span class="plain"> 3</span>
    <span class="definitionkeyword">define</span> <span class="constant">CONTINUE_SANN</span><span class="plain"> 4</span>
    <span class="definitionkeyword">define</span> <span class="constant">ENDM_SANN</span><span class="plain"> 5</span>
    <span class="definitionkeyword">define</span> <span class="constant">END_SANN</span><span class="plain"> 6</span>
</pre>
<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b>And these for "return" annotations:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">DEC_RANN</span><span class="plain"> 1</span>
    <span class="definitionkeyword">define</span> <span class="constant">DEV_RANN</span><span class="plain"> 2</span>
    <span class="definitionkeyword">define</span> <span class="constant">TOC_RANN</span><span class="plain"> 3</span>
    <span class="definitionkeyword">define</span> <span class="constant">TOV_RANN</span><span class="plain"> 4</span>
    <span class="definitionkeyword">define</span> <span class="constant">TO_RANN</span><span class="plain"> 5</span>
</pre>
<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b>Now we come to the grammar for phrase definitions (not rules). This is
surprisingly complicated, but many of the options are reserved for the
Standard Rules.
</p>

<p class="inwebparagraph">We know from coarse mode parsing of the preamble that it starts with the
word "to".
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt; ( </span><span class="identifier">deprecated</span><span class="plain"> ) |			==&gt; </span><span class="identifier">R</span><span class="plain">[1]; &lt;&lt;</span><span class="identifier">deprecated</span><span class="plain">&gt;&gt; = </span><span class="identifier">TRUE</span>
        <span class="plain">&lt;</span><span class="identifier">say</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt;	|							==&gt; </span><span class="constant">SAY_ANN</span><span class="plain">; &lt;&lt;</span><span class="identifier">say</span><span class="plain">-</span><span class="identifier">ann</span><span class="plain">&gt;&gt; = </span><span class="identifier">R</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">to</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt;								==&gt; </span><span class="identifier">R</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">to</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">to</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt; ( </span><span class="identifier">arithmetic</span><span class="plain"> </span><span class="identifier">operation</span><span class="plain"> &lt;</span><span class="identifier">cardinal</span><span class="plain">-</span><span class="identifier">number</span><span class="plain">&gt; ) |	==&gt; </span><span class="identifier">R</span><span class="plain">[1]; &lt;&lt;</span><span class="identifier">operation</span><span class="plain">&gt;&gt; = </span><span class="identifier">R</span><span class="plain">[2]</span>
        <span class="plain">&lt;</span><span class="identifier">to</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt; ( </span><span class="identifier">assignment</span><span class="plain"> </span><span class="identifier">operation</span><span class="plain"> ) |	==&gt; </span><span class="identifier">R</span><span class="plain">[1]; &lt;&lt;</span><span class="identifier">assignment</span><span class="plain">&gt;&gt; = </span><span class="identifier">TRUE</span>
        <span class="plain">{</span><span class="identifier">let</span><span class="plain"> ... </span><span class="identifier">be</span><span class="plain"> </span><span class="identifier">given</span><span class="plain"> </span><span class="identifier">by</span><span class="plain"> ...} |					==&gt; </span><span class="constant">LET_ANN</span><span class="plain">; &lt;&lt;</span><span class="identifier">eqn</span><span class="plain">&gt;&gt; = </span><span class="identifier">TRUE</span>
        <span class="plain">{</span><span class="identifier">let</span><span class="plain"> ...} |									==&gt; </span><span class="constant">LET_ANN</span><span class="plain">; &lt;&lt;</span><span class="identifier">eqn</span><span class="plain">&gt;&gt; = </span><span class="identifier">FALSE</span>
        <span class="plain">... -- </span><span class="identifier">end</span><span class="plain"> |								==&gt; </span><span class="constant">BLOCK_ANN</span>
        <span class="plain">... -- </span><span class="identifier">end</span><span class="plain"> </span><span class="identifier">conditional</span><span class="plain"> |					==&gt; </span><span class="constant">CONDITIONAL_ANN</span>
        <span class="plain">... -- </span><span class="identifier">end</span><span class="plain"> </span><span class="identifier">loop</span><span class="plain"> |							==&gt; </span><span class="constant">LOOP_ANN</span>
        <span class="plain">... -- </span><span class="identifier">in</span><span class="plain"> </span><span class="identifier">loop</span><span class="plain"> |							==&gt; </span><span class="constant">IN_LOOP_ANN</span>
        <span class="plain">... -- </span><span class="identifier">in</span><span class="plain"> ### |								==&gt; </span><span class="constant">IN_ANN</span>
        <span class="plain">...											==&gt;	</span><span class="constant">NO_ANN</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b>The definition remaining after the preamble is removed is then vetted.
This is a possibly controversial point, in fact, because the check in question
is to make sure the phrase definition doesn't mask off a relationship, which
would almost certainly throw a cascade of other but less helpful problem
messages.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">vetting</span><span class="plain">&gt; ::=</span>
        <span class="plain">( ...... ) &lt;</span><span class="identifier">copular</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; {&lt;</span><span class="identifier">copular</span><span class="plain">-</span><span class="identifier">preposition</span><span class="plain">&gt;} ( ...... )	==&gt; &lt;&lt;</span><span class="identifier">rel1</span><span class="plain">&gt;&gt; = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">WR</span><span class="plain">[2]); &lt;&lt;</span><span class="identifier">rel2</span><span class="plain">&gt;&gt; = </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">WR</span><span class="plain">[2]); &lt;&lt;</span><span class="identifier">preposition_identity</span><span class="plain">:</span><span class="identifier">prep</span><span class="plain">&gt;&gt; = </span><span class="identifier">RP</span><span class="plain">[2]; </span>&lt;<span class="cwebmacro">Issue PM_MasksRelation problem</span> <span class="cwebmacronumber">13.1</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP13_1"></a><b>&#167;13.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_MasksRelation problem</span> <span class="cwebmacronumber">13.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">preposition_identity</span><span class="plain"> *</span><span class="identifier">prep</span><span class="plain"> = &lt;&lt;</span><span class="identifier">preposition_identity</span><span class="plain">:</span><span class="identifier">prep</span><span class="plain">&gt;&gt;;</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">K_number</span><span class="plain">;</span>
        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Prepositions::get_where_pu_created</span><span class="plain">(</span><span class="identifier">prep</span><span class="plain">) == </span><span class="identifier">NULL</span><span class="plain">)</span>
            <span class="identifier">Problems::quote_text</span><span class="plain">(4, </span><span class="string">"This is a relation defined inside Inform."</span><span class="plain">);</span>
        <span class="reserved">else</span>
            <span class="identifier">Problems::quote_source</span><span class="plain">(4, </span><span class="identifier">Prepositions::get_where_pu_created</span><span class="plain">(</span><span class="identifier">prep</span><span class="plain">));</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(3, </span><span class="identifier">Wordings::new</span><span class="plain">(&lt;&lt;</span><span class="identifier">rel1</span><span class="plain">&gt;&gt;, &lt;&lt;</span><span class="identifier">rel2</span><span class="plain">&gt;&gt;));</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_MasksRelation</span><span class="plain">));</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"I don't want you to define a phrase with the wording you've used in "</span>
            <span class="string">"in %1 because it could be misunderstood. There is already a definition "</span>
            <span class="string">"of what it means for something to be '%3' something else, so this "</span>
            <span class="string">"phrase definition would look too much like testing whether "</span>
            <span class="string">"'X is %3 Y'. (%4.)"</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP13">&#167;13</a>.</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14.  </b>Phrases whose definitions begin "To say" are usually text substitutions,
the exception being the primordial phrase for saying text.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">say</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">say</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt; -- </span><span class="identifier">running</span><span class="plain"> </span><span class="identifier">on</span><span class="plain"> |				==&gt; </span><span class="identifier">R</span><span class="plain">[1]; &lt;&lt;</span><span class="identifier">run</span><span class="plain">-</span><span class="identifier">on</span><span class="plain">&gt;&gt; = </span><span class="identifier">TRUE</span>
        <span class="plain">{</span><span class="identifier">say</span><span class="plain"> </span><span class="identifier">otherwise</span><span class="plain">/</span><span class="reserved">else</span><span class="plain">} |						==&gt; </span><span class="constant">CONTROL_SANN</span><span class="plain">; &lt;&lt;</span><span class="identifier">control</span><span class="plain">&gt;&gt; = </span><span class="constant">OTHERWISE_SAY_CS</span>
        <span class="plain">{</span><span class="identifier">say</span><span class="plain"> </span><span class="identifier">otherwise</span><span class="plain">/</span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain">/</span><span class="identifier">unless</span><span class="plain"> ...} |		==&gt; </span><span class="constant">CONTROL_SANN</span><span class="plain">; &lt;&lt;</span><span class="identifier">control</span><span class="plain">&gt;&gt; = </span><span class="constant">OTHERWISE_IF_SAY_CS</span>
        <span class="plain">{</span><span class="identifier">say</span><span class="plain"> </span><span class="reserved">if</span><span class="plain">/</span><span class="identifier">unless</span><span class="plain"> ...} |						==&gt; </span><span class="constant">CONTROL_SANN</span><span class="plain">; &lt;&lt;</span><span class="identifier">control</span><span class="plain">&gt;&gt; = </span><span class="constant">IF_SAY_CS</span>
        <span class="plain">{</span><span class="identifier">say</span><span class="plain"> </span><span class="identifier">end</span><span class="plain"> </span><span class="reserved">if</span><span class="plain">/</span><span class="identifier">unless</span><span class="plain">} |						==&gt; </span><span class="constant">CONTROL_SANN</span><span class="plain">; &lt;&lt;</span><span class="identifier">control</span><span class="plain">&gt;&gt; = </span><span class="constant">END_IF_SAY_CS</span>
        <span class="plain">{</span><span class="identifier">say</span><span class="plain"> ...} -- </span><span class="identifier">beginning</span><span class="plain"> ### |				==&gt; </span><span class="constant">BEGIN_SANN</span>
        <span class="plain">{</span><span class="identifier">say</span><span class="plain"> ...} -- </span><span class="identifier">continuing</span><span class="plain"> ### |				==&gt; </span><span class="constant">CONTINUE_SANN</span>
        <span class="plain">{</span><span class="identifier">say</span><span class="plain"> ...} -- </span><span class="identifier">ending</span><span class="plain"> ### </span><span class="identifier">with</span><span class="plain"> </span><span class="identifier">marker</span><span class="plain"> ### |	==&gt; </span><span class="constant">ENDM_SANN</span>
        <span class="plain">{</span><span class="identifier">say</span><span class="plain"> ...} -- </span><span class="identifier">ending</span><span class="plain"> ### |					==&gt; </span><span class="constant">END_SANN</span>
        <span class="plain">{</span><span class="identifier">say</span><span class="plain"> ...}									==&gt; </span><span class="constant">NO_SANN</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b>The following is used on the same text as &lt;to-preamble&gt;, but later on,
for timing reasons.
</p>

<p class="inwebparagraph">Note that &lt;k-kind-for-template&gt; parses &lt;k-kind&gt;, but in a mode which causes
the kind variables to be read as formal prototypes and not as their values.
This allows for tricky definitions like:
</p>

<blockquote>
    <p>To decide which K is (name of kind of value K) which relates to (Y - L) by (R - relation of Ks to values of kind L)</p>

</blockquote>

<p class="inwebparagraph">where &lt;k-kind-for-template&gt; needs to recognise "K" even though the tokens
haven't yet been parsed, so that we don't yet know it will be meaningful.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">to</span><span class="plain">-</span><span class="reserved">return</span><span class="plain">-</span><span class="identifier">data</span><span class="plain">&gt; ::=</span>
        <span class="identifier">to</span><span class="plain"> {</span><span class="identifier">decide</span><span class="plain"> </span><span class="identifier">yes</span><span class="plain">/</span><span class="identifier">no</span><span class="plain">} |							==&gt; </span><span class="constant">DEC_RANN</span>
        <span class="identifier">to</span><span class="plain"> {</span><span class="identifier">decide</span><span class="plain"> </span><span class="identifier">on</span><span class="plain"> ...} |							==&gt; </span><span class="constant">DEV_RANN</span>
        <span class="identifier">to</span><span class="plain"> </span><span class="identifier">decide</span><span class="plain"> </span><span class="identifier">whether</span><span class="plain">/</span><span class="reserved">if</span><span class="plain"> </span><span class="identifier">the</span><span class="plain"> ... |					==&gt;	</span><span class="constant">TOC_RANN</span>
        <span class="identifier">to</span><span class="plain"> </span><span class="identifier">decide</span><span class="plain"> </span><span class="identifier">whether</span><span class="plain">/</span><span class="reserved">if</span><span class="plain"> ... |						==&gt; </span><span class="constant">TOC_RANN</span>
        <span class="identifier">to</span><span class="plain"> </span><span class="identifier">decide</span><span class="plain"> </span><span class="identifier">what</span><span class="plain">/</span><span class="identifier">which</span><span class="plain"> &lt;</span><span class="reserved">return</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">&gt; </span><span class="identifier">is</span><span class="plain"> </span><span class="identifier">the</span><span class="plain"> ... |	==&gt; </span><span class="constant">TOV_RANN</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="identifier">to</span><span class="plain"> </span><span class="identifier">decide</span><span class="plain"> </span><span class="identifier">what</span><span class="plain">/</span><span class="identifier">which</span><span class="plain"> &lt;</span><span class="reserved">return</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">&gt; </span><span class="identifier">is</span><span class="plain"> ... |		==&gt; </span><span class="constant">TOV_RANN</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="identifier">to</span><span class="plain"> ...											==&gt; </span><span class="constant">TO_RANN</span>

    <span class="plain">&lt;</span><span class="reserved">return</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="reserved">for</span><span class="plain">-</span><span class="identifier">template</span><span class="plain">&gt; |							==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">...												==&gt; </span>&lt;<span class="cwebmacro">Issue PM_UnknownValueToDecide problem</span> <span class="cwebmacronumber">15.1</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP15_1"></a><b>&#167;15.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_UnknownValueToDecide problem</span> <span class="cwebmacronumber">15.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">K_number</span><span class="plain">;</span>
        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnknownValueToDecide</span><span class="plain">));</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"The phrase you describe in %1 seems to be trying to decide a value, "</span>
            <span class="string">"but '%2' is not a kind that I recognise. (I had expected something "</span>
            <span class="string">"like 'number' or 'object' - see the Kinds index for what's available.)"</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP15">&#167;15</a>.</p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16.  </b>The support code needed for the <code class="display"><span class="extract">&lt;to-return-data&gt;</span></code> grammar.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">no_truth_state_returns</span><span class="plain"> = 0;</span>
    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">Phrases::TypeData::Textual::phtd_parse_return_data</span><span class="plain">(</span><span class="reserved">ph_type_data</span><span class="plain"> *</span><span class="identifier">phtd</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">XW</span><span class="plain">) {</span>
        <span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;return_kind</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">to</span><span class="plain">-</span><span class="reserved">return</span><span class="plain">-</span><span class="identifier">data</span><span class="plain">&gt;(</span><span class="identifier">XW</span><span class="plain">)) {</span>
            <span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">to</span><span class="plain">-</span><span class="reserved">return</span><span class="plain">-</span><span class="identifier">data</span><span class="plain">&gt;, 1);</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">mor</span><span class="plain"> = -1; </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">switch</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">DEC_RANN</span><span class="plain">: </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">DEV_RANN</span><span class="plain">: </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">TOC_RANN</span><span class="plain">: </span><span class="identifier">mor</span><span class="plain"> = </span><span class="constant">DECIDES_CONDITION_MOR</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">TOV_RANN</span><span class="plain">: </span><span class="identifier">mor</span><span class="plain"> = </span><span class="constant">DECIDES_VALUE_MOR</span><span class="plain">; </span><span class="identifier">K</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">TO_RANN</span><span class="plain">:  </span><span class="identifier">mor</span><span class="plain"> = </span><span class="constant">DECIDES_NOTHING_MOR</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">mor</span><span class="plain"> &gt;= 0) </span><span class="functiontext">Phrases::TypeData::set_mor</span><span class="plain">(</span><span class="identifier">phtd</span><span class="plain">, </span><span class="identifier">mor</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"to phrase without to"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::eq</span><span class="plain">(</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;return_kind</span><span class="plain">, </span><span class="identifier">K_truth_state</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">no_truth_state_returns</span><span class="plain">++ &gt; 0)</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_TruthStateToDecide</span><span class="plain">),</span>
                <span class="string">"phrases are not allowed to decide a truth state"</span><span class="plain">,</span>
                <span class="string">"and should be defined with the form 'To decide if ...' rather than "</span>
                <span class="string">"'To decide what truth state is ...'."</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">XW</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::TypeData::Textual::phtd_parse_return_data is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17.  </b>The "doodads" are the special features of a phrase notated at the back of
the preamble, which is why the following routine may move the end of the
preamble word range backwards &mdash; it returns the current last word number.
</p>


<pre class="display">
    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">Phrases::TypeData::Textual::phtd_parse_doodads</span><span class="plain">(</span><span class="reserved">ph_type_data</span><span class="plain"> *</span><span class="identifier">phtd</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">say_flag</span><span class="plain">) {</span>
        <span class="plain">&lt;&lt;</span><span class="identifier">operation</span><span class="plain">&gt;&gt; = -1; &lt;&lt;</span><span class="identifier">assignment</span><span class="plain">&gt;&gt; = </span><span class="identifier">FALSE</span><span class="plain">; &lt;&lt;</span><span class="identifier">deprecated</span><span class="plain">&gt;&gt; = </span><span class="identifier">FALSE</span><span class="plain">; &lt;&lt;</span><span class="identifier">run</span><span class="plain">-</span><span class="identifier">on</span><span class="plain">&gt;&gt; = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">&lt;</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">); </span>    <span class="comment">guaranteed to match any non-empty text</span>
        <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt; == </span><span class="constant">SAY_ANN</span><span class="plain">) </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">say</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt;, 1);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">to</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt;, 1);</span>

        <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">deprecated</span><span class="plain">&gt;&gt;) </span><span class="functiontext">Phrases::TypeData::deprecate_phrase</span><span class="plain">(</span><span class="identifier">phtd</span><span class="plain">);</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">let</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">blk</span><span class="plain"> = </span><span class="constant">NO_BLOCK_FOLLOWS</span><span class="plain">, </span><span class="identifier">only_in</span><span class="plain"> = 0; </span>    <span class="comment">"nothing unusual" defaults</span>
        <span class="reserved">switch</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">BLOCK_ANN</span><span class="plain">:			</span><span class="identifier">blk</span><span class="plain"> = </span><span class="constant">MISCELLANEOUS_BLOCK_FOLLOWS</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">CONDITIONAL_ANN</span><span class="plain">:	</span><span class="identifier">blk</span><span class="plain"> = </span><span class="constant">CONDITIONAL_BLOCK_FOLLOWS</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">IN_ANN</span><span class="plain">:			</span>&lt;<span class="cwebmacro">Set only-in to the first keyword</span> <span class="cwebmacronumber">17.1</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">IN_LOOP_ANN</span><span class="plain">:		</span><span class="identifier">only_in</span><span class="plain"> = -1; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">LET_ANN</span><span class="plain">:			</span><span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">eqn</span><span class="plain">&gt;&gt;) </span><span class="identifier">let</span><span class="plain"> = </span><span class="constant">EQUATION_LET_PHRASE</span><span class="plain">;</span>
                                    <span class="reserved">else</span><span class="plain"> </span><span class="identifier">let</span><span class="plain"> = </span><span class="constant">ASSIGNMENT_LET_PHRASE</span><span class="plain">;</span>
                                    <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">LOOP_ANN</span><span class="plain">:			</span><span class="identifier">blk</span><span class="plain"> = </span><span class="constant">LOOP_BODY_BLOCK_FOLLOWS</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">SAY_ANN</span><span class="plain">: 			</span>&lt;<span class="cwebmacro">We seem to be parsing a "say" phrase</span> <span class="cwebmacronumber">17.2</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>

        <span class="functiontext">Phrases::TypeData::make_id</span><span class="plain">(&amp;(</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;as_inline</span><span class="plain">),</span>
            <span class="plain">&lt;&lt;</span><span class="identifier">operation</span><span class="plain">&gt;&gt;, &lt;&lt;</span><span class="identifier">assignment</span><span class="plain">&gt;&gt;, </span><span class="identifier">let</span><span class="plain">, </span><span class="identifier">blk</span><span class="plain">, </span><span class="identifier">only_in</span><span class="plain">);</span>

        <span class="plain">&lt;</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">vetting</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">);</span>

        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::TypeData::Textual::phtd_parse_doodads is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP17_1"></a><b>&#167;17.1.  </b>For example, if the preamble is "To while...", then this sets <code class="display"><span class="extract">only_in</span></code>
to the word number of "while".
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Set only-in to the first keyword</span> <span class="cwebmacronumber">17.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">to</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt;, 2);</span>
        <span class="identifier">only_in</span><span class="plain"> = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">OW</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP17">&#167;17</a>.</p>

<p class="inwebparagraph"><a id="SP17_2"></a><b>&#167;17.2.  </b>And similarly for the say annotations.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">We seem to be parsing a "say" phrase</span> <span class="cwebmacronumber">17.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">say_flag</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">cs</span><span class="plain"> = -1, </span><span class="identifier">pos</span><span class="plain"> = -1, </span><span class="identifier">at</span><span class="plain"> = -1, </span><span class="identifier">cat</span><span class="plain"> = -1;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (&lt;&lt;</span><span class="identifier">say</span><span class="plain">-</span><span class="identifier">ann</span><span class="plain">&gt;&gt;) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">CONTROL_SANN</span><span class="plain">:	</span><span class="identifier">cs</span><span class="plain"> = &lt;&lt;</span><span class="identifier">control</span><span class="plain">&gt;&gt;; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">BEGIN_SANN</span><span class="plain">:	</span><span class="identifier">pos</span><span class="plain"> = </span><span class="constant">SSP_START</span><span class="plain">; </span><span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">say</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt;, 2); </span><span class="identifier">at</span><span class="plain"> = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">CONTINUE_SANN</span><span class="plain">:	</span><span class="identifier">pos</span><span class="plain"> = </span><span class="constant">SSP_MIDDLE</span><span class="plain">; </span><span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">say</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt;, 2); </span><span class="identifier">at</span><span class="plain"> = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">ENDM_SANN</span><span class="plain">:		</span><span class="identifier">pos</span><span class="plain"> = </span><span class="constant">SSP_END</span><span class="plain">; </span><span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">say</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt;, 2); </span><span class="identifier">at</span><span class="plain"> = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">);</span>
                                <span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">say</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt;, 3); </span><span class="identifier">cat</span><span class="plain"> = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">);</span>
                                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">END_SANN</span><span class="plain">:		</span><span class="identifier">pos</span><span class="plain"> = </span><span class="constant">SSP_END</span><span class="plain">; </span><span class="identifier">XW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">say</span><span class="plain">-</span><span class="identifier">preamble</span><span class="plain">&gt;, 2); </span><span class="identifier">at</span><span class="plain"> = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="functiontext">Phrases::TypeData::make_sd</span><span class="plain">(&amp;(</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;as_say</span><span class="plain">), &lt;&lt;</span><span class="identifier">run</span><span class="plain">-</span><span class="identifier">on</span><span class="plain">&gt;&gt;, </span><span class="identifier">cs</span><span class="plain">, </span><span class="identifier">pos</span><span class="plain">, </span><span class="identifier">at</span><span class="plain">, </span><span class="identifier">cat</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP17">&#167;17</a>.</p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18.  </b>The syntax for the body of a phrase definition is that it's a sequence of
fixed single words, which are not brackets, and bracketed token definitions,
occurring in any quantity and any order. For example:
</p>

<blockquote>
    <p>begin the (A - activity on value of kind K) activity with (val - K)</p>

</blockquote>

<p class="inwebparagraph">is a sequence of word, word, token, word, word, token.
</p>

<p class="inwebparagraph">For implementation convenience, we write a grammar which splits off the next
piece of the definition from the front of the text. In production (e), it's
a single word; in production (b), a token definition; and the others all
give problems for misuse of brackets.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="reserved">phrase</span><span class="plain">-</span><span class="reserved">definition</span><span class="plain">-</span><span class="identifier">word</span><span class="plain">-</span><span class="identifier">or</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">&gt; ::=</span>
        <span class="plain">( ) *** |								==&gt; </span>&lt;<span class="cwebmacro">Issue PM_TokenWithEmptyBrackets problem</span> <span class="cwebmacronumber">18.2</span>&gt;
        <span class="plain">( &lt;</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">declaration</span><span class="plain">&gt; ) *** |	==&gt; </span><span class="identifier">TRUE</span><span class="plain">; &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">form</span><span class="plain">&gt;&gt; = </span><span class="identifier">R</span><span class="plain">[1]; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">( *** |									==&gt; </span>&lt;<span class="cwebmacro">Issue PM_TokenWithoutCloseBracket problem</span> <span class="cwebmacronumber">18.3</span>&gt;
        <span class="plain">) *** |									==&gt; </span>&lt;<span class="cwebmacro">Issue PM_TokenWithoutOpenBracket problem</span> <span class="cwebmacronumber">18.4</span>&gt;
        <span class="plain">### ***									==&gt; </span><span class="identifier">FALSE</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP18_1"></a><b>&#167;18.1.  </b>Phrase token declarations allow a variety of non-standard constructs.
</p>

<p class="inwebparagraph">Note that nested brackets are allowed in the kind indication after
the hyphen, and this is sorely needed with complicated functional kinds.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">declaration</span><span class="plain">&gt; ::=</span>
        <span class="plain">*** ( *** - ...... |												==&gt; </span>&lt;<span class="cwebmacro">Issue PM_TokenWithNestedBrackets problem</span> <span class="cwebmacronumber">18.1.1</span>&gt;
        <span class="plain">...... - </span><span class="identifier">a</span><span class="plain"> </span><span class="identifier">nonexisting</span><span class="plain"> </span><span class="identifier">variable</span><span class="plain"> |									==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">); &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">NEW_LOCAL_PT_CONSTRUCT</span>
        <span class="plain">...... - </span><span class="identifier">a</span><span class="plain"> </span><span class="identifier">nonexisting</span><span class="plain"> &lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="reserved">for</span><span class="plain">-</span><span class="identifier">template</span><span class="plain">&gt; </span><span class="identifier">variable</span><span class="plain"> |				==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1]); &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">NEW_LOCAL_PT_CONSTRUCT</span>
        <span class="plain">...... - </span><span class="identifier">a</span><span class="plain"> </span><span class="identifier">nonexisting</span><span class="plain"> &lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="reserved">for</span><span class="plain">-</span><span class="identifier">template</span><span class="plain">&gt; </span><span class="identifier">that</span><span class="plain">/</span><span class="identifier">which</span><span class="plain"> </span><span class="identifier">varies</span><span class="plain"> |	==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1]); &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">NEW_LOCAL_PT_CONSTRUCT</span>
        <span class="plain">...... - </span><span class="identifier">nonexisting</span><span class="plain"> </span><span class="identifier">variable</span><span class="plain"> |										==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">); &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">NEW_LOCAL_PT_CONSTRUCT</span>
        <span class="plain">...... - </span><span class="identifier">nonexisting</span><span class="plain"> &lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="reserved">for</span><span class="plain">-</span><span class="identifier">template</span><span class="plain">&gt; </span><span class="identifier">variable</span><span class="plain"> |				==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1]); &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">NEW_LOCAL_PT_CONSTRUCT</span>
        <span class="plain">...... - </span><span class="identifier">nonexisting</span><span class="plain"> &lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="reserved">for</span><span class="plain">-</span><span class="identifier">template</span><span class="plain">&gt; </span><span class="identifier">that</span><span class="plain">/</span><span class="identifier">which</span><span class="plain"> </span><span class="identifier">varies</span><span class="plain"> |		==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1]); &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">NEW_LOCAL_PT_CONSTRUCT</span>
        <span class="plain">...... - {</span><span class="identifier">an</span><span class="plain"> </span><span class="identifier">existing</span><span class="plain"> </span><span class="identifier">variable</span><span class="plain">} |									==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">); </span><span class="identifier">ParseTree::set_text</span><span class="plain">(*</span><span class="identifier">XP</span><span class="plain">, </span><span class="identifier">WR</span><span class="plain">[2]); &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">EXISTING_LOCAL_PT_CONSTRUCT</span>
        <span class="plain">...... - {</span><span class="identifier">an</span><span class="plain"> </span><span class="identifier">existing</span><span class="plain"> &lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="reserved">for</span><span class="plain">-</span><span class="identifier">template</span><span class="plain">&gt; </span><span class="identifier">variable</span><span class="plain">} |				==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1]); </span><span class="identifier">ParseTree::set_text</span><span class="plain">(*</span><span class="identifier">XP</span><span class="plain">, </span><span class="identifier">WR</span><span class="plain">[2]); &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">EXISTING_LOCAL_PT_CONSTRUCT</span>
        <span class="plain">...... - {</span><span class="identifier">an</span><span class="plain"> </span><span class="identifier">existing</span><span class="plain"> &lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="reserved">for</span><span class="plain">-</span><span class="identifier">template</span><span class="plain">&gt; </span><span class="identifier">that</span><span class="plain">/</span><span class="identifier">which</span><span class="plain"> </span><span class="identifier">varies</span><span class="plain">} |	==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1]); </span><span class="identifier">ParseTree::set_text</span><span class="plain">(*</span><span class="identifier">XP</span><span class="plain">, </span><span class="identifier">WR</span><span class="plain">[2]); &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">EXISTING_LOCAL_PT_CONSTRUCT</span>
        <span class="plain">...... - {</span><span class="identifier">existing</span><span class="plain"> </span><span class="identifier">variable</span><span class="plain">} |										==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">); </span><span class="identifier">ParseTree::set_text</span><span class="plain">(*</span><span class="identifier">XP</span><span class="plain">, </span><span class="identifier">WR</span><span class="plain">[2]); &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">EXISTING_LOCAL_PT_CONSTRUCT</span>
        <span class="plain">...... - {</span><span class="identifier">existing</span><span class="plain"> &lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="reserved">for</span><span class="plain">-</span><span class="identifier">template</span><span class="plain">&gt; </span><span class="identifier">variable</span><span class="plain">} |				==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1]); </span><span class="identifier">ParseTree::set_text</span><span class="plain">(*</span><span class="identifier">XP</span><span class="plain">, </span><span class="identifier">WR</span><span class="plain">[2]); &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">EXISTING_LOCAL_PT_CONSTRUCT</span>
        <span class="plain">...... - {</span><span class="identifier">existing</span><span class="plain"> &lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="reserved">for</span><span class="plain">-</span><span class="identifier">template</span><span class="plain">&gt; </span><span class="identifier">that</span><span class="plain">/</span><span class="identifier">which</span><span class="plain"> </span><span class="identifier">varies</span><span class="plain">} |		==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1]); </span><span class="identifier">ParseTree::set_text</span><span class="plain">(*</span><span class="identifier">XP</span><span class="plain">, </span><span class="identifier">WR</span><span class="plain">[2]); &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">EXISTING_LOCAL_PT_CONSTRUCT</span>
        <span class="plain">...... - </span><span class="identifier">a</span><span class="plain"> </span><span class="identifier">condition</span><span class="plain"> |												==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">CONDITION_PT_CONSTRUCT</span>
        <span class="plain">...... - </span><span class="identifier">condition</span><span class="plain"> |												==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">CONDITION_PT_CONSTRUCT</span>
        <span class="plain">...... - </span><span class="identifier">a</span><span class="plain"> </span><span class="reserved">phrase</span><span class="plain"> |													==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">VOID_PT_CONSTRUCT</span>
        <span class="plain">...... - </span><span class="reserved">phrase</span><span class="plain"> |													==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">VOID_PT_CONSTRUCT</span>
        <span class="plain">...... - </span><span class="identifier">storage</span><span class="plain"> |													==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">); </span><span class="identifier">ParseTree::set_text</span><span class="plain">(*</span><span class="identifier">XP</span><span class="plain">, </span><span class="identifier">WR</span><span class="plain">[2]); &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">STORAGE_PT_CONSTRUCT</span>
        <span class="plain">...... - </span><span class="identifier">a</span><span class="plain"> </span><span class="reserved">table</span><span class="plain">-</span><span class="identifier">reference</span><span class="plain"> |										==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">); </span><span class="identifier">ParseTree::set_text</span><span class="plain">(*</span><span class="identifier">XP</span><span class="plain">, </span><span class="identifier">WR</span><span class="plain">[2]); &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">TABLE_REFERENCE_PT_CONSTRUCT</span>
        <span class="plain">...... - </span><span class="reserved">table</span><span class="plain">-</span><span class="identifier">reference</span><span class="plain"> |											==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">); </span><span class="identifier">ParseTree::set_text</span><span class="plain">(*</span><span class="identifier">XP</span><span class="plain">, </span><span class="identifier">WR</span><span class="plain">[2]); &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">TABLE_REFERENCE_PT_CONSTRUCT</span>
        <span class="plain">...... - &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">&gt; |									==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]; &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">STANDARD_PT_CONSTRUCT</span>
        <span class="plain">...... - &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">&gt; |								==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]; &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">KIND_NAME_PT_CONSTRUCT</span>
        <span class="plain">...... - ...... |													==&gt; </span>&lt;<span class="cwebmacro">Issue PM_BadTypeIndication problem</span> <span class="cwebmacronumber">18.1.2</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">&gt; |											==&gt; </span><span class="identifier">FALSE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]; &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; = </span><span class="constant">KIND_NAME_PT_CONSTRUCT</span>
        <span class="plain">......																==&gt; </span>&lt;<span class="cwebmacro">Issue PM_TokenMisunderstood problem</span> <span class="cwebmacronumber">18.1.3</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP18_2"></a><b>&#167;18.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_TokenWithEmptyBrackets problem</span> <span class="cwebmacronumber">18.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">NOT_APPLICABLE</span><span class="plain">;</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_TokenWithEmptyBrackets</span><span class="plain">),</span>
            <span class="string">"nothing is between the opening bracket '(' and its matching close bracket ')'"</span><span class="plain">,</span>
            <span class="string">"so I can't see what is meant to be the fixed text and what is meant to be "</span>
            <span class="string">"changeable. The idea is to put brackets around whatever varies from one "</span>
            <span class="string">"usage to another: for instance, 'To contribute (N - a number) dollars: ...'."</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18">&#167;18</a>.</p>

<p class="inwebparagraph"><a id="SP18_3"></a><b>&#167;18.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_TokenWithoutCloseBracket problem</span> <span class="cwebmacronumber">18.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">NOT_APPLICABLE</span><span class="plain">;</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_TokenWithoutCloseBracket</span><span class="plain">),</span>
            <span class="string">"the opening bracket '(' has no matching close bracket ')'"</span><span class="plain">,</span>
            <span class="string">"so I can't see what is meant to be the fixed text and what is meant to be "</span>
            <span class="string">"changeable. The idea is to put brackets around whatever varies from one "</span>
            <span class="string">"usage to another: for instance, 'To contribute (N - a number) dollars: ...'."</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18">&#167;18</a>.</p>

<p class="inwebparagraph"><a id="SP18_4"></a><b>&#167;18.4.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_TokenWithoutOpenBracket problem</span> <span class="cwebmacronumber">18.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">NOT_APPLICABLE</span><span class="plain">;</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_TokenWithoutOpenBracket</span><span class="plain">),</span>
            <span class="string">"a close bracket ')' appears here with no matching open '('"</span><span class="plain">,</span>
            <span class="string">"so I can't see what is meant to be the fixed text and what is meant to "</span>
            <span class="string">"be changeable. The idea is to put brackets around whatever varies from "</span>
            <span class="string">"one usage to another: for instance, 'To contribute (N - a number) "</span>
            <span class="string">"dollars: ...'."</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18">&#167;18</a>.</p>

<p class="inwebparagraph"><a id="SP18_1_1"></a><b>&#167;18.1.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_TokenWithNestedBrackets problem</span> <span class="cwebmacronumber">18.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">NOT_APPLICABLE</span><span class="plain">;</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_TokenWithNestedBrackets</span><span class="plain">),</span>
            <span class="string">"the name of the token inside the brackets '(' and ')' and before the "</span>
            <span class="string">"hyphen '-' itself contains another open bracket '('"</span><span class="plain">,</span>
            <span class="string">"which is not allowed."</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18_1">&#167;18.1</a>.</p>

<p class="inwebparagraph"><a id="SP18_1_2"></a><b>&#167;18.1.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_BadTypeIndication problem</span> <span class="cwebmacronumber">18.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">NOT_APPLICABLE</span><span class="plain">;</span>
        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">declaration</span><span class="plain">&gt;, 2));</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BadTypeIndication</span><span class="plain">));</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"In %1, the text '%2' after the hyphen should tell me what kind of value "</span>
            <span class="string">"goes here (like 'a number', or 'a vehicle'), but it's not something I "</span>
            <span class="string">"recognise."</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18_1">&#167;18.1</a>.</p>

<p class="inwebparagraph"><a id="SP18_1_3"></a><b>&#167;18.1.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_TokenMisunderstood problem</span> <span class="cwebmacronumber">18.1.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"On %W\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">NOT_APPLICABLE</span><span class="plain">;</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_TokenMisunderstood</span><span class="plain">),</span>
            <span class="string">"the brackets '(' and ')' here neither say that something varies but has "</span>
            <span class="string">"a given type, nor specify a called name"</span><span class="plain">,</span>
            <span class="string">"so I can't make sense of them. For a 'To...' phrase, brackets like this "</span>
            <span class="string">"are used with a hyphen dividing the name for a varying value and the "</span>
            <span class="string">"kind it has: for instance, 'To contribute (N - a number) dollars: ...'. "</span>
            <span class="string">"Rules, on the other hand, use brackets to give names to things or rooms "</span>
            <span class="string">"found when matching conditions: for instance, 'Instead of opening a "</span>
            <span class="string">"container in the presence of a man (called the box-watcher): ...'"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18_1">&#167;18.1</a>.</p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19.  </b>This internal simply wraps &lt;k-kind-as-name-token&gt; up as a value.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">s</span><span class="plain"> = </span><span class="identifier">kind_parsing_mode</span><span class="plain">;</span>
        <span class="identifier">kind_parsing_mode</span><span class="plain"> = </span><span class="identifier">PHRASE_TOKEN_KIND_PARSING</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">t</span><span class="plain"> = &lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">kind_parsing_mode</span><span class="plain"> = </span><span class="identifier">s</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">t</span><span class="plain">) {</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(&lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;);</span>
            <span class="identifier">ParseTree::set_text</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">;</span>
            <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP20"></a><b>&#167;20.  </b>At this final stage of parsing, all annotations to do with inline or say
behaviour have been stripped away, and what's left is the text which will
form the word and token sequences:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Phrases::TypeData::Textual::phtd_parse_word_sequence</span><span class="plain">(</span><span class="reserved">ph_type_data</span><span class="plain"> *</span><span class="identifier">phtd</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;no_tokens</span><span class="plain"> = 0;</span>
        <span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;no_words</span><span class="plain"> = 0;</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain"> = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">while</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain"> &lt;= </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">word_to_add</span><span class="plain"> = 0; </span>    <span class="comment">redundant assignment to keep <code class="display"><span class="extract">gcc</span></code> happy</span>
            <span class="plain">&lt;</span><span class="reserved">phrase</span><span class="plain">-</span><span class="reserved">definition</span><span class="plain">-</span><span class="identifier">word</span><span class="plain">-</span><span class="identifier">or</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">&gt;(</span><span class="identifier">Wordings::from</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">i</span><span class="plain">));</span>
            <span class="reserved">switch</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">NOT_APPLICABLE</span><span class="plain">:	</span><span class="reserved">return</span><span class="plain">; </span>    <span class="comment">a problem message has been issued</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">:				</span>&lt;<span class="cwebmacro">Add a token next</span> <span class="cwebmacronumber">20.2</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">: 			</span>&lt;<span class="cwebmacro">Add a word next</span> <span class="cwebmacronumber">20.1</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;no_words</span><span class="plain"> &gt;= </span><span class="constant">MAX_WORDS_PER_PHRASE</span><span class="plain">) {</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_PhraseTooLong</span><span class="plain">),</span>
                    <span class="string">"this phrase has too many words"</span><span class="plain">,</span>
                    <span class="string">"and needs to be simplified."</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;word_sequence</span><span class="plain">[</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;no_words</span><span class="plain">++] = </span><span class="identifier">word_to_add</span><span class="plain">;</span>
        <span class="plain">}</span>

        &lt;<span class="cwebmacro">Sort out the kind variables in this declaration</span> <span class="cwebmacronumber">20.3</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::TypeData::Textual::phtd_parse_word_sequence is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP20_1"></a><b>&#167;20.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Add a word next</span> <span class="cwebmacronumber">20.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">word_to_add</span><span class="plain"> = </span><span class="identifier">i</span><span class="plain">++;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP20">&#167;20</a>.</p>

<p class="inwebparagraph"><a id="SP20_2"></a><b>&#167;20.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Add a token next</span> <span class="cwebmacronumber">20.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">form</span><span class="plain">&gt;&gt; == </span><span class="identifier">NOT_APPLICABLE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">; </span>    <span class="comment">a problem message has been issued</span>

        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;; </span>    <span class="comment">what is to be matched</span>

        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">TW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">form</span><span class="plain">&gt;&gt;) </span><span class="identifier">TW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">declaration</span><span class="plain">&gt;, 1); </span>    <span class="comment">the name</span>

        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">A</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="reserved">phrase</span><span class="plain">-</span><span class="reserved">definition</span><span class="plain">-</span><span class="identifier">word</span><span class="plain">-</span><span class="identifier">or</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">&gt;, 1);</span>
        <span class="identifier">i</span><span class="plain"> = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">A</span><span class="plain">);</span>
        <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Wordings::up_to</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">A</span><span class="plain">)); </span>    <span class="comment">move past this token</span>

        &lt;<span class="cwebmacro">Unless we are inline, phrase tokens have to be or describe values</span> <span class="cwebmacronumber">20.2.2</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Phrase tokens cannot be quantified</span> <span class="cwebmacronumber">20.2.3</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Fashion a suitable phrase token</span> <span class="cwebmacronumber">20.2.1</span>&gt;<span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP20">&#167;20</a>.</p>

<p class="inwebparagraph"><a id="SP20_2_1"></a><b>&#167;20.2.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Fashion a suitable phrase token</span> <span class="cwebmacronumber">20.2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">phrase_token</span><span class="plain"> </span><span class="identifier">pht</span><span class="plain">;</span>
        <span class="identifier">pht</span><span class="element">.to_match</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">;</span>
        <span class="identifier">pht</span><span class="element">.token_kind</span><span class="plain"> = </span><span class="functiontext">Specifications::to_kind</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="identifier">pht</span><span class="element">.construct</span><span class="plain"> = &lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt;;</span>
        <span class="identifier">pht</span><span class="element">.token_name</span><span class="plain"> = </span><span class="identifier">TW</span><span class="plain">;</span>
        <span class="identifier">word_to_add</span><span class="plain"> = </span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;no_tokens</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;no_tokens</span><span class="plain"> &gt;= </span><span class="constant">MAX_TOKENS_PER_PHRASE</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;no_tokens</span><span class="plain"> == </span><span class="constant">MAX_TOKENS_PER_PHRASE</span><span class="plain">) {</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">n</span><span class="plain"> = </span><span class="constant">MAX_TOKENS_PER_PHRASE</span><span class="plain">;</span>
                <span class="identifier">Problems::quote_number</span><span class="plain">(3, &amp;</span><span class="identifier">n</span><span class="plain">);</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_TooManyTokens</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"In %1, I ran out of tokens when I got up to '%2'. "</span>
                    <span class="string">"Phrases are only allowed %3 tokens, that is, they "</span>
                    <span class="string">"are only allowed %3 bracketed parts in their definitions."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
            <span class="plain">}</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;token_sequence</span><span class="plain">[</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;no_tokens</span><span class="plain">] = </span><span class="identifier">pht</span><span class="plain">;</span>
            <span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;no_tokens</span><span class="plain">++;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP20_2">&#167;20.2</a>.</p>

<p class="inwebparagraph"><a id="SP20_2_2"></a><b>&#167;20.2.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Unless we are inline, phrase tokens have to be or describe values</span> <span class="cwebmacronumber">20.2.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((&lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; != </span><span class="constant">STANDARD_PT_CONSTRUCT</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(&lt;&lt;</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">construct</span><span class="plain">&gt;&gt; != </span><span class="constant">KIND_NAME_PT_CONSTRUCT</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;as_inline.invoked_inline_not_as_call</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
            <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
            <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
            <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_NoninlineUsesNonvalues</span><span class="plain">));</span>
            <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                <span class="string">"In %1, the text '%2' after the hyphen should tell me what kind of "</span>
                <span class="string">"value goes here (like 'a number', or 'a vehicle'), but this is not "</span>
                <span class="string">"a kind: it does describe something I can understand, but not "</span>
                <span class="string">"something which can then be used as a value. (It would be allowed "</span>
                <span class="string">"in low-level, so-called 'inline' phrase definitions, but not in a "</span>
                <span class="string">"standard phrase definition like this one.)"</span><span class="plain">);</span>
            <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP20_2">&#167;20.2</a>.</p>

<p class="inwebparagraph"><a id="SP20_2_3"></a><b>&#167;20.2.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Phrase tokens cannot be quantified</span> <span class="cwebmacronumber">20.2.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="constant">TEST_VALUE_NT</span><span class="plain">)) {</span>
            <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Variables::number_free</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">) != 1) {</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_PhraseTokenQuantified</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"In %1, the text '%2' after the hyphen should tell me what kind of "</span>
                    <span class="string">"value goes here (like 'a number', or 'a vehicle'), but it has to "</span>
                    <span class="string">"be a single value, and not a description of what might be multiple "</span>
                    <span class="string">"values. So 'N - a number' is fine, but not 'N - three numbers' or "</span>
                    <span class="string">"'N - every number'."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP20_2">&#167;20.2</a>.</p>

<p class="inwebparagraph"><a id="SP20_3"></a><b>&#167;20.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Sort out the kind variables in this declaration</span> <span class="cwebmacronumber">20.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">t</span><span class="plain"> = 0;</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">declarations</span><span class="plain">[27];</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">usages</span><span class="plain">[27];</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">=1; </span><span class="identifier">i</span><span class="plain">&lt;=26; </span><span class="identifier">i</span><span class="plain">++) { </span><span class="identifier">usages</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] = 0; </span><span class="identifier">declarations</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] = </span><span class="identifier">NULL</span><span class="plain">; }</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;no_tokens</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++)</span>
            <span class="identifier">t</span><span class="plain"> += </span><span class="functiontext">Phrases::TypeData::Textual::find_kind_variable_domains</span><span class="plain">(</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;token_sequence</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]</span><span class="element">.token_kind</span><span class="plain">,</span>
                <span class="identifier">usages</span><span class="plain">, </span><span class="identifier">declarations</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">t</span><span class="plain"> &gt; 0) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">problem_thrown</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">v</span><span class="plain">=1; (</span><span class="identifier">v</span><span class="plain">&lt;=26) &amp;&amp; (</span><span class="identifier">problem_thrown</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">); </span><span class="identifier">v</span><span class="plain">++)</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">usages</span><span class="plain">[</span><span class="identifier">v</span><span class="plain">] &gt; 0) &amp;&amp; (</span><span class="identifier">declarations</span><span class="plain">[</span><span class="identifier">v</span><span class="plain">] == </span><span class="identifier">NULL</span><span class="plain">))</span>
                    &lt;<span class="cwebmacro">Issue a problem for an undeclared kind variable</span> <span class="cwebmacronumber">20.3.1</span>&gt;<span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_thrown</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;no_tokens</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++)</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;token_sequence</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]</span><span class="element">.token_kind</span><span class="plain">)</span>
                        &lt;<span class="cwebmacro">Substitute for any kind variables in the match specification</span> <span class="cwebmacronumber">20.3.2</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP20">&#167;20</a>.</p>

<p class="inwebparagraph"><a id="SP20_3_1"></a><b>&#167;20.3.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue a problem for an undeclared kind variable</span> <span class="cwebmacronumber">20.3.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UndeclaredKindVariable</span><span class="plain">),</span>
            <span class="string">"this phrase uses a kind variable which is not declared"</span><span class="plain">,</span>
            <span class="string">"which is not allowed."</span><span class="plain">);</span>
        <span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;token_sequence</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]</span><span class="element">.token_kind</span><span class="plain"> =</span>
            <span class="identifier">Kinds::binary_construction</span><span class="plain">(</span><span class="identifier">CON_phrase</span><span class="plain">, </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">K_value</span><span class="plain">);</span>
        <span class="identifier">problem_thrown</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP20_3">&#167;20.3</a>.</p>

<p class="inwebparagraph"><a id="SP20_3_2"></a><b>&#167;20.3.2.  </b>This following process is much less mysterious than it sounds. Suppose we
have the phrase:
</p>

<blockquote>
    <p>To add (purchase - K) to (shopping list - list of arithmetic values of kind K): ...</p>

</blockquote>

<p class="inwebparagraph">This tells us that the matcher should accept any list of arithmetic values,
and then set K equal to the kind of the entries, and require that the purchase
agree. According to the <code class="display"><span class="extract">declarations</span></code> array already made, K is declared as a
kind of "arithmetic value". What the code in this paragraph does is to change
the <code class="display"><span class="extract">to_match</span></code> specifications as if the phrase had read:
</p>

<blockquote>
    <p>To add (purchase - arithmetic value) to (shopping list - list of arithmetic values): ...</p>

</blockquote>

<p class="inwebparagraph">In other words, we substitute "arithmetic value" in place of K, and thus get
rid of variables from the match specifications entirely. We can safely do
this because the <code class="display"><span class="extract">token_kind</span></code> for these two tokens remain
"K" and "list of K" respectively.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Substitute for any kind variables in the match specification</span> <span class="cwebmacronumber">20.3.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">changed</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">substituted</span><span class="plain"> = </span><span class="identifier">Kinds::substitute</span><span class="plain">(</span>
            <span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;token_sequence</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]</span><span class="element">.token_kind</span><span class="plain">, </span><span class="identifier">declarations</span><span class="plain">, &amp;</span><span class="identifier">changed</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">changed</span><span class="plain">)</span>
            <span class="identifier">phtd</span><span class="plain">-</span><span class="element">&gt;token_sequence</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]</span><span class="element">.to_match</span><span class="plain"> =</span>
                <span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">substituted</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP20_3">&#167;20.3</a>.</p>

<p class="inwebparagraph"><a id="SP21"></a><b>&#167;21.  </b>The following recurses down through the tree structure of a kind, returning
the number of kind variables it finds. (So for lots of straightforward kinds,
such as "list of numbers", it returns 0.)
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Phrases::TypeData::Textual::find_kind_variable_domains</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">usages</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> **</span><span class="identifier">declarations</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">t</span><span class="plain"> = 0;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain">) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">N</span><span class="plain"> = </span><span class="identifier">Kinds::get_variable_number</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">N</span><span class="plain"> &gt; 0) {</span>
                <span class="identifier">t</span><span class="plain">++;</span>
                &lt;<span class="cwebmacro">A kind variable has been found</span> <span class="cwebmacronumber">21.1</span>&gt;<span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::is_proper_constructor</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">)) {</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">a</span><span class="plain"> = </span><span class="identifier">Kinds::arity_of_constructor</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">a</span><span class="plain"> == 1)</span>
                    <span class="identifier">t</span><span class="plain"> += </span><span class="functiontext">Phrases::TypeData::Textual::find_kind_variable_domains</span><span class="plain">(</span>
                        <span class="identifier">Kinds::unary_construction_material</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">), </span><span class="identifier">usages</span><span class="plain">, </span><span class="identifier">declarations</span><span class="plain">);</span>
                <span class="reserved">else</span><span class="plain"> {</span>
                    <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">, *</span><span class="identifier">Y</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
                    <span class="identifier">Kinds::binary_construction_material</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, &amp;</span><span class="identifier">X</span><span class="plain">, &amp;</span><span class="identifier">Y</span><span class="plain">);</span>
                    <span class="identifier">t</span><span class="plain"> += </span><span class="functiontext">Phrases::TypeData::Textual::find_kind_variable_domains</span><span class="plain">(</span><span class="identifier">X</span><span class="plain">, </span><span class="identifier">usages</span><span class="plain">, </span><span class="identifier">declarations</span><span class="plain">);</span>
                    <span class="identifier">t</span><span class="plain"> += </span><span class="functiontext">Phrases::TypeData::Textual::find_kind_variable_domains</span><span class="plain">(</span><span class="identifier">Y</span><span class="plain">, </span><span class="identifier">usages</span><span class="plain">, </span><span class="identifier">declarations</span><span class="plain">);</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">t</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::TypeData::Textual::find_kind_variable_domains is used in <a href="#SP20_3">&#167;20.3</a>.</p>

<p class="inwebparagraph"><a id="SP21_1"></a><b>&#167;21.1.  </b>We count how many times each variable appears. It should be given a domain
in exactly one place: for example,
</p>

<blockquote>
    <p>To amaze (alpha - an arithmetic value of kind K) with (beta - an enumerated value of kind K): ...</p>

</blockquote>

<p class="inwebparagraph">produces the following problem, because the domain of K has been given twice.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">A kind variable has been found</span> <span class="cwebmacronumber">21.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">usages</span><span class="plain">[</span><span class="identifier">N</span><span class="plain">]++;</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">dec</span><span class="plain"> = </span><span class="identifier">Kinds::get_variable_stipulation</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">dec</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">declarations</span><span class="plain">[</span><span class="identifier">N</span><span class="plain">]) {</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_DoublyDeclaredKindVariable</span><span class="plain">),</span>
                    <span class="string">"this phrase declares the same kind variable more than once"</span><span class="plain">,</span>
                    <span class="string">"and ought to declare each variable once each."</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="identifier">declarations</span><span class="plain">[</span><span class="identifier">N</span><span class="plain">] = </span><span class="identifier">dec</span><span class="plain">;</span>
        <span class="plain">}</span>

</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP21">&#167;21</a>.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="22-ptd.html">Back to 'Phrase Type Data'</a></li><li><a href="22-po.html">Continue with 'Phrase Options'</a></li></ul><hr class="tocbar">
<!--End of weave: 1001 lines from a web of 94125-->
	</body>
</html>

