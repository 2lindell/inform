<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>22/pi</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../compiler.html"><b>compiler</b></a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul>
<h2>Compiler Webs</h2>
<ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul>
<h2>Inbuild Modules</h2>
<ul>
<li><a href="../inbuild-module/index.html">inbuild</a></li>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../html-module/index.html">html</a></li>
</ul>
<h2>Inform7 Modules</h2>
<ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul>
<h2>Inter Modules</h2>
<ul>
<li><a href="../inter-module/index.html">inter</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of '23/ad' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="../compiler.html">Compiler</a></li><li><a href="index.html">core</a></li><li><a href="index.html#23">Chapter 23: Calculated Adjectives</a></li><li><b>Adjectival Definitions</b></li></ul><p class="purpose">The second of four ways phrases are invoked: as definitions of adjectives which can be used as unary predicates in the calculus. (And we also look after adjectives arising from I6 or I7 conditions, and from I6 routines.)</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP3">&#167;3. The adjectives traverse</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>A typical example would be:
</p>

<blockquote>
    <p>Definition: A container is significant if it contains a clue.</p>

</blockquote>

<p class="inwebparagraph">Here the domain of the definition is "container", and the meaning assigned
to "significant" is an I7 condition; but we can also make it an I6
condition, or (a tidier way to express the same thing) delegate it to an
I6 routine. Phrases enter only when we define an adjective with an
explicit, though nameless, I7 rule:
</p>

<blockquote>
    <p>Definition: A container (called the sac) is significant: if the sac contains a clue, decide yes; ...</p>

</blockquote>

<p class="inwebparagraph">That makes four distinct kinds of adjective, but all share the following
structure to hold details of their specific meanings:
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">definition</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">definition_node</span><span class="plain">; </span>    <span class="comment">current sentence: where the word "Definition" is</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">node</span><span class="plain">; </span>    <span class="comment">where the actual definition is</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">format</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">+1</span></code> to go by condition, <code class="display"><span class="extract">-1</span></code> to negate it, <code class="display"><span class="extract">0</span></code> to use routine</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">condition_to_match</span><span class="plain">; </span>    <span class="comment">text of condition to match, if <code class="display"><span class="extract">+1</span></code> or <code class="display"><span class="extract">-1</span></code></span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">domain_calling</span><span class="plain">; </span>    <span class="comment">what if anything the term is called</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am_of_def</span><span class="plain">; </span>    <span class="comment">which adjective meaning</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">definition</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure definition is accessed in 23/abrp, 23/abrc, 23/abp, 23/abc and here.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. The adjectives traverse. </b>The following is used to deal with adjective definitions. In the simple
example:
</p>

<blockquote>
    <p>Definition: A container is significant if it contains something.</p>

</blockquote>

<p class="inwebparagraph">we recognise this as a definition because its preamble consists just of
that one word:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="reserved">definition</span><span class="plain">-</span><span class="identifier">header</span><span class="plain">&gt; ::=</span>
        <span class="reserved">definition</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>Having got that far, Inform descends to the body of the definition:
</p>

<blockquote>
    <p>A container is significant if it contains something</p>

</blockquote>

<p class="inwebparagraph">and applies the following grammar. This parsing happens very early in Inform's
run, before most of the kinds are created; but eventually the text of the
domain is expected to match &lt;k-kind&gt;. The text of the condition in
productions (a) and (b) in &lt;adjective-definition&gt; can have various
different forms. For timing reasons, we don't parse it this way, but it's
as if it had to match one of the following list of choices:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(1) &lt;measurement-adjective-definition&gt;
</li><li>(2) &lt;inform6-routine-adjective-definition&gt;
</li><li>(3) &lt;inform6-condition-adjective-definition&gt;
</li><li>(4) &lt;spec-condition&gt;
</li></ul>
<p class="inwebparagraph">At any rate, it will eventually have to make sense, but not yet.
</p>

<p class="inwebparagraph">Production (c) here looks useless, but is intended to catch cases like
this:
</p>

<blockquote>
    <p>Definition: a container is roomy rather than poky: ...</p>

</blockquote>

<p class="inwebparagraph">where the material at <code class="display"><span class="extract">...</span></code> is a phrase determining the truth of the
definition. (This was a very early feature of Inform, and one I think the
language could drop without much loss. No comparable feature exists for
binary predicates, so it seems odd to have it for unary predicates, and
the doubled use of colons is unfortunate.)
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="reserved">definition</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">domain</span><span class="plain">&gt; </span><span class="identifier">is</span><span class="plain">/</span><span class="identifier">are</span><span class="plain"> &lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">wording</span><span class="plain">&gt; </span><span class="reserved">if</span><span class="plain"> ... |		==&gt; </span><span class="constant">DEFINED_POSITIVELY</span>
        <span class="plain">&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">domain</span><span class="plain">&gt; </span><span class="identifier">is</span><span class="plain">/</span><span class="identifier">are</span><span class="plain"> &lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">wording</span><span class="plain">&gt; </span><span class="identifier">unless</span><span class="plain"> ... |	==&gt; </span><span class="constant">DEFINED_NEGATIVELY</span>
        <span class="plain">&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">domain</span><span class="plain">&gt; </span><span class="identifier">is</span><span class="plain">/</span><span class="identifier">are</span><span class="plain"> &lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">wording</span><span class="plain">&gt;				==&gt; </span><span class="constant">DEFINED_PHRASALLY</span>

    <span class="plain">&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">domain</span><span class="plain">&gt; ::=</span>
        <span class="plain">... ( </span><span class="identifier">called</span><span class="plain"> </span><span class="identifier">the</span><span class="plain"> ... ) |		==&gt; 0; &lt;&lt;</span><span class="identifier">calling</span><span class="plain">&gt;&gt; = </span><span class="identifier">TRUE</span>
        <span class="plain">... ( </span><span class="identifier">called</span><span class="plain"> ... ) |			==&gt; 0; &lt;&lt;</span><span class="identifier">calling</span><span class="plain">&gt;&gt; = </span><span class="identifier">TRUE</span>
        <span class="plain">...								==&gt; 0; &lt;&lt;</span><span class="identifier">calling</span><span class="plain">&gt;&gt; = </span><span class="identifier">FALSE</span>

    <span class="plain">&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">wording</span><span class="plain">&gt; ::=</span>
        <span class="plain">... </span><span class="identifier">rather</span><span class="plain"> </span><span class="identifier">than</span><span class="plain"> ... |			==&gt; 0; &lt;&lt;</span><span class="identifier">antonym</span><span class="plain">&gt;&gt; = </span><span class="identifier">TRUE</span>
        <span class="plain">...								==&gt; 0; &lt;&lt;</span><span class="identifier">antonym</span><span class="plain">&gt;&gt; = </span><span class="identifier">FALSE</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>And here is the supporting code:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">DEFINED_POSITIVELY</span><span class="plain"> 1</span>
    <span class="definitionkeyword">define</span> <span class="constant">DEFINED_NEGATIVELY</span><span class="plain"> -1</span>
    <span class="definitionkeyword">define</span> <span class="constant">DEFINED_PHRASALLY</span><span class="plain"> 0</span>
    <span class="definitionkeyword">define</span> <span class="constant">DEFINED_IN_SOME_WAY_NOT_YET_KNOWN</span><span class="plain"> -2</span>
</pre>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Phrases::Adjectives::traverse</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">ParseTree::traverse</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="functiontext">Phrases::Adjectives::look_for_headers</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Phrases::Adjectives::look_for_headers</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">) == </span><span class="identifier">ROUTINE_NT</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="reserved">definition</span><span class="plain">-</span><span class="identifier">header</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">))) {</span>
                <span class="identifier">compilation_module</span><span class="plain"> *</span><span class="identifier">cm</span><span class="plain"> = </span><span class="functiontext">Modules::current</span><span class="plain">();</span>
                <span class="functiontext">Modules::set_current</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
                <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">q</span><span class="plain"> = (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">)?(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">):</span><span class="identifier">NULL</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">q</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span>&lt;<span class="cwebmacro">Futz with the parse tree, trying right not down</span> <span class="cwebmacronumber">5.1</span>&gt;<span class="plain">;</span>

                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">DNW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">; </span>    <span class="comment">domain name</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">CALLW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">; </span>    <span class="comment">calling</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">AW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">; </span>    <span class="comment">adjective name</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">NW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">; </span>    <span class="comment">negation name</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">CONW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">; </span>    <span class="comment">condition text</span>
                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">the_format</span><span class="plain"> = </span><span class="constant">DEFINED_IN_SOME_WAY_NOT_YET_KNOWN</span><span class="plain">;</span>

                &lt;<span class="cwebmacro">Parse the Q-node as an adjective definition</span> <span class="cwebmacronumber">5.2</span>&gt;<span class="plain">;</span>
                &lt;<span class="cwebmacro">Perform sanity checks on the result</span> <span class="cwebmacronumber">5.3</span>&gt;<span class="plain">;</span>
                &lt;<span class="cwebmacro">Register the resulting adjective</span> <span class="cwebmacronumber">5.4</span>&gt;<span class="plain">;</span>

                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">the_format</span><span class="plain"> != </span><span class="constant">DEFINED_PHRASALLY</span><span class="plain">)  </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>

                <span class="functiontext">Modules::set_current_to</span><span class="plain">(</span><span class="identifier">cm</span><span class="plain">);</span>
            <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::Adjectives::traverse is used in 1/htc (<a href="1-htc.html#SP2_3">&#167;2.3</a>).</p>

<p class="endnote">The function Phrases::Adjectives::look_for_headers appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP5_1"></a><b>&#167;5.1.  </b>The tree structure is slightly different according to whether the adjective
is defined by routine or not.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Futz with the parse tree, trying right not down</span> <span class="cwebmacronumber">5.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) ||</span>
            <span class="plain">(</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">) != </span><span class="identifier">ROUTINE_NT</span><span class="plain">)) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">),</span>
                <span class="string">"don't leave me in suspense"</span><span class="plain">,</span>
                <span class="string">"write a definition after 'Definition:'!"</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">q</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">; </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">q</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">; </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> = </span><span class="identifier">q</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">; </span><span class="identifier">q</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP5">&#167;5</a>.</p>

<p class="inwebparagraph"><a id="SP5_2"></a><b>&#167;5.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Parse the Q-node as an adjective definition</span> <span class="cwebmacronumber">5.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="reserved">definition</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">q</span><span class="plain">))) {</span>
            <span class="identifier">the_format</span><span class="plain"> = &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;;</span>
            <span class="identifier">DNW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">domain</span><span class="plain">&gt;, 1);</span>
            <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">calling</span><span class="plain">&gt;&gt;) </span><span class="identifier">CALLW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">domain</span><span class="plain">&gt;, 2);</span>
            <span class="identifier">AW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">wording</span><span class="plain">&gt;, 1);</span>
            <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">antonym</span><span class="plain">&gt;&gt;) </span><span class="identifier">NW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">wording</span><span class="plain">&gt;, 2);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">the_format</span><span class="plain"> != </span><span class="constant">DEFINED_PHRASALLY</span><span class="plain">)</span>
                <span class="identifier">CONW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="reserved">definition</span><span class="plain">&gt;, 1);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP5">&#167;5</a>.</p>

<p class="inwebparagraph"><a id="SP5_3"></a><b>&#167;5.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Perform sanity checks on the result</span> <span class="cwebmacronumber">5.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">the_format</span><span class="plain"> == </span><span class="constant">DEFINED_IN_SOME_WAY_NOT_YET_KNOWN</span><span class="plain">) ||</span>
            <span class="plain">((</span><span class="identifier">the_format</span><span class="plain"> == </span><span class="constant">DEFINED_PHRASALLY</span><span class="plain">) &amp;&amp; (</span><span class="identifier">q</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">))) {</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Definition tree (%d):\</span><span class="plain">n</span><span class="string">$T\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">the_format</span><span class="plain">, </span><span class="identifier">q</span><span class="plain">);</span>
            <span class="identifier">Problems::Issue::definition_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_DefinitionWithoutCondition</span><span class="plain">),</span>
                <span class="identifier">q</span><span class="plain">, </span><span class="string">"a definition must take the form 'Definition: a ... is ... if/unless "</span>
                <span class="string">"...' or else 'Definition: a ... is ...: ...'"</span><span class="plain">,</span>
                <span class="string">"but I can't make this fit either shape."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Wordings::mismatched_brackets</span><span class="plain">(</span><span class="identifier">AW</span><span class="plain">)) ||</span>
            <span class="plain">((</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">NW</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">Wordings::mismatched_brackets</span><span class="plain">(</span><span class="identifier">NW</span><span class="plain">)))) {</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Definition tree:\</span><span class="plain">n</span><span class="string">$T\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">);</span>
            <span class="identifier">Problems::Issue::definition_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BracketedAdjective</span><span class="plain">),</span>
                <span class="identifier">q</span><span class="plain">, </span><span class="string">"this definition seems to involve unexpected brackets in the name of "</span>
                <span class="string">"the adjective being defined"</span><span class="plain">,</span>
                <span class="string">"so I think I must be misreading it."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP5">&#167;5</a>.</p>

<p class="inwebparagraph"><a id="SP5_4"></a><b>&#167;5.4.  </b>As we've seen, adjectives can take many forms, and what we do here is to
offer the new adjective around and see if anybody claims it.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Register the resulting adjective</span> <span class="cwebmacronumber">5.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::parse</span><span class="plain">(</span><span class="identifier">q</span><span class="plain">, </span><span class="identifier">the_format</span><span class="plain">, </span><span class="identifier">AW</span><span class="plain">, </span><span class="identifier">DNW</span><span class="plain">, </span><span class="identifier">CONW</span><span class="plain">, </span><span class="identifier">CALLW</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"unclaimed adjective definition"</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">NW</span><span class="plain">)) {</span>
            <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">neg</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::negate</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">);</span>
            <span class="functiontext">Adjectives::Meanings::declare</span><span class="plain">(</span><span class="identifier">neg</span><span class="plain">, </span><span class="identifier">NW</span><span class="plain">, 5);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP5">&#167;5</a>.</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">ADJECTIVE_NAME_VETTING</span><span class="plain"> </span><span class="functiontext">Phrases::Adjectives::vet_name</span>
</pre>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Phrases::Adjectives::vet_name</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">article</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ArticleAsAdjective</span><span class="plain">),</span>
                <span class="string">"a defined adjective cannot consist only of an article such as "</span>
                <span class="string">"'a' or 'the'"</span><span class="plain">,</span>
                <span class="string">"since this will lead to parsing ambiguities."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">unsuitable</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> == 0) {</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_AdjectivePunctuated</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"The sentence %1 seems to create an adjective with the name "</span>
                    <span class="string">"'%2', but adjectives have to be contain only unpunctuated "</span>
                    <span class="string">"words."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
            <span class="plain">}</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">n</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)</span>
            <span class="identifier">Preform::mark_word</span><span class="plain">(</span><span class="identifier">n</span><span class="plain">, &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">adjective</span><span class="plain">&gt;);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::Adjectives::vet_name appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>Which leaves only:
</p>


<pre class="display">
    <span class="reserved">definition</span><span class="plain"> *</span><span class="functiontext">Phrases::Adjectives::def_new</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">q</span><span class="plain">) {</span>
        <span class="reserved">definition</span><span class="plain"> *</span><span class="identifier">def</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">definition</span><span class="plain">);</span>
        <span class="identifier">def</span><span class="plain">-</span><span class="element">&gt;node</span><span class="plain"> = </span><span class="identifier">q</span><span class="plain">;</span>
        <span class="identifier">def</span><span class="plain">-</span><span class="element">&gt;format</span><span class="plain"> = 0;</span>
        <span class="identifier">def</span><span class="plain">-</span><span class="element">&gt;condition_to_match</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">def</span><span class="plain">-</span><span class="element">&gt;domain_calling</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">def</span><span class="plain">-</span><span class="element">&gt;definition_node</span><span class="plain"> = </span><span class="identifier">current_sentence</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">def</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Phrases::Adjectives::def_new is used in 23/abrp (<a href="23-abrp.html#SP2">&#167;2</a>), 23/abrc (<a href="23-abrc.html#SP2">&#167;2</a>), 23/abp (<a href="23-abp.html#SP1">&#167;1</a>), 23/abc (<a href="23-abc.html#SP1">&#167;1</a>).</p>

<hr class="tocbar">
<ul class="toc"><li><i>(This section begins Chapter 23: Calculated Adjectives.)</i></li><li><a href="23-abrp.html">Continue with 'Adjectives by Raw Phrase'</a></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

