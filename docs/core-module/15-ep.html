<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>15/pr</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '15/ep' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#15">Chapter 15: Properties</a></li><li><b>Either-Or Properties</b></li></ul><p class="purpose">Properties which can either be present or not, but have no value attached.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. A design choice</a></li><li><a href="#SP3">&#167;3. Requesting new named properties</a></li><li><a href="#SP4">&#167;4. Requesting new nameless properties</a></li><li><a href="#SP5">&#167;5. Initialising details</a></li><li><a href="#SP9">&#167;9. Assertion</a></li><li><a href="#SP10">&#167;10. Compilation</a></li><li><a href="#SP12">&#167;12. Either/or properties as adjectives</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. A design choice. </b>A property name structure with the either/or flag set represents one which is
true or false. It's not obvious what the best way to handle these properties
would be. A traditional computer-science view would be that a property like
"open" is really just another valued property, whose kind of value is
"truth state" &mdash; that is, "true" or "false". The word "closed" would
then be no property at all, only a sort of syntactic sugar for a particular
way to initialise the "open" property.
</p>

<p class="inwebparagraph">But in natural language, there seems no reason why "open" should be somehow
more real than "closed". Source text ought to regard them as linguistically
the same, and might talk about "the closed property" just as readily as
"the open property". It's true that at some low-level implementation level
these two properties, "open" and "closed", are tied together, but
otherwise they ought both to be just as valid.
</p>

<p class="inwebparagraph">The language is the same either way, but the compiler has to choose which of
these tacks it will take in implementing either/or properties. The first
approach involves messy higher-level code pretending that certain linguistic
features are properties even when they don't map onto <code class="display"><span class="extract">property</span></code>
structures, which is bad; the second approach involves messy lower-level code
coping with the fact that two different <code class="display"><span class="extract">property</span></code> structures are somehow
the same, which is also bad. In the end, we went with the second approach (but
about every two years consider stripping it out and rewriting the other way,
just the same).
</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>The rule, therefore, is:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(a) If an either/or property has one named form for when it is present and
another for when it is absent, both forms are considered either/or properties.
Each has a <code class="display"><span class="extract">property</span></code> structure. We call these a "pair".
</li></ul>
<ul class="items"><li>(b) Within a pair, the <code class="display"><span class="extract">negation</span></code> field of each member points to the other.
Thus it points from the "open" structure to the "closed" one, and vice
versa.
</li></ul>
<ul class="items"><li>(c) Exactly one member of the pair has <code class="display"><span class="extract">stored_in_negation</span></code> set. This one is
the ghostly one not existing at run-time; for example, in the Standard Rules,
"open" is the stored one and "closed" is the ghost, so "closed" has
<code class="display"><span class="extract">stored_in_negation</span></code> set.
</li></ul>
<ul class="items"><li>(d) If an either/or property has no named form for when it is absent, it is
a "singleton" and not a member of any pair. Its <code class="display"><span class="extract">negation</span></code> field is <code class="display"><span class="extract">NULL</span></code>,
and <code class="display"><span class="extract">stored_in_negation</span></code> is clear.
</li></ul>
<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Requesting new named properties. </b>This is how the either/or properties declared by the source text are made.
</p>


<pre class="display">
    <span class="reserved">property</span><span class="plain"> *</span><span class="functiontext">Properties::EitherOr::obtain</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_KindAdjectiveClash</span><span class="plain">),</span>
                <span class="string">"this tries to create a new either/or adjective with the same name "</span>
                <span class="string">"as an existing kind"</span><span class="plain">,</span>
                <span class="string">"which isn't allowed. For example, 'A hopper can be a container.' is "</span>
                <span class="string">"not allowed because something either is, or is not, a 'container', "</span>
                <span class="string">"and that can never change during play. 'Container' is a kind, and "</span>
                <span class="string">"those are fixed. 'A hopper is a container' would be allowed, because "</span>
                <span class="string">"that makes a definite statement."</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain"> = </span><span class="functiontext">Properties::obtain</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;either_or</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::domain</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;adjectival_meaning_registered</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)</span>
            <span class="functiontext">Properties::EitherOr::create_adjective_from_property</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">);</span>
        <span class="reserved">else</span>
            <span class="functiontext">Properties::EitherOr::make_new_adjective_sense_from_property</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prn</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::EitherOr::obtain is used in 9/pd (<a href="9-pd.html#SP5_9">&#167;5.9</a>, <a href="9-pd.html#SP5_10">&#167;5.10</a>).</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Requesting new nameless properties. </b>These are properties needed for implementation reasons by the template, and
which are added to the model by plugins here inside Inform, but which have
no existence at the source text level &mdash; and hence have no names.
</p>

<p class="inwebparagraph">Setting them up as adjectives may seem a little over the top, since they cannot
be encountered in source text, but the plugins will have to set these properties
by asserting propositions to be true; and type-checking of those propositions
relies on adjectival meanings.
</p>


<pre class="display">
    <span class="reserved">property</span><span class="plain"> *</span><span class="functiontext">Properties::EitherOr::new_nameless</span><span class="plain">(</span><span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">I6_form</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Feeds::feed_text</span><span class="plain">(</span><span class="identifier">I6_form</span><span class="plain">);</span>
        <span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="functiontext">Hierarchy::make_iname_with_memo</span><span class="plain">(</span><span class="constant">PROPERTY_HL</span><span class="plain">, </span><span class="functiontext">Hierarchy::template</span><span class="plain">(), </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain"> = </span><span class="functiontext">Properties::create</span><span class="plain">(</span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="functiontext">Hierarchy::template</span><span class="plain">(), </span><span class="identifier">iname</span><span class="plain">);</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;either_or</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="functiontext">Properties::exclude_from_index</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">);</span>
        <span class="functiontext">Properties::set_translation</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">I6_form</span><span class="plain">);</span>
    <span class="comment">compilation_module *cm = Modules::current();</span>
    <span class="comment">Modules::set_current_to_SR();</span>
        <span class="functiontext">Properties::EitherOr::create_adjective_from_property</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">);</span>
    <span class="comment">Modules::set_current_to(cm);</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;run_time_only</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prn</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::EitherOr::new_nameless appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Initialising details. </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::initialise</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;negation</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;stored_in_negation</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;implemented_as_attribute</span><span class="plain"> = </span><span class="identifier">NOT_APPLICABLE</span><span class="plain">;</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;adjectival_meaning_registered</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;adjectival_phrase_registered</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;eo_parsing_grammar</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">endif</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::EitherOr::initialise is used in 15/pr (<a href="15-pr.html#SP5_3">&#167;5.3</a>).</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>When created, all properties start out as singletons; the following joins
two together into a pair. It's allowed to rejoin an existing pair (either way
around), but not to break one.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::make_negations</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">, </span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">neg</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prn</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;either_or</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"non-EO property"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">neg</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;either_or</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"non-EO property"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;negation</span><span class="plain">) || (</span><span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;negation</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;negation</span><span class="plain"> != </span><span class="identifier">neg</span><span class="plain">) || (</span><span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;negation</span><span class="plain"> != </span><span class="identifier">prn</span><span class="plain">)) {</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="functiontext">Problems::quote_property</span><span class="plain">(2, </span><span class="identifier">prn</span><span class="plain">);</span>
                <span class="functiontext">Problems::quote_property</span><span class="plain">(3, </span><span class="identifier">neg</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;negation</span><span class="plain">) {</span>
                    <span class="functiontext">Problems::quote_property</span><span class="plain">(4, </span><span class="identifier">prn</span><span class="plain">);</span>
                    <span class="functiontext">Problems::quote_property</span><span class="plain">(5, </span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;negation</span><span class="plain">);</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="functiontext">Problems::quote_property</span><span class="plain">(4, </span><span class="identifier">neg</span><span class="plain">);</span>
                    <span class="functiontext">Problems::quote_property</span><span class="plain">(5, </span><span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;negation</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BrokenNegationPair</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"In %1, you proposed to set up the properties '%2' and '%3' as "</span>
                    <span class="string">"opposites of each other. But I can't allow that, because '%4' "</span>
                    <span class="string">"already has an opposite in another context ('%5')."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>

        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;negation</span><span class="plain"> = </span><span class="identifier">neg</span><span class="plain">; </span><span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;negation</span><span class="plain"> = </span><span class="identifier">prn</span><span class="plain">;</span>
        <span class="functiontext">Properties::EitherOr::make_stored_in_negation</span><span class="plain">(</span><span class="identifier">neg</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">property</span><span class="plain"> *</span><span class="functiontext">Properties::EitherOr::get_negation</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prn</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;either_or</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"non-EO property"</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;negation</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::EitherOr::make_negations is used in 9/pd (<a href="9-pd.html#SP5_10">&#167;5.10</a>).</p>

<p class="endnote">The function Properties::EitherOr::get_negation is used in <a href="#SP15_1">&#167;15.1</a>, <a href="#SP15_2">&#167;15.2</a>, <a href="#SP17">&#167;17</a>, 9/imp (<a href="9-imp.html#SP6_1">&#167;6.1</a>), 9/pd (<a href="9-pd.html#SP5_8_3">&#167;5.8.3</a>), 14/rv (<a href="14-rv.html#SP24_3_1">&#167;24.3.1</a>), 15/pr (<a href="15-pr.html#SP15">&#167;15</a>, <a href="15-pr.html#SP21">&#167;21</a>, <a href="15-pr.html#SP22_2">&#167;22.2</a>, <a href="15-pr.html#SP23">&#167;23</a>, <a href="15-pr.html#SP26">&#167;26</a>, <a href="15-pr.html#SP27">&#167;27</a>), 15/epv (<a href="15-epv.html#SP2">&#167;2</a>, <a href="15-epv.html#SP2_1">&#167;2.1</a>, <a href="15-epv.html#SP4">&#167;4</a>), 16/pp (<a href="16-pp.html#SP8">&#167;8</a>), 16/in (<a href="16-in.html#SP14">&#167;14</a>, <a href="16-in.html#SP16">&#167;16</a>, <a href="16-in.html#SP17">&#167;17</a>, <a href="16-in.html#SP19">&#167;19</a>), 16/cmw (<a href="16-cmw.html#SP1_2_2">&#167;1.2.2</a>).</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::stored_in_negation</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prn</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;either_or</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"non-EO property"</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;stored_in_negation</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::make_stored_in_negation</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prn</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;either_or</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"non-EO property"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;negation</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"singleton EO cannot store in negation"</span><span class="plain">);</span>

        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;stored_in_negation</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;negation</span><span class="plain">) </span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;negation</span><span class="plain">-</span><span class="element">&gt;stored_in_negation</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::EitherOr::stored_in_negation is used in <a href="#SP15_1">&#167;15.1</a>, <a href="#SP15_2">&#167;15.2</a>, 14/rv (<a href="14-rv.html#SP24_3_1">&#167;24.3.1</a>), 15/epv (<a href="15-epv.html#SP2">&#167;2</a>, <a href="15-epv.html#SP2_1">&#167;2.1</a>, <a href="15-epv.html#SP3">&#167;3</a>, <a href="15-epv.html#SP4">&#167;4</a>), 16/in (<a href="16-in.html#SP16">&#167;16</a>).</p>

<p class="endnote">The function Properties::EitherOr::make_stored_in_negation is used in <a href="#SP6">&#167;6</a>, 15/pr (<a href="15-pr.html#SP22_2">&#167;22.2</a>).</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>Miscellaneous details:
</p>


<pre class="display">
    <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
    <span class="identifier">grammar_verb</span><span class="plain"> *</span><span class="functiontext">Properties::EitherOr::get_parsing_grammar</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prn</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;either_or</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;eo_parsing_grammar</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::set_parsing_grammar</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">grammar_verb</span><span class="plain"> *</span><span class="identifier">gv</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prn</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;either_or</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"non-EO property"</span><span class="plain">);</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;eo_parsing_grammar</span><span class="plain"> = </span><span class="identifier">gv</span><span class="plain">;</span>
    <span class="plain">}</span>
    <span class="plain">#</span><span class="identifier">endif</span>

    <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="functiontext">Properties::EitherOr::get_aph</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prn</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;either_or</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"non-EO property"</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;adjectival_phrase_registered</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::EitherOr::get_parsing_grammar appears nowhere else.</p>

<p class="endnote">The function Properties::EitherOr::set_parsing_grammar appears nowhere else.</p>

<p class="endnote">The function Properties::EitherOr::get_aph is used in <a href="#SP9">&#167;9</a>, 9/imp (<a href="9-imp.html#SP7_1_3">&#167;7.1.3</a>), 11/pr (<a href="11-pr.html#SP35_2">&#167;35.2</a>), 11/sc (<a href="11-sc.html#SP3_3">&#167;3.3</a>).</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Assertion. </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::assert</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">,</span>
        <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">owner</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">parity</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">certainty</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::unary_PREDICATE_from_aph</span><span class="plain">(</span>
            <span class="functiontext">Properties::EitherOr::get_aph</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">), (</span><span class="identifier">parity</span><span class="plain">)?</span><span class="identifier">FALSE</span><span class="plain">:</span><span class="identifier">TRUE</span><span class="plain">);</span>
        <span class="functiontext">Calculus::Propositions::Assert::assert_true_about</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">owner</span><span class="plain">, </span><span class="identifier">certainty</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::EitherOr::assert appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Compilation. </b>Inform 6 provides "attributes" as a faster-access, more memory-efficient
form of object properties, stored at run-time in a bitmap rather than as
key-value pairs in a small dictionary. Because the bitmap is inflexibly sized,
only some of our either/or properties will be able to make use of it. See
"Properties of Objects" for how these are chosen; the following simply
keep a flag recording the outcome.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::implemented_as_attribute</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prn</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;either_or</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"non-EO property"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;implemented_as_attribute</span><span class="plain"> == </span><span class="identifier">NOT_APPLICABLE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;implemented_as_attribute</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::implement_as_attribute</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">state</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prn</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;either_or</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"non-EO property"</span><span class="plain">);</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;implemented_as_attribute</span><span class="plain"> = </span><span class="identifier">state</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;negation</span><span class="plain">) </span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;negation</span><span class="plain">-</span><span class="element">&gt;implemented_as_attribute</span><span class="plain"> = </span><span class="identifier">state</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::EitherOr::implemented_as_attribute is used in 15/pr (<a href="15-pr.html#SP27">&#167;27</a>), 15/epv (<a href="15-epv.html#SP2_1">&#167;2.1</a>, <a href="15-epv.html#SP4">&#167;4</a>).</p>

<p class="endnote">The function Properties::EitherOr::implement_as_attribute is used in 15/epv (<a href="15-epv.html#SP3">&#167;3</a>).</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b>Otherwise, each either/or property is stored as either <code class="display"><span class="extract">true</span></code> or <code class="display"><span class="extract">false</span></code>
in a given cell of memory at run-time &mdash; wastefully since only 1 of the
16 or 32 bits in that memory word is used, but at least rapidly. The
following compiles this <code class="display"><span class="extract">true</span></code> or <code class="display"><span class="extract">false</span></code> value.
</p>

<p class="inwebparagraph">(Because of the way the attribute optimisation works, it's very important not to
change the strings of compiled code here without making a matching change in
"Properties of Objects".)
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::compile_value</span><span class="plain">(</span><span class="reserved">value_holster</span><span class="plain"> *</span><span class="identifier">VH</span><span class="plain">, </span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">val</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">val</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Holsters::data_acceptable</span><span class="plain">(</span><span class="identifier">VH</span><span class="plain">))</span>
                <span class="functiontext">Holsters::holster_pair</span><span class="plain">(</span><span class="identifier">VH</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Holsters::data_acceptable</span><span class="plain">(</span><span class="identifier">VH</span><span class="plain">))</span>
                <span class="functiontext">Holsters::holster_pair</span><span class="plain">(</span><span class="identifier">VH</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::compile_default_value</span><span class="plain">(</span><span class="reserved">value_holster</span><span class="plain"> *</span><span class="identifier">VH</span><span class="plain">, </span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Holsters::data_acceptable</span><span class="plain">(</span><span class="identifier">VH</span><span class="plain">))</span>
            <span class="functiontext">Holsters::holster_pair</span><span class="plain">(</span><span class="identifier">VH</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::EitherOr::compile_value is used in 15/pr (<a href="15-pr.html#SP26">&#167;26</a>).</p>

<p class="endnote">The function Properties::EitherOr::compile_default_value is used in 15/pr (<a href="15-pr.html#SP25">&#167;25</a>).</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Either/or properties as adjectives. </b>What makes either/or properties linguistically interesting is their use as
adjectives: an open door, a transparent container. Adjectival
meanings arising in this way are of the <code class="display"><span class="extract">EORP_KADJ</span></code> kind, and the following
is called every time an either/or property is created, to create its matching
adjectival meaning:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::create_adjective_from_property</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain"> =</span>
            <span class="functiontext">Adjectives::Meanings::new</span><span class="plain">(</span><span class="constant">EORP_KADJ</span><span class="plain">, </span><span class="identifier">STORE_POINTER_property</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">), </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="functiontext">Adjectives::Meanings::declare</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, 1);</span>
        <span class="functiontext">Adjectives::Meanings::set_domain_from_kind</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">);</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;adjectival_phrase_registered</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::get_aph_from_am</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">);</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;adjectival_meaning_registered</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::make_new_adjective_sense_from_property</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain"> = </span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;adjectival_phrase_registered</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Adjectives::Meanings::applicable_to</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain"> =</span>
            <span class="functiontext">Adjectives::Meanings::new</span><span class="plain">(</span><span class="constant">EORP_KADJ</span><span class="plain">, </span><span class="identifier">STORE_POINTER_property</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">), </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="functiontext">Adjectives::Meanings::declare</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, 2);</span>
        <span class="functiontext">Adjectives::Meanings::set_domain_from_kind</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::EitherOr::create_adjective_from_property is used in <a href="#SP3">&#167;3</a>, <a href="#SP4">&#167;4</a>.</p>

<p class="endnote">The function Properties::EitherOr::make_new_adjective_sense_from_property is used in <a href="#SP3">&#167;3</a>.</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b>And here are the methods which define <code class="display"><span class="extract">EORP</span></code> adjectives. They arise other
than by parsing, as we've seen, so:
</p>


<pre class="display">
    <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="functiontext">Properties::EitherOr::ADJ_parse</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">q</span><span class="plain">,</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">sense</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">AW</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">DNW</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">CONW</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">CALLW</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::EitherOr::ADJ_parse is used in 4/am (<a href="4-am.html#SP37">&#167;37</a>).</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14.  </b>Compiling tests or assertions of these adjectives is easy, because it just
means using their schemata in the usual way...
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::ADJ_compile</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">T</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">emit_flag</span><span class="plain">, </span><span class="reserved">ph_stack_frame</span><span class="plain"> *</span><span class="identifier">phsf</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::EitherOr::ADJ_compile is used in 4/am (<a href="4-am.html#SP39">&#167;39</a>).</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b>...but writing those schemata is not so easy, partly because of the way
either/or properties may be paired, partly because of the attribute storage
optimisation applied to some but not all of them.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::ADJ_compiling_soon</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">, </span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">T</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"Unregistered adjectival either/or property in either/or atom"</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Adjectives::Meanings::get_ready_flag</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="functiontext">Adjectives::Meanings::set_ready_flag</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">);</span>

        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::get_domain</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">))</span>
            &lt;<span class="cwebmacro">Set the schemata for an either/or property adjective with objects as domain</span> <span class="cwebmacronumber">15.1</span>&gt;
        <span class="reserved">else</span>
            &lt;<span class="cwebmacro">Set the schemata for an either/or property adjective with some other domain</span> <span class="cwebmacronumber">15.2</span>&gt;<span class="plain">;</span>
        <span class="reserved">return</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::EitherOr::ADJ_compiling_soon is used in 4/am (<a href="4-am.html#SP38">&#167;38</a>).</p>

<p class="inwebparagraph"><a id="SP15_1"></a><b>&#167;15.1.  </b>The "objects" domain is not really very different, but it's the one used
overwhelmingly most often, so we will call the relevant routines directly rather
than accessing them via the unifying routines <code class="display"><span class="extract">GProperty</span></code> and <code class="display"><span class="extract">WriteGProperty</span></code> &mdash;
which would work just as well, but more slowly.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Set the schemata for an either/or property adjective with objects as domain</span> <span class="cwebmacronumber">15.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Properties::EitherOr::stored_in_negation</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">)) {</span>
            <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">neg</span><span class="plain"> = </span><span class="functiontext">Properties::EitherOr::get_negation</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">);</span>
            <span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">identifier</span><span class="plain"> = </span><span class="functiontext">Properties::iname</span><span class="plain">(</span><span class="identifier">neg</span><span class="plain">);</span>

            <span class="reserved">i6_schema</span><span class="plain"> *</span><span class="identifier">sch</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::set_i6_schema</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="constant">TEST_ADJECTIVE_TASK</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"GetEitherOrProperty(*1, %n) == false"</span><span class="plain">, </span><span class="identifier">identifier</span><span class="plain">);</span>

            <span class="identifier">sch</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::set_i6_schema</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="constant">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"SetEitherOrProperty(*1, %n, true)"</span><span class="plain">, </span><span class="identifier">identifier</span><span class="plain">);</span>

            <span class="identifier">sch</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::set_i6_schema</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="constant">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"SetEitherOrProperty(*1, %n, false)"</span><span class="plain">, </span><span class="identifier">identifier</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">identifier</span><span class="plain"> = </span><span class="functiontext">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">);</span>

            <span class="reserved">i6_schema</span><span class="plain"> *</span><span class="identifier">sch</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::set_i6_schema</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="constant">TEST_ADJECTIVE_TASK</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"GetEitherOrProperty(*1, %n)"</span><span class="plain">, </span><span class="identifier">identifier</span><span class="plain">);</span>

            <span class="identifier">sch</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::set_i6_schema</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="constant">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"SetEitherOrProperty(*1, %n, false)"</span><span class="plain">, </span><span class="identifier">identifier</span><span class="plain">);</span>

            <span class="identifier">sch</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::set_i6_schema</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="constant">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"SetEitherOrProperty(*1, %n, true)"</span><span class="plain">, </span><span class="identifier">identifier</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP15">&#167;15</a>.</p>

<p class="inwebparagraph"><a id="SP15_2"></a><b>&#167;15.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Set the schemata for an either/or property adjective with some other domain</span> <span class="cwebmacronumber">15.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Properties::EitherOr::stored_in_negation</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">)) {</span>
            <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">neg</span><span class="plain"> = </span><span class="functiontext">Properties::EitherOr::get_negation</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">);</span>

            <span class="reserved">i6_schema</span><span class="plain"> *</span><span class="identifier">sch</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::set_i6_schema</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="constant">TEST_ADJECTIVE_TASK</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"GProperty(%k, *1, %n) == false"</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">,</span>
                <span class="functiontext">Properties::iname</span><span class="plain">(</span><span class="identifier">neg</span><span class="plain">));</span>

            <span class="identifier">sch</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::set_i6_schema</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="constant">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"WriteGProperty(%k, *1, %n)"</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">,</span>
                <span class="functiontext">Properties::iname</span><span class="plain">(</span><span class="identifier">neg</span><span class="plain">));</span>

            <span class="identifier">sch</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::set_i6_schema</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="constant">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"WriteGProperty(%k, *1, %n, true)"</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">,</span>
                <span class="functiontext">Properties::iname</span><span class="plain">(</span><span class="identifier">neg</span><span class="plain">));</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">i6_schema</span><span class="plain"> *</span><span class="identifier">sch</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::set_i6_schema</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="constant">TEST_ADJECTIVE_TASK</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"GProperty(%k, *1, %n)"</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">,</span>
                <span class="functiontext">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>

            <span class="identifier">sch</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::set_i6_schema</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="constant">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"WriteGProperty(%k, *1, %n, true)"</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">,</span>
                <span class="functiontext">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>

            <span class="identifier">sch</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::set_i6_schema</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="constant">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"WriteGProperty(%k, *1, %n)"</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">,</span>
                <span class="functiontext">Properties::iname</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP15">&#167;15</a>.</p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16.  </b>To assert an adjective like "open" is to draw an inference about its
property.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::ADJ_assert</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">,</span>
        <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs_to_assert_on</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">val_to_assert_on</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">parity</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">parity</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="functiontext">World::Inferences::draw_negated_property</span><span class="plain">(</span><span class="identifier">infs_to_assert_on</span><span class="plain">, </span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="functiontext">World::Inferences::draw_property</span><span class="plain">(</span><span class="identifier">infs_to_assert_on</span><span class="plain">, </span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::EitherOr::ADJ_assert is used in 4/am (<a href="4-am.html#SP40">&#167;40</a>).</p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17.  </b>And finally:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::ADJ_index</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {</span>
        <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">neg</span><span class="plain"> = </span><span class="functiontext">Properties::EitherOr::get_negation</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">);</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"either/or property"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Properties::permission_list</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">)) {</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" of "</span><span class="plain">); </span><span class="functiontext">World::Permissions::index</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">prn</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">neg</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">Properties::permission_list</span><span class="plain">(</span><span class="identifier">neg</span><span class="plain">))) {</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" of "</span><span class="plain">); </span><span class="functiontext">World::Permissions::index</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">neg</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">neg</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">", opposite of &lt;/i&gt;%+W&lt;i&gt;"</span><span class="plain">, </span><span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::EitherOr::ADJ_index is used in 4/am (<a href="4-am.html#SP41">&#167;41</a>).</p>

<hr class="tocbar">
<ul class="toc"><li><a href="15-pr.html">Back to 'Properties'</a></li><li><a href="15-vp.html">Continue with 'Valued Properties'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

