<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>7/hdn</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '7/ns' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#7">Chapter 7: Sentences</a></li><li><b>Nonstructural Sentences</b></li></ul><p class="purpose">To construct verb-phrase nodes in the parse tree.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP8">&#167;8. Traversing for primary verbs</a></li><li><a href="#SP20">&#167;20. Logging verb numbers</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>At this point in the narrative, we have read files from disc, lexed the text
into a stream of words, and broken this into a list of sentences; we have
identified requests to include extensions, and fully acted on these, so that
we can now forget about that whole complication; and we have built a tree
of headings and subheadings (and file divisions) so that we have a clear map
of the overall structure of the source text. Sentences intended for use only
in some circumstances (for instance, when compiling for the Glulx virtual
machine) have been omitted as necessary, so that we can forget about that
complication, too.
</p>

<p class="inwebparagraph">This gives as much information as we can squeeze out by easily specified
mechanical means: we have attacked the text at the very small scale, letters
and words, and at the very large, headings and files. This zig-zag in scale
will continue. In the rest of this chapter, we find the overall structure of
sentences.
</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>The parse tree is currently a long, long list: each sentence is a node
which is a child of the root, but no sentence has any child nodes of its own.
(That is about to change.) We can divide these sentences into three:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(a) Structural sentences &mdash; headings, extension requests, extension bookends.
All these have now been dealt with.
</li></ul>
<ul class="items"><li>(b) Sentences inside rules: rule preambles (<code class="display"><span class="extract">ROUTINE_NT</span></code> nodes)
and phrases (<code class="display"><span class="extract">INVOCATION_LIST_NT</span></code>). These will not even be looked at until the
second phase of compilation, after the model world has been created.
</li></ul>
<ul class="items"><li>(c) Sentences with primary verbs, having node type <code class="display"><span class="extract">SENTENCE_NT</span></code>. These are
the assertions: they make statements about the initial state of the model
world &mdash; the existence of places and things, and their properties at the
start of play &mdash; and which describe patterns of behaviour during play.
</li></ul>
<p class="inwebparagraph">In the present section of code, then, we identify the primary verbs of
assertion sentences, and deal right away with some of the easier cases,
while leaving the harder ones for later.
</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>Every <code class="display"><span class="extract">SENTENCE_NT</span></code> node is annotated with a verb type from the enumeration
below. All of the assertions which create objects and kinds, and put them
into relationships with each other &mdash; a tremendous variety of possible
sentences, between them making up about three-quarters of all <code class="display"><span class="extract">SENTENCE_NT</span></code>
nodes in typical source &mdash; fall into one of two verb types:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">ASSERT_VB</span><span class="plain"> 10 </span>    <span class="comment">"The bat and ball are on the table."</span>
</pre>
<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>Finally, the remaining verb types are all direct commands to Inform &mdash;
note the imperative forms they take: Use, Understand, Include, and so forth.
In a sense the whole source text is an instruction to Inform, but mostly
it's a passive one: the implicit message is "make the world so that all
this comes right". Here, on the other hand, the user actually speaks
directly. This is a point of the design which has sometimes seemed a little
doubtful &mdash; wouldn't it be more consistent for all of these sentences to be
more passively worded? &mdash; but pragmatism won out: circumlocutions such as
"American dialect is used." or "The story file is released along with..."
are plausible enough, but
</p>

<blockquote>
    <p>"take noun" is understood as taking the noun.</p>

</blockquote>

<p class="inwebparagraph">would mean a lot of important sentences being oddly punctuated with no
initial capital letter, while forcing meaningless extra words, as in
</p>

<blockquote>
    <p>The command "take noun" is understood as taking the noun.</p>

</blockquote>

<p class="inwebparagraph">might prove annoying. Users seem to find the directness of the imperative
easier to use, at any rate, and perhaps the difference in mood helps to
clarify that these are sentences rather different in implication from
the usual sort.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">SPECIAL_MEANING_VB</span><span class="plain"> 70</span>
</pre>
<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>This isn't a verb, and is used only to mark errors:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">BAD_NONVERB</span><span class="plain"> 1000</span>
</pre>
<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b></p>


<pre class="display">
    <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">FOW</span><span class="plain">, </span><span class="identifier">FSW</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Traversing for primary verbs. </b>As with headings, so with <code class="display"><span class="extract">SENTENCE_NT</span></code> nodes: we want the ability to
come back later and add some more. That means that the primary-verb-finder
needs to be able to make more than one pass through. To handle this, all
<code class="display"><span class="extract">SENTENCE_NT</span></code> nodes are annotated on creation with the "sentence
unparsed" marker: we run through the top level of the parse tree,
look at all nodes with this marker, parse their associated sentences,
and remove the marker from them. (So, for instance, if this is run twice
in quick succession, the second run-through does nothing.)
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Sentences::VPs::traverse</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">ParseTree::traverse</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="functiontext">Sentences::VPs::visit</span><span class="plain">);</span>
    <span class="plain">}</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Sentences::VPs::visit</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">) == </span><span class="identifier">TRACE_NT</span><span class="plain">) {</span>
            <span class="identifier">trace_sentences</span><span class="plain"> = 1 - </span><span class="identifier">trace_sentences</span><span class="plain">;</span>
            <span class="identifier">Log::tracing_on</span><span class="plain">(</span><span class="identifier">trace_sentences</span><span class="plain">, </span><span class="identifier">I</span><span class="string">"Diagramming"</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">) == </span><span class="identifier">SENTENCE_NT</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">sentence_unparsed_ANNOT</span><span class="plain">))) {</span>
            <span class="functiontext">Sentences::VPs::seek</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
            &lt;<span class="cwebmacro">Check that this is allowed, if it occurs in the Options file</span> <span class="cwebmacronumber">8.1</span>&gt;<span class="plain">;</span>
            <span class="functiontext">Sentences::Rearrangement::check_sentence_for_direction_creation</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
            <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">sentence_unparsed_ANNOT</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Sentences::VPs::traverse is used in 1/htc (<a href="1-htc.html#SP2_3">&#167;2.3</a>).</p>

<p class="endnote">The function Sentences::VPs::visit appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP8_1"></a><b>&#167;8.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Check that this is allowed, if it occurs in the Options file</span> <span class="cwebmacronumber">8.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::within</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">), </span><span class="identifier">options_file_wording</span><span class="plain">)) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">rev</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="identifier">verb_meaning</span><span class="plain"> *</span><span class="identifier">vm</span><span class="plain"> = </span><span class="identifier">ParseTree::get_verb_meaning</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">);</span>
            <span class="identifier">special_meaning_fn</span><span class="plain"> </span><span class="identifier">soa</span><span class="plain"> = </span><span class="identifier">VerbMeanings::get_special_meaning</span><span class="plain">(</span><span class="identifier">vm</span><span class="plain">, &amp;</span><span class="identifier">rev</span><span class="plain">);</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">err</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">soa</span><span class="plain"> == </span><span class="functiontext">UseOptions::use_SMF</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">soa</span><span class="plain"> == </span><span class="functiontext">PL::Parsing::TestScripts::test_with_SMF</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">soa</span><span class="plain"> == </span><span class="functiontext">Sentences::VPs::include_in_SMF</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">soa</span><span class="plain"> == </span><span class="functiontext">Sentences::VPs::omit_from_SMF</span><span class="plain">)) </span><span class="identifier">err</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">soa</span><span class="plain"> == </span><span class="identifier">PL::Bibliographic::Release::release_along_with_SMF</span><span class="plain">) </span><span class="identifier">err</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="plain">#</span><span class="identifier">endif</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">err</span><span class="plain">)</span>
                <span class="identifier">Problems::Issue::unlocated_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">), </span>    <span class="comment">not usefully testable, anyway</span>
                    <span class="string">"The options file placed in this installation of Inform's folder "</span>
                    <span class="string">"is incorrect, making use of a sentence form which isn't allowed "</span>
                    <span class="string">"in that situation. The options file is only allowed to contain "</span>
                    <span class="string">"use options, Test ... with..., and Release along with... "</span>
                    <span class="string">"instructions."</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>To break up an individual sentence into noun phrases and a verb phrase
is quite simple: we feed it to the &lt;nonstructural-sentence&gt; grammar,
and if that doesn't work, we feed it to &lt;bad-nonstructural-sentence-diagnosis&gt;
to look for a good contextual problem message.
</p>


<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">nss_tree_head</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">bootstrapped</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Sentences::VPs::seek</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">PN</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bootstrapped</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="functiontext">NewVerbs::bootstrap</span><span class="plain">();</span>
            <span class="identifier">bootstrapped</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">nss_tree_head</span><span class="plain"> = </span><span class="identifier">PN</span><span class="plain">;</span>
        <span class="identifier">CLEAR_RW</span><span class="plain">(&lt;</span><span class="identifier">nonstructural</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">&gt;);</span>
        <span class="reserved">if</span><span class="plain"> (!(&lt;</span><span class="identifier">nonstructural</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">PN</span><span class="plain">))))</span>
            <span class="plain">&lt;</span><span class="identifier">bad</span><span class="plain">-</span><span class="identifier">nonstructural</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">diagnosis</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">PN</span><span class="plain">));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Sentences::VPs::seek is used in <a href="#SP8">&#167;8</a>, 7/oaf (<a href="7-oaf.html#SP10">&#167;10</a>).</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b></p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">the</span><span class="plain">-</span><span class="identifier">debugging</span><span class="plain">-</span><span class="identifier">log</span><span class="plain">&gt; ::=</span>
        <span class="identifier">the</span><span class="plain"> </span><span class="identifier">debugging</span><span class="plain"> </span><span class="identifier">log</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Sentences::VPs::include_in_SMF</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">NPs</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[1]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">O2W</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[2]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) { </span>    <span class="comment">"Index map with ..."</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ACCEPT_SMFT</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">the</span><span class="plain">-</span><span class="identifier">debugging</span><span class="plain">-</span><span class="identifier">log</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">)) {</span>
                    <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="constant">SPECIAL_MEANING_VB</span><span class="plain">);</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">articled</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt;(</span><span class="identifier">O2W</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="functiontext">Sentences::VPs::switch_dl_mode</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Sentences::VPs::omit_from_SMF</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">NPs</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[1]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">O2W</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[2]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) { </span>    <span class="comment">"Index map with ..."</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ACCEPT_SMFT</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">the</span><span class="plain">-</span><span class="identifier">debugging</span><span class="plain">-</span><span class="identifier">log</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">)) {</span>
                    <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="constant">SPECIAL_MEANING_VB</span><span class="plain">);</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">articled</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt;(</span><span class="identifier">O2W</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="functiontext">Sentences::VPs::switch_dl_mode</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>


</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Sentences::VPs::include_in_SMF is used in <a href="#SP8_1">&#167;8.1</a>, 6/nv (<a href="6-nv.html#SP16">&#167;16</a>).</p>

<p class="endnote">The function Sentences::VPs::omit_from_SMF is used in <a href="#SP8_1">&#167;8.1</a>, 6/nv (<a href="6-nv.html#SP16">&#167;16</a>).</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Sentences::VPs::switch_dl_mode</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">PN</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">sense</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">PN</span><span class="plain">) == </span><span class="identifier">AND_NT</span><span class="plain">) {</span>
            <span class="functiontext">Sentences::VPs::switch_dl_mode</span><span class="plain">(</span><span class="identifier">PN</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">);</span>
            <span class="functiontext">Sentences::VPs::switch_dl_mode</span><span class="plain">(</span><span class="identifier">PN</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="functiontext">Sentences::VPs::set_aspect_from_text</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">PN</span><span class="plain">), </span><span class="identifier">sense</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Sentences::VPs::switch_dl_mode is used in <a href="#SP11">&#167;11</a>.</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b></p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">include</span><span class="plain">-</span><span class="identifier">in</span><span class="plain">-</span><span class="identifier">debugging</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt; ::=</span>
        <span class="identifier">only</span><span class="plain"> &lt;</span><span class="identifier">debugging</span><span class="plain">-</span><span class="identifier">log</span><span class="plain">-</span><span class="identifier">request</span><span class="plain">&gt; |		==&gt; </span><span class="identifier">R</span><span class="plain">[1] | </span><span class="constant">ONLY_DLR</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">debugging</span><span class="plain">-</span><span class="identifier">log</span><span class="plain">-</span><span class="identifier">request</span><span class="plain">&gt;				==&gt; </span><span class="identifier">R</span><span class="plain">[1]; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">debugging</span><span class="plain">-</span><span class="identifier">log</span><span class="plain">-</span><span class="identifier">request</span><span class="plain">&gt; ::=</span>
        <span class="identifier">everything</span><span class="plain"> |						==&gt; </span><span class="constant">EVERYTHING_DLR</span>
        <span class="identifier">nothing</span><span class="plain"> |							==&gt; </span><span class="constant">NOTHING_DLR</span>
        <span class="plain">&lt;</span><span class="identifier">preform</span><span class="plain">-</span><span class="identifier">nonterminal</span><span class="plain">&gt; |				==&gt; </span><span class="constant">PREFORM_DLR</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">...									==&gt; </span><span class="constant">SOMETHING_DLR</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Sentences::VPs::set_aspect_from_text</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">new_state</span><span class="plain">) {</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">DEBUGGING_LOG_INCLUSIONS</span><span class="plain">, </span><span class="string">"Set contents of debugging log: %W -&gt; %s\</span><span class="plain">n</span><span class="string">"</span><span class="plain">,</span>
            <span class="identifier">W</span><span class="plain">, </span><span class="identifier">new_state</span><span class="plain">?</span><span class="string">"TRUE"</span><span class="plain">:</span><span class="string">"FALSE"</span><span class="plain">);</span>

        &lt;<span class="cwebmacro">See if this is a compound request for debugging information</span> <span class="cwebmacronumber">13.1</span>&gt;<span class="plain">;</span>

        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnknownDA</span><span class="plain">));</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"In the sentence %1, you asked to include '%2' in the "</span>
            <span class="string">"debugging log, but there is no such debugging log topic."</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Sentences::VPs::set_aspect_from_text is used in <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP13_1"></a><b>&#167;13.1.  </b>Requests can be divided as "R and S" (and can even use the serial comma),
and we also understand "only R" and "everything" and "nothing".
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">ONLY_DLR</span><span class="plain"> 1</span>
    <span class="definitionkeyword">define</span> <span class="constant">EVERYTHING_DLR</span><span class="plain"> 2</span>
    <span class="definitionkeyword">define</span> <span class="constant">NOTHING_DLR</span><span class="plain"> 4</span>
    <span class="definitionkeyword">define</span> <span class="constant">SOMETHING_DLR</span><span class="plain"> 8</span>
    <span class="definitionkeyword">define</span> <span class="constant">PREFORM_DLR</span><span class="plain"> 16</span>
</pre>

<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">See if this is a compound request for debugging information</span> <span class="cwebmacronumber">13.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">&lt;</span><span class="identifier">include</span><span class="plain">-</span><span class="identifier">in</span><span class="plain">-</span><span class="identifier">debugging</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt; &amp; </span><span class="constant">ONLY_DLR</span><span class="plain">) </span><span class="identifier">Log::set_all_aspects</span><span class="plain">(1-</span><span class="identifier">new_state</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt; &amp; </span><span class="constant">EVERYTHING_DLR</span><span class="plain">) { </span><span class="identifier">Log::set_all_aspects</span><span class="plain">(</span><span class="identifier">new_state</span><span class="plain">); </span><span class="reserved">return</span><span class="plain">; }</span>
        <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt; &amp; </span><span class="constant">NOTHING_DLR</span><span class="plain">) { </span><span class="identifier">Log::set_all_aspects</span><span class="plain">(1-</span><span class="identifier">new_state</span><span class="plain">); </span><span class="reserved">return</span><span class="plain">; }</span>
        <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt; &amp; </span><span class="constant">SOMETHING_DLR</span><span class="plain">) {</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">RQW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">debugging</span><span class="plain">-</span><span class="identifier">log</span><span class="plain">-</span><span class="identifier">request</span><span class="plain">&gt;, 1);</span>
            &lt;<span class="cwebmacro">See if this is a simple request for debugging information</span> <span class="cwebmacronumber">13.1.1</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt; &amp; </span><span class="constant">PREFORM_DLR</span><span class="plain">) { </span><span class="identifier">Preform::watch</span><span class="plain">(&lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;, </span><span class="identifier">new_state</span><span class="plain">); </span><span class="reserved">return</span><span class="plain">; }</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP13">&#167;13</a>.</p>

<p class="inwebparagraph"><a id="SP13_1_1"></a><b>&#167;13.1.1.  </b>Otherwise a request must be the name of a single debugging aspect.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">See if this is a simple request for debugging information</span> <span class="cwebmacronumber">13.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">req</span><span class="plain">);</span>
        <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">j</span><span class="plain">, </span><span class="identifier">RQW</span><span class="plain">) {</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">req</span><span class="plain">, </span><span class="string">"%N"</span><span class="plain">, </span><span class="identifier">j</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">j</span><span class="plain">&lt;</span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">RQW</span><span class="plain">)) </span><span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">req</span><span class="plain">, </span><span class="string">" "</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">rv</span><span class="plain"> = </span><span class="identifier">Log::set_aspect_from_command_line</span><span class="plain">(</span><span class="identifier">req</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">req</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">rv</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP13_1">&#167;13.1</a>.</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14.  </b>Here, then, is one of Inform's largest grammars, &lt;nonstructural-sentence&gt;.
</p>

<p class="inwebparagraph">It's large because of the many exceptional, ad-hoc-looking syntaxes, and at
first sight those seem unnecessary: why not simply define more built-in verbs
and relations, and handle them as regular sentences? The answer to this is that
they have an irregular structure to them. Consider:
</p>

<blockquote>
    <p>Trampling is an action applying to nothing.</p>

</blockquote>

<p class="inwebparagraph">This doesn't conform to the pattern of a verb plus a subject and object
noun phrase, each of which refers to some value.
</p>

<p class="inwebparagraph">An arguably inconsistent feature of the design of Inform is that some of these
sentences take the imperative mood:
</p>

<blockquote>
    <p>Release along with the solution.</p>

</blockquote>

<p class="inwebparagraph">rather than the indicative ("The ball is in the box") which is otherwise
used for all Inform sentences other than rule definitions. Sometimes I think
this is a mistake, sometimes a virtue. In the case of "Release along", for
instance, we're telling the computer to do something, rather than telling
the computer about something &mdash; which seems a worthwhile distinction. In the
case of "Understand X as Y", though, it could be argued that an indicative
use of "X means Y" would work better. (It was actually Andrew Plotkin's
suggestion that we use "Understand", and it stuck.) At any rate, it's too
late now, and I ask translators into natural languages to follow the same
pattern: use imperatives if the English does, and use indicatives otherwise.
</p>

<p class="inwebparagraph">Note also that "Index map with..." is an imperative, with the verb being
"to index", that is, it's an instruction to make a map; "index map" is
not a noun phrase here.
</p>

<p class="inwebparagraph">The ordering of the sentences in this nonterminal is important. A few notes:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(a) We check Unicode translations first of all, because we haven't any control
over the wording of character names in the Unicode standard. Among the 12,997
definitions used in the Unicode Full Character Names extension are such choice
examples as "downwards arrow from bar", "arabic hamza above", "kangxi
radical use" and so forth, and we don't want to misread "from", "above",
"use", and so on, as prepositions or verbs: in sentences like this one
they are nouns.
</li></ul>
<ul class="items"><li>(b) Any sentence form with "is" or "has" in it must be checked before
regular sentences are checked: "X is an action...", for instance, is
otherwise easily mistaken for a regular assertion.
</li></ul>
<ul class="items"><li>(c) We could conceivably have implemented "action" and "activity" as
pseudo-kinds, and thus handled sentences like these through ordinary
assertions, but it would have been a lot of fuss. So we do it the
simple-minded way.
</li></ul>
<ul class="items"><li>(d) Note that activity declarations always simply end "is an activity.",
thus having nothing interesting by way of an object noun phrase, whereas
action declarations continue with usually extensive further text:
"... is an action applying to two visible things.", say.
</li></ul>

<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">nonstructural</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">sentence</span><span class="plain">&gt;								==&gt; </span>&lt;<span class="cwebmacro">Construct NSS subtree for regular sentence</span> <span class="cwebmacronumber">14.1</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP14_1"></a><b>&#167;14.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Construct NSS subtree for regular sentence</span> <span class="cwebmacronumber">14.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = 0;</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">VP_PN</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">linguistic_error_here_ANNOT</span><span class="plain">) == </span><span class="identifier">TwoLikelihoods_LINERROR</span><span class="plain">)</span>
            &lt;<span class="cwebmacro">Issue two likelihoods problem</span> <span class="cwebmacronumber">14.1.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">) == 0)</span>
            <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="constant">ASSERT_VB</span><span class="plain">);</span>
        <span class="identifier">ParseTree::graft</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">nss_tree_head</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">trace_sentences</span><span class="plain">) {</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"$T\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">nss_tree_head</span><span class="plain">); </span><span class="identifier">STREAM_FLUSH</span><span class="plain">(</span><span class="identifier">DL</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = 0;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP14">&#167;14</a>.</p>

<p class="inwebparagraph"><a id="SP14_1_1"></a><b>&#167;14.1.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue two likelihoods problem</span> <span class="cwebmacronumber">14.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_TwoLikelihoods</span><span class="plain">),</span>
            <span class="string">"this sentence seems to have a likelihood qualification on both "</span>
            <span class="string">"sides of the verb"</span><span class="plain">,</span>
            <span class="string">"which is not allowed. 'The black door certainly is usually open' "</span>
            <span class="string">"might possibly be grammatical English in some idioms, but Inform "</span>
            <span class="string">"doesn't like a sentence in this shape because the 'certainly' "</span>
            <span class="string">"on one side of the verb and the 'usually' on the other are "</span>
            <span class="string">"rival indications of certainty."</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP14_1">&#167;14.1</a>.</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b>In all other cases it's routine to construct the subtree, which typically
gives the sentence node three children: verb phrase, subject noun phrase,
object noun phrase.
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">SENTENCE_NT "Railway Departure begins when the player is in the train"</span>
        <span class="plain">    AVERB_NT "begins when"</span>
        <span class="plain">    PROPER_NOUN_NT "Railway Departure"</span>
        <span class="plain">    PROPER_NOUN_NT "the player is in the train"</span>
</pre>

<p class="inwebparagraph">This is made by <code class="display"><span class="extract">Sentences::VPs::nss_tree2</span></code>, but there are variants for one noun phrase or three.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Sentences::VPs::nss_tree1</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">t</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">VW</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">np1</span><span class="plain">) {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">VP_PN</span><span class="plain"> = </span><span class="identifier">ParseTree::new</span><span class="plain">(</span><span class="identifier">AVERB_NT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::set_text</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">VW</span><span class="plain">);</span>
        <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="identifier">t</span><span class="plain">);</span>
        <span class="identifier">ParseTree::graft</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">nss_tree_head</span><span class="plain">);</span>
        <span class="identifier">ParseTree::graft</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">np1</span><span class="plain">, </span><span class="identifier">nss_tree_head</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> 0;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Sentences::VPs::nss_tree2</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">t</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">VW</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">np1</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">np2</span><span class="plain">) {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">VP_PN</span><span class="plain"> = </span><span class="identifier">ParseTree::new</span><span class="plain">(</span><span class="identifier">AVERB_NT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::set_text</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">VW</span><span class="plain">);</span>
        <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="identifier">t</span><span class="plain">);</span>
        <span class="identifier">ParseTree::graft</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">nss_tree_head</span><span class="plain">);</span>
        <span class="identifier">ParseTree::graft</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">np1</span><span class="plain">, </span><span class="identifier">nss_tree_head</span><span class="plain">);</span>
        <span class="identifier">ParseTree::graft</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">np2</span><span class="plain">, </span><span class="identifier">nss_tree_head</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> 0;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Sentences::VPs::nss_tree3</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">t</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">VW</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">np1</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">np2</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">np3</span><span class="plain">) {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">VP_PN</span><span class="plain"> = </span><span class="identifier">ParseTree::new</span><span class="plain">(</span><span class="identifier">AVERB_NT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::set_text</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">VW</span><span class="plain">);</span>
        <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="identifier">t</span><span class="plain">);</span>
        <span class="identifier">ParseTree::graft</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">VP_PN</span><span class="plain">, </span><span class="identifier">nss_tree_head</span><span class="plain">);</span>
        <span class="identifier">ParseTree::graft</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">np1</span><span class="plain">, </span><span class="identifier">nss_tree_head</span><span class="plain">);</span>
        <span class="identifier">ParseTree::graft</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">np2</span><span class="plain">, </span><span class="identifier">nss_tree_head</span><span class="plain">);</span>
        <span class="identifier">ParseTree::graft</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">np3</span><span class="plain">, </span><span class="identifier">nss_tree_head</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> 0;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Sentences::VPs::nss_tree1 appears nowhere else.</p>

<p class="endnote">The function Sentences::VPs::nss_tree2 appears nowhere else.</p>

<p class="endnote">The function Sentences::VPs::nss_tree3 appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16.  </b>In the assertion parser, any text at all can be a noun phrase. However,
to disambiguate sentences we sometimes want to insist that it takes a
particular form: for instance &lt;nounphrase-figure&gt; matches any text ending
in the word "figure".
</p>

<p class="inwebparagraph">&lt;nounphrase-actionable&gt; is an awkward necessity, designed to prevent the
regular sentence
</p>

<blockquote>
    <p>The impulse is an action name that varies.</p>

</blockquote>

<p class="inwebparagraph">from being parsed as an instance of "... is an action ...", creating a
new action.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">figure</span><span class="plain">&gt; ::=</span>
        <span class="identifier">figure</span><span class="plain"> ...							==&gt; </span><span class="identifier">GENERATE_RAW_NP</span>

    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">sound</span><span class="plain">&gt; ::=</span>
        <span class="identifier">sound</span><span class="plain"> ...							==&gt; </span><span class="identifier">GENERATE_RAW_NP</span>

    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">external</span><span class="plain">-</span><span class="identifier">file</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">external</span><span class="plain">-</span><span class="identifier">file</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt;						==&gt; </span><span class="identifier">GENERATE_RAW_NP</span>

    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">actionable</span><span class="plain">&gt; ::=</span>
        <span class="plain">^&lt;</span><span class="identifier">variable</span><span class="plain">-</span><span class="identifier">creation</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt;			==&gt; </span><span class="identifier">GENERATE_RAW_NP</span>

    <span class="plain">&lt;</span><span class="identifier">variable</span><span class="plain">-</span><span class="identifier">creation</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; ::=</span>
        <span class="plain">*** </span><span class="identifier">that</span><span class="plain">/</span><span class="identifier">which</span><span class="plain"> </span><span class="identifier">vary</span><span class="plain">/</span><span class="identifier">varies</span><span class="plain"> |</span>
        <span class="plain">*** </span><span class="identifier">variable</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17.  </b>"I6" and "Inform 6" are synonymous here.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">translation</span><span class="plain">-</span><span class="identifier">target</span><span class="plain">-</span><span class="identifier">unicode</span><span class="plain">&gt; ::=</span>
        <span class="identifier">unicode</span><span class="plain">								==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>

    <span class="plain">&lt;</span><span class="identifier">translation</span><span class="plain">-</span><span class="identifier">target</span><span class="plain">-</span><span class="identifier">i6</span><span class="plain">&gt; ::=</span>
        <span class="identifier">i6</span><span class="plain"> |								==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">inform</span><span class="plain"> 6							==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>

    <span class="plain">&lt;</span><span class="identifier">translation</span><span class="plain">-</span><span class="identifier">target</span><span class="plain">-</span><span class="identifier">language</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">natural</span><span class="plain">-</span><span class="identifier">language</span><span class="plain">&gt;					==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Sentences::VPs::translates_into_unicode_as_SMF</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">NPs</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[0]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[1]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">O2W</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[2]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) { </span>    <span class="comment">"Black king chess piece translates into Unicode as 9818"</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ACCEPT_SMFT</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">translation</span><span class="plain">-</span><span class="identifier">target</span><span class="plain">-</span><span class="identifier">unicode</span><span class="plain">&gt;(</span><span class="identifier">O2W</span><span class="plain">)) {</span>
                    <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="constant">SPECIAL_MEANING_VB</span><span class="plain">);</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">definite</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">articled</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TRAVERSE2_SMFT</span><span class="plain">:</span>
                <span class="functiontext">UnicodeTranslations::unicode_translates</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Sentences::VPs::translates_into_I6_as_SMF</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">NPs</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[0]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[1]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">O2W</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[2]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) { </span>    <span class="comment">"Black king chess piece translates into Unicode as 9818"</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ACCEPT_SMFT</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">translation</span><span class="plain">-</span><span class="identifier">target</span><span class="plain">-</span><span class="identifier">i6</span><span class="plain">&gt;(</span><span class="identifier">O2W</span><span class="plain">)) {</span>
                    <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="constant">SPECIAL_MEANING_VB</span><span class="plain">);</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">definite</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">articled</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TRAVERSE1_SMFT</span><span class="plain">:</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TRAVERSE2_SMFT</span><span class="plain">:</span>
                <span class="functiontext">IdentifierTranslations::as</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Sentences::VPs::translates_into_language_as_SMF</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">NPs</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[0]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[1]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">O2W</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[2]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) { </span>    <span class="comment">"Black king chess piece translates into Unicode as 9818"</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ACCEPT_SMFT</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">translation</span><span class="plain">-</span><span class="identifier">target</span><span class="plain">-</span><span class="identifier">language</span><span class="plain">&gt;(</span><span class="identifier">O2W</span><span class="plain">)) {</span>
                    <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="constant">SPECIAL_MEANING_VB</span><span class="plain">);</span>
                    <span class="identifier">inform_language</span><span class="plain"> *</span><span class="identifier">nl</span><span class="plain"> = (</span><span class="identifier">inform_language</span><span class="plain"> *) (&lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;);</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">definite</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">articled</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="identifier">ParseTree::set_defn_language</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">nl</span><span class="plain">);</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TRAVERSE1_SMFT</span><span class="plain">:</span>
                <span class="functiontext">UseNouns::nl_translates</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Sentences::VPs::translates_into_unicode_as_SMF is used in 6/nv (<a href="6-nv.html#SP16">&#167;16</a>).</p>

<p class="endnote">The function Sentences::VPs::translates_into_I6_as_SMF is used in 6/nv (<a href="6-nv.html#SP16">&#167;16</a>).</p>

<p class="endnote">The function Sentences::VPs::translates_into_language_as_SMF is used in 6/nv (<a href="6-nv.html#SP16">&#167;16</a>).</p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19.  </b>This final case never matches a legal sentence: it simply hoovers up
usages of past tense assertion verbs in order to give them a better
Problem message than the one they will otherwise receive later on.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">bad</span><span class="plain">-</span><span class="identifier">nonstructural</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">diagnosis</span><span class="plain">&gt; ::=</span>
        <span class="plain">... &lt;</span><span class="identifier">bad</span><span class="plain">-</span><span class="identifier">nonstructural</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">diagnosis</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt;</span>

    <span class="plain">&lt;</span><span class="identifier">bad</span><span class="plain">-</span><span class="identifier">nonstructural</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">diagnosis</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">relative</span><span class="plain">-</span><span class="identifier">clause</span><span class="plain">-</span><span class="identifier">marker</span><span class="plain">&gt; &lt;</span><span class="identifier">certainty</span><span class="plain">&gt; &lt;</span><span class="identifier">meaningful</span><span class="plain">-</span><span class="identifier">nonimperative</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; ... |	==&gt; 0; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FAIL_NONTERMINAL</span><span class="plain"> + </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">WR</span><span class="plain">[1]) - </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="plain">&lt;</span><span class="identifier">relative</span><span class="plain">-</span><span class="identifier">clause</span><span class="plain">-</span><span class="identifier">marker</span><span class="plain">&gt; &lt;</span><span class="identifier">meaningful</span><span class="plain">-</span><span class="identifier">nonimperative</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; ... |						==&gt; 0; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FAIL_NONTERMINAL</span><span class="plain"> + </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">WR</span><span class="plain">[1]) - </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="plain">&lt;</span><span class="identifier">past</span><span class="plain">-</span><span class="identifier">tense</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; ... |																==&gt; </span>&lt;<span class="cwebmacro">Issue PM_NonPresentTense problem</span> <span class="cwebmacronumber">19.1</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">negated</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; ...																	==&gt; </span>&lt;<span class="cwebmacro">Issue PM_NegatedVerb1 problem</span> <span class="cwebmacronumber">19.2</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP19_1"></a><b>&#167;19.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_NonPresentTense problem</span> <span class="cwebmacronumber">19.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">current_sentence</span><span class="plain">, </span><span class="constant">verb_problem_issued_ANNOT</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">current_sentence</span><span class="plain">, </span><span class="constant">verb_problem_issued_ANNOT</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_NonPresentTense</span><span class="plain">),</span>
                <span class="string">"assertions about the initial state of play must be given in the "</span>
                <span class="string">"present tense"</span><span class="plain">,</span>
                <span class="string">"so 'The cat is in the basket' is fine but not 'The cat has been in "</span>
                <span class="string">"the basket'. Time is presumed to start only when the game begins, so "</span>
                <span class="string">"there is no anterior state which we can speak of."</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP19">&#167;19</a>.</p>

<p class="inwebparagraph"><a id="SP19_2"></a><b>&#167;19.2.  </b>This catches sentences like "Timothy does not carry the ring".
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_NegatedVerb1 problem</span> <span class="cwebmacronumber">19.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">current_sentence</span><span class="plain">, </span><span class="constant">verb_problem_issued_ANNOT</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">current_sentence</span><span class="plain">, </span><span class="constant">verb_problem_issued_ANNOT</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
            <span class="identifier">Problems::Issue::negative_sentence_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_NegatedVerb1</span><span class="plain">));</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP19">&#167;19</a>.</p>

<p class="inwebparagraph"><a id="SP20"></a><b>&#167;20. Logging verb numbers. </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Sentences::VPs::log</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">verb_number</span><span class="plain">) {</span>
        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">verb_number</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">ASSERT_VB</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"ASSERT_VB"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">SPECIAL_MEANING_VB</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"SPECIAL_MEANING_VB"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">default</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"(number %d)"</span><span class="plain">, </span><span class="identifier">verb_number</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Sentences::VPs::log is used in 1/cm (<a href="1-cm.html#SP5">&#167;5</a>, <a href="1-cm.html#SP6_6">&#167;6.6</a>).</p>

<p class="inwebparagraph"><a id="SP21"></a><b>&#167;21.  </b></p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">np</span><span class="plain">-</span><span class="identifier">relative</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">implicit</span><span class="plain">&gt; ::=</span>
        <span class="identifier">worn</span><span class="plain"> |									==&gt; </span>&lt;<span class="cwebmacro">Act on the implicit RP worn</span> <span class="cwebmacronumber">21.1</span>&gt;<span class="plain">; </span>    <span class="comment">player\_plugin</span>
        <span class="identifier">carried</span><span class="plain"> |								==&gt; </span>&lt;<span class="cwebmacro">Act on the implicit RP carried</span> <span class="cwebmacronumber">21.2</span>&gt;<span class="plain">; </span>    <span class="comment">player\_plugin</span>
        <span class="identifier">initially</span><span class="plain"> </span><span class="identifier">carried</span><span class="plain"> |						==&gt; </span>&lt;<span class="cwebmacro">Act on the implicit RP initially carried</span> <span class="cwebmacronumber">21.3</span>&gt;<span class="plain">; </span>    <span class="comment">player\_plugin</span>
        <span class="identifier">here</span><span class="plain">									==&gt; </span>&lt;<span class="cwebmacro">Act on the implicit RP here</span> <span class="cwebmacronumber">21.4</span>&gt;<span class="plain">; </span>    <span class="comment">spatial\_plugin</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP21_1"></a><b>&#167;21.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Act on the implicit RP worn</span> <span class="cwebmacronumber">21.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">#</span><span class="identifier">ifndef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NounPhrases::PN_rel</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">R_wearing</span><span class="plain">, -1, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="plain">#</span><span class="identifier">endif</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP21">&#167;21</a>.</p>

<p class="inwebparagraph"><a id="SP21_2"></a><b>&#167;21.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Act on the implicit RP carried</span> <span class="cwebmacronumber">21.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">#</span><span class="identifier">ifndef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NounPhrases::PN_rel</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">R_carrying</span><span class="plain">, -1, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="plain">#</span><span class="identifier">endif</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP21">&#167;21</a>.</p>

<p class="inwebparagraph"><a id="SP21_3"></a><b>&#167;21.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Act on the implicit RP initially carried</span> <span class="cwebmacronumber">21.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">#</span><span class="identifier">ifndef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NounPhrases::PN_rel</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">R_carrying</span><span class="plain">, -1, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="plain">#</span><span class="identifier">endif</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP21">&#167;21</a>.</p>

<p class="inwebparagraph"><a id="SP21_4"></a><b>&#167;21.4.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Act on the implicit RP here</span> <span class="cwebmacronumber">21.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">#</span><span class="identifier">ifndef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NounPhrases::PN_rel</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">PARENTAGE_HERE_RELN</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="plain">#</span><span class="identifier">endif</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP21">&#167;21</a>.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="7-hdn.html">Back to 'Headings'</a></li><li><a href="7-oaf.html">Continue with 'Of and From'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

