<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>15/vp</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '15/cp' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#15">Chapter 15: Properties</a></li><li><b>Condition Properties</b></li></ul><p class="purpose">Properties which hold one of an enumerated set of named states of something.</p>

<ul class="toc"><li><a href="#SP5">&#167;5. Coincidence</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1.  </b>Some valued properties are "conditions", in the sense of "What
condition is this in?": for instance the sentence
</p>

<blockquote>
    <p>The cask can be wedged open, bolted closed or stoved in.</p>

</blockquote>

<p class="inwebparagraph">sets up a new property called the "cask condition", whose value must be one of
these three named possibilities. (A new kind of value is set up whose three
possible values these are.)
</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Properties::Conditions::initialise</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;condition_of</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;condition_anonymously_named</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::Conditions::initialise is used in 15/vp (<a href="15-vp.html#SP4">&#167;4</a>).</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b></p>


<pre class="display">
    <span class="reserved">property</span><span class="plain"> *</span><span class="functiontext">Properties::Conditions::new</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">NW</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">set</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">already</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">anon</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">NW</span><span class="plain">;</span>
        <span class="plain">*</span><span class="identifier">already</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">NW</span><span class="plain">)) {</span>
            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">common_kind</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">mixed_kind</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">some_new</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">CKW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="identifier">NKW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">option</span><span class="plain"> = </span><span class="identifier">set</span><span class="plain">; </span><span class="identifier">option</span><span class="plain">; </span><span class="identifier">option</span><span class="plain"> = (</span><span class="identifier">option</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">)?(</span><span class="identifier">option</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">):</span><span class="identifier">NULL</span><span class="plain">) {</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">option</span><span class="plain">) == </span><span class="identifier">AND_NT</span><span class="plain">)</span>
                    <span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">option</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">);</span>
                <span class="reserved">else</span>
                    <span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">option</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt;(</span><span class="identifier">PW</span><span class="plain">)) {</span>
                    <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::has_ENUMERATIVE_meaning</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">);</span>
                    <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = (</span><span class="identifier">I</span><span class="plain">)?</span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">):</span><span class="identifier">NULL</span><span class="plain">;</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">common_kind</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
                        <span class="identifier">common_kind</span><span class="plain"> = </span><span class="identifier">K</span><span class="plain">;</span>
                        <span class="identifier">CKW</span><span class="plain"> = </span><span class="identifier">PW</span><span class="plain">;</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::eq</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">common_kind</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                            <span class="identifier">mixed_kind</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                            <span class="identifier">NKW</span><span class="plain"> = </span><span class="identifier">PW</span><span class="plain">;</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="identifier">some_new</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="identifier">NKW</span><span class="plain"> = </span><span class="identifier">PW</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">common_kind</span><span class="plain">) {</span>
                <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain"> = </span><span class="functiontext">Properties::Conditions::get_coinciding_property</span><span class="plain">(</span><span class="identifier">common_kind</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">NKW</span><span class="plain">)) {</span>
                    <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                    <span class="functiontext">Problems::quote_kind</span><span class="plain">(2, </span><span class="identifier">common_kind</span><span class="plain">);</span>
                    <span class="identifier">Problems::quote_wording</span><span class="plain">(3, </span><span class="identifier">CKW</span><span class="plain">);</span>
                    <span class="identifier">Problems::quote_wording</span><span class="plain">(4, </span><span class="identifier">NKW</span><span class="plain">);</span>
                    <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_MixedExistingConstants</span><span class="plain">));</span>
                    <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                        <span class="string">"In %1, one of the values you supply as a possibility is '%3', "</span>
                        <span class="string">"but this already has a meaning (as %2). This might be okay if "</span>
                        <span class="string">"every other possibility was also %2, but '%4' isn't."</span><span class="plain">);</span>
                    <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prn</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
                    <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                    <span class="functiontext">Problems::quote_kind</span><span class="plain">(2, </span><span class="identifier">common_kind</span><span class="plain">);</span>
                    <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">)); </span>    <span class="comment">because it won't parse</span>
                    <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                        <span class="string">"In %1, every value you supply as a possibility is %2. "</span>
                        <span class="string">"That would be okay if it were a property which is a condition "</span>
                        <span class="string">"of something, but it isn't."</span><span class="plain">);</span>
                    <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="plain">*</span><span class="identifier">already</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prn</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            &lt;<span class="cwebmacro">Devise a name to give to this currently nameless condition</span> <span class="cwebmacronumber">3.1</span>&gt;<span class="plain">;</span>
            <span class="identifier">anon</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>

        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::Abstract::to_create_something</span><span class="plain">(</span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::concatenate</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">,</span>
            <span class="functiontext">Calculus::Propositions::Abstract::to_make_a_kind</span><span class="plain">(</span><span class="identifier">K_value</span><span class="plain">));</span>
        <span class="functiontext">Calculus::Propositions::Assert::assert_true</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">prevailing_mood</span><span class="plain">);</span>

        <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain"> = </span><span class="functiontext">Properties::Valued::obtain</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;either_or</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;condition_of</span><span class="plain"> = </span><span class="identifier">infs</span><span class="plain">;</span>
        <span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;condition_anonymously_named</span><span class="plain"> = </span><span class="identifier">anon</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prn</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::Conditions::new is used in 9/pd (<a href="9-pd.html#SP5_9">&#167;5.9</a>).</p>

<p class="inwebparagraph"><a id="SP3_1"></a><b>&#167;3.1.  </b>The name is ideally the subject's name plus "condition": for instance,
"lounge table condition". But we need to be careful in case there are
multiple such conditions, because we don't want to duplicate the name. So
we begin by counting how many such already exist, and then append a number:
thus "lounge table condition", then "lounge table condition 2", and so on.
</p>

<p class="inwebparagraph">We could be more fanatical about this, if we wanted. The code here doesn't
guarantee uniqueness of the resulting name in all cases, because it's possible
for two subjects to have identical names. (But when that happens, it's unlikely
that different condition properties are given to them.) We won't obsess over
this because the point is only to help the user by minimising namespace
clashes; it isn't essential to Inform's running.
</p>

<p class="inwebparagraph">(And at present it seems very unlikely that conditions would ever be applied to
nameless subjects.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Devise a name to give to this currently nameless condition</span> <span class="cwebmacronumber">3.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">ct</span><span class="plain"> = 0;</span>
        <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">, </span><span class="reserved">property</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;condition_of</span><span class="plain"> == </span><span class="identifier">infs</span><span class="plain">) &amp;&amp; (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;condition_anonymously_named</span><span class="plain">))</span>
                <span class="identifier">ct</span><span class="plain">++;</span>
        <span class="identifier">feed_t</span><span class="plain"> </span><span class="identifier">id</span><span class="plain"> = </span><span class="identifier">Feeds::begin</span><span class="plain">();</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W2</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::get_name_text</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W2</span><span class="plain">)) </span><span class="identifier">Feeds::feed_wording</span><span class="plain">(</span><span class="identifier">W2</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">Feeds::feed_text</span><span class="plain">(</span><span class="identifier">L</span><span class="string">" nameless "</span><span class="plain">);</span>
        <span class="identifier">Feeds::feed_text</span><span class="plain">(</span><span class="identifier">L</span><span class="string">" condition "</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ct</span><span class="plain"> &gt; 0) {</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">numb</span><span class="plain">);</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">numb</span><span class="plain">, </span><span class="string">" %d "</span><span class="plain">, </span><span class="identifier">ct</span><span class="plain">+1);</span>
            <span class="identifier">Feeds::feed_stream</span><span class="plain">(</span><span class="identifier">numb</span><span class="plain">);</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">numb</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Feeds::end</span><span class="plain">(</span><span class="identifier">id</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP3">&#167;3</a>.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b></p>


<pre class="display">
    <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="functiontext">Properties::Conditions::of_what</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prn</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;either_or</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prn</span><span class="plain">-</span><span class="element">&gt;condition_of</span><span class="plain">; </span>    <span class="comment">which will be null if not a condition property</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::Conditions::of_what is used in 5/ins (<a href="5-ins.html#SP6_3">&#167;6.3</a>, <a href="5-ins.html#SP37">&#167;37</a>), 14/lv (<a href="14-lv.html#SP14_3_1">&#167;14.3.1</a>).</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Coincidence. </b>Coincidence of kinds and properties occurs where a kind has the same name
exactly as a property, allowing the same name to be used grammatically in
two different contexts. We say that the kind and the property "coincide".
In particular, this happens with conditions:
</p>

<blockquote>
    <p>Brightness is a kind of value. The brightnesses are guttering, weak, radiant and blazing. The lantern has a brightness. The lantern is blazing.</p>

</blockquote>

<p class="inwebparagraph">Here "brightness" becomes the name of a new kind, but "brightness" also
becomes the name of a property.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Properties::Conditions::name_can_coincide_with_property</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">K</span><span class="plain">-</span><span class="element">&gt;construct</span><span class="plain">-&gt;</span><span class="identifier">can_coincide_with_property</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">property</span><span class="plain"> *</span><span class="functiontext">Properties::Conditions::get_coinciding_property</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">K</span><span class="plain">-</span><span class="element">&gt;construct</span><span class="plain">-&gt;</span><span class="identifier">coinciding_property</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Properties::Conditions::set_coinciding_property</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">, </span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">K</span><span class="plain">-</span><span class="element">&gt;construct</span><span class="plain">-&gt;</span><span class="identifier">coinciding_property</span><span class="plain"> = </span><span class="identifier">P</span><span class="plain">;</span>
    <span class="plain">}</span>

</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Properties::Conditions::name_can_coincide_with_property is used in 12/ter (<a href="12-ter.html#SP5">&#167;5</a>, <a href="12-ter.html#SP8">&#167;8</a>), 15/vp (<a href="15-vp.html#SP6">&#167;6</a>), 15/cr (<a href="15-cr.html#SP7_1">&#167;7.1</a>).</p>

<p class="endnote">The function Properties::Conditions::get_coinciding_property is used in <a href="#SP3">&#167;3</a>, 5/ins (<a href="5-ins.html#SP6">&#167;6</a>, <a href="5-ins.html#SP10">&#167;10</a>, <a href="5-ins.html#SP36">&#167;36</a>, <a href="5-ins.html#SP37">&#167;37</a>), 9/ma (<a href="9-ma.html#SP3_3_41">&#167;3.3.41</a>, <a href="9-ma.html#SP3_3_41_5">&#167;3.3.41.5</a>), 11/tr (<a href="11-tr.html#SP9">&#167;9</a>), 11/pr (<a href="11-pr.html#SP27">&#167;27</a>, <a href="11-pr.html#SP35_1">&#167;35.1</a>), 12/ter (<a href="12-ter.html#SP5_1">&#167;5.1</a>, <a href="12-ter.html#SP8">&#167;8</a>, <a href="12-ter.html#SP8_1">&#167;8.1</a>), 14/ds2 (<a href="14-ds2.html#SP11_9_1_1_5_1_1">&#167;11.9.1.1.5.1.1</a>, <a href="14-ds2.html#SP11_9_1_1_5_1_2">&#167;11.9.1.1.5.1.2</a>), 15/cr (<a href="15-cr.html#SP5">&#167;5</a>, <a href="15-cr.html#SP7_1">&#167;7.1</a>).</p>

<p class="endnote">The function Properties::Conditions::set_coinciding_property is used in 5/ins (<a href="5-ins.html#SP9">&#167;9</a>).</p>

<hr class="tocbar">
<ul class="toc"><li><a href="15-vp.html">Back to 'Valued Properties'</a></li><li><a href="15-ia.html">Continue with 'Indefinite Appearance'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

