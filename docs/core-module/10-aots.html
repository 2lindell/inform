<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>9/pd</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '10/aots' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#10">Chapter 10: The S-Parser</a></li><li><b>Architecture of the S-Parser</b></li></ul><p class="purpose">Top-level structure of the S-parser, which turns text into S-nodes.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Introduction</a></li><li><a href="#SP3">&#167;3. Top-level nonterminals</a></li><li><a href="#SP11">&#167;11. The cache</a></li><li><a href="#SP15">&#167;15. Void phrases</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Introduction. </b>The purpose of the S-parser is to turn excerpts of text into specification
nodes. Nonterminals here almost all have names beginning with the "s-" prefix,
which indicates that their results are S-nodes.
</p>

<p class="inwebparagraph">The simplest nonterminal in the S-grammar is &lt;s-plain-text&gt;, which
accepts any non-empty piece of text. (The same can be said exactly of
&lt;nounphrase&gt;, and the difference is purely to do with how Inform stores
the results: &lt;nounphrase&gt; makes nodes in the main parse tree, a rather
permanent structure, whereas &lt;s-plain-text&gt; makes an S-node.)
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">plain</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::new_UNKNOWN</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>And here is a curious variation, which is needed because equations are
parsed with completely different spacing rules, and don't respect words. It
matches any non-empty text where one of the words contains an equals sign
as one of its characters: thus
</p>

<blockquote>
    <p>V = fl</p>

</blockquote>

<blockquote>
    <p>F=ma</p>

</blockquote>

<p class="inwebparagraph">both match this, the first example being three words long, the second only one.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">plain</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">-</span><span class="identifier">with</span><span class="plain">-</span><span class="identifier">equals</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">) {</span>
            <span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">Lexer::word_raw_text</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">);</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">j</span><span class="plain">=0; </span><span class="identifier">p</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">]; </span><span class="identifier">j</span><span class="plain">++)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">] == </span><span class="character">'='</span><span class="plain">) {</span>
                    <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::new_UNKNOWN</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Top-level nonterminals. </b>These five nonterminals are the most useful and powerful, so they're the
main junction between the S-parser and the rest of Inform.
</p>

<p class="inwebparagraph">These are coded as internals for efficiency's sake. We will often reparse the
same wording over and over, so we cache the results. But &lt;s-value&gt; matches
exactly the same text as &lt;s-value-uncached&gt;, and so on for the other four.
</p>

<p class="inwebparagraph">&lt;s-value&gt; looks for source text which can be evaluated &mdash; a constant, a
variable or other storage object, or a phrase to decide a value.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">ExParser::parse_with_cache</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, 0, &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt;);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="constant">UNKNOWN_NT</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>&lt;s-condition&gt; looks for a condition &mdash; anything legal after an
"if", in short. This includes sentence-like excerpts such as "six
animals have been in the Stables".
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">condition</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="functiontext">LocalVariables::make_necessary_callings</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">ExParser::parse_with_cache</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, 1, &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">condition</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt;);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="constant">UNKNOWN_NT</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>&lt;s-non-action-condition&gt; is the same, but disallowing action patterns
as conditions, so for example "taking something" would not match.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">non</span><span class="plain">-</span><span class="identifier">action</span><span class="plain">-</span><span class="identifier">condition</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="functiontext">LocalVariables::make_necessary_callings</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">old_state</span><span class="plain"> = </span><span class="identifier">PL::Actions::Patterns::suppress</span><span class="plain">();</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">ExParser::parse_with_cache</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, 2, &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">condition</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt;);</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="identifier">PL::Actions::Patterns::resume</span><span class="plain">(</span><span class="identifier">old_state</span><span class="plain">);</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="constant">UNKNOWN_NT</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>&lt;s-type-expression&gt; is for where we expect to find the "type" of something
&mdash; for instance, the kind of value to be stored in a variable, or the
specification of a phrase argument.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">ExParser::parse_with_cache</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, 3, &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt;);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="constant">UNKNOWN_NT</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>&lt;s-descriptive-type-expression&gt; is the same thing, with one difference: it
allows nounless descriptions, such as "open opaque fixed in place", and to
this end it treats bare adjective names as descriptions rather than values. If
we have said "Colour is a kind of value. The colours are red, green and taupe.
A thing has a colour.", then "green" is parsed by &lt;s-descriptive-type-expression&gt;
as a description meaning "any thing which is green", but by &lt;s-type-expression&gt;
and &lt;s-value&gt; as a constant value of the kind "colour".
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">descriptive</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">ExParser::parse_with_cache</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, 4, &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">descriptive</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt;);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="constant">UNKNOWN_NT</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>The following internal is just a shell for &lt;s-descriptive-type-expression&gt;,
but it temporarily changes the parsing mode to phrase token parsing, so that
kind variables will be read as formal prototypes.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">token</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">s</span><span class="plain"> = </span><span class="identifier">kind_parsing_mode</span><span class="plain">;</span>
        <span class="identifier">kind_parsing_mode</span><span class="plain"> = </span><span class="identifier">PHRASE_TOKEN_KIND_PARSING</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">t</span><span class="plain"> = &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">descriptive</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">kind_parsing_mode</span><span class="plain"> = </span><span class="identifier">s</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">t</span><span class="plain">) { *</span><span class="identifier">X</span><span class="plain"> = &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;; *</span><span class="identifier">XP</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;; }</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">t</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>That's it for the cached nonterminals, but we will also define a convenient
super-nonterminal which matches almost any meaningful reference to data, so
it's frequently used as a way of finding out whether a new name will clash
with some existing meaning.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">-</span><span class="identifier">or</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">&gt; |	==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">&gt;				==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>One further convenience is for text which describes an explicit action in
a noun-like way.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">explicit</span><span class="plain">-</span><span class="identifier">action</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">S</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">permit_trying_omission</span><span class="plain">;</span>
        <span class="identifier">permit_trying_omission</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">condition</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) </span><span class="identifier">S</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
        <span class="identifier">permit_trying_omission</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Rvalues::is_CONSTANT_of_kind</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">, </span><span class="identifier">K_stored_action</span><span class="plain">)) {</span>
                <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">S</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Conditions::is_TEST_ACTION</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">)) {</span>
                <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">;</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">constant</span><span class="plain">-</span><span class="identifier">action</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">S</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">permit_trying_omission</span><span class="plain">;</span>
        <span class="identifier">permit_trying_omission</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">p2</span><span class="plain"> = </span><span class="identifier">permit_nonconstant_action_parameters</span><span class="plain">;</span>
        <span class="identifier">permit_nonconstant_action_parameters</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">condition</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) </span><span class="identifier">S</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
        <span class="identifier">permit_trying_omission</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">;</span>
        <span class="identifier">permit_nonconstant_action_parameters</span><span class="plain"> = </span><span class="identifier">p2</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">S</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Rvalues::is_CONSTANT_of_kind</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">, </span><span class="identifier">K_stored_action</span><span class="plain">)) {</span>
                <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">S</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Conditions::is_TEST_ACTION</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">)) {</span>
                <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">S</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">;</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. The cache. </b>The above nonterminals are called pretty frequently on overlapping or
coinciding runs of text. Inform runs substantially faster if the results of
parsing the most recent expressions are cached; so, for instance, if Inform
parses the text in words 507 to 511 once, it need not do so again in the same
context.
</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b>The cache takes the form of a modest ring buffer for each of the contexts:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">MAXIMUM_CACHE_SIZE</span><span class="plain"> 20 </span>    <span class="comment">a Goldilocks value: too high slows us down, too low doesn't cache enough</span>
    <span class="definitionkeyword">define</span> <span class="constant">NUMBER_OF_CACHED_NONTERMINALS</span><span class="plain"> 5</span>
</pre>

<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">expression_cache</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">expression_cache_entry</span><span class="plain"> </span><span class="identifier">pe_cache</span><span class="plain">[</span><span class="constant">MAXIMUM_CACHE_SIZE</span><span class="plain">];</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">pe_cache_size</span><span class="plain">; </span>    <span class="comment">number of entries used, 0 to <code class="display"><span class="extract">MAXIMUM_CACHE_SIZE</span></code></span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">pe_cache_posn</span><span class="plain">; </span>    <span class="comment">next write position, 0 to <code class="display"><span class="extract">pe_cache_size</span></code> minus 1</span>
    <span class="plain">} </span><span class="reserved">expression_cache</span><span class="plain">;</span>

    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">expression_cache_entry</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">cached_query</span><span class="plain">; </span>    <span class="comment">the word range whose parsing this is</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">cached_result</span><span class="plain">; </span>    <span class="comment">and the result (quite possibly <code class="display"><span class="extract">UNKNOWN_NT</span></code>)</span>
    <span class="plain">} </span><span class="reserved">expression_cache_entry</span><span class="plain">;</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">expression_cache_has_been_used</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="reserved">expression_cache</span><span class="plain"> </span><span class="identifier">contextual_cache</span><span class="plain">[</span><span class="constant">NUMBER_OF_CACHED_NONTERMINALS</span><span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure expression_cache is private to this section.</p>

<p class="endnote">The structure expression_cache_entry is private to this section.</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b></p>


<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">ExParser::parse_with_cache</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">context</span><span class="plain">, </span><span class="identifier">nonterminal</span><span class="plain"> *</span><span class="identifier">nt</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Specifications::new_UNKNOWN</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">context</span><span class="plain"> &lt; 0) || (</span><span class="identifier">context</span><span class="plain"> &gt;= </span><span class="constant">NUMBER_OF_CACHED_NONTERMINALS</span><span class="plain">))</span>
            <span class="identifier">internal_error</span><span class="plain"> (</span><span class="string">"bad expression parsing context"</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">Check the expression cache to see if we already know the answer</span> <span class="cwebmacronumber">13.1</span>&gt;<span class="plain">;</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">unwanted</span><span class="plain"> = 0; </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">plm</span><span class="plain"> = </span><span class="identifier">preform_lookahead_mode</span><span class="plain">;</span>
        <span class="identifier">preform_lookahead_mode</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Preform::parse_nt_against_word_range</span><span class="plain">(</span><span class="identifier">nt</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">, &amp;</span><span class="identifier">unwanted</span><span class="plain">, (</span><span class="reserved">void</span><span class="plain"> **) &amp;</span><span class="identifier">spec</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">))) </span><span class="identifier">ParseTree::set_text</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Specifications::new_UNKNOWN</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">preform_lookahead_mode</span><span class="plain"> = </span><span class="identifier">plm</span><span class="plain">;</span>

        &lt;<span class="cwebmacro">Write the newly discovered specification to the cache for future use</span> <span class="cwebmacronumber">13.2</span>&gt;<span class="plain">;</span>
        <span class="identifier">ParseTree::verify_structure</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>

        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">spec</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ExParser::parse_with_cache is used in <a href="#SP3">&#167;3</a>, <a href="#SP4">&#167;4</a>, <a href="#SP5">&#167;5</a>, <a href="#SP6">&#167;6</a>, <a href="#SP7">&#167;7</a>.</p>

<p class="inwebparagraph"><a id="SP13_1"></a><b>&#167;13.1.  </b>The following seeks a previously cached answer:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Check the expression cache to see if we already know the answer</span> <span class="cwebmacronumber">13.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">expression_cache</span><span class="plain"> *</span><span class="identifier">ec</span><span class="plain"> = &amp;(</span><span class="identifier">contextual_cache</span><span class="plain">[</span><span class="identifier">context</span><span class="plain">]);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">expression_cache_has_been_used</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="functiontext">ExParser::warn_expression_cache</span><span class="plain">(); </span>    <span class="comment">this empties all the caches</span>
            <span class="identifier">expression_cache_has_been_used</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">ec</span><span class="plain">-</span><span class="element">&gt;pe_cache_size</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::eq</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">ec</span><span class="plain">-</span><span class="element">&gt;pe_cache</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]</span><span class="element">.cached_query</span><span class="plain">))</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">ec</span><span class="plain">-</span><span class="element">&gt;pe_cache</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]</span><span class="element">.cached_result</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP13">&#167;13</a>.</p>

<p class="inwebparagraph"><a id="SP13_2"></a><b>&#167;13.2.  </b>The cache expands until it reaches <code class="display"><span class="extract">MAXIMUM_CACHE_SIZE</span></code>; after that,
entries are written in a position cycling through the ring. In either case
it takes <code class="display"><span class="extract">MAXIMUM_CACHE_SIZE</span></code> further parses (not found in the cache) to
overwrite the one we put down now.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Write the newly discovered specification to the cache for future use</span> <span class="cwebmacronumber">13.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">expression_cache</span><span class="plain"> *</span><span class="identifier">ec</span><span class="plain"> = &amp;(</span><span class="identifier">contextual_cache</span><span class="plain">[</span><span class="identifier">context</span><span class="plain">]);</span>
        <span class="identifier">ec</span><span class="plain">-</span><span class="element">&gt;pe_cache</span><span class="plain">[</span><span class="identifier">ec</span><span class="plain">-</span><span class="element">&gt;pe_cache_posn</span><span class="plain">]</span><span class="element">.cached_query</span><span class="plain"> = </span><span class="identifier">W</span><span class="plain">;</span>
        <span class="identifier">ec</span><span class="plain">-</span><span class="element">&gt;pe_cache</span><span class="plain">[</span><span class="identifier">ec</span><span class="plain">-</span><span class="element">&gt;pe_cache_posn</span><span class="plain">]</span><span class="element">.cached_result</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">;</span>
        <span class="identifier">ec</span><span class="plain">-</span><span class="element">&gt;pe_cache_posn</span><span class="plain">++;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ec</span><span class="plain">-</span><span class="element">&gt;pe_cache_size</span><span class="plain"> &lt; </span><span class="constant">MAXIMUM_CACHE_SIZE</span><span class="plain">) </span><span class="identifier">ec</span><span class="plain">-</span><span class="element">&gt;pe_cache_size</span><span class="plain">++;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ec</span><span class="plain">-</span><span class="element">&gt;pe_cache_posn</span><span class="plain"> == </span><span class="constant">MAXIMUM_CACHE_SIZE</span><span class="plain">) </span><span class="identifier">ec</span><span class="plain">-</span><span class="element">&gt;pe_cache_posn</span><span class="plain"> = 0;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP13">&#167;13</a>.</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14.  </b>As with all caches, we have to be careful that the information does not fall
out of date. There are two things which can go wrong: the S-node in the cache
might be altered, perhaps as a result of the type-checker trying to force a
round peg into a square hole; or the stock of Inform's defined names might
change, so that the same text now has to be read differently.
</p>

<p class="inwebparagraph">The first problem can't be fixed here. It's tempting to try something like
flagging S-nodes which have been altered, and then ensuring that the
cache never serves up an altered result. But that fails for timing reasons &mdash;
by the time the S-node might be altered, pointers to it may exist
in multiple data structures already, because the cache might have served
it more than once by that time. (Not just a theoretical possibility &mdash; tests
show that this does, albeit rarely, happen.) The brute force solution is to
serve a copy of the cache entry, and thus never send out the same pointer
twice. But this more than doubles the memory required to store S-nodes,
which is unacceptable, and also slows Inform down, because allocating memory
for all those copies is laborious. We therefore just have to be very careful
about modifying S-nodes which have arisen from parsing.
</p>

<p class="inwebparagraph">The second problem is easier. We require other parts of Inform which make
or unmake name definitions to warn us, by calling this routine. Definitions
are made and unmade relatively rarely, so the performance hit is small.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ExParser::warn_expression_cache</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="constant">NUMBER_OF_CACHED_NONTERMINALS</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) {</span>
            <span class="identifier">contextual_cache</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]</span><span class="element">.pe_cache_size</span><span class="plain"> = 0;</span>
            <span class="identifier">contextual_cache</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]</span><span class="element">.pe_cache_posn</span><span class="plain"> = 0;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ExParser::warn_expression_cache is used in <a href="#SP13_1">&#167;13.1</a>, 24/lv (<a href="24-lv.html#SP7">&#167;7</a>, <a href="24-lv.html#SP41">&#167;41</a>), 25/pi (<a href="25-pi.html#SP5">&#167;5</a>), 25/cp (<a href="25-cp.html#SP3_2">&#167;3.2</a>).</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15. Void phrases. </b>The S-parser is also used by the main code compiler to turn phrases into
S-nodes, using &lt;s-command&gt; and &lt;s-say-command&gt;. These however need a
wrapper: instead of turning text into an S-node, we take text from an
existing node (in the structural parse tree for a routine), turn that
into a new S-node with an invocation list below it, then glue the list
back into the original tree but throw away the S-node head.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ExParser::parse_void_phrase</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">) {</span>
        <span class="functiontext">ExParser::parse_phrase_inner</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
    <span class="plain">}</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ExParser::parse_say_term</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">) {</span>
        <span class="functiontext">ExParser::parse_phrase_inner</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
    <span class="plain">}</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">ExParser::parse_phrase_inner</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">as_say_term</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"no node to parse"</span><span class="plain">);</span>
        <span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">))) {</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">results</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">as_say_term</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">command</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">)))) </span><span class="identifier">results</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">as_say_term</span><span class="plain">) &amp;&amp; (&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">say</span><span class="plain">-</span><span class="identifier">command</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">)))) </span><span class="identifier">results</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">results</span><span class="plain">) &amp;&amp; (</span><span class="identifier">results</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">)) </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> = </span><span class="identifier">results</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ExParser::parse_void_phrase is used in 25/cp (<a href="25-cp.html#SP6">&#167;6</a>).</p>

<p class="endnote">The function ExParser::parse_say_term is used in 25/cp (<a href="25-cp.html#SP5_2_1">&#167;5.2.1</a>).</p>

<p class="endnote">The function ExParser::parse_phrase_inner appears nowhere else.</p>

<hr class="tocbar">
<ul class="toc"><li><i>(This section begins Chapter 10: The S-Parser.)</i></li><li><a href="10-pl.html">Continue with 'Parse Literals'</a></li></ul><hr class="tocbar">
<!--End of weave: 323 lines from a web of 93250-->
	</body>
</html>

