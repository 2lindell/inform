<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>3/pd</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '4/its' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#4">Chapter 4: Bridge to Linguistics Module</a></li><li><b>Introduction to Semantics</b></li></ul><p class="purpose">A general introduction to the S-parser and the data structures it makes use of.</p>

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1.  </b>At this point, the text read in by Inform is now a stream of words, each of
which is identified by a pointer to a <code class="display"><span class="extract">vocabulary_entry</span></code> structure in its
dictionary. The words are numbered upwards from 0, and we refer to any
contiguous run of words as an "excerpt", often writing <code class="display"><span class="extract">(w1, w2)</span></code> to mean
the text starting with word <code class="display"><span class="extract">w1</span></code> and continuing to word <code class="display"><span class="extract">w2</span></code>. The stream
of words has been divided further into sentences.
</p>

<p class="inwebparagraph">Inform has two mechanisms for making sense of this text, the A-parser and
the S-parser.
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(A) A stands for "assertion". For instance, "Two men are in Verona." is
an assertion, telling Inform that at the start of play there are to be two
previously unknown men and that they begin in the room called Verona. The
A-parser handles entire sentences.
</li></ul>
<ul class="items"><li>(S) S stands for "semantics", the study of how already-understood
meanings correspond to excerpts of text within a sentence. The S-parser
handles anything from tiny excerpts like "6" through noun phrases such as
"Verona" to complicated expressions like "the number of men in Verona".
</li></ul>
<p class="inwebparagraph">There are many similarities between the A-parser and the S-parser, partly
because A makes use of S, but also because they contain parallel mechanisms
which handle verbs and prepositions similarly. But there are also many
differences. The A-parser will accept "On the dressing table is an amber
comb." even if table and comb have never been mentioned before, whereas
the S-parser can only recognise meanings already defined. On the other
hand, the S-parser will accept conditions like the one in "if there are
fewer than 8 men in Verona, ..." whereas the A-parser would reject
the assertion "There are fewer than 8 men in Verona." as being too vague
to act upon. Similarly, the A-parser works only in the present tense,
whereas the S-parser can handle the past and perfect tenses. (Neither
can handle any future tenses, since a computer cannot either control or
definitely predict the future.)
</p>

<p class="inwebparagraph">The A-parser works by applying the S-parser to text at <code class="display"><span class="extract">parse_node</span></code> structures
in the parse tree. So we will build the S-parser first, which won't involve
the parse tree at all. We will then go back to the parse tree to write the
A-parser.
</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>The S-parser is similar to the expression parser in a regular compiler. It
is in some ways simpler because natural language tends not to form complex
formulae, but in other ways more complicated, because performance issues
are very significant when comparing excerpts of text, and because there are
many more ambiguities to resolve.
</p>

<p class="inwebparagraph">Our aim is to turn any excerpt into a <code class="display"><span class="extract">specification</span></code> structure inside
Inform. This is a universal holder for both values and descriptions of
values, where "value" is interpreted very broadly. It is usually too
difficult to go directly from text to a <code class="display"><span class="extract">specification</span></code>, so we use
a two-stage process:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(1) parse the text to a <code class="display"><span class="extract">parse_node</span></code> which holds all possible interpretations
of it, and then
</li><li>(2) convert the most likely-looking interpretation(s) to a <code class="display"><span class="extract">specification</span></code>.
</li></ul>
<p class="inwebparagraph">Thus <code class="display"><span class="extract">parse_node</span></code> structures are private to the S-parser, whereas
<code class="display"><span class="extract">specification</span></code> structures appear all over Inform.
</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>Consider the following contrived example.
</p>

<blockquote>
    <p>if Mr Fitzwilliam Darcy was carrying at least three things which are in the box, increase the score by 7;</p>

</blockquote>

<ul class="items"><li>(1) There are <code class="display"><span class="extract">excerpt_meaning</span></code> structures for "Mr Fitzwilliam Darcy" and
"Mr Bingham's box", which hold the wording needed to refer to these objects.
In parsing the example sentence, we connect these structures to the excerpts
"Mr Fitzwilliam Darcy" &mdash; an exact match &mdash; and "the box" &mdash; an
abbreviated one. The <code class="display"><span class="extract">excerpt_meaning</span></code> structures contain pointers to
further <code class="display"><span class="extract">instance</span></code> structures which represent the identities of these
two tangible things, that is, Darcy and his friend's box.
</li><li>(2) Another <code class="display"><span class="extract">excerpt_meaning</span></code> holds the name "score" and points it to a
<code class="display"><span class="extract">nonlocal_variable</span></code> structure for the relevant global variable.
</li><li>(3) And a further <code class="display"><span class="extract">excerpt_meaning</span></code> holds the name "things" and points it
to a <code class="display"><span class="extract">instance</span></code> structure representing the common identity shared by
all things. Inform treats individual, tangible objects such as Mr Darcy
and intangible categories of objects such as thing by representing both
with the same structure &mdash; <code class="display"><span class="extract">instance</span></code>. This mirrors the way that common
and proper nouns are grammatically quite similar in natural language.
</li><li>(4) The final noun phrase in the above example is "7". There's no
<code class="display"><span class="extract">excerpt_meaning</span></code> structure for this &mdash; it would be insanely inefficient
to make such things &mdash; and instead it is parsed directly as a "literal",
being converted immediately into a <code class="display"><span class="extract">specification</span></code>, of which more below.
</li><li>(5) Another <code class="display"><span class="extract">excerpt_meaning</span></code> structure holds the wording "if ... , ..."
and is connected to a <code class="display"><span class="extract">phrase</span></code> structure for the "if" construction. Here,
the wording includes flexible-sized gaps (written "...") where excerpts
should appear: the S-parser will only recognise this if the excerpts make
sense in themselves. The combination of a <code class="display"><span class="extract">phrase</span></code> plus the results of parsing
these gaps is stored in a structure called an <code class="display"><span class="extract">invocation</span></code>.
</li><li>(6) In the example, the first gap is filled by "Mr Fitzwilliam Darcy was
carrying at least three things which are in the box", which the S-parser
detects as being a condition. This is translated into a <code class="display"><span class="extract">pcalc_prop</span></code>
structure &mdash; a predicate-calculus proposition, that is, which is a
representation in mathematical logic of the meaning of this sentence.
<ul class="items"><li>(a) "was carrying" is recognised as matching wording in a <code class="display"><span class="extract">verb_usage</span></code>
structure. This points to an underlying relation, stored in a <code class="display"><span class="extract">binary_predicate</span></code>
structure, but combines it with an indication of tense stored in a <code class="display"><span class="extract">time_period</span></code>.
Here the <code class="display"><span class="extract">binary_predicate</span></code> is the carrying relation and the <code class="display"><span class="extract">time_period</span></code>
is the past tense. (The term "binary predicate" comes from logic once
again; an Inform author would call the same concept a "relation".)
</li><li>(b) "are in" is recognised as a usage of the verb "to be" plus "in",
which matches the wording of a <code class="display"><span class="extract">preposition_identity</span></code> structure. Here the tense
derives only from the "to be" part: which is "are", so the <code class="display"><span class="extract">time_period</span></code>
parsed is the present tense. This makes the <code class="display"><span class="extract">preposition_identity</span></code> a simpler
business than the <code class="display"><span class="extract">verb_usage</span></code> structure &mdash; it only needs to refer to the
underlying meaning, which is once again a <code class="display"><span class="extract">binary_predicate</span></code> structure,
the one for the containment relation.
</li><li>(c) "which" is a word introducing a relative clause. A sentence can
only have one primary verb, which in this example is "was carrying".
But other verbs can exist in relative clauses, and the effect of writing
"X which V Y" qualifies X by saying that any noun N matching X must also
satisfy "N V Y", where V is the verb. The relative-clause construction
is an example of syntax built directly into the S-parser. It doesn't come
from any data structures, like the meanings of "score" or "Mr Fitzwilliam
Darcy".
</li><li>(d) "at least three things" is an example of a noun phrase which has a
head and a tail. The head, "at least three", is recognised as matching
the wording in a <code class="display"><span class="extract">determiner</span></code> structure, "at least (number)", together
with the literal number 3. Once again, the <code class="display"><span class="extract">determiner</span></code> describes textual
appearances; it points to another structure, a <code class="display"><span class="extract">quantifier</span></code>, to hold the
meaning. This is another logical term, and Inform's debugging log would
write the resulting term as <code class="display"><span class="extract">Card&gt;=3</span></code> ("cardinality of at least 3").
Inform only uses <code class="display"><span class="extract">determiner</span></code> structures when they quantify, that is, when
they talk about a possible range of objects rather than a single item.
A grammar of English would probably say that the "the" in "the box" is
also grammatically a determiner, but it doesn't get a <code class="display"><span class="extract">determiner</span></code> structure
in Inform.
</li></ul>
<li>(7) The second gap in the "if ... , ..." excerpt is "increase the score
by 1", which the S-parser detects as a use of yet another <code class="display"><span class="extract">phrase</span></code>, this
time referred to by the <code class="display"><span class="extract">excerpt_meaning</span></code> structure for "increase ... by
...". It's worth noting that the S-parser doesn't check types, so it would
have been happy to match "increase 2 by 1" &mdash; an impossibility. The
S-parser's job is to find all possible meanings at a textual level,
sometimes producing a list of options: the type-checker will winnow these
out later on.
</li></ul>
<p class="inwebparagraph">So parsing the text "if Mr Fitzwilliam Darcy was carrying at least three
things which are in the box, increase the score by 7" is going to result in
a mass of pointers to different structures, and we need an umbrella structure
to hold this mass together. This is what the <code class="display"><span class="extract">parse_node</span></code> is for, but as
explained above, it's really only an intermediate state used while the S-parser
is working.
</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>One obvious category of word is missing: there are no adjectives in this
example. Inform currently supports many sorts of adjective &mdash; either/or
properties, such as "open"; values of kinds of value which coincide with
properties, such as "green" as a value of a "colour"; and adjectives
defined with conditions or full phrases, such as "invisible" resulting
from "Definition: a thing is invisible if...".
</p>

<p class="inwebparagraph">The S-parser treats all adjectives alike &mdash; more or less just as names.
This is because "open" may mean one thing for containers and another
for scenes, for example. The identification of an adjective's name with
its set of possible meanings is via a structure called <code class="display"><span class="extract">adjectival_phrase</span></code>.
</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>To sum up. If we write "text" --&gt; structure used for parsing
--&gt; structure used to hold meaning, our example is parsed like so:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(1) "Mr Fitzwilliam Darcy" --&gt; <code class="display"><span class="extract">excerpt_meaning</span></code> --&gt; <code class="display"><span class="extract">instance</span></code>
</li></ul>
<ul class="items"><li>(2) "the score" --&gt; <code class="display"><span class="extract">excerpt_meaning</span></code> --&gt; <code class="display"><span class="extract">nonlocal_variable</span></code>
</li></ul>
<ul class="items"><li>(3) "things" --&gt; <code class="display"><span class="extract">excerpt_meaning</span></code> --&gt; <code class="display"><span class="extract">instance</span></code>
</li></ul>
<ul class="items"><li>(4) "7" --&gt; ...none... --&gt; <code class="display"><span class="extract">specification</span></code>
</li></ul>
<ul class="items"><li>(5) "if Mr Fitzwilliam Darcy was carrying at least three things which are in the
box, increase the score by 7" --&gt; <code class="display"><span class="extract">excerpt_meaning</span></code> --&gt;
<code class="display"><span class="extract">invocation</span></code> (incorporating a <code class="display"><span class="extract">phrase</span></code>)
</li></ul>
<ul class="items"><li>(6) "Mr Fitzwilliam Darcy was carrying at least three things which are in the box"
--&gt; ...many... --&gt; <code class="display"><span class="extract">pcalc_prop</span></code>
<ul class="items"><li>(a) "was carrying" --&gt; <code class="display"><span class="extract">verb_usage</span></code> --&gt; <code class="display"><span class="extract">binary_predicate</span></code>
plus <code class="display"><span class="extract">time_period</span></code>
</li><li>(b) "are in" --&gt; <code class="display"><span class="extract">preposition_identity</span></code> --&gt; <code class="display"><span class="extract">binary_predicate</span></code>
plus <code class="display"><span class="extract">time_period</span></code>
</li><li>(c) "at least three" --&gt; <code class="display"><span class="extract">determiner</span></code> --&gt; <code class="display"><span class="extract">quantifier</span></code> plus
literal number
</li></ul>
</li></ul>
<p class="inwebparagraph"></p>

<ul class="items"><li>(7) "increase the score by 7" --&gt; <code class="display"><span class="extract">excerpt_meaning</span></code> --&gt;
<code class="display"><span class="extract">invocation</span></code> (incorporating a <code class="display"><span class="extract">phrase</span></code>)
</li></ul>
<ul class="items"><li>(8) Adjectives like the "closed" in "three closed doors" are identified
by name only, with little attempt to detect which sense is meant, so they
pass straight through the S-parser as pointers to <code class="display"><span class="extract">adjectival_phrase</span></code>
structures.
</li></ul>
<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>To sum up further still, <code class="display"><span class="extract">excerpt_meaning</span></code> structures are used to parse
simple nouns and imperative phrases, whereas other specialist structures
(<code class="display"><span class="extract">preposition_identity</span></code>, <code class="display"><span class="extract">determiner</span></code>, etc.) are used to parse the hinges
which hold sentences together. Once parsed, individual excerpts tend to
have meanings which might be pointers to a bewildering range of structures
(<code class="display"><span class="extract">instance</span></code>, <code class="display"><span class="extract">quantifier</span></code>, <code class="display"><span class="extract">binary_predicate</span></code>, <code class="display"><span class="extract">adjectival_phrase</span></code>,
etc.) but these pointers are held together inside the S-parser by a single
unifying construction: the <code class="display"><span class="extract">parse_node</span></code>. And we will eventually turn the
whole thing into a <code class="display"><span class="extract">specification</span></code> for the rest of Inform to use.
</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">PREFORM_LANGUAGE_TYPE</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">natural_language</span>
    <span class="definitionkeyword">define</span> <span class="constant">PREFORM_ADAPTIVE_PERSON</span><span class="plain"> </span><span class="functiontext">NaturalLanguages::adaptive_person</span>
    <span class="definitionkeyword">define</span> <span class="constant">PREFORM_LANGUAGE_FROM_NAME</span><span class="plain"> </span><span class="functiontext">NaturalLanguages::get_nl</span>
    <span class="definitionkeyword">define</span> <span class="constant">PREFORM_OPTIMISER</span><span class="plain"> </span><span class="functiontext">Semantics::mark_preform_requirements</span>
    <span class="definitionkeyword">define</span> <span class="constant">PREFORM_CIRCULARITY_BREAKER</span><span class="plain"> </span><span class="functiontext">Semantics::break_preform_circularities</span>
    <span class="definitionkeyword">define</span> <span class="constant">PREFORM_ERROR_HANDLER</span><span class="plain"> </span><span class="functiontext">NaturalLanguages::preform_error</span>
</pre>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Semantics::read_preform</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        &lt;<span class="cwebmacro">Mark certain nonterminals to have their vocabularies numbered and flagged</span> <span class="cwebmacronumber">7.1</span>&gt;<span class="plain">;</span>
        <span class="functiontext">NaturalLanguages::scan</span><span class="plain">();</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="functiontext">NaturalLanguages::load_preform</span><span class="plain">(</span><span class="functiontext">NaturalLanguages::English</span><span class="plain">());</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">nonterminals_declared</span><span class="plain"> = </span><span class="identifier">Preform::parse_preform</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="identifier">language_definition_top</span><span class="plain"> = </span><span class="identifier">lexer_wordcount</span><span class="plain"> - 1;</span>

        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"%d declarations read (%d words)\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">nonterminals_declared</span><span class="plain">, </span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Semantics::read_preform is used in 1/mr (<a href="1-mr.html#SP4_7">&#167;4.7</a>).</p>

<p class="inwebparagraph"><a id="SP7_1"></a><b>&#167;7.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Mark certain nonterminals to have their vocabularies numbered and flagged</span> <span class="cwebmacronumber">7.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Preform::assign_bitmap_bit</span><span class="plain">(&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">adjective</span><span class="plain">&gt;, 3);</span>
        <span class="identifier">Preform::assign_bitmap_bit</span><span class="plain">(&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">instance</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt;, 5);</span>
        <span class="identifier">Preform::assign_bitmap_bit</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">&gt;, 5);</span>
        <span class="identifier">Preform::assign_bitmap_bit</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">&gt;, 5);</span>
        <span class="identifier">Preform::assign_bitmap_bit</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">base</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">&gt;, 5);</span>
        <span class="identifier">Preform::assign_bitmap_bit</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">construction</span><span class="plain">&gt;, 5);</span>
        <span class="identifier">Preform::assign_bitmap_bit</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">-</span><span class="identifier">texts</span><span class="plain">&gt;, 5);</span>
        <span class="identifier">Preform::assign_bitmap_bit</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt;, 5);</span>
        <span class="identifier">Preform::assign_bitmap_bit</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">formal</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt;, 5);</span>
        <span class="identifier">Preform::assign_bitmap_bit</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">irregular</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">construction</span><span class="plain">&gt;, 5);</span>
        <span class="identifier">Preform::assign_bitmap_bit</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">-</span><span class="reserved">definition</span><span class="plain">&gt;, 5);</span>
        <span class="identifier">Preform::assign_bitmap_bit</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">single</span><span class="plain">-</span><span class="identifier">material</span><span class="plain">&gt;, 5);</span>
        <span class="identifier">Preform::assign_bitmap_bit</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">optional</span><span class="plain">-</span><span class="identifier">material</span><span class="plain">&gt;, 5);</span>
        <span class="identifier">Preform::assign_bitmap_bit</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">tupled</span><span class="plain">-</span><span class="identifier">material</span><span class="plain">&gt;, 5);</span>
        <span class="identifier">Preform::assign_bitmap_bit</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">tuple</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt;, 5);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7">&#167;7</a>.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Semantics::mark_preform_requirements</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">Preform::mark_nt_as_requiring_itself_conj</span><span class="plain">(&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">adjective</span><span class="plain">&gt;);</span>
        <span class="functiontext">Semantics::mark_nt_as_requiring_itself_articled</span><span class="plain">(&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">instance</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt;);</span>
        <span class="functiontext">Semantics::mark_nt_as_requiring_itself_articled</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt;);</span>
        <span class="functiontext">Semantics::mark_nt_as_requiring_itself_articled</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">formal</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt;);</span>
        <span class="functiontext">Semantics::mark_nt_as_requiring_itself_articled</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">base</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">&gt;);</span>
        <span class="functiontext">Semantics::mark_nt_as_requiring_itself_articled</span><span class="plain">(&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">construction</span><span class="plain">&gt;);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Semantics::break_preform_circularities</span><span class="plain">(</span><span class="identifier">nonterminal</span><span class="plain"> *</span><span class="identifier">nt</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">nt</span><span class="plain"> == &lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">&gt;) </span><span class="functiontext">Semantics::mark_nt_as_requiring_itself_articled</span><span class="plain">(</span><span class="identifier">nt</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">nt</span><span class="plain"> == &lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">&gt;) </span><span class="functiontext">Semantics::mark_nt_as_requiring_itself_articled</span><span class="plain">(</span><span class="identifier">nt</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Semantics::mark_nt_as_requiring_itself_articled</span><span class="plain">(</span><span class="identifier">nonterminal</span><span class="plain"> *</span><span class="identifier">nt</span><span class="plain">) {</span>
        <span class="identifier">Preform::mark_nt_as_requiring_itself_augmented</span><span class="plain">(</span><span class="identifier">nt</span><span class="plain">, </span><span class="identifier">Preform::nt_bitmap_bit</span><span class="plain">(&lt;</span><span class="identifier">article</span><span class="plain">&gt;));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Semantics::mark_preform_requirements appears nowhere else.</p>

<p class="endnote">The function Semantics::break_preform_circularities appears nowhere else.</p>

<p class="endnote">The function Semantics::mark_nt_as_requiring_itself_articled appears nowhere else.</p>

<hr class="tocbar">
<ul class="toc"><li><i>(This section begins Chapter 4: Bridge to Linguistics Module.)</i></li><li><a href="4-am.html">Continue with 'Adjective Meanings'</a></li></ul><hr class="tocbar">
<!--End of weave: 259 lines from a web of 94125-->
	</body>
</html>

