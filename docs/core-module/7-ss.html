<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>7/ptu</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '7/ss' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#7">Chapter 7: Sentences</a></li><li><b>Structural Sentences</b></li></ul><p class="purpose">To parse structurally important sentences.</p>

<ul class="toc"><li><a href="#SP7">&#167;7. Sentence division</a></li><li><a href="#SP8">&#167;8. Sentence breaking</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">list_node_type</span><span class="plain"> </span><span class="constant">ROUTINE_NT</span>
    <span class="definitionkeyword">define</span> <span class="constant">list_entry_node_type</span><span class="plain"> </span><span class="constant">INVOCATION_LIST_NT</span>
</pre>
<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">SENTENCE_ANNOTATION_FUNCTION</span><span class="plain"> </span><span class="functiontext">StructuralSentences::annotate_new_sentence</span>
</pre>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">StructuralSentences::annotate_new_sentence</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">new</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">text_loaded_from_source</span><span class="plain">) {</span>
            <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">new</span><span class="plain">, </span><span class="identifier">sentence_unparsed_ANNOT</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="functiontext">Sentences::VPs::seek</span><span class="plain">(</span><span class="identifier">new</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function StructuralSentences::annotate_new_sentence appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">NEW_HEADING_HANDLER</span><span class="plain"> </span><span class="functiontext">StructuralSentences::new_heading</span>
</pre>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">StructuralSentences::new_heading</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">new</span><span class="plain">) {</span>
        <span class="reserved">heading</span><span class="plain"> *</span><span class="identifier">h</span><span class="plain"> = </span><span class="functiontext">Sentences::Headings::declare</span><span class="plain">(</span><span class="identifier">new</span><span class="plain">);</span>
        <span class="identifier">ParseTree::set_embodying_heading</span><span class="plain">(</span><span class="identifier">new</span><span class="plain">, </span><span class="identifier">h</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Sentences::Headings::include_material</span><span class="plain">(</span><span class="identifier">h</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function StructuralSentences::new_heading appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">NEW_BEGINEND_HANDLER</span><span class="plain"> </span><span class="functiontext">StructuralSentences::new_beginend</span>
</pre>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">StructuralSentences::new_beginend</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">new</span><span class="plain">, </span><span class="reserved">extension_file</span><span class="plain"> *</span><span class="identifier">ef</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">new</span><span class="plain">) == </span><span class="identifier">BEGINHERE_NT</span><span class="plain">)</span>
            <span class="functiontext">Extensions::Inclusion::check_begins_here</span><span class="plain">(</span><span class="identifier">new</span><span class="plain">, </span><span class="identifier">sfsm_extension</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">new</span><span class="plain">) == </span><span class="identifier">ENDHERE_NT</span><span class="plain">)</span>
            <span class="functiontext">Extensions::Inclusion::check_ends_here</span><span class="plain">(</span><span class="identifier">new</span><span class="plain">, </span><span class="identifier">sfsm_extension</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function StructuralSentences::new_beginend appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">NEW_LANGUAGE_HANDLER</span><span class="plain"> </span><span class="functiontext">StructuralSentences::new_language</span>
</pre>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">StructuralSentences::new_language</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UseElementWithdrawn</span><span class="plain">),</span>
            <span class="string">"the ability to activate or deactivate compiler elements in source text has been withdrawn"</span><span class="plain">,</span>
            <span class="string">"in favour of a new system with Inform kits."</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function StructuralSentences::new_language appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">EXTENSION_FILE_TYPE</span><span class="plain"> </span><span class="reserved">extension_file</span>
</pre>
<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Sentence division. </b>Sentence division can happen either early in Inform's run, when the vast bulk
of the source text is read, or at intermittent periods later when fresh text
is generated internally. New sentences need to be treated slightly differently
in these cases, so this seems as good a point as any to define the routine
which the <code class="display"><span class="extract">.i6t</span></code> interpreter calls when it wants to signal that the source
text has now officially been read.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">StructuralSentences::declare_source_loaded</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">text_loaded_from_source</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function StructuralSentences::declare_source_loaded is used in 1/mr (<a href="1-mr.html#SP4_10">&#167;4.10</a>).</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Sentence breaking. </b>The <code class="display"><span class="extract">Sentences::break</span></code> routine is used for long stretches of text,
normally entire files. The following provides a way for the <code class="display"><span class="extract">.i6t</span></code>
interpreter to apply it to the whole text as lexed, which provides the
original basis for parsing. (This won't be the entire source text,
though: extensions, including the Standard Rules, have yet to be read.)
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">StructuralSentences::break_source</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">l</span><span class="plain"> = </span><span class="identifier">ParseTree::push_attachment_point</span><span class="plain">(</span><span class="identifier">tree_root</span><span class="plain">);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">n</span><span class="plain"> = 0;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">language_definition_top</span><span class="plain"> &gt;= </span><span class="identifier">n</span><span class="plain">) </span><span class="identifier">n</span><span class="plain"> = </span><span class="identifier">language_definition_top</span><span class="plain">+1;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">doc_references_top</span><span class="plain"> &gt;= </span><span class="identifier">n</span><span class="plain">) </span><span class="identifier">n</span><span class="plain"> = </span><span class="identifier">doc_references_top</span><span class="plain">+1;</span>
        <span class="identifier">Sentences::break</span><span class="plain">(</span><span class="identifier">Wordings::new</span><span class="plain">(</span><span class="identifier">n</span><span class="plain">, </span><span class="identifier">lexer_wordcount</span><span class="plain">-1), </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="identifier">ParseTree::pop_attachment_point</span><span class="plain">(</span><span class="identifier">l</span><span class="plain">);</span>
        <span class="functiontext">NaturalLanguages::include_required</span><span class="plain">();</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">implicit_heading</span><span class="plain"> = </span><span class="identifier">ParseTree::new</span><span class="plain">(</span><span class="identifier">HEADING_NT</span><span class="plain">);</span>
        <span class="identifier">ParseTree::set_text</span><span class="plain">(</span><span class="identifier">implicit_heading</span><span class="plain">, </span><span class="identifier">Feeds::feed_text_expanding_strings</span><span class="plain">(</span><span class="identifier">L</span><span class="string">"Invented sentences"</span><span class="plain">));</span>
        <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">implicit_heading</span><span class="plain">, </span><span class="identifier">sentence_unparsed_ANNOT</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">implicit_heading</span><span class="plain">, </span><span class="identifier">heading_level_ANNOT</span><span class="plain">, 0);</span>
        <span class="identifier">ParseTree::insert_sentence</span><span class="plain">(</span><span class="identifier">implicit_heading</span><span class="plain">);</span>
        <span class="functiontext">Sentences::Headings::declare</span><span class="plain">(</span><span class="identifier">implicit_heading</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function StructuralSentences::break_source is used in 1/mr (<a href="1-mr.html#SP4_10">&#167;4.10</a>).</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>Sentences in the source text are of five categories: dividing sentences,
which divide up the source into segments; structural sentences, which split
the source into different forms (standard text, tables, equations, I6 matter,
and so on); nonstructural sentences, which make grammatical definitions and
give Inform other more or less direct instructions; rule declarations; and
regular sentences, those which use the standard verbs. Examples:
</p>

<blockquote>
    <p>Volume II [dividing]</p>

</blockquote>

<blockquote>
    <p>Include Locksmith by Emily Short [structural]</p>

</blockquote>

<blockquote>
    <p>Release along with a website [nonstructural]</p>

</blockquote>

<blockquote>
    <p>Instead of looking [rule]</p>

</blockquote>

<blockquote>
    <p>The cushion is on the wooden chair [regular]</p>

</blockquote>

<p class="inwebparagraph">Dividing sentences are always read, whereas the others may be skipped in
sections of source not being included for one reason or another. Dividing
sentences must match the following. Note that the extension end markers are
only read in extensions, so they can never accidentally match in the main
source text.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">dividing</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">start</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">-</span><span class="identifier">paragraph</span><span class="plain">&gt; &lt;</span><span class="reserved">heading</span><span class="plain">&gt; |	==&gt; </span><span class="identifier">R</span><span class="plain">[2]</span>
        <span class="plain">&lt;</span><span class="identifier">extension</span><span class="plain">-</span><span class="identifier">end</span><span class="plain">-</span><span class="identifier">marker</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">&gt;		==&gt; </span><span class="identifier">R</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="reserved">heading</span><span class="plain">&gt; ::=</span>
        <span class="identifier">volume</span><span class="plain"> ... |						==&gt; 1</span>
        <span class="identifier">book</span><span class="plain"> ... |							==&gt; 2</span>
        <span class="identifier">part</span><span class="plain"> ... |							==&gt; 3</span>
        <span class="identifier">chapter</span><span class="plain"> ... |						==&gt; 4</span>
        <span class="identifier">section</span><span class="plain"> ...							==&gt; 5</span>

    <span class="plain">&lt;</span><span class="identifier">extension</span><span class="plain">-</span><span class="identifier">end</span><span class="plain">-</span><span class="identifier">marker</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">&gt; ::=</span>
        <span class="plain">... </span><span class="identifier">begin</span><span class="plain">/</span><span class="identifier">begins</span><span class="plain"> </span><span class="identifier">here</span><span class="plain"> |				==&gt; -1; </span>&lt;<span class="cwebmacro">Check we can begin an extension here</span> <span class="cwebmacronumber">9.1</span>&gt;<span class="plain">;</span>
        <span class="plain">... </span><span class="identifier">end</span><span class="plain">/</span><span class="identifier">ends</span><span class="plain"> </span><span class="identifier">here</span><span class="plain">					==&gt; -2; </span>&lt;<span class="cwebmacro">Check we can end an extension here</span> <span class="cwebmacronumber">9.2</span>&gt;<span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9_1"></a><b>&#167;9.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Check we can begin an extension here</span> <span class="cwebmacronumber">9.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">sfsm_extension_position</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> 1: </span><span class="identifier">sfsm_extension_position</span><span class="plain">++; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 2: </span><span class="functiontext">Problems::Issue::extension_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ExtMultipleBeginsHere</span><span class="plain">),</span>
                <span class="identifier">sfsm_extension</span><span class="plain">, </span><span class="string">"has more than one 'begins here' sentence"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 3: </span><span class="functiontext">Problems::Issue::extension_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ExtBeginsAfterEndsHere</span><span class="plain">),</span>
                <span class="identifier">sfsm_extension</span><span class="plain">, </span><span class="string">"has a further 'begins here' after an 'ends here'"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP9">&#167;9</a>.</p>

<p class="inwebparagraph"><a id="SP9_2"></a><b>&#167;9.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Check we can end an extension here</span> <span class="cwebmacronumber">9.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">sfsm_extension_position</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> 1: </span><span class="functiontext">Problems::Issue::extension_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ExtEndsWithoutBegins</span><span class="plain">),</span>
                <span class="identifier">sfsm_extension</span><span class="plain">, </span><span class="string">"has an 'ends here' with nothing having begun"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 2: </span><span class="identifier">sfsm_extension_position</span><span class="plain">++; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 3: </span><span class="functiontext">Problems::Issue::extension_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ExtMultipleEndsHere</span><span class="plain">),</span>
                <span class="identifier">sfsm_extension</span><span class="plain">, </span><span class="string">"has more than one 'ends here' sentence"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP9">&#167;9</a>.</p>

<p class="inwebparagraph"><a id="SP_1"></a><b>&#167;.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Detect a dividing sentence</span> <span class="cwebmacronumber">.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">dividing</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="reserved">switch</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;) {</span>
                <span class="reserved">case</span><span class="plain"> -1: </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sfsm_extension_position</span><span class="plain"> &gt; 0) </span><span class="identifier">begins_or_ends</span><span class="plain"> = 1;</span>
                    <span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> -2:</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sfsm_extension_position</span><span class="plain"> &gt; 0) </span><span class="identifier">begins_or_ends</span><span class="plain"> = -1;</span>
                    <span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">default</span><span class="plain">:</span>
                    <span class="identifier">heading_level</span><span class="plain"> = &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;;</span>
                    <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is never used.</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>Structural sentences are defined as follows. (The asterisk notation isn't
known to most Inform users: it increases output to the debugging log.)
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">structural</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">start</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">-</span><span class="identifier">source</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">&gt; &lt;</span><span class="identifier">quoted</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">&gt; |				==&gt; 0; </span><span class="identifier">ssnt</span><span class="plain"> = </span><span class="constant">BIBLIOGRAPHIC_NT</span><span class="plain">;</span>
        <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">start</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">-</span><span class="identifier">source</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">&gt; &lt;</span><span class="identifier">quoted</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">&gt; ... |			==&gt; 0; </span><span class="identifier">ssnt</span><span class="plain"> = </span><span class="constant">BIBLIOGRAPHIC_NT</span><span class="plain">;</span>
        <span class="plain">&lt;</span><span class="identifier">language</span><span class="plain">-</span><span class="identifier">modifying</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">&gt; |							==&gt; </span><span class="identifier">R</span><span class="plain">[1]</span>
        <span class="plain">* |														==&gt; 0; </span><span class="identifier">ssnt</span><span class="plain"> = </span><span class="constant">TRACE_NT</span><span class="plain">;</span>
        <span class="plain">* &lt;</span><span class="identifier">quoted</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">-</span><span class="identifier">without</span><span class="plain">-</span><span class="identifier">subs</span><span class="plain">&gt; |							==&gt; 0; </span><span class="identifier">ssnt</span><span class="plain"> = </span><span class="constant">TRACE_NT</span><span class="plain">;</span>
        <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">start</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">-</span><span class="identifier">paragraph</span><span class="plain">&gt; </span><span class="reserved">table</span><span class="plain"> ... |						==&gt; 0; </span><span class="identifier">ssnt</span><span class="plain"> = </span><span class="constant">TABLE_NT</span><span class="plain">;</span>
        <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">start</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">-</span><span class="identifier">paragraph</span><span class="plain">&gt; </span><span class="reserved">equation</span><span class="plain"> ... |					==&gt; 0; </span><span class="identifier">ssnt</span><span class="plain"> = </span><span class="constant">EQUATION_NT</span><span class="plain">;</span>
        <span class="identifier">include</span><span class="plain"> &lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">articled</span><span class="plain">&gt; </span><span class="identifier">by</span><span class="plain"> &lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt; |			==&gt; 0; </span><span class="identifier">ssnt</span><span class="plain"> = </span><span class="identifier">INCLUDE_NT</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]; ((</span><span class="identifier">parse_node</span><span class="plain"> *) </span><span class="identifier">RP</span><span class="plain">[1])-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2];</span>
        <span class="identifier">include</span><span class="plain"> (- ...											==&gt; 0; </span><span class="identifier">ssnt</span><span class="plain"> = </span><span class="constant">INFORM6CODE_NT</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b>Properly speaking, despite the definition above, language modifying sentences
are nonstructural. So what are they doing here? The answer is that we need to
read them early on, because they affect the way that they parse all other
sentences. Whereas other nonstructural sentences can wait, these can't.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">language</span><span class="plain">-</span><span class="identifier">modifying</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">&gt; ::=</span>
        <span class="identifier">include</span><span class="plain"> (- ### </span><span class="identifier">in</span><span class="plain"> </span><span class="identifier">the</span><span class="plain"> </span><span class="identifier">preform</span><span class="plain"> </span><span class="identifier">grammar</span><span class="plain"> |			==&gt; -2; </span><span class="identifier">ssnt</span><span class="plain"> = </span><span class="constant">INFORM6CODE_NT</span><span class="plain">;</span>
        <span class="identifier">use</span><span class="plain"> ... </span><span class="identifier">language</span><span class="plain"> </span><span class="identifier">element</span><span class="plain">/</span><span class="identifier">elements</span><span class="plain">				==&gt; -1</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">SYNTAX_PROBLEM_HANDLER</span><span class="plain"> </span><span class="functiontext">StructuralSentences::syntax_problem_handler</span>
</pre>

<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">StructuralSentences::syntax_problem_handler</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">err_no</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">void</span><span class="plain"> *</span><span class="identifier">ref</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">k</span><span class="plain">) {</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">err_no</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">UnexpectedSemicolon_SYNERROR</span><span class="plain">:</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">NounPhrases::new_raw</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnexpectedSemicolon</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"The text %1 is followed by a semicolon ';', which only makes "</span>
                    <span class="string">"sense to me inside a rule or phrase (where there's a heading, "</span>
                    <span class="string">"then a colon, then a list of instructions divided by semicolons). "</span>
                    <span class="string">"Perhaps you want a full stop '.' instead?"</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ParaEndsInColon_SYNERROR</span><span class="plain">:</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">NounPhrases::new_raw</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ParaEndsInColon</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"The text %1 seems to end a paragraph with a colon. (Rule declarations "</span>
                    <span class="string">"can end a sentence with a colon, so maybe there's accidentally a "</span>
                    <span class="string">"skipped line here?)"</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">SentenceEndsInColon_SYNERROR</span><span class="plain">:</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">NounPhrases::new_raw</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_SentenceEndsInColon</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"The text %1 seems to have a colon followed by a full stop, which is "</span>
                    <span class="string">"punctuation I don't understand."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">SentenceEndsInSemicolon_SYNERROR</span><span class="plain">:</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">NounPhrases::new_raw</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_SentenceEndsInSemicolon</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"The text %1 seems to have a semicolon followed by a full stop, which is "</span>
                    <span class="string">"punctuation I don't understand."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">SemicolonAfterColon_SYNERROR</span><span class="plain">:</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">NounPhrases::new_raw</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_SemicolonAfterColon</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"The text %1 seems to have a semicolon following a colon, which is "</span>
                    <span class="string">"punctuation I don't understand."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">SemicolonAfterStop_SYNERROR</span><span class="plain">:</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">NounPhrases::new_raw</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_SemicolonAfterStop</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"The text %1 seems to have a semicolon following a full stop, which is "</span>
                    <span class="string">"punctuation I don't understand."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ExtNoBeginsHere_SYNERROR</span><span class="plain">: {</span>
                <span class="reserved">extension_file</span><span class="plain"> *</span><span class="identifier">ef</span><span class="plain"> = (</span><span class="reserved">extension_file</span><span class="plain"> *) </span><span class="identifier">ref</span><span class="plain">;</span>
                <span class="functiontext">Problems::Issue::extension_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ExtNoBeginsHere</span><span class="plain">),</span>
                    <span class="identifier">ef</span><span class="plain">, </span><span class="string">"has no 'begins here' sentence"</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ExtNoEndsHere_SYNERROR</span><span class="plain">: {</span>
                <span class="reserved">extension_file</span><span class="plain"> *</span><span class="identifier">ef</span><span class="plain"> = (</span><span class="reserved">extension_file</span><span class="plain"> *) </span><span class="identifier">ref</span><span class="plain">;</span>
                <span class="functiontext">Problems::Issue::extension_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ExtNoEndsHere</span><span class="plain">),</span>
                    <span class="identifier">ef</span><span class="plain">, </span><span class="string">"has no 'ends here' sentence"</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ExtSpuriouslyContinues_SYNERROR</span><span class="plain">: {</span>
                <span class="reserved">extension_file</span><span class="plain"> *</span><span class="identifier">ef</span><span class="plain"> = (</span><span class="reserved">extension_file</span><span class="plain"> *) </span><span class="identifier">ref</span><span class="plain">;</span>
                <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Spurious text: %W\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
                <span class="functiontext">Problems::Issue::extension_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ExtSpuriouslyContinues</span><span class="plain">),</span>
                    <span class="identifier">ef</span><span class="plain">, </span><span class="string">"continues after the 'ends here' sentence"</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">HeadingOverLine_SYNERROR</span><span class="plain">:</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">NounPhrases::new_raw</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(2, </span><span class="identifier">NounPhrases::new_raw</span><span class="plain">(</span><span class="identifier">Wordings::up_to</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">k</span><span class="plain">-1)));</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(3, </span><span class="identifier">NounPhrases::new_raw</span><span class="plain">(</span><span class="identifier">Wordings::from</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">k</span><span class="plain">)));</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_HeadingOverLine</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"The text %1 seems to be a heading, but contains a "</span>
                    <span class="string">"line break, which is not allowed: so I am reading it "</span>
                    <span class="string">"as just %2 and ignoring the continuation %3. The rule "</span>
                    <span class="string">"is that a heading must be a single line which is the "</span>
                    <span class="string">"only sentence in its paragraph, so there must be a "</span>
                    <span class="string">"skipped line above and below."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">HeadingStopsBeforeEndOfLine_SYNERROR</span><span class="plain">:</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">NounPhrases::new_raw</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">));</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(2,</span>
                    <span class="identifier">NounPhrases::new_raw</span><span class="plain">(</span><span class="identifier">Wordings::new</span><span class="plain">(</span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)+1, </span><span class="identifier">k</span><span class="plain">-1)));</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_HeadingStopsBeforeEndOfLine</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"The text %1 seems to be a heading, but does not occupy "</span>
                    <span class="string">"the whole of its line of source text, which continues %2. "</span>
                    <span class="string">"The rule is that a heading must occupy a whole single line "</span>
                    <span class="string">"which is the only sentence in its paragraph, so there "</span>
                    <span class="string">"must be a skipped line above and below. %P"</span>
                    <span class="string">"A heading must not contain a colon ':' or any full stop "</span>
                    <span class="string">"characters '.', even if they occur in an ellipsis '...' or a "</span>
                    <span class="string">"number '2.3.13'. (I mention that because sometimes this problem "</span>
                    <span class="string">"arises when a decimal point is misread as a full stop.)"</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">default</span><span class="plain">: </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"unimplemented problem message"</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>

</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function StructuralSentences::syntax_problem_handler appears nowhere else.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="7-ptu.html">Back to 'Parse Tree Usage'</a></li><li><a href="7-hdn.html">Continue with 'Headings'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

