<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>4/its</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '4/am' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#4">Chapter 4: Bridge to Linguistics Module</a></li><li><b>Adjective Meanings</b></li></ul><p class="purpose">One individual meaning which an adjective can have.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP6">&#167;6. Symbols</a></li><li><a href="#SP7">&#167;7. The block of definitions</a></li><li><a href="#SP11">&#167;11. Checking an adjective's applicability</a></li><li><a href="#SP12">&#167;12. Broad applicability tests</a></li><li><a href="#SP13">&#167;13. Asserting the initial state</a></li><li><a href="#SP14">&#167;14. Sorting lists of meanings</a></li><li><a href="#SP17">&#167;17. Individual meanings</a></li><li><a href="#SP19">&#167;19. The domain of validity</a></li><li><a href="#SP22">&#167;22. Specifying the domain of a new AM</a></li><li><a href="#SP26">&#167;26. Comparing domains of validity</a></li><li><a href="#SP27">&#167;27. Testing and asserting in play</a></li><li><a href="#SP33">&#167;33. Support routines</a></li><li><a href="#SP36">&#167;36. Kinds of adjectives</a></li><li><a href="#SP42">&#167;42. Parsing for adaptive text</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>An adjective can have a long list of meanings in different contexts:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">ADJECTIVE_MEANING_TYPE</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">adjective_meaning_block</span>
</pre>

<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">adjective_meaning_block</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">possible_meanings</span><span class="plain">; </span>    <span class="comment">list of definitions in order given</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">sorted_meanings</span><span class="plain">; </span>    <span class="comment">the same list sorted into logical order</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">adjective_meaning_block</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure adjective_meaning_block is private to this section.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>Each individual sense of an adjective has its own <code class="display"><span class="extract">adjective_meaning</span></code>
structure, which we define next. It consists of some logistical data to keep
its place in the linked lists (see above), some data to specify its domain
(see below), some indexing data which is not very important, and then the
crucial part: its "detailed meaning".
</p>

<p class="inwebparagraph">The general model is that adjective meanings come in different "kinds",
for which specific code is scattered across Inform. In each case, the
<code class="display"><span class="extract">detailed_meaning</span></code> points to an appropriate data structure, and specialised
routines are called to create and use the adjective.
</p>

<p class="inwebparagraph">We can also specify that the meaning implied by this pointer is to be
understood reversely: that the adjective is the negation of the one specified.
This enables "non-empty" for texts (say) to be defined identically with
"empty" for texts, but with the <code class="display"><span class="extract">meaning_parity</span></code> flag set to <code class="display"><span class="extract">FALSE</span></code>
rather than <code class="display"><span class="extract">TRUE</span></code>.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">CONDITION_KADJ</span><span class="plain"> 1 </span>    <span class="comment">defined by a condition in I7 source text</span>
    <span class="definitionkeyword">define</span> <span class="constant">PHRASE_KADJ</span><span class="plain"> 2 </span>    <span class="comment">defined by an explicit but nameless rule</span>
    <span class="definitionkeyword">define</span> <span class="constant">I6_ROUTINE_KADJ</span><span class="plain"> 3 </span>    <span class="comment">defined by a named I6 routine</span>
    <span class="definitionkeyword">define</span> <span class="constant">I6_CONDITION_KADJ</span><span class="plain"> 4 </span>    <span class="comment">defined by an explicit I6 schema</span>
    <span class="definitionkeyword">define</span> <span class="constant">MEASUREMENT_KADJ</span><span class="plain"> 5 </span>    <span class="comment">defined by numerical comparison with a property value</span>
    <span class="definitionkeyword">define</span> <span class="constant">ENUMERATIVE_KADJ</span><span class="plain"> 6 </span>    <span class="comment">defined by a property like "colour" with named values</span>
    <span class="definitionkeyword">define</span> <span class="constant">EORP_KADJ</span><span class="plain"> 7 </span>    <span class="comment">defined by an either/or property like "closed"</span>
</pre>

<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">adjective_meaning</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">adjective_index_text</span><span class="plain">; </span>    <span class="comment">text to use in the Phrasebook index</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">defined_at</span><span class="plain">; </span>    <span class="comment">from what sentence this came (if it did)</span>

        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">owning_adjective</span><span class="plain">; </span>    <span class="comment">of which this is a definition</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">next_meaning</span><span class="plain">; </span>    <span class="comment">next in order of definition</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">next_sorted</span><span class="plain">; </span>    <span class="comment">next in logically sorted order</span>

        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">domain_text</span><span class="plain">; </span>    <span class="comment">domain to which defn applies</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">domain_infs</span><span class="plain">; </span>    <span class="comment">what domain the defn applies to</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">setting_domain</span><span class="plain">; </span>    <span class="comment">are we currently working this out?</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">domain_kind</span><span class="plain">; </span>    <span class="comment">what kind of values</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">problems_thrown</span><span class="plain">; </span>    <span class="comment">complaining about the domain of this adjective</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">meaning_parity</span><span class="plain">; </span>    <span class="comment">meaning understood positively?</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am_negated_from</span><span class="plain">; </span>    <span class="comment">if explicitly constructed as such</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">adjective_form</span><span class="plain">; </span>    <span class="comment">one of the <code class="display"><span class="extract">*_KADJ</span></code> constants: see below</span>
        <span class="identifier">general_pointer</span><span class="plain"> </span><span class="identifier">detailed_meaning</span><span class="plain">; </span>    <span class="comment">to the relevant structure</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">task_via_support_routine</span><span class="plain">[</span><span class="constant">NO_ADJECTIVE_TASKS</span><span class="plain"> + 1];</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">i6_schema</span><span class="plain"> </span><span class="identifier">i6s_to_transfer_to_SR</span><span class="plain">[</span><span class="constant">NO_ADJECTIVE_TASKS</span><span class="plain"> + 1]; </span>    <span class="comment">where <code class="display"><span class="extract">TRUE</span></code></span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">i6_schema</span><span class="plain"> </span><span class="identifier">i6s_for_runtime_task</span><span class="plain">[</span><span class="constant">NO_ADJECTIVE_TASKS</span><span class="plain"> + 1]; </span>    <span class="comment">where <code class="display"><span class="extract">TRUE</span></code></span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">am_ready_flag</span><span class="plain">; </span>    <span class="comment">optional flag to mark whether schemas prepared yet</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">defined_already</span><span class="plain">; </span>    <span class="comment">temporary workspace used when compiling support routines</span>

        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">adjective_meaning</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure adjective_meaning is private to this section.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>What are adjectives for? Since an adjective is a unary predicate, it can be
thought of as an assignment from its domain set to the set of two possibilities:
true, false. Thus one sense of "open" maps doors to true if they are currently
open, false if they are closed.
</p>

<p class="inwebparagraph">There are altogether five things we might want to do with an adjective:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(1) Test whether it is true at any given point during play.
</li><li>(2) Assert that it is true at the start of play.
</li><li>(3) Assert that it is false at the start of play.
</li><li>(4) Assert that it is now to be true from this point on during play.
</li><li>(5) Assert that it is now to be false from this point on during play.
</li></ul>
<p class="inwebparagraph">We do not need to test whether it is false, since we need only test whether
it is true and negate the result.
</p>

<p class="inwebparagraph">Adjectives for which all five of these operations can be carried out are
the exception rather than the rule. "Open" is an example:
</p>

<blockquote>
    <p>[1] if the marble door is open, ...</p>

</blockquote>

<blockquote>
    <p>[2] The marble door is open.</p>

</blockquote>

<blockquote>
    <p>[3] The marble door is not open.</p>

</blockquote>

<blockquote>
    <p>[4] now the marble door is open;</p>

</blockquote>

<blockquote>
    <p>[5] now the marble door is not open;</p>

</blockquote>

<p class="inwebparagraph">Every adjective in practice supports (1), testing for truth, but this is
not required by the code below. Many adjectives &mdash; properly speaking, many
senses of an adjective &mdash; only support testing: "empty" in the sense of
texts, for instance.
</p>

<p class="inwebparagraph">Of the five possibilities, (1), (4) and (5) happen at run-time. These are
called "tasks" and are identified by the following constants. While in
theory an adjective's handling code can compile anything it likes to carry
out these tasks, in practice most are defined by providing an I6 schema,
which is why the <code class="display"><span class="extract">adjective_meaning</span></code> structure contains these &mdash; see below.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">NO_ADJECTIVE_TASKS</span><span class="plain"> 3</span>
    <span class="definitionkeyword">define</span> <span class="constant">TEST_ADJECTIVE_TASK</span><span class="plain"> 1 </span>    <span class="comment">test if currently true</span>
    <span class="definitionkeyword">define</span> <span class="constant">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain"> 2 </span>    <span class="comment">assert now true</span>
    <span class="definitionkeyword">define</span> <span class="constant">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain"> 3 </span>    <span class="comment">assert now false</span>
</pre>
<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>For indexing (only) we need to run through the definitions of a given
adjectival phrase in sorted order, so:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="identifier">LOOP_OVER_SORTED_MEANINGS</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">am</span><span class="plain">)</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::get_sorted_definition_list</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">); </span><span class="identifier">am</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">=</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain">)</span>
</pre>
<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Symbols. </b></p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">adjective_iname_holder</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph_held</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">task_code</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">weak_ID_of_domain</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">iname_held</span><span class="plain">;</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">adjective_iname_holder</span><span class="plain">;</span>

    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::iname</span><span class="plain">(</span><span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">weak_id</span><span class="plain">) {</span>
        <span class="reserved">adjective_iname_holder</span><span class="plain"> *</span><span class="identifier">aih</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">aih</span><span class="plain">, </span><span class="reserved">adjective_iname_holder</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">aih</span><span class="plain">-</span><span class="element">&gt;aph_held</span><span class="plain"> == </span><span class="identifier">aph</span><span class="plain">) &amp;&amp; (</span><span class="identifier">aih</span><span class="plain">-</span><span class="element">&gt;task_code</span><span class="plain"> == </span><span class="identifier">task</span><span class="plain">) &amp;&amp; (</span><span class="identifier">aih</span><span class="plain">-</span><span class="element">&gt;weak_ID_of_domain</span><span class="plain"> == </span><span class="identifier">weak_id</span><span class="plain">))</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">aih</span><span class="plain">-</span><span class="element">&gt;iname_held</span><span class="plain">;</span>
        <span class="identifier">aih</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">adjective_iname_holder</span><span class="plain">);</span>
        <span class="identifier">aih</span><span class="plain">-</span><span class="element">&gt;aph_held</span><span class="plain"> = </span><span class="identifier">aph</span><span class="plain">;</span>
        <span class="identifier">aih</span><span class="plain">-</span><span class="element">&gt;task_code</span><span class="plain"> = </span><span class="identifier">task</span><span class="plain">;</span>
        <span class="identifier">aih</span><span class="plain">-</span><span class="element">&gt;weak_ID_of_domain</span><span class="plain"> = </span><span class="identifier">weak_id</span><span class="plain">;</span>
        <span class="identifier">package_request</span><span class="plain"> *</span><span class="identifier">PR</span><span class="plain"> = </span><span class="functiontext">Hierarchy::package_within</span><span class="plain">(</span><span class="constant">ADJECTIVE_TASKS_HAP</span><span class="plain">, </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">aph_package</span><span class="plain">);</span>
        <span class="identifier">aih</span><span class="plain">-</span><span class="element">&gt;iname_held</span><span class="plain"> = </span><span class="functiontext">Hierarchy::make_iname_in</span><span class="plain">(</span><span class="constant">TASK_FN_HL</span><span class="plain">, </span><span class="identifier">PR</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">aih</span><span class="plain">-</span><span class="element">&gt;iname_held</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::iname is used in <a href="#SP29_1">&#167;29.1</a>, <a href="#SP30">&#167;30</a>, <a href="#SP34_2">&#167;34.2</a>.</p>

<p class="endnote">The structure adjective_iname_holder is private to this section.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. The block of definitions. </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">EMPTY_ADJECTIVE_MEANING</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::new_block</span>
</pre>

<pre class="display">
    <span class="reserved">adjective_meaning_block</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::new_block</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">adjective_meaning_block</span><span class="plain"> *</span><span class="identifier">amb</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">adjective_meaning_block</span><span class="plain">);</span>
        <span class="identifier">amb</span><span class="plain">-</span><span class="element">&gt;possible_meanings</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="identifier">amb</span><span class="plain">-</span><span class="element">&gt;sorted_meanings</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">amb</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::new_block appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>The following assigns a new meaning to a given word range: we find the
appropriate APH (creating if necessary) and then add the new meaning to the
end of its unsorted meaning list.
</p>

<p class="inwebparagraph">We eventually need to sort this list of definitions into logical priority
order &mdash; so that a definition applying to just Count Dracula precedes one
applying to men, which in turn precedes one applying to things. (Priority
order is irrelevant when two senses apply to domains with no overlap, as
in the case of texts and table names.) It's convenient and costs little
memory to keep the sorted list as a second linked list.
</p>


<pre class="display">
    <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::declare</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">,</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">route</span><span class="plain">) {</span>
        <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain"> = </span><span class="identifier">Adjectives::declare</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">aml</span><span class="plain"> = </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;possible_meanings</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">aml</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;possible_meanings</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">;</span>
        <span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">while</span><span class="plain"> (</span><span class="identifier">aml</span><span class="plain">-</span><span class="element">&gt;next_meaning</span><span class="plain">) </span><span class="identifier">aml</span><span class="plain"> = </span><span class="identifier">aml</span><span class="plain">-</span><span class="element">&gt;next_meaning</span><span class="plain">;</span>
            <span class="identifier">aml</span><span class="plain">-</span><span class="element">&gt;next_meaning</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_meaning</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;owning_adjective</span><span class="plain"> = </span><span class="identifier">aph</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">aph</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::declare is used in 5/ins (<a href="5-ins.html#SP38_2">&#167;38.2</a>), 15/ep (<a href="15-ep.html#SP12">&#167;12</a>), 15/ma (<a href="15-ma.html#SP11_5">&#167;11.5</a>), 23/ad (<a href="23-ad.html#SP5_4">&#167;5.4</a>), 23/abrp (<a href="23-abrp.html#SP2">&#167;2</a>), 23/abrc (<a href="23-abrc.html#SP2">&#167;2</a>), 23/abp (<a href="23-abp.html#SP1">&#167;1</a>), 23/abc (<a href="23-abc.html#SP1">&#167;1</a>).</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>Once declared, an AM stays with the same APH for the whole of Inform's run,
and it can only be declared once. So every AM belongs to one and only one
APH, which we can read off as follows:
</p>


<pre class="display">
    <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::get_aph_from_am</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;owning_adjective</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::get_aph_from_am is used in 15/ep (<a href="15-ep.html#SP12">&#167;12</a>).</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>And here we log the unsorted meaning list.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::log_meanings</span><span class="plain">(</span><span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">) {</span>
        <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">n</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">aph</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) { </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"&lt;null-APH&gt;\</span><span class="plain">n</span><span class="string">"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain">; }</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">n</span><span class="plain">=1, </span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;possible_meanings</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">; </span><span class="identifier">n</span><span class="plain">++, </span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_meaning</span><span class="plain">)</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"%d: %W (domain:$j) (dk:$u)\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">n</span><span class="plain">, </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_index_text</span><span class="plain">,</span>
                <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain">, </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_kind</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::log_meanings appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Checking an adjective's applicability. </b>If the source tries to apply the word "open", say, to a given value or
object X, when does that make sense?
</p>

<p class="inwebparagraph">We can only find out by checking every possible meaning of "open" to see
if it can accommodate the kind of value of X. But this time we use weak
checking, and make it weaker still since a null kind is taken to mean "any
object", either in the AM's definition &mdash; which can happen if we are very
early in Inform's run &mdash; or because the caller doesn't actually know the
kind of value of X. (In other words, adjectives tend to assume they apply
to objects rather than other values.) This means we will accept some
logically impossible outcomes &mdash; we would say that it's acceptable to apply
"open" to an animal, say &mdash; but that is actually a good thing. It means
that "list of open things" or "something open" are allowed. Source text
such as:
</p>

<blockquote>
    <p>The labrador puppy is an open animal.</p>

</blockquote>

<p class="inwebparagraph">will successfully parse, but then result in higher-level problem messages.
The following does compile:
</p>

<blockquote>
    <p>now the labrador puppy is open;</p>

</blockquote>

<p class="inwebparagraph">but results in a run-time problem message when it executes.
</p>

<p class="inwebparagraph">It makes no difference what order we check the AMs in, so we can use the
unsorted list, which is helpful since we may need to call this routine
early in the run when sorting cannot yet be done.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::applicable_to</span><span class="plain">(</span><span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">,</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">aph</span><span class="plain">) {</span>
            <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;possible_meanings</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">; </span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_meaning</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;setting_domain</span><span class="plain">) </span>&lt;<span class="cwebmacro">Issue a problem for a circularity</span> <span class="cwebmacronumber">11.1</span>&gt;<span class="plain">;</span>
                    <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;setting_domain</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                    <span class="functiontext">Adjectives::Meanings::set_definition_domain</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
                    <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;setting_domain</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">am_kind</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::get_domain</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">am_kind</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)) {</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">K</span><span class="plain">) &amp;&amp; (</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp;</span>
                        <span class="plain">(</span><span class="identifier">Kinds::Compare::compatible</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">am_kind</span><span class="plain">) == </span><span class="identifier">ALWAYS_MATCH</span><span class="plain">))</span>
                        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::applicable_to is used in 10/cad (<a href="10-cad.html#SP13">&#167;13</a>), 11/tcp (<a href="11-tcp.html#SP10">&#167;10</a>), 15/ep (<a href="15-ep.html#SP12">&#167;12</a>).</p>

<p class="inwebparagraph"><a id="SP11_1"></a><b>&#167;11.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue a problem for a circularity</span> <span class="cwebmacronumber">11.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> == 0) {</span>
            <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
            <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">Clusters::get_name</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">adjective_names</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">));</span>
            <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_AdjectiveCircular</span><span class="plain">));</span>
            <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                <span class="string">"In the sentence %1, it looks as if the definition of the adjective "</span>
                <span class="string">"'%2' may be circular."</span><span class="plain">);</span>
            <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP11">&#167;11</a>.</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Broad applicability tests. </b>Does a given APH have any interpretation as an enumerated property value,
or an either/or property? If so we return the earliest known.
</p>


<pre class="display">
    <span class="reserved">instance</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::has_ENUMERATIVE_meaning</span><span class="plain">(</span><span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">) {</span>
        <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;possible_meanings</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">; </span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_meaning</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_form</span><span class="plain"> == </span><span class="constant">ENUMERATIVE_KADJ</span><span class="plain">)</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">RETRIEVE_POINTER_instance</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">property</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::has_EORP_meaning</span><span class="plain">(</span><span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">sense</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">aph</span><span class="plain">)</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;possible_meanings</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">; </span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_meaning</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_form</span><span class="plain"> == </span><span class="constant">EORP_KADJ</span><span class="plain">) {</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sense</span><span class="plain">) *</span><span class="identifier">sense</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;meaning_parity</span><span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">RETRIEVE_POINTER_property</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">);</span>
                <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::has_ENUMERATIVE_meaning is used in 9/rpt (<a href="9-rpt.html#SP6">&#167;6</a>), 9/ma (<a href="9-ma.html#SP3_3_13">&#167;3.3.13</a>), 11/tr (<a href="11-tr.html#SP8">&#167;8</a>), 14/ds2 (<a href="14-ds2.html#SP11_9_1_1_5_1_2">&#167;11.9.1.1.5.1.2</a>), 15/cp (<a href="15-cp.html#SP3">&#167;3</a>).</p>

<p class="endnote">The function Adjectives::Meanings::has_EORP_meaning is used in 9/imp (<a href="9-imp.html#SP4_2_3">&#167;4.2.3</a>, <a href="9-imp.html#SP7_1">&#167;7.1</a>), 11/tr (<a href="11-tr.html#SP8">&#167;8</a>), 12/ap (<a href="12-ap.html#SP13_1">&#167;13.1</a>, <a href="12-ap.html#SP14_2">&#167;14.2</a>), 14/ds2 (<a href="14-ds2.html#SP11_9_1_1_5_1_2">&#167;11.9.1.1.5.1.2</a>).</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. Asserting the initial state. </b>All that domain-checking machinery means we can begin to use an adjective.
</p>

<p class="inwebparagraph">Suppose an assertion sentence in the source text claims that, in the initial
state of things, what the adjective tests is true. For example:
</p>

<blockquote>
    <p>The ormolu clock is fixed in place.</p>

</blockquote>

<p class="inwebparagraph">The S-parser, finding that this sentence is syntactically reasonable,
identifies "fixed in place" as an adjective, and stores a pointer to its
APH structure, but goes no further. Later on, the A-parser, working through
sentences like this, works out that the adjective is to be applied to
the instance "ormolu clock", whose kind is "thing"; and that the
sentence asserts a truth, not a falsity. It then calls the following
routine, with <code class="display"><span class="extract">parity</span></code> equal to <code class="display"><span class="extract">TRUE</span></code>.
</p>

<p class="inwebparagraph">What happens is that the list of definitions for "fixed in place" is
strictly checked in logical precedence order, and that <code class="display"><span class="extract">Adjectives::Meanings::assert</span></code> is
eventually called on the logically narrowest definition which the "ormolu
clock" matches. (That will probably be the definition for the "fixed
in place" either/or property for things, unless someone has given the
adjective some special meaning unique to the clock.)
</p>

<p class="inwebparagraph">The following routine therefore acts as a junction-box, deciding which
sense of the adjective is to be applied. We return <code class="display"><span class="extract">TRUE</span></code> if we were
able to find a definition which could be asserted and which the clock
matched, and <code class="display"><span class="extract">FALSE</span></code> if there was no definition which applied, or if
none of those which did could be asserted for it.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::assert</span><span class="plain">(</span><span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">kind_domain</span><span class="plain">,</span>
        <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs_to_assert_on</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">val_to_assert_on</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">parity</span><span class="plain">) {</span>
        <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">;</span>
        <span class="functiontext">Adjectives::Meanings::sort</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">);</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;sorted_meanings</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">; </span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Adjectives::Meanings::domain_weak_match</span><span class="plain">(</span><span class="identifier">kind_domain</span><span class="plain">,</span>
                <span class="functiontext">Adjectives::Meanings::get_domain</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">)) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">continue</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Adjectives::Meanings::domain_subj_compare</span><span class="plain">(</span><span class="identifier">infs_to_assert_on</span><span class="plain">, </span><span class="identifier">am</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">continue</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Adjectives::Meanings::assert_single</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">infs_to_assert_on</span><span class="plain">, </span><span class="identifier">val_to_assert_on</span><span class="plain">, </span><span class="identifier">parity</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::assert is used in 12/ap (<a href="12-ap.html#SP9_10">&#167;9.10</a>).</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Sorting lists of meanings. </b>After meanings have been declared, a typical APH will have a disordered
"possible meaning" list and an empty "sorted meaning" list. The following
sorts the possibles list into the sorted list.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::sort</span><span class="plain">(</span><span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">aph</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to sort meanings for null APH"</span><span class="plain">);</span>
        <span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;sorted_meanings</span><span class="plain"> =</span>
            <span class="functiontext">Adjectives::Meanings::list_sort</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;possible_meanings</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::sort is used in <a href="#SP13">&#167;13</a>, <a href="#SP29">&#167;29</a>, <a href="#SP34_1">&#167;34.1</a>.</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b>And voil\`a, the result can be read here:
</p>


<pre class="display">
    <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::get_sorted_definition_list</span><span class="plain">(</span><span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;sorted_meanings</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::get_sorted_definition_list is used in <a href="#SP5">&#167;5</a>.</p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16.  </b>Occasionally we just want one meaning:
</p>


<pre class="display">
    <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::first_meaning</span><span class="plain">(</span><span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;possible_meanings</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::list_sort</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">unsorted_head</span><span class="plain">) {</span>
        <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">sorted_head</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">, *</span><span class="identifier">am2</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">unsorted_head</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">; </span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_meaning</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)</span>
                <span class="functiontext">Adjectives::Meanings::set_definition_domain</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">unsorted_head</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">; </span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_meaning</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sorted_head</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
                <span class="identifier">sorted_head</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">;</span>
                <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">lastdef</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">am2</span><span class="plain"> = </span><span class="identifier">sorted_head</span><span class="plain">; </span><span class="identifier">am2</span><span class="plain">; </span><span class="identifier">am2</span><span class="plain"> = </span><span class="identifier">am2</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain">) {</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Adjectives::Meanings::compare</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">am2</span><span class="plain">) == 1) {</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lastdef</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
                            <span class="identifier">sorted_head</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">;</span>
                            <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain"> = </span><span class="identifier">am2</span><span class="plain">;</span>
                        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                            <span class="identifier">lastdef</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">;</span>
                            <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain"> = </span><span class="identifier">am2</span><span class="plain">;</span>
                        <span class="plain">}</span>
                        <span class="reserved">break</span><span class="plain">;</span>
                    <span class="plain">}</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am2</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
                        <span class="identifier">am2</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">;</span>
                        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
                        <span class="reserved">break</span><span class="plain">;</span>
                    <span class="plain">}</span>
                    <span class="identifier">lastdef</span><span class="plain"> = </span><span class="identifier">am2</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">sorted_head</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::first_meaning is used in 11/bas (<a href="11-bas.html#SP18">&#167;18</a>).</p>

<p class="endnote">The function Adjectives::Meanings::list_sort is used in <a href="#SP14">&#167;14</a>.</p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17. Individual meanings. </b>So you want to define a new meaning for an adjective? Here's the procedure:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(1) Call <code class="display"><span class="extract">Adjectives::Meanings::new</span></code> to create it. The <code class="display"><span class="extract">form</span></code> should
be one of the <code class="display"><span class="extract">*_KADJ</span></code> constants, and the <code class="display"><span class="extract">details</span></code> should contain a pointer to
the data structure it uses. The word range is used for indexing only.
</li><li>(2) Call <code class="display"><span class="extract">Adjectives::Meanings::declare</span></code> to associate it with a given
adjective name, and thus have it added to the possible meanings list of the
appropriate APH.
</li><li>(3) Give it a domain of definition (see below).
</li><li>(4) Optionally, give it explicit I6 schemas for testing and asserting (see
below) &mdash; this makes coding what the adjective compiles to much easier.
</li></ul>

<pre class="display">
    <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::new</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">form</span><span class="plain">, </span><span class="identifier">general_pointer</span><span class="plain"> </span><span class="identifier">details</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain">);</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;defined_at</span><span class="plain"> = </span><span class="identifier">current_sentence</span><span class="plain">;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_index_text</span><span class="plain"> = </span><span class="identifier">W</span><span class="plain">;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;owning_adjective</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_meaning</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_text</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_kind</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;setting_domain</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_form</span><span class="plain"> = </span><span class="identifier">form</span><span class="plain">;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain"> = </span><span class="identifier">details</span><span class="plain">;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;defined_already</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;problems_thrown</span><span class="plain"> = 0;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;meaning_parity</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;am_ready_flag</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=1; </span><span class="identifier">i</span><span class="plain">&lt;=</span><span class="constant">NO_ADJECTIVE_TASKS</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) {</span>
            <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;task_via_support_routine</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] = </span><span class="identifier">NOT_APPLICABLE</span><span class="plain">;</span>
            <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(&amp;(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;i6s_for_runtime_task</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]), </span><span class="string">""</span><span class="plain">);</span>
            <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(&amp;(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;i6s_to_transfer_to_SR</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]), </span><span class="string">""</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;am_negated_from</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">am</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::new is used in 5/ins (<a href="5-ins.html#SP38_2">&#167;38.2</a>), 15/ep (<a href="15-ep.html#SP12">&#167;12</a>), 15/ma (<a href="15-ma.html#SP11_5">&#167;11.5</a>), 23/abrp (<a href="23-abrp.html#SP2">&#167;2</a>), 23/abrc (<a href="23-abrc.html#SP2">&#167;2</a>), 23/abp (<a href="23-abp.html#SP1">&#167;1</a>), 23/abc (<a href="23-abc.html#SP1">&#167;1</a>).</p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18.  </b>Negating an AM.
If you want to define an adjective as the logical negation of an existing one,
take any AM which has been through stages (1) to (4) and then apply
<code class="display"><span class="extract">Adjectives::Meanings::negate</span></code> to create a new AM. Then use
<code class="display"><span class="extract">Adjectives::Meanings::declare</span></code> to associate this with a (presumably
different) name, but there's no need to specify its I6 schemas or its domain &mdash;
those are inherited.
</p>


<pre class="display">
    <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::negate</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">) {</span>
        <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">neg</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain">);</span>
        <span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;defined_at</span><span class="plain"> = </span><span class="identifier">current_sentence</span><span class="plain">;</span>
        <span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;adjective_index_text</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_index_text</span><span class="plain">;</span>
        <span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;owning_adjective</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;next_meaning</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;domain_text</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_text</span><span class="plain">;</span>
        <span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain">; </span><span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;domain_kind</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_kind</span><span class="plain">;</span>
        <span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;adjective_form</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_form</span><span class="plain">;</span>
        <span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">;</span>
        <span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;defined_already</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;problems_thrown</span><span class="plain"> = 0;</span>
        <span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;am_ready_flag</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;meaning_parity</span><span class="plain"> = (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;meaning_parity</span><span class="plain">)?</span><span class="identifier">FALSE</span><span class="plain">:</span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=1; </span><span class="identifier">i</span><span class="plain">&lt;=</span><span class="constant">NO_ADJECTIVE_TASKS</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">j</span><span class="plain"> = </span><span class="identifier">i</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain"> == </span><span class="constant">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain">) </span><span class="identifier">j</span><span class="plain"> = </span><span class="constant">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain"> == </span><span class="constant">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain">) </span><span class="identifier">j</span><span class="plain"> = </span><span class="constant">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain">;</span>
            <span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;task_via_support_routine</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">] = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;task_via_support_routine</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">];</span>
            <span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;i6s_for_runtime_task</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">] = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;i6s_for_runtime_task</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">];</span>
            <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(&amp;(</span><span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;i6s_to_transfer_to_SR</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">]), </span><span class="string">""</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="identifier">neg</span><span class="plain">-</span><span class="element">&gt;am_negated_from</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">neg</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::get_form</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> -1;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_form</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::negate is used in 23/ad (<a href="23-ad.html#SP5_4">&#167;5.4</a>).</p>

<p class="endnote">The function Adjectives::Meanings::get_form is used in 23/abp (<a href="23-abp.html#SP1">&#167;1</a>).</p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19. The domain of validity. </b>Every AM has a clearly defined range of values or objects to which it applies.
For example, "odd" for numbers has <code class="display"><span class="extract">domain_infs</span></code> equal to "number",
while the sense of "odd" created by
</p>

<blockquote>
    <p>Mrs Elspeth Spong can be odd, eccentric or mildly dotty.</p>

</blockquote>

<p class="inwebparagraph">would have <code class="display"><span class="extract">domain_infs</span></code> equal to Mrs Spong herself.
</p>

<p class="inwebparagraph"><a id="SP20"></a><b>&#167;20.  </b>In comparing and testing domains, we use two different levels of matching:
weak and strong.
</p>

<p class="inwebparagraph">Strong checking makes an exact match, but weak checking blurs the definitions
so that two domains are counted as equal if they are close enough that run-time
type checking can be used to tell them apart.
</p>

<p class="inwebparagraph">In general, any two base kinds are different even in weak checking &mdash; "scene"
and "number", for instance. On the other hand, "list of scenes" weakly
matches "list of numbers", and "container" weakly matches "animal".
As this last example shows, two domains can be completely disjoint and still
make a weak match.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::domain_weak_match</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K1</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K2</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Kinds::RunTime::weak_id</span><span class="plain">(</span><span class="identifier">K1</span><span class="plain">) == </span><span class="functiontext">Kinds::RunTime::weak_id</span><span class="plain">(</span><span class="identifier">K2</span><span class="plain">))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::domain_weak_match is used in <a href="#SP13">&#167;13</a>, <a href="#SP29">&#167;29</a>, <a href="#SP34_2_1">&#167;34.2.1</a>, <a href="#SP35">&#167;35</a>.</p>

<p class="inwebparagraph"><a id="SP21"></a><b>&#167;21.  </b>Whereas the following makes a strict check of whether a given subject is
within the domain of an adjective meaning.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::domain_subj_compare</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">, </span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">) {</span>
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::as_object_instance</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain"> == </span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">K_object</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> (</span><span class="identifier">infs</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain"> == </span><span class="identifier">infs</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="identifier">infs</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::narrowest_broader_subject</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::domain_subj_compare is used in <a href="#SP13">&#167;13</a>.</p>

<p class="inwebparagraph"><a id="SP22"></a><b>&#167;22. Specifying the domain of a new AM. </b>In principle the domain should be set as soon as the AM is created, but in
practice some AMs &mdash; those coming from properties &mdash; might need to be
created very early in Inform's run, at a time when objects and kinds of
object do not exist. For those cases, an alternative is to give a word range &mdash;
"a number", say, or "a container" &mdash; and if necessary this is left
until later on in the run to parse. (For "a number", it wouldn't be
necessary; for "a container", it would.)
</p>

<p class="inwebparagraph">The inclusion of <code class="display"><span class="extract">domain_kind</span></code> may seem redundant here; surely the INFS is
sufficient? But it isn't, because "list of numbers" &mdash; say &mdash; has the
same INFS as "list of texts" or a list of anything else, so that if we
recorded the domain only as an INFS then we couldn't define adjectives
over specific constructed kinds.
</p>

<p class="inwebparagraph">To set the domain, call exactly one of the following three routines:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::set_domain_text</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_kind</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_text</span><span class="plain"> = </span><span class="identifier">W</span><span class="plain">;</span>
        <span class="functiontext">Adjectives::Meanings::set_definition_domain</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::set_domain_from_instance</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">,</span>
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain"> = </span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">K_object</span><span class="plain">);</span>
            <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_kind</span><span class="plain"> = </span><span class="identifier">K_object</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain"> = </span><span class="functiontext">Instances::as_subject</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
            <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_kind</span><span class="plain"> = </span><span class="identifier">Kinds::weaken</span><span class="plain">(</span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
        <span class="plain">}</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_text</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::set_domain_text is used in 15/ma (<a href="15-ma.html#SP11_5">&#167;11.5</a>), 23/abrp (<a href="23-abrp.html#SP2">&#167;2</a>), 23/abrc (<a href="23-abrc.html#SP2">&#167;2</a>), 23/abp (<a href="23-abp.html#SP1">&#167;1</a>), 23/abc (<a href="23-abc.html#SP1">&#167;1</a>).</p>

<p class="endnote">The function Adjectives::Meanings::set_domain_from_instance is used in 5/ins (<a href="5-ins.html#SP38_2">&#167;38.2</a>).</p>

<p class="inwebparagraph"><a id="SP23"></a><b>&#167;23.  </b>Note that we round up the kind to "object" if it's more specialised than that
&mdash; say, if it's "door" &mdash; because run-time rather than compile-time
disambiguation is used when applying adjectives to objects.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::set_domain_from_kind</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">K</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">))) </span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">K_object</span><span class="plain">;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain"> = </span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_kind</span><span class="plain"> = </span><span class="identifier">K</span><span class="plain">;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_text</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::set_domain_from_kind is used in 5/ins (<a href="5-ins.html#SP38_2">&#167;38.2</a>), 15/ep (<a href="15-ep.html#SP12">&#167;12</a>).</p>

<p class="inwebparagraph"><a id="SP24"></a><b>&#167;24.  </b>And we can read the main domain thus:
</p>


<pre class="display">
    <span class="identifier">kind</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::get_domain</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_kind</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">kind</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::get_domain_forcing</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">) {</span>
        <span class="functiontext">Adjectives::Meanings::set_definition_domain</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_kind</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::get_domain is used in <a href="#SP11">&#167;11</a>, <a href="#SP13">&#167;13</a>, <a href="#SP28">&#167;28</a>, <a href="#SP29">&#167;29</a>, <a href="#SP30">&#167;30</a>, <a href="#SP33">&#167;33</a>, <a href="#SP34_2_1">&#167;34.2.1</a>, <a href="#SP35">&#167;35</a>, 11/bas (<a href="11-bas.html#SP18">&#167;18</a>), 15/ep (<a href="15-ep.html#SP15">&#167;15</a>), 15/ma (<a href="15-ma.html#SP13">&#167;13</a>).</p>

<p class="endnote">The function Adjectives::Meanings::get_domain_forcing is used in 23/abp (<a href="23-abp.html#SP1">&#167;1</a>).</p>

<p class="inwebparagraph"><a id="SP25"></a><b>&#167;25.  </b>In the case where the domain is declared as a word range, the following
routine eventually converts it to the correct form. In effect, this is a
lazy evaluation trick &mdash; the routine is called just before the domain is
actually needed.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::set_definition_domain</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">early</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;defined_at</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_text</span><span class="plain">)) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"undeclared domain kind for AM"</span><span class="plain">);</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">supplied</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">&gt;(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_text</span><span class="plain">))</span>
            <span class="identifier">supplied</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">supplied</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span>&lt;<span class="cwebmacro">Reject domain of adjective</span> <span class="cwebmacronumber">25.1</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Reject domain of adjective unless a kind of value or description of objects</span> <span class="cwebmacronumber">25.4</span>&gt;<span class="plain">;</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">ParseTreeUsage::is_condition</span><span class="plain">(</span><span class="identifier">supplied</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Specifications::to_kind</span><span class="plain">(</span><span class="identifier">supplied</span><span class="plain">))</span>
                <span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">Specifications::to_kind</span><span class="plain">(</span><span class="identifier">supplied</span><span class="plain">);</span>
            <span class="reserved">else</span><span class="plain"> </span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">K_object</span><span class="plain">;</span>
            &lt;<span class="cwebmacro">Reject domain of adjective if it is a set of objects which may vary in play</span> <span class="cwebmacronumber">25.5</span>&gt;<span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">ParseTreeUsage::is_rvalue</span><span class="plain">(</span><span class="identifier">supplied</span><span class="plain">))</span>
            <span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">Rvalues::to_kind</span><span class="plain">(</span><span class="identifier">supplied</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span>&lt;<span class="cwebmacro">Reject domain of adjective</span> <span class="cwebmacronumber">25.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Behaviour::is_kind_of_kind</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">)) </span>&lt;<span class="cwebmacro">Reject domain as vague</span> <span class="cwebmacronumber">25.2</span>&gt;<span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::eq</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_understanding</span><span class="plain">)) </span>&lt;<span class="cwebmacro">Reject domain as topic</span> <span class="cwebmacronumber">25.3</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Set the domain INFS as needed</span> <span class="cwebmacronumber">25.6</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::set_definition_domain is used in <a href="#SP11">&#167;11</a>, <a href="#SP16">&#167;16</a>, <a href="#SP22">&#167;22</a>, <a href="#SP24">&#167;24</a>, <a href="#SP29">&#167;29</a>, <a href="#SP34_1">&#167;34.1</a>.</p>

<p class="inwebparagraph"><a id="SP25_1"></a><b>&#167;25.1.  </b>Note that we throw only one problem message per AM, as otherwise duplication
can't be avoided.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Reject domain of adjective</span> <span class="cwebmacronumber">25.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">early</span><span class="plain">) || (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;problems_thrown</span><span class="plain">++ &gt; 0)) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;defined_at</span><span class="plain">;</span>
        <span class="identifier">Problems::Issue::adjective_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_AdjDomainUnknown</span><span class="plain">),</span>
            <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_index_text</span><span class="plain">, </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_text</span><span class="plain">,</span>
            <span class="string">"this isn't a thing, a kind of thing or a kind of value"</span><span class="plain">,</span>
            <span class="string">"and indeed doesn't have any meaning I can make sense of."</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP25">&#167;25</a> (twice).</p>

<p class="inwebparagraph"><a id="SP25_2"></a><b>&#167;25.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Reject domain as vague</span> <span class="cwebmacronumber">25.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">early</span><span class="plain">) || (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;problems_thrown</span><span class="plain">++ &gt; 0)) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;defined_at</span><span class="plain">;</span>
        <span class="identifier">Problems::Issue::adjective_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_AdjDomainVague</span><span class="plain">),</span>
            <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_index_text</span><span class="plain">, </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_text</span><span class="plain">,</span>
            <span class="string">"this isn't allowed as the domain of a definition"</span><span class="plain">,</span>
            <span class="string">"since it potentially describes many different kinds, not just one."</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP25">&#167;25</a>.</p>

<p class="inwebparagraph"><a id="SP25_3"></a><b>&#167;25.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Reject domain as topic</span> <span class="cwebmacronumber">25.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">early</span><span class="plain">) || (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;problems_thrown</span><span class="plain">++ &gt; 0)) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;defined_at</span><span class="plain">;</span>
        <span class="identifier">Problems::Issue::adjective_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_AdjDomainTopic</span><span class="plain">),</span>
            <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_index_text</span><span class="plain">, </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_text</span><span class="plain">,</span>
            <span class="string">"this isn't allowed as the domain of a definition"</span><span class="plain">,</span>
            <span class="string">"because 'topic' doesn't behave the way other kinds of value do when "</span>
            <span class="string">"it comes to making comparisons."</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP25">&#167;25</a>.</p>

<p class="inwebparagraph"><a id="SP25_4"></a><b>&#167;25.4.  </b>Similarly:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Reject domain of adjective unless a kind of value or description of objects</span> <span class="cwebmacronumber">25.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">supplied</span><span class="plain">, </span><span class="constant">CONSTANT_NT</span><span class="plain">)) &amp;&amp;</span>
            <span class="plain">(</span><span class="functiontext">Specifications::is_description_like</span><span class="plain">(</span><span class="identifier">supplied</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="functiontext">Rvalues::to_instance</span><span class="plain">(</span><span class="identifier">supplied</span><span class="plain">) == </span><span class="identifier">NULL</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">early</span><span class="plain">) || (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;problems_thrown</span><span class="plain">++ &gt; 0)) </span><span class="reserved">return</span><span class="plain">;</span>
            <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;defined_at</span><span class="plain">;</span>
            <span class="identifier">Problems::Issue::adjective_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_AdjDomainSurreal</span><span class="plain">),</span>
                <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_index_text</span><span class="plain">, </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_text</span><span class="plain">,</span>
                <span class="string">"this isn't allowed as the domain of a definition"</span><span class="plain">,</span>
                <span class="string">"since adjectives like this can be applied only to specific things, "</span>
                <span class="string">"kinds of things or kinds of values: so 'Definition: a door is ajar "</span>
                <span class="string">"if...' is fine, because a door is a kind of thing, and 'Definition: "</span>
                <span class="string">"a number is prime if ...' is fine too, but 'Definition: 5 is prime "</span>
                <span class="string">"if ...' is not allowed."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP25">&#167;25</a>.</p>

<p class="inwebparagraph"><a id="SP25_5"></a><b>&#167;25.5.  </b>And a final possible objection:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Reject domain of adjective if it is a set of objects which may vary in play</span> <span class="cwebmacronumber">25.5</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Descriptions::is_qualified</span><span class="plain">(</span><span class="identifier">supplied</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;problems_thrown</span><span class="plain">++ &gt; 0) </span><span class="reserved">return</span><span class="plain">;</span>
            <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;defined_at</span><span class="plain">;</span>
            <span class="identifier">Problems::Issue::adjective_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_AdjDomainSlippery</span><span class="plain">),</span>
                <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_index_text</span><span class="plain">, </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_text</span><span class="plain">,</span>
                <span class="string">"this is slippery"</span><span class="plain">,</span>
                <span class="string">"because it can change during play. Definitions can only be "</span>
                <span class="string">"made in cases where it's clear for any given value or object "</span>
                <span class="string">"what definition will apply. For instance, 'Definition: a "</span>
                <span class="string">"door is shiny if ...' is fine, but 'Definition: an open "</span>
                <span class="string">"door is shiny if ...' is not allowed - Inform wouldn't know "</span>
                <span class="string">"whether or not to apply it to the Big Blue Door (say), since "</span>
                <span class="string">"it would only apply some of the time."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP25">&#167;25</a>.</p>

<p class="inwebparagraph"><a id="SP25_6"></a><b>&#167;25.6.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Set the domain INFS as needed</span> <span class="cwebmacronumber">25.6</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain"> = </span><span class="functiontext">Rvalues::to_object_instance</span><span class="plain">(</span><span class="identifier">supplied</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain">) </span><span class="identifier">supplied</span><span class="plain"> = </span><span class="functiontext">Rvalues::from_instance</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::lt</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">))</span>
            <span class="identifier">supplied</span><span class="plain"> = </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::from_specification</span><span class="plain">(</span><span class="identifier">supplied</span><span class="plain">);</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_kind</span><span class="plain"> = </span><span class="identifier">K</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP25">&#167;25</a>.</p>

<p class="inwebparagraph"><a id="SP26"></a><b>&#167;26. Comparing domains of validity. </b>In order to sort AMs into logical precedence order, we rely on the
following routine, which like <code class="display"><span class="extract">strcmp</span></code> returns a positive number to favour
the first term, a negative to favour the second, and zero if they are
equally good. Note that zero is only in fact returned when the two AMs
compared are one and the same &mdash; we want to ensure that there is one
and only one possible sorted state for any given list of AMs.
</p>

<p class="inwebparagraph">Suppose the adjectives A_1 and A_2 have domain sets D_1 and D_2. Then:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(i) If D_1⊆ D_2 and D_1!= D_2, then A_1 precedes A_2.
</li><li>(ii) If D_2⊆ D_1 and D_2!= D_1, then A_2 precedes A_1.
</li><li>(iii) If D_1 = D_2 or if D_1∩ D_2 = ∅ then we have to be
pragmatic: see below.
</li></ul>
<p class="inwebparagraph">Those are the only possibilities; the range of possible domains is set up
so that there can never be an interesting Venn diagram of overlaps
between them.
</p>

<p class="inwebparagraph">Unlike our weak domain tests above, this is a strict test.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::compare</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am1</span><span class="plain">, </span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am2</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am1</span><span class="plain"> == </span><span class="identifier">am2</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> 0;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">am1</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain">) &amp;&amp; (</span><span class="identifier">am2</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> 1;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">am1</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) &amp;&amp; (</span><span class="identifier">am2</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> -1;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">InferenceSubjects::is_strictly_within</span><span class="plain">(</span><span class="identifier">am1</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain">, </span><span class="identifier">am2</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> 1;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">InferenceSubjects::is_strictly_within</span><span class="plain">(</span><span class="identifier">am2</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain">, </span><span class="identifier">am1</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> -1;</span>

        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K1</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::as_nonobject_kind</span><span class="plain">(</span><span class="identifier">am1</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain">);</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K2</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::as_nonobject_kind</span><span class="plain">(</span><span class="identifier">am2</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">K1</span><span class="plain">) &amp;&amp; (</span><span class="identifier">K2</span><span class="plain">)) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">c1</span><span class="plain"> = </span><span class="identifier">Kinds::Compare::compatible</span><span class="plain">(</span><span class="identifier">K1</span><span class="plain">, </span><span class="identifier">K2</span><span class="plain">);</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">c2</span><span class="plain"> = </span><span class="identifier">Kinds::Compare::compatible</span><span class="plain">(</span><span class="identifier">K2</span><span class="plain">, </span><span class="identifier">K1</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">c1</span><span class="plain"> == </span><span class="identifier">ALWAYS_MATCH</span><span class="plain">) &amp;&amp; (</span><span class="identifier">c2</span><span class="plain"> != </span><span class="identifier">ALWAYS_MATCH</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> 1;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">c1</span><span class="plain"> != </span><span class="identifier">ALWAYS_MATCH</span><span class="plain">) &amp;&amp; (</span><span class="identifier">c2</span><span class="plain"> == </span><span class="identifier">ALWAYS_MATCH</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> -1;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am1</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain"> == </span><span class="identifier">am2</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain">)</span>
            &lt;<span class="cwebmacro">Worry about definitions of the same adjective on the same domain</span> <span class="cwebmacronumber">26.1</span>&gt;<span class="plain">;</span>

        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">am2</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain"> - </span><span class="identifier">am1</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::compare is used in <a href="#SP16">&#167;16</a>.</p>

<p class="inwebparagraph"><a id="SP26_1"></a><b>&#167;26.1.  </b>In general, it's an error to define the same adjective on the same domain
twice, except for a redefinition in the source text of a definition in an
extension. (We exclude enumerative adjectives because they are defined
internally by a method which involves occasional duplication but where
the duplicates are all mutually consistent; these do not arise from the
author's source text.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Worry about definitions of the same adjective on the same domain</span> <span class="cwebmacronumber">26.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">am1</span><span class="plain">-</span><span class="element">&gt;defined_at</span><span class="plain">))) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">am2</span><span class="plain">-</span><span class="element">&gt;defined_at</span><span class="plain">))) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">am1</span><span class="plain">-</span><span class="element">&gt;adjective_form</span><span class="plain"> != </span><span class="constant">ENUMERATIVE_KADJ</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">am2</span><span class="plain">-</span><span class="element">&gt;adjective_form</span><span class="plain"> != </span><span class="constant">ENUMERATIVE_KADJ</span><span class="plain">)) {</span>
            <span class="reserved">extension_file</span><span class="plain"> *</span><span class="identifier">ef1</span><span class="plain"> =</span>
                <span class="functiontext">SourceFiles::get_extension_corresponding</span><span class="plain">(</span>
                    <span class="identifier">Lexer::file_of_origin</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">am1</span><span class="plain">-</span><span class="element">&gt;defined_at</span><span class="plain">))));</span>
            <span class="reserved">extension_file</span><span class="plain"> *</span><span class="identifier">ef2</span><span class="plain"> =</span>
                <span class="functiontext">SourceFiles::get_extension_corresponding</span><span class="plain">(</span>
                    <span class="identifier">Lexer::file_of_origin</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">am2</span><span class="plain">-</span><span class="element">&gt;defined_at</span><span class="plain">))));</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">ef1</span><span class="plain"> == </span><span class="identifier">ef2</span><span class="plain">) || ((</span><span class="identifier">ef1</span><span class="plain">) &amp;&amp; (</span><span class="identifier">ef2</span><span class="plain">))) {</span>
                <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">am1</span><span class="plain">-</span><span class="element">&gt;defined_at</span><span class="plain">;</span>
                <span class="identifier">Problems::quote_wording_as_source</span><span class="plain">(1, </span><span class="identifier">am1</span><span class="plain">-</span><span class="element">&gt;adjective_index_text</span><span class="plain">);</span>
                <span class="identifier">Problems::quote_wording_as_source</span><span class="plain">(2, </span><span class="identifier">am2</span><span class="plain">-</span><span class="element">&gt;adjective_index_text</span><span class="plain">);</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_AdjDomainDuplicated</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"The definitions %1 and %2 both try to cover the same situation: "</span>
                    <span class="string">"the same adjective applied to the exact same range. %P"</span>
                    <span class="string">"It's okay to override a definition in an extension with another "</span>
                    <span class="string">"one in the main source text, but it's not okay to define the same "</span>
                    <span class="string">"adjective twice over the same domain in the same file."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ef1</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> 1;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ef2</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> -1;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP26">&#167;26</a>.</p>

<p class="inwebparagraph"><a id="SP27"></a><b>&#167;27. Testing and asserting in play. </b>Now for testing, making true and making false in play. We won't be there when
the story file is played, of course, so what we have to do is to compile code
to perform the test or force the state.
</p>

<p class="inwebparagraph">In fact what we do is to supply an I6 schema, which for this purpose is
simply the text of I6 code in which the escape <code class="display"><span class="extract">*1</span></code> represents the value
to which the adjective is applied. In the example of "open" for containers,
we might choose:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">if the sack is open, ...  --&gt;   (Adj_53_t1_v61(*1))</span>
        <span class="plain">now the sack is open; ...  --&gt;   Adj_53_t2_v61(*1)</span>
        <span class="plain">now the sack is not open; ...  --&gt;   Adj_53_t3_v61(*1)</span>
</pre>

<p class="inwebparagraph">These schemas call an I6 routine called a "support routine". The names
here are schematic: "open" on this run was APH number 53, the run-time
tasks to perform were task 1, task 2 and task 3, and the sense of the
adjective was the one applying to domain 61 &mdash; which in this example run
was the weak ID of "object". In other words, these are routines to "test
open in the sense of objects", "now open in the sense of objects", and
"now not open in the sense of objects".
</p>

<p class="inwebparagraph">If we make a choice like that, then we say that the task is provided
"via a support routine". We need not do so: for instance,
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">if the Entire Game is happening, ...  --&gt;  (scene_status-&gt;(*1 - 1)==1)</span>
</pre>

<p class="inwebparagraph">is an example where the sense of "happening" for scenes can be tested
directly using a schema, without calling a support routine. And clearly
support routines only put off the problem, because we will also have to
compile the routine itself. So why use them? The answer is that in
complicated situations where run-time type checking is needed, they
avoid duplication of code, and can make repeated use of the <code class="display"><span class="extract">*1</span></code> value
without repeating any side-effects produced by the calculation of this
value. They also make the code simpler for human eyes to read.
</p>

<p class="inwebparagraph"><a id="SP28"></a><b>&#167;28.  </b>When an AM has been declared, the provider can choose to set an I6
schema for it, for any of the tasks, immediately; or can wait and do it
later; or can choose not to do it, and instead provide code which
generates a suitable schema on the fly. If at whatever stage the
provider does set an I6 schema for a task, it should call the following.
</p>

<p class="inwebparagraph">Note that any AM working on objects always has to go via a support
routine &mdash; this is because, thanks to weak domain-checking, there may
be run-time type-checking code to apply. In other cases, the provider
can choose to go via a support routine or not.
</p>


<pre class="display">
    <span class="reserved">i6_schema</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::set_i6_schema</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">,</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">T</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">via_support</span><span class="plain">) {</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::get_domain</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">K_object</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)) </span><span class="identifier">via_support</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;task_via_support_routine</span><span class="plain">[</span><span class="identifier">T</span><span class="plain">] = </span><span class="identifier">via_support</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> &amp;(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;i6s_for_runtime_task</span><span class="plain">[</span><span class="identifier">T</span><span class="plain">]);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::set_i6_schema is used in <a href="#SP31">&#167;31</a>, 5/ins (<a href="5-ins.html#SP38_3">&#167;38.3</a>), 15/ep (<a href="15-ep.html#SP15_1">&#167;15.1</a>, <a href="15-ep.html#SP15_2">&#167;15.2</a>), 15/ma (<a href="15-ma.html#SP12">&#167;12</a>), 23/abrp (<a href="23-abrp.html#SP2">&#167;2</a>), 23/abrc (<a href="23-abrc.html#SP2">&#167;2</a>), 23/abp (<a href="23-abp.html#SP1">&#167;1</a>).</p>

<p class="inwebparagraph"><a id="SP29"></a><b>&#167;29.  </b>When Inform's code-generator needs to compile one of the tasks, then, it
calls the following to obtain the correct I6 schema.
</p>

<p class="inwebparagraph">Note that the <code class="display"><span class="extract">task_via_support_routine</span></code> values are not flags: they can be
<code class="display"><span class="extract">TRUE</span></code> (allowed, done via support routine), <code class="display"><span class="extract">FALSE</span></code> (allowed, done directly)
or <code class="display"><span class="extract">NOT_APPLICABLE</span></code> (the task certainly can't be done). If none of the
applicable meanings for the adjective are able to perform the task at
run-time, we return <code class="display"><span class="extract">NULL</span></code> as our schema, and the code-generator will use
that to issue a suitable problem message.
</p>


<pre class="display">
    <span class="reserved">i6_schema</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::get_i6_schema</span><span class="plain">(</span><span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">,</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">kind_domain</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">T</span><span class="plain">) {</span>
        <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">kind_domain</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">kind_domain</span><span class="plain"> = </span><span class="identifier">K_object</span><span class="plain">;</span>
        <span class="functiontext">Adjectives::Meanings::sort</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">);</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;sorted_meanings</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">; </span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain">) {</span>
            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">am_kind</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::get_domain</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am_kind</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="functiontext">Adjectives::Meanings::set_definition_domain</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Adjectives::Meanings::domain_weak_match</span><span class="plain">(</span><span class="identifier">kind_domain</span><span class="plain">, </span><span class="identifier">am_kind</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">continue</span><span class="plain">;</span>
            <span class="functiontext">Adjectives::Meanings::compiling_soon</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">T</span><span class="plain">);</span>
            <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;task_via_support_routine</span><span class="plain">[</span><span class="identifier">T</span><span class="plain">]) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> &amp;(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;i6s_for_runtime_task</span><span class="plain">[</span><span class="identifier">T</span><span class="plain">]);</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">:</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Schemas::empty</span><span class="plain">(&amp;(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;i6s_to_transfer_to_SR</span><span class="plain">[</span><span class="identifier">T</span><span class="plain">])))</span>
                        &lt;<span class="cwebmacro">Construct a schema for this adjective, using the standard routine naming</span> <span class="cwebmacronumber">29.1</span>&gt;<span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain"> &amp;(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;i6s_to_transfer_to_SR</span><span class="plain">[</span><span class="identifier">T</span><span class="plain">]);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::get_i6_schema is used in <a href="#SP30">&#167;30</a>, 12/ca (<a href="12-ca.html#SP6_6">&#167;6.6</a>).</p>

<p class="inwebparagraph"><a id="SP29_1"></a><b>&#167;29.1.  </b>Where the following is complicated by the need to respect negations; it may
be that the original adjective has a support routine defined, but that the
negation does not, and so must use those of the original.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Construct a schema for this adjective, using the standard routine naming</span> <span class="cwebmacronumber">29.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain"> = </span><span class="identifier">T</span><span class="plain">; </span><span class="reserved">char</span><span class="plain"> *</span><span class="identifier">negation_operator</span><span class="plain"> = </span><span class="string">""</span><span class="plain">;</span>
        <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">use_aph</span><span class="plain"> = </span><span class="identifier">aph</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;am_negated_from</span><span class="plain">) {</span>
            <span class="identifier">use_aph</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;am_negated_from</span><span class="plain">-</span><span class="element">&gt;owning_adjective</span><span class="plain">;</span>
            <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">T</span><span class="plain">) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">TEST_ADJECTIVE_TASK</span><span class="plain">: </span><span class="identifier">negation_operator</span><span class="plain"> = </span><span class="string">"~~"</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain">: </span><span class="identifier">task</span><span class="plain"> = </span><span class="constant">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain">: </span><span class="identifier">task</span><span class="plain"> = </span><span class="constant">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::iname</span><span class="plain">(</span><span class="identifier">use_aph</span><span class="plain">, </span><span class="identifier">task</span><span class="plain">, </span><span class="functiontext">Kinds::RunTime::weak_id</span><span class="plain">(</span><span class="identifier">am_kind</span><span class="plain">));</span>
        <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(&amp;(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;i6s_to_transfer_to_SR</span><span class="plain">[</span><span class="identifier">T</span><span class="plain">]), </span><span class="string">"*=-(%s%n(*1))"</span><span class="plain">,</span>
            <span class="identifier">negation_operator</span><span class="plain">, </span><span class="identifier">iname</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP29">&#167;29</a>.</p>

<p class="inwebparagraph"><a id="SP30"></a><b>&#167;30.  </b>The following is needed when making sense of the I6-to-I7 escape sequence
<code class="display"><span class="extract">(+ adj +)</span></code>, where <code class="display"><span class="extract">adj</span></code> is the name of an adjective. Since I6 is typeless,
there's no good way to choose which sense of the adjective is meant, so we
don't know which routine to expand out. The convention is: a meaning for
objects, if there is one; otherwise the first-declared meaning.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::write_adjective_test_routine</span><span class="plain">(</span><span class="identifier">value_holster</span><span class="plain"> *</span><span class="identifier">VH</span><span class="plain">,</span>
        <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">) {</span>
        <span class="reserved">i6_schema</span><span class="plain"> *</span><span class="identifier">sch</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">weak_id</span><span class="plain"> = </span><span class="functiontext">Kinds::RunTime::weak_id</span><span class="plain">(</span><span class="identifier">K_object</span><span class="plain">);</span>
        <span class="identifier">sch</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::get_i6_schema</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">,</span>
            <span class="constant">TEST_ADJECTIVE_TASK</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sch</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;possible_meanings</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">am_kind</span><span class="plain"> =</span>
                <span class="functiontext">Adjectives::Meanings::get_domain</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;possible_meanings</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am_kind</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="identifier">weak_id</span><span class="plain"> = </span><span class="functiontext">Kinds::RunTime::weak_id</span><span class="plain">(</span><span class="identifier">am_kind</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Adjectives::Meanings::iname</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="constant">TEST_ADJECTIVE_TASK</span><span class="plain">, </span><span class="identifier">weak_id</span><span class="plain">));</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::write_adjective_test_routine is used in 25/cii (<a href="25-cii.html#SP8">&#167;8</a>).</p>

<p class="inwebparagraph"><a id="SP31"></a><b>&#167;31.  </b>The following instructs an AM to use a support routine to handle a given
task.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::pass_task_to_support_routine</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">,</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">T</span><span class="plain">) {</span>
        <span class="functiontext">Adjectives::Meanings::set_i6_schema</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::pass_task_to_support_routine is used in 15/ma (<a href="15-ma.html#SP11_5">&#167;11.5</a>), 23/abrp (<a href="23-abrp.html#SP2">&#167;2</a>), 23/abrc (<a href="23-abrc.html#SP2">&#167;2</a>), 23/abp (<a href="23-abp.html#SP1">&#167;1</a>), 23/abc (<a href="23-abc.html#SP1">&#167;1</a>).</p>

<p class="inwebparagraph"><a id="SP32"></a><b>&#167;32.  </b>Some kinds of adjective find it useful to do some preparation work just
before first compilation, but only once. For those, the ready flag is available:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::get_ready_flag</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;am_ready_flag</span><span class="plain">;</span>
    <span class="plain">}</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::set_ready_flag</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">) {</span>
        <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;am_ready_flag</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::get_ready_flag is used in 15/ep (<a href="15-ep.html#SP15">&#167;15</a>).</p>

<p class="endnote">The function Adjectives::Meanings::set_ready_flag is used in 15/ep (<a href="15-ep.html#SP15">&#167;15</a>).</p>

<p class="inwebparagraph"><a id="SP33"></a><b>&#167;33. Support routines. </b>Using these is only passing the buck: and the buck stops here.
</p>

<p class="inwebparagraph">The following utility is used to loop through the sorted meaning list,
skipping over any which have been dealt with already.
</p>


<pre class="display">
    <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::list_next_domain_kind</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> **</span><span class="identifier">K</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">T</span><span class="plain">) {</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">am</span><span class="plain">) &amp;&amp; ((</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;defined_already</span><span class="plain">) || (</span><span class="functiontext">Adjectives::Meanings::compilation_possible</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">T</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)))</span>
            <span class="identifier">am</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="plain">*</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::get_domain</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::list_next_domain_kind is used in <a href="#SP34">&#167;34</a>.</p>

<p class="inwebparagraph"><a id="SP34"></a><b>&#167;34.  </b>And this is where we do the iteration. The idea is that one adjective
definition routine is defined (for each task number) which covers all of
the weakly-domain-equal definitions for the same adjective. Thus one
routine might handle "detailed" for rulebooks, and another might handle
"detailed" for all of its meanings associated with objects &mdash; possibly
many AMs.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::compile_support_code</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        &lt;<span class="cwebmacro">Ensure, just in case, that domains exist and are sorted on</span> <span class="cwebmacronumber">34.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">T</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">T</span><span class="plain">=1; </span><span class="identifier">T</span><span class="plain">&lt;=</span><span class="constant">NO_ADJECTIVE_TASKS</span><span class="plain">; </span><span class="identifier">T</span><span class="plain">++) {</span>
            <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">;</span>
            <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">adjectival_phrase</span><span class="plain">) {</span>
                <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">;</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;possible_meanings</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">; </span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_meaning</span><span class="plain">)</span>
                    <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;defined_already</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;sorted_meanings</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">; ) {</span>
                    <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
                    <span class="identifier">am</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::list_next_domain_kind</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, &amp;</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">T</span><span class="plain">);</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain">)</span>
                        &lt;<span class="cwebmacro">Compile adjective definition for this atomic kind of value</span> <span class="cwebmacronumber">34.2</span>&gt;<span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::compile_support_code is used in 22/cs (<a href="22-cs.html#SP10_4">&#167;10.4</a>).</p>

<p class="inwebparagraph"><a id="SP34_1"></a><b>&#167;34.1.  </b>It's unlikely that we have got this far without the domains for the AMs
having been established, but certainly possible. We need the domains to be
known in order to sort.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Ensure, just in case, that domains exist and are sorted on</span> <span class="cwebmacronumber">34.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">adjectival_phrase</span><span class="plain">) {</span>
            <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;possible_meanings</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">; </span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_meaning</span><span class="plain">) {</span>
                <span class="functiontext">Adjectives::Meanings::set_definition_domain</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
                <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;defined_already</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="functiontext">Adjectives::Meanings::sort</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP34">&#167;34</a>.</p>

<p class="inwebparagraph"><a id="SP34_2"></a><b>&#167;34.2.  </b>The following is a standard way to compile a one-off routine.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Compile adjective definition for this atomic kind of value</span> <span class="cwebmacronumber">34.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Adjectives::get_text</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">VARIABLE_CREATIONS</span><span class="plain">, </span><span class="string">"Compiling support code for %W applying to $u, task %d\</span><span class="plain">n</span><span class="string">"</span><span class="plain">,</span>
            <span class="identifier">W</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">T</span><span class="plain">);</span>

        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::iname</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">T</span><span class="plain">, </span><span class="functiontext">Kinds::RunTime::weak_id</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">));</span>
        <span class="identifier">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="functiontext">Routines::begin</span><span class="plain">(</span><span class="identifier">iname</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">Add an it-variable to represent the value or object in the domain</span> <span class="cwebmacronumber">34.2.1</span>&gt;<span class="plain">;</span>

        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="string">"meaning of \</span><span class="plain">"</span><span class="string">"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="string">"%~W"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="string">"&lt;nameless&gt;"</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="string">"\</span><span class="plain">"</span><span class="string">"</span><span class="plain">);</span>
        <span class="functiontext">Emit::code_comment</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> == 0) {</span>
            <span class="reserved">local_variable</span><span class="plain"> *</span><span class="identifier">it_lv</span><span class="plain"> = </span><span class="functiontext">LocalVariables::it_variable</span><span class="plain">();</span>
            <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">it_s</span><span class="plain"> = </span><span class="functiontext">LocalVariables::declare_this</span><span class="plain">(</span><span class="identifier">it_lv</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, 8);</span>
            <span class="functiontext">Adjectives::Meanings::list_compile</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;sorted_meanings</span><span class="plain">, </span><span class="functiontext">Frames::current_stack_frame</span><span class="plain">(), </span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">it_s</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="identifier">Produce::rfalse</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="functiontext">Routines::end</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP34">&#167;34</a>.</p>

<p class="inwebparagraph"><a id="SP34_2_1"></a><b>&#167;34.2.1.  </b>The stack frame has just one call parameter: the value x which might, or
might not, be such that adjective(x) is true. We allow this to be called
"it", though it can also have a calling name in some cases (see below).
</p>

<p class="inwebparagraph">Clearly it ought to have the kind which defines the domain &mdash; so it's a rulebook
if the domain is all rulebooks, and so on &mdash; but it doesn't always do so. The
exception is that it is bogusly given the kind "number" if the adjective is
being defined only by I6 routines. This is done to avoid compiling very
inefficient code from the Standard Rules. For instance, the SR reads, in
slightly simplified form:
</p>

<blockquote>
    <p>Definition: a text is empty if I6 routine |"TEXT\_TY\_Empty"| says so.</p>

</blockquote>

<p class="inwebparagraph">rather than the more obvious:
</p>

<blockquote>
    <p>Definition: a text is empty if it is not |""|.</p>

</blockquote>

<p class="inwebparagraph">Both of these definitions work. But if the routine defining "empty" for text
is allowed to act on a text variable, Inform needs to compile code which acts
on block values held on the memory heap at run-time. That means it needs to
compile a memory heap; and that costs 8K or so of storage, making large
Z-machine games which don't need text alteration or lists impossible to fit into
the 64K array space limit. (There's also a benefit even if we do need a heap;
the adjective can act on a direct pointer to the structure, and no time is
wasted allocating memory and copying the block value first.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Add an it-variable to represent the value or object in the domain</span> <span class="cwebmacronumber">34.2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">add_K</span><span class="plain"> = </span><span class="identifier">K_number</span><span class="plain">;</span>
        <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">meanings</span><span class="plain">-</span><span class="element">&gt;sorted_meanings</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">; </span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_form</span><span class="plain"> != </span><span class="constant">I6_ROUTINE_KADJ</span><span class="plain">) &amp;&amp;</span>
                <span class="plain">(</span><span class="functiontext">Adjectives::Meanings::domain_weak_match</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="functiontext">Adjectives::Meanings::get_domain</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">))))</span>
                <span class="identifier">add_K</span><span class="plain"> = </span><span class="identifier">K</span><span class="plain">;</span>

        <span class="functiontext">LocalVariables::add_pronoun</span><span class="plain">(</span><span class="functiontext">Frames::current_stack_frame</span><span class="plain">(), </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="identifier">add_K</span><span class="plain">);</span>
        <span class="functiontext">LocalVariables::enable_possessive_form_of_it</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP34_2">&#167;34.2</a>.</p>

<p class="inwebparagraph"><a id="SP35"></a><b>&#167;35.  </b>We run through possible meanings of the APH which share the current weak
domain, and compile code which performs the stronger part of the domain
test at run-time. In practice, at present the only weak domain which might
have multiple definitions is "object", but that may change.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::list_compile</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">list_head</span><span class="plain">,</span>
        <span class="reserved">ph_stack_frame</span><span class="plain"> *</span><span class="identifier">phsf</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">t0_s</span><span class="plain">) {</span>
        <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">list_head</span><span class="plain">; </span><span class="identifier">am</span><span class="plain">; </span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;next_sorted</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">Adjectives::Meanings::compilation_possible</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">T</span><span class="plain">)) &amp;&amp;</span>
                <span class="plain">(</span><span class="functiontext">Adjectives::Meanings::domain_weak_match</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="functiontext">Adjectives::Meanings::get_domain</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">)))) {</span>
                <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;defined_at</span><span class="plain">;</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="functiontext">InferenceSubjects::emit_element_of_condition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain">, </span><span class="identifier">t0_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">RETURN_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;meaning_parity</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">T</span><span class="plain"> == </span><span class="constant">TEST_ADJECTIVE_TASK</span><span class="plain">)) {</span>
                                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">NOT_BIP</span><span class="plain">);</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="plain">}</span>
                            <span class="functiontext">Adjectives::Meanings::emit_meaning</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">phsf</span><span class="plain">);</span>
                            <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;defined_already</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;meaning_parity</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">T</span><span class="plain"> == </span><span class="constant">TEST_ADJECTIVE_TASK</span><span class="plain">)) {</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="plain">}</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::list_compile is used in <a href="#SP34_2">&#167;34.2</a>.</p>

<p class="inwebparagraph"><a id="SP36"></a><b>&#167;36. Kinds of adjectives. </b>This is where <code class="display"><span class="extract">inweb</span></code>'s use of C rather than <code class="display"><span class="extract">C++</span></code> or Python as a base
language becomes a little embarrassing: we really want to have seven or
eight subclasses of an "adjective" class, and provide a group of methods.
Instead we simulate this with the following clumsy code. (More elegant
code using pointers to functions would trip up <code class="display"><span class="extract">inweb</span></code>'s structure-element
usage checking.)
</p>

<p class="inwebparagraph">To define a new kind of adjective, first allocate it a new <code class="display"><span class="extract">*_KADJ</span></code>
constant (see above). Then declare functions to handle the following
methods.
</p>

<p class="inwebparagraph"><a id="SP37"></a><b>&#167;37.  </b>1. <code class="display"><span class="extract">*_KADJ_parse</span></code>. This enables the kind of adjective to claim a definition
which the user has explicitly written, like so:
</p>

<blockquote>
    <p>Definition: A ... (called ...) is ... if ...</p>

</blockquote>

<p class="inwebparagraph">In place of the ellipses are the adjective name, domain name, condition
text and (optionally) also the calling name. The routine should return a
pointer to the AM it creates, if it does want to claim the definition;
and <code class="display"><span class="extract">NULL</span></code> if it doesn't want it. <code class="display"><span class="extract">sense</span></code> is either 1, meaning that
"if" was used (the condition has positive sense); or -1, meaning
that it was "unless" (a negative sense); or 0, meaning that instead
of a condition, a rule was supplied. (Most kinds of adjective will only
claim if the sense is 1; some never claim at all.)
</p>


<pre class="display">
    <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="functiontext">Adjectives::Meanings::parse</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">q</span><span class="plain">,</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">sense</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">AW</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">DNW</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">CONW</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">CALLW</span><span class="plain">) {</span>
        <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">am</span><span class="plain"> = </span><span class="functiontext">Properties::EitherOr::ADJ_parse</span><span class="plain">(</span><span class="identifier">q</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">, </span><span class="identifier">AW</span><span class="plain">, </span><span class="identifier">DNW</span><span class="plain">, </span><span class="identifier">CONW</span><span class="plain">, </span><span class="identifier">CALLW</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">am</span><span class="plain"> = </span><span class="functiontext">Instances::ADJ_parse</span><span class="plain">(</span><span class="identifier">q</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">, </span><span class="identifier">AW</span><span class="plain">, </span><span class="identifier">DNW</span><span class="plain">, </span><span class="identifier">CONW</span><span class="plain">, </span><span class="identifier">CALLW</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">am</span><span class="plain"> = </span><span class="functiontext">Properties::Measurement::ADJ_parse</span><span class="plain">(</span><span class="identifier">q</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">, </span><span class="identifier">AW</span><span class="plain">, </span><span class="identifier">DNW</span><span class="plain">, </span><span class="identifier">CONW</span><span class="plain">, </span><span class="identifier">CALLW</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">am</span><span class="plain"> = </span><span class="functiontext">Phrases::RawCondition::ADJ_parse</span><span class="plain">(</span><span class="identifier">q</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">, </span><span class="identifier">AW</span><span class="plain">, </span><span class="identifier">DNW</span><span class="plain">, </span><span class="identifier">CONW</span><span class="plain">, </span><span class="identifier">CALLW</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">am</span><span class="plain"> = </span><span class="functiontext">Phrases::RawPhrasal::ADJ_parse</span><span class="plain">(</span><span class="identifier">q</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">, </span><span class="identifier">AW</span><span class="plain">, </span><span class="identifier">DNW</span><span class="plain">, </span><span class="identifier">CONW</span><span class="plain">, </span><span class="identifier">CALLW</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">am</span><span class="plain"> = </span><span class="functiontext">Phrases::Phrasal::ADJ_parse</span><span class="plain">(</span><span class="identifier">q</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">, </span><span class="identifier">AW</span><span class="plain">, </span><span class="identifier">DNW</span><span class="plain">, </span><span class="identifier">CONW</span><span class="plain">, </span><span class="identifier">CALLW</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">am</span><span class="plain"> = </span><span class="functiontext">Phrases::Condition::ADJ_parse</span><span class="plain">(</span><span class="identifier">q</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">, </span><span class="identifier">AW</span><span class="plain">, </span><span class="identifier">DNW</span><span class="plain">, </span><span class="identifier">CONW</span><span class="plain">, </span><span class="identifier">CALLW</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">am</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::parse is used in 23/ad (<a href="23-ad.html#SP5_4">&#167;5.4</a>).</p>

<p class="inwebparagraph"><a id="SP38"></a><b>&#167;38.  </b>2. <code class="display"><span class="extract">*_KADJ_compiling_soon</span></code>. This warns the adjective that it will shortly be
needed in compilation, that is, that code will soon be compiled which uses it.
This advance warning is an opportunity to compile a schema for the adjective
at the last minute, but there is no obligation. There is also no return value.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::compiling_soon</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">T</span><span class="plain">) {</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_form</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">CONDITION_KADJ</span><span class="plain">: </span><span class="functiontext">Phrases::Condition::ADJ_compiling_soon</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">,</span>
                <span class="identifier">RETRIEVE_POINTER_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">), </span><span class="identifier">T</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">I6_CONDITION_KADJ</span><span class="plain">: </span><span class="functiontext">Phrases::RawCondition::ADJ_compiling_soon</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">,</span>
                <span class="identifier">RETRIEVE_POINTER_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">), </span><span class="identifier">T</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">I6_ROUTINE_KADJ</span><span class="plain">: </span><span class="functiontext">Phrases::RawPhrasal::ADJ_compiling_soon</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">,</span>
                <span class="identifier">RETRIEVE_POINTER_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">), </span><span class="identifier">T</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">PHRASE_KADJ</span><span class="plain">: </span><span class="functiontext">Phrases::Phrasal::ADJ_compiling_soon</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">,</span>
                <span class="identifier">RETRIEVE_POINTER_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">), </span><span class="identifier">T</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MEASUREMENT_KADJ</span><span class="plain">: </span><span class="functiontext">Properties::Measurement::ADJ_compiling_soon</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">,</span>
                <span class="identifier">RETRIEVE_POINTER_measurement_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">), </span><span class="identifier">T</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">ENUMERATIVE_KADJ</span><span class="plain">: </span><span class="functiontext">Instances::ADJ_compiling_soon</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">,</span>
                <span class="identifier">RETRIEVE_POINTER_instance</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">), </span><span class="identifier">T</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">EORP_KADJ</span><span class="plain">: </span><span class="functiontext">Properties::EitherOr::ADJ_compiling_soon</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">,</span>
                <span class="identifier">RETRIEVE_POINTER_property</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">), </span><span class="identifier">T</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::compiling_soon is used in <a href="#SP29">&#167;29</a>, <a href="#SP39">&#167;39</a>.</p>

<p class="inwebparagraph"><a id="SP39"></a><b>&#167;39.  </b>3. <code class="display"><span class="extract">*_KADJ_compile</span></code>. We should now either compile code which, in the
given stack frame and writing code to the given file handle, carries out the
given task for the adjective, and return <code class="display"><span class="extract">TRUE</span></code>; or return <code class="display"><span class="extract">FALSE</span></code> to
tell Inform that the task is impossible.
</p>

<p class="inwebparagraph">Note that if an adjective has defined a schema to handle the task, then its
<code class="display"><span class="extract">*_KADJ_compile</span></code> is not needed and not consulted.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::emit_meaning</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">T</span><span class="plain">, </span><span class="reserved">ph_stack_frame</span><span class="plain"> *</span><span class="identifier">phsf</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::compile_inner</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">phsf</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::compilation_possible</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">T</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::compile_inner</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::compile_inner</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">T</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">emit_flag</span><span class="plain">, </span><span class="reserved">ph_stack_frame</span><span class="plain"> *</span><span class="identifier">phsf</span><span class="plain">) {</span>
        <span class="functiontext">Adjectives::Meanings::compiling_soon</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">T</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">Use the I6 schema instead to compile the task, if one exists</span> <span class="cwebmacronumber">39.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_form</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">CONDITION_KADJ</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Phrases::Condition::ADJ_compile</span><span class="plain">(</span>
                <span class="identifier">RETRIEVE_POINTER_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">), </span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">emit_flag</span><span class="plain">, </span><span class="identifier">phsf</span><span class="plain">);</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">I6_ROUTINE_KADJ</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Phrases::RawPhrasal::ADJ_compile</span><span class="plain">(</span>
                <span class="identifier">RETRIEVE_POINTER_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">), </span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">emit_flag</span><span class="plain">, </span><span class="identifier">phsf</span><span class="plain">);</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">I6_CONDITION_KADJ</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Phrases::RawCondition::ADJ_compile</span><span class="plain">(</span>
                <span class="identifier">RETRIEVE_POINTER_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">), </span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">emit_flag</span><span class="plain">, </span><span class="identifier">phsf</span><span class="plain">);</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">PHRASE_KADJ</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Phrases::Phrasal::ADJ_compile</span><span class="plain">(</span>
                <span class="identifier">RETRIEVE_POINTER_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">), </span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">emit_flag</span><span class="plain">, </span><span class="identifier">phsf</span><span class="plain">);</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MEASUREMENT_KADJ</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Properties::Measurement::ADJ_compile</span><span class="plain">(</span>
                <span class="identifier">RETRIEVE_POINTER_measurement_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">), </span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">emit_flag</span><span class="plain">, </span><span class="identifier">phsf</span><span class="plain">);</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">ENUMERATIVE_KADJ</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Instances::ADJ_compile</span><span class="plain">(</span>
                <span class="identifier">RETRIEVE_POINTER_instance</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">), </span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">emit_flag</span><span class="plain">, </span><span class="identifier">phsf</span><span class="plain">);</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">EORP_KADJ</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::ADJ_compile</span><span class="plain">(</span>
                <span class="identifier">RETRIEVE_POINTER_property</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">), </span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">emit_flag</span><span class="plain">, </span><span class="identifier">phsf</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"unknown KADJ code"</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::emit_meaning is used in <a href="#SP35">&#167;35</a>.</p>

<p class="endnote">The function Adjectives::Meanings::compilation_possible is used in <a href="#SP33">&#167;33</a>, <a href="#SP35">&#167;35</a>.</p>

<p class="endnote">The function Adjectives::Meanings::compile_inner appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP39_1"></a><b>&#167;39.1.  </b>We expand the I6 schema, placing the "it" variable &mdash; a nameless call
parameter which is always local variable number 0 for this stack frame &mdash;
into <code class="display"><span class="extract">*1</span></code>.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Use the I6 schema instead to compile the task, if one exists</span> <span class="cwebmacronumber">39.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Schemas::empty</span><span class="plain">(&amp;(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;i6s_for_runtime_task</span><span class="plain">[</span><span class="identifier">T</span><span class="plain">])) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">emit_flag</span><span class="plain">) {</span>
                <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">it_var</span><span class="plain"> = </span><span class="functiontext">Lvalues::new_LOCAL_VARIABLE</span><span class="plain">(</span><span class="identifier">EMPTY_WORDING</span><span class="plain">,</span>
                    <span class="functiontext">LocalVariables::it_variable</span><span class="plain">());</span>
                <span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">it_term</span><span class="plain"> = </span><span class="functiontext">Calculus::Terms::new_constant</span><span class="plain">(</span><span class="identifier">it_var</span><span class="plain">);</span>
                <span class="functiontext">Calculus::Schemas::emit_expand_from_terms</span><span class="plain">(&amp;(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;i6s_for_runtime_task</span><span class="plain">[</span><span class="identifier">T</span><span class="plain">]), &amp;</span><span class="identifier">it_term</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP39">&#167;39</a>.</p>

<p class="inwebparagraph"><a id="SP40"></a><b>&#167;40.  </b>4. <code class="display"><span class="extract">*_KADJ_assert</span></code>. We should now either take action to ensure that
the adjective will hold (or not hold, according to <code class="display"><span class="extract">parity</span></code>) for the given
object or value; or return <code class="display"><span class="extract">FALSE</span></code> to tell Inform that this cannot be
asserted, which will trigger a problem message.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::assert_single</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">, </span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs_to_assert_on</span><span class="plain">,</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">val_to_assert_on</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">parity</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;meaning_parity</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="identifier">am</span><span class="plain"> = </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;am_negated_from</span><span class="plain">; </span><span class="identifier">parity</span><span class="plain"> = (</span><span class="identifier">parity</span><span class="plain">)?</span><span class="identifier">FALSE</span><span class="plain">:</span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_form</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">CONDITION_KADJ</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Phrases::Condition::ADJ_assert</span><span class="plain">(</span>
                <span class="identifier">RETRIEVE_POINTER_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">),</span>
                <span class="identifier">infs_to_assert_on</span><span class="plain">, </span><span class="identifier">val_to_assert_on</span><span class="plain">, </span><span class="identifier">parity</span><span class="plain">);</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">I6_CONDITION_KADJ</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Phrases::RawCondition::ADJ_assert</span><span class="plain">(</span>
                <span class="identifier">RETRIEVE_POINTER_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">),</span>
                <span class="identifier">infs_to_assert_on</span><span class="plain">, </span><span class="identifier">val_to_assert_on</span><span class="plain">, </span><span class="identifier">parity</span><span class="plain">);</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">I6_ROUTINE_KADJ</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Phrases::RawPhrasal::ADJ_assert</span><span class="plain">(</span>
                <span class="identifier">RETRIEVE_POINTER_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">),</span>
                <span class="identifier">infs_to_assert_on</span><span class="plain">, </span><span class="identifier">val_to_assert_on</span><span class="plain">, </span><span class="identifier">parity</span><span class="plain">);</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">PHRASE_KADJ</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Phrases::Phrasal::ADJ_assert</span><span class="plain">(</span>
                <span class="identifier">RETRIEVE_POINTER_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">),</span>
                <span class="identifier">infs_to_assert_on</span><span class="plain">, </span><span class="identifier">val_to_assert_on</span><span class="plain">, </span><span class="identifier">parity</span><span class="plain">);</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">MEASUREMENT_KADJ</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Properties::Measurement::ADJ_assert</span><span class="plain">(</span>
                <span class="identifier">RETRIEVE_POINTER_measurement_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">),</span>
                <span class="identifier">infs_to_assert_on</span><span class="plain">, </span><span class="identifier">val_to_assert_on</span><span class="plain">, </span><span class="identifier">parity</span><span class="plain">);</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">ENUMERATIVE_KADJ</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Instances::ADJ_assert</span><span class="plain">(</span>
                <span class="identifier">RETRIEVE_POINTER_instance</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">),</span>
                <span class="identifier">infs_to_assert_on</span><span class="plain">, </span><span class="identifier">val_to_assert_on</span><span class="plain">, </span><span class="identifier">parity</span><span class="plain">);</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">EORP_KADJ</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Properties::EitherOr::ADJ_assert</span><span class="plain">(</span>
                <span class="identifier">RETRIEVE_POINTER_property</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">),</span>
                <span class="identifier">infs_to_assert_on</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">parity</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"unknown KADJ code"</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::assert_single is used in <a href="#SP13">&#167;13</a>.</p>

<p class="inwebparagraph"><a id="SP41"></a><b>&#167;41.  </b>5. <code class="display"><span class="extract">*_KADJ_index</span></code>. This should print a description of the adjective to the
index, for use in the Phrasebook lexicon. Note that it is only needed where
the AM has been constructed positively, that is, it is not needed if the
AM was made as a negation of something else.
</p>

<p class="inwebparagraph">Note also that if the AM was defined with any indexing text then that will
be printed if the routine does nothing better.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::print_to_index</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">rv</span><span class="plain">;</span>
        &lt;<span class="cwebmacro">Index the domain of validity of the AM</span> <span class="cwebmacronumber">41.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;am_negated_from</span><span class="plain">) {</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Adjectives::get_text</span><span class="plain">(</span>
                <span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;am_negated_from</span><span class="plain">-</span><span class="element">&gt;owning_adjective</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" opposite of &lt;/i&gt;%+W&lt;i&gt;"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_form</span><span class="plain">) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">CONDITION_KADJ</span><span class="plain">: </span><span class="identifier">rv</span><span class="plain"> = </span><span class="functiontext">Phrases::Condition::ADJ_index</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">,</span>
                    <span class="identifier">RETRIEVE_POINTER_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">)); </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">I6_CONDITION_KADJ</span><span class="plain">: </span><span class="identifier">rv</span><span class="plain"> = </span><span class="functiontext">Phrases::RawCondition::ADJ_index</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">,</span>
                    <span class="identifier">RETRIEVE_POINTER_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">)); </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">I6_ROUTINE_KADJ</span><span class="plain">: </span><span class="identifier">rv</span><span class="plain"> = </span><span class="functiontext">Phrases::RawPhrasal::ADJ_index</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">,</span>
                    <span class="identifier">RETRIEVE_POINTER_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">)); </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">PHRASE_KADJ</span><span class="plain">: </span><span class="identifier">rv</span><span class="plain"> = </span><span class="functiontext">Phrases::Phrasal::ADJ_index</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">,</span>
                    <span class="identifier">RETRIEVE_POINTER_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">)); </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">MEASUREMENT_KADJ</span><span class="plain">: </span><span class="identifier">rv</span><span class="plain"> = </span><span class="functiontext">Properties::Measurement::ADJ_index</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">,</span>
                    <span class="identifier">RETRIEVE_POINTER_measurement_definition</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">)); </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">ENUMERATIVE_KADJ</span><span class="plain">: </span><span class="identifier">rv</span><span class="plain"> = </span><span class="functiontext">Instances::ADJ_index</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">,</span>
                    <span class="identifier">RETRIEVE_POINTER_instance</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">)); </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">EORP_KADJ</span><span class="plain">: </span><span class="identifier">rv</span><span class="plain"> = </span><span class="functiontext">Properties::EitherOr::ADJ_index</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">,</span>
                    <span class="identifier">RETRIEVE_POINTER_property</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;detailed_meaning</span><span class="plain">)); </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">default</span><span class="plain">: </span><span class="identifier">rv</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">rv</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_index_text</span><span class="plain">)))</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_index_text</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_index_text</span><span class="plain">))</span>
            <span class="identifier">Index::link</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;adjective_index_text</span><span class="plain">));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::print_to_index appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP41_1"></a><b>&#167;41.1.  </b>This is supposed to imitate dictionaries, distinguishing meanings by
concisely showing their usage. Thus "empty" would have indexed entries
prefaced "(of a rulebook)", "(of an activity)", and so on.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Index the domain of validity of the AM</span> <span class="cwebmacronumber">41.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain">)</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"(of &lt;/i&gt;%+W&lt;i&gt;) "</span><span class="plain">, </span><span class="functiontext">InferenceSubjects::get_name_text</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">-</span><span class="element">&gt;domain_infs</span><span class="plain">));</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP41">&#167;41</a>.</p>

<p class="inwebparagraph"><a id="SP42"></a><b>&#167;42. Parsing for adaptive text. </b></p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">adaptive</span><span class="plain">-</span><span class="identifier">adjective</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">language_of_play</span><span class="plain"> == </span><span class="identifier">English_language</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">adjectival_phrase</span><span class="plain">) {</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">AW</span><span class="plain"> = </span><span class="identifier">Clusters::get_name_general</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">adjective_names</span><span class="plain">, </span><span class="identifier">language_of_play</span><span class="plain">, 1, -1);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::match</span><span class="plain">(</span><span class="identifier">AW</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)) {</span>
                <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">aph</span><span class="plain">; *</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP43"></a><b>&#167;43.  </b>Compiling to:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::agreements</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">language_of_play</span><span class="plain"> == </span><span class="identifier">English_language</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">adjectival_phrase</span><span class="plain">) {</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">Clusters::get_name_general</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">adjective_names</span><span class="plain">, </span><span class="identifier">language_of_play</span><span class="plain">, 1, -1);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">PW</span><span class="plain">)) </span><span class="reserved">continue</span><span class="plain">;</span>

            <span class="identifier">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="functiontext">Routines::begin</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">aph_iname</span><span class="plain">);</span>
            <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">o_s</span><span class="plain"> = </span><span class="functiontext">LocalVariables::add_named_call_as_symbol</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"o"</span><span class="plain">);</span>
            <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">force_plural_s</span><span class="plain"> = </span><span class="functiontext">LocalVariables::add_named_call_as_symbol</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"force_plural"</span><span class="plain">);</span>
            <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">gna_s</span><span class="plain"> = </span><span class="functiontext">LocalVariables::add_internal_local_as_symbol</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"gna"</span><span class="plain">);</span>

            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IFELSE_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">o_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val_nothing</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gna_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 6);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gna_s</span><span class="plain">);</span>
                        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">GETGNAOFOBJECT_HL</span><span class="plain">);</span>
                        <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">iname</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">o_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">force_plural_s</span><span class="plain">);</span>
                <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IFELSE_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">NE_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">PRIOR_NAMED_LIST_GENDER_HL</span><span class="plain">));</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) -1);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gna_s</span><span class="plain">);</span>
                                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PLUS_BIP</span><span class="plain">);</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 3);</span>
                                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">PRIOR_NAMED_LIST_GENDER_HL</span><span class="plain">));</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gna_s</span><span class="plain">);</span>
                                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 3);</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gna_s</span><span class="plain">);</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">MODULO_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gna_s</span><span class="plain">);</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 6);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">SWITCH_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">gna_s</span><span class="plain">);</span>
                <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">gna</span><span class="plain">=0; </span><span class="identifier">gna</span><span class="plain">&lt;6; </span><span class="identifier">gna</span><span class="plain">++) {</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">CASE_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="identifier">gna</span><span class="plain">);</span>
                            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINT_BIP</span><span class="plain">);</span>
                                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                    <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">);</span>
                                    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">number_sought</span><span class="plain"> = 1, </span><span class="identifier">gender_sought</span><span class="plain"> = </span><span class="identifier">NEUTER_GENDER</span><span class="plain">;</span>
                                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gna</span><span class="plain">%3 == 0) </span><span class="identifier">gender_sought</span><span class="plain"> = </span><span class="identifier">MASCULINE_GENDER</span><span class="plain">;</span>
                                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gna</span><span class="plain">%3 == 1) </span><span class="identifier">gender_sought</span><span class="plain"> = </span><span class="identifier">FEMININE_GENDER</span><span class="plain">;</span>
                                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">gna</span><span class="plain"> &gt;= 3) </span><span class="identifier">number_sought</span><span class="plain"> = 2;</span>
                                    <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">AW</span><span class="plain"> = </span><span class="identifier">Clusters::get_name_general</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">adjective_names</span><span class="plain">,</span>
                                        <span class="identifier">language_of_play</span><span class="plain">, </span><span class="identifier">number_sought</span><span class="plain">, </span><span class="identifier">gender_sought</span><span class="plain">);</span>
                                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">AW</span><span class="plain">)) </span><span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">, </span><span class="string">"%W"</span><span class="plain">, </span><span class="identifier">AW</span><span class="plain">);</span>
                                    <span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">, </span><span class="string">"%W"</span><span class="plain">, </span><span class="identifier">PW</span><span class="plain">);</span>
                                    <span class="identifier">Produce::val_text</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">T</span><span class="plain">);</span>
                                    <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">);</span>
                                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="plain">}</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

            <span class="functiontext">Routines::end</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Adjectives::Meanings::emit</span><span class="plain">(</span><span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">) {</span>
        <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">aph_iname</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">PRIOR_NAMED_NOUN_HL</span><span class="plain">));</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">GE_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">PRIOR_NAMED_LIST_HL</span><span class="plain">));</span>
                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 2);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::ref_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">SAY__P_HL</span><span class="plain">));</span>
            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Adjectives::Meanings::agreements is used in 1/mr (<a href="1-mr.html#SP4_14">&#167;4.14</a>).</p>

<p class="endnote">The function Adjectives::Meanings::emit is used in 25/ci (<a href="25-ci.html#SP3_1">&#167;3.1</a>, <a href="25-ci.html#SP3_2_3_3_1">&#167;3.2.3.3.1</a>, <a href="25-ci.html#SP3_2_3_4_1">&#167;3.2.3.4.1</a>).</p>

<hr class="tocbar">
<ul class="toc"><li><a href="4-its.html">Back to 'Introduction to Semantics'</a></li><li><i>(This section ends Chapter 4: Bridge to Linguistics Module.)</i></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

