<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>8/ef</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '8/ie' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#8">Chapter 8: Extensions</a></li><li><b>Including Extensions</b></li></ul><p class="purpose">To fulfill requests to include extensions, adding their material to the parse tree as needed, and removing INCLUDE nodes.</p>

<ul class="toc"><li><a href="#SP5">&#167;5. Extension loading</a></li><li><a href="#SP7">&#167;7. Checking the begins here and ends here sentences</a></li><li><a href="#SP11">&#167;11. Sentence handlers for begins here and ends here</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1.  </b>At this point in the narrative of a typical run of Inform, we have read in the
source text supplied by the user. The lexer automatically prefaced this with
"Include Standard Rules by Graham Nelson", and the sentence-breaker
converted all such sentences to nodes of type <code class="display"><span class="extract">INCLUDE_NT</span></code> which are
children of the parse tree root. (The eldest child, therefore, is the
Standard Rules inclusion.)
</p>

<p class="inwebparagraph">We now look through the parse tree in sentence order &mdash; something we shall
do many times, and which we call a "traverse" &mdash; and look for INCLUDE
nodes. Each is replaced with a mass of further nodes for the material in
whatever new extensions were required. This process is repeated until there
are no "Include" sentences left. In principle this could go on forever if
A includes B which includes A, or some such, but we log each extension read
in to ensure that nothing is read twice.
</p>

<p class="inwebparagraph">At the end of this routine, provided no Problems have been issued, there are
guaranteed to be no INCLUDE nodes remaining in the parse tree.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Extensions::Inclusion::traverse</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">includes_cleared</span><span class="plain">;</span>
        <span class="reserved">do</span><span class="plain"> {</span>
            <span class="identifier">includes_cleared</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> &gt; 0) </span><span class="reserved">return</span><span class="plain">;</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">elder</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="identifier">ParseTree::traverse_ppni</span><span class="plain">(</span><span class="functiontext">Extensions::Inclusion::visit</span><span class="plain">, &amp;</span><span class="identifier">elder</span><span class="plain">, &amp;</span><span class="identifier">includes_cleared</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">while</span><span class="plain"> (</span><span class="identifier">includes_cleared</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Extensions::Inclusion::visit</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> **</span><span class="identifier">elder</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">includes_cleared</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">) == </span><span class="identifier">INCLUDE_NT</span><span class="plain">) {</span>
            &lt;<span class="cwebmacro">Replace INCLUDE node with sentence nodes for any extensions required</span> <span class="cwebmacronumber">1.1</span>&gt;<span class="plain">;</span>
            <span class="plain">*</span><span class="identifier">includes_cleared</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">) != </span><span class="identifier">ROOT_NT</span><span class="plain">) {</span>
            <span class="plain">*</span><span class="identifier">elder</span><span class="plain"> = </span><span class="identifier">pn</span><span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Extensions::Inclusion::traverse is used in 1/htc (<a href="1-htc.html#SP2_3">&#167;2.3</a>).</p>

<p class="endnote">The function Extensions::Inclusion::visit appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP1_1"></a><b>&#167;1.1.  </b>The INCLUDE node becomes an INCLUSION, which in turn contains the extension's code.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Replace INCLUDE node with sentence nodes for any extensions required</span> <span class="cwebmacronumber">1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">title</span><span class="plain"> = </span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">, *</span><span class="identifier">author</span><span class="plain"> = </span><span class="identifier">pn</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">l</span><span class="plain"> = </span><span class="identifier">ParseTree::begin_inclusion</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">);</span>
        <span class="functiontext">Extensions::Inclusion::fulfill_request_to_include_extension</span><span class="plain">(</span><span class="identifier">title</span><span class="plain">, </span><span class="identifier">author</span><span class="plain">);</span>
        <span class="identifier">ParseTree::end_inclusion</span><span class="plain">(</span><span class="identifier">l</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1">&#167;1</a>.</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>Here we parse requests to include one or more extensions. People mostly
don't avail themselves of the opportunity, but it is legal to include
several at once, with a line like:
</p>

<blockquote>
    <p>Include Carrots by Peter Rabbit and Green Lettuce by Flopsy Bunny.</p>

</blockquote>

<p class="inwebparagraph">A consequence of this convention is that "and" is not permitted in the
name of an extension. We might change this some day.
</p>

<p class="inwebparagraph">Here's how an individual title is described. The bracketed text is later
parsed by &lt;platform-qualifier&gt;.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">extension</span><span class="plain">-</span><span class="identifier">title</span><span class="plain">-</span><span class="identifier">and</span><span class="plain">-</span><span class="identifier">version</span><span class="plain">&gt; ::=</span>
        <span class="identifier">version</span><span class="plain"> &lt;</span><span class="identifier">extension</span><span class="plain">-</span><span class="identifier">version</span><span class="plain">&gt; </span><span class="identifier">of</span><span class="plain"> &lt;</span><span class="identifier">definite</span><span class="plain">-</span><span class="identifier">article</span><span class="plain">&gt; &lt;</span><span class="identifier">extension</span><span class="plain">-</span><span class="identifier">unversioned</span><span class="plain">&gt; |	==&gt; </span><span class="identifier">R</span><span class="plain">[1]</span>
        <span class="identifier">version</span><span class="plain"> &lt;</span><span class="identifier">extension</span><span class="plain">-</span><span class="identifier">version</span><span class="plain">&gt; </span><span class="identifier">of</span><span class="plain"> &lt;</span><span class="identifier">extension</span><span class="plain">-</span><span class="identifier">unversioned</span><span class="plain">&gt; |					==&gt; </span><span class="identifier">R</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">definite</span><span class="plain">-</span><span class="identifier">article</span><span class="plain">&gt; &lt;</span><span class="identifier">extension</span><span class="plain">-</span><span class="identifier">unversioned</span><span class="plain">&gt;	|								==&gt; -1</span>
        <span class="plain">&lt;</span><span class="identifier">extension</span><span class="plain">-</span><span class="identifier">unversioned</span><span class="plain">&gt;														==&gt; -1</span>

    <span class="plain">&lt;</span><span class="identifier">extension</span><span class="plain">-</span><span class="identifier">unversioned</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">extension</span><span class="plain">-</span><span class="identifier">unversioned</span><span class="plain">-</span><span class="identifier">inner</span><span class="plain">&gt; ( ... )	|	==&gt; 0; &lt;&lt;</span><span class="identifier">rest1</span><span class="plain">&gt;&gt; = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">WR</span><span class="plain">[1]); &lt;&lt;</span><span class="identifier">rest2</span><span class="plain">&gt;&gt; = </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">WR</span><span class="plain">[1])</span>
        <span class="plain">&lt;</span><span class="identifier">extension</span><span class="plain">-</span><span class="identifier">unversioned</span><span class="plain">-</span><span class="identifier">inner</span><span class="plain">&gt; 				==&gt; 0; &lt;&lt;</span><span class="identifier">rest1</span><span class="plain">&gt;&gt; = -1; &lt;&lt;</span><span class="identifier">rest2</span><span class="plain">&gt;&gt; = -1</span>

    <span class="plain">&lt;</span><span class="identifier">extension</span><span class="plain">-</span><span class="identifier">unversioned</span><span class="plain">-</span><span class="identifier">inner</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">quoted</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">&gt; *** |							==&gt; </span>&lt;<span class="cwebmacro">Issue PM_IncludeExtQuoted problem</span> <span class="cwebmacronumber">2.1</span>&gt;
        <span class="plain">...											==&gt; 0; &lt;&lt;</span><span class="identifier">t1</span><span class="plain">&gt;&gt; = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">); &lt;&lt;</span><span class="identifier">t2</span><span class="plain">&gt;&gt; = </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2_1"></a><b>&#167;2.1.  </b>Quite a popular mistake, this:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_IncludeExtQuoted problem</span> <span class="cwebmacronumber">2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">&lt;&lt;</span><span class="identifier">t1</span><span class="plain">&gt;&gt; = -1; &lt;&lt;</span><span class="identifier">t2</span><span class="plain">&gt;&gt; = -1;</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_IncludeExtQuoted</span><span class="plain">),</span>
            <span class="string">"the name of an included extension should be given without double "</span>
            <span class="string">"quotes in an Include sentence"</span><span class="plain">,</span>
            <span class="string">"so for instance 'Include Oh My God by Janice Bing.' rather than "</span>
            <span class="string">"'Include \</span><span class="plain">"</span><span class="string">Oh My God\</span><span class="plain">"</span><span class="string"> by Janice Bing.')"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP2">&#167;2</a>.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>This internal parses version text such as "12/110410".
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">extension</span><span class="plain">-</span><span class="identifier">version</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> 1 {</span>
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">); </span>    <span class="comment">actually, defer parsing by returning a word number here</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Extensions::Inclusion::fulfill_request_to_include_extension</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">auth_p</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">) == </span><span class="identifier">AND_NT</span><span class="plain">) {</span>
            <span class="functiontext">Extensions::Inclusion::fulfill_request_to_include_extension</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">, </span><span class="identifier">auth_p</span><span class="plain">);</span>
            <span class="functiontext">Extensions::Inclusion::fulfill_request_to_include_extension</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">auth_p</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>

        <span class="plain">&lt;&lt;</span><span class="identifier">rest1</span><span class="plain">&gt;&gt; = -1; &lt;&lt;</span><span class="identifier">rest2</span><span class="plain">&gt;&gt; = -1;</span>
        <span class="plain">&lt;&lt;</span><span class="identifier">t1</span><span class="plain">&gt;&gt; = -1; &lt;&lt;</span><span class="identifier">t2</span><span class="plain">&gt;&gt; = -1;</span>
        <span class="plain">&lt;</span><span class="identifier">extension</span><span class="plain">-</span><span class="identifier">title</span><span class="plain">-</span><span class="identifier">and</span><span class="plain">-</span><span class="identifier">version</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">));</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Wordings::new</span><span class="plain">(&lt;&lt;</span><span class="identifier">t1</span><span class="plain">&gt;&gt;, &lt;&lt;</span><span class="identifier">t2</span><span class="plain">&gt;&gt;);</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">AW</span><span class="plain"> = </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">auth_p</span><span class="plain">);</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">RW</span><span class="plain"> = </span><span class="identifier">Wordings::new</span><span class="plain">(&lt;&lt;</span><span class="identifier">rest1</span><span class="plain">&gt;&gt;, &lt;&lt;</span><span class="identifier">rest2</span><span class="plain">&gt;&gt;);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">version_word</span><span class="plain"> = &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span>&lt;<span class="cwebmacro">Fulfill request to include a single extension</span> <span class="cwebmacronumber">4.1</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Extensions::Inclusion::fulfill_request_to_include_extension is used in <a href="#SP1_1">&#167;1.1</a>.</p>

<p class="inwebparagraph"><a id="SP4_1"></a><b>&#167;4.1.  </b>A request consists of author, name and version, the latter being optional.
We obtain the extension file structure corresponding to this: it may have
no text at all (for instance if Inform could not open the file), or it may be
one we have seen before, thanks to an earlier inclusion. Only when it
provided genuinely new text will its <code class="display"><span class="extract">body_text_unbroken</span></code> flag be set,
and then we call the sentence-breaker to ParseTree::graft the new material on to the
parse tree.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Fulfill request to include a single extension</span> <span class="cwebmacronumber">4.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">version_word</span><span class="plain"> &gt;= 0)</span>
            <span class="functiontext">Extensions::Inclusion::parse_version</span><span class="plain">(</span><span class="identifier">version_word</span><span class="plain">); </span>    <span class="comment">this checks the formatting of the version number</span>

        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">exft</span><span class="plain">);</span>
        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">exfa</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">exft</span><span class="plain">, </span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">exfa</span><span class="plain">, </span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">AW</span><span class="plain">);</span>
        <span class="identifier">inbuild_work</span><span class="plain"> *</span><span class="identifier">work</span><span class="plain"> = </span><span class="identifier">Works::new</span><span class="plain">(</span><span class="identifier">extension_genre</span><span class="plain">, </span><span class="identifier">exft</span><span class="plain">, </span><span class="identifier">exfa</span><span class="plain">);</span>
        <span class="identifier">Works::add_to_database</span><span class="plain">(</span><span class="identifier">work</span><span class="plain">, </span><span class="identifier">LOADED_WDBC</span><span class="plain">);</span>
        <span class="identifier">semantic_version_number</span><span class="plain"> </span><span class="identifier">min</span><span class="plain"> = </span><span class="identifier">VersionNumbers::null</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">version_word</span><span class="plain"> &gt;= 0) </span><span class="identifier">min</span><span class="plain"> = </span><span class="functiontext">Extensions::Inclusion::parse_version</span><span class="plain">(</span><span class="identifier">version_word</span><span class="plain">);</span>
        <span class="identifier">inbuild_requirement</span><span class="plain"> *</span><span class="identifier">req</span><span class="plain"> = </span><span class="identifier">Requirements::new</span><span class="plain">(</span><span class="identifier">work</span><span class="plain">, </span><span class="identifier">min</span><span class="plain">, </span><span class="identifier">VersionNumbers::null</span><span class="plain">());</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">exft</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">exfa</span><span class="plain">);</span>

        <span class="identifier">inform_extension</span><span class="plain"> *</span><span class="identifier">E</span><span class="plain"> = </span><span class="functiontext">Extensions::Inclusion::load</span><span class="plain">(</span><span class="identifier">req</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">E</span><span class="plain">) {</span>
            <span class="identifier">Extensions::set_inclusion_sentence</span><span class="plain">(</span><span class="identifier">E</span><span class="plain">, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
            <span class="identifier">Extensions::set_VM_text</span><span class="plain">(</span><span class="identifier">E</span><span class="plain">, </span><span class="identifier">RW</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">E</span><span class="plain">) &amp;&amp; (</span><span class="identifier">E</span><span class="plain">-&gt;</span><span class="identifier">body_text_unbroken</span><span class="plain">)) {</span>
            <span class="identifier">Sentences::break</span><span class="plain">(</span><span class="identifier">E</span><span class="plain">-&gt;</span><span class="identifier">body_text</span><span class="plain">, </span><span class="identifier">E</span><span class="plain">);</span>
            <span class="identifier">E</span><span class="plain">-&gt;</span><span class="identifier">body_text_unbroken</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP4">&#167;4</a>.</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Extension loading. </b>Extensions are loaded here.
</p>


<pre class="display">
    <span class="identifier">inform_extension</span><span class="plain"> *</span><span class="functiontext">Extensions::Inclusion::load</span><span class="plain">(</span><span class="identifier">inbuild_requirement</span><span class="plain"> *</span><span class="identifier">req</span><span class="plain">) {</span>
        <span class="functiontext">NaturalLanguages::scan</span><span class="plain">(); </span>    <span class="comment">to avoid wording from those interleaving with extension wording</span>
        &lt;<span class="cwebmacro">Do not load the same extension work twice</span> <span class="cwebmacronumber">5.1</span>&gt;<span class="plain">;</span>

        <span class="identifier">inform_extension</span><span class="plain"> *</span><span class="identifier">E</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        &lt;<span class="cwebmacro">Read the extension file into the lexer, and break it into body and documentation</span> <span class="cwebmacronumber">5.2</span>&gt;<span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">E</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Extensions::Inclusion::load is used in <a href="#SP4_1">&#167;4.1</a>.</p>

<p class="inwebparagraph"><a id="SP5_1"></a><b>&#167;5.1.  </b>Note that we ignore a request for an extension which has already been
loaded, except if the new request ups the ante in terms of the minimum
version permitted: in which case we need to record that the requirement has
been tightened. That is, if we previously wanted version 2 of Pantomime
Sausages by Mr Punch, and loaded it, but then read the sentence
</p>

<blockquote>
    <p>Include version 3 of Pantomime Sausages by Mr Punch.</p>

</blockquote>

<p class="inwebparagraph">then we need to note that the version requirement on PS has been raised to 3.
(This is why version numbers are not checked at load time: in general, we
can't know at load time what we will ultimately require.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Do not load the same extension work twice</span> <span class="cwebmacronumber">5.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">inform_extension</span><span class="plain"> *</span><span class="identifier">E</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">E</span><span class="plain">, </span><span class="identifier">inform_extension</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Requirements::meets</span><span class="plain">(</span><span class="identifier">E</span><span class="plain">-&gt;</span><span class="identifier">as_copy</span><span class="plain">-&gt;</span><span class="identifier">edition</span><span class="plain">, </span><span class="identifier">req</span><span class="plain">)) {</span>
                <span class="identifier">Extensions::must_satisfy</span><span class="plain">(</span><span class="identifier">E</span><span class="plain">, </span><span class="identifier">req</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">E</span><span class="plain">;</span>
            <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP5">&#167;5</a>.</p>

<p class="inwebparagraph"><a id="SP5_2"></a><b>&#167;5.2.  </b>We finally make our call out of the Extensions section, down through the
trap-door into Read Source Text, to seek and open the file.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Read the extension file into the lexer, and break it into body and documentation</span> <span class="cwebmacronumber">5.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">found_to_be_malformed</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">req</span><span class="plain">-&gt;</span><span class="identifier">allow_malformed</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">linked_list</span><span class="plain"> *</span><span class="identifier">L</span><span class="plain"> = </span><span class="identifier">NEW_LINKED_LIST</span><span class="plain">(</span><span class="identifier">inbuild_search_result</span><span class="plain">);</span>
        <span class="identifier">Nests::search_for</span><span class="plain">(</span><span class="identifier">req</span><span class="plain">, </span><span class="identifier">Inbuild::nest_list</span><span class="plain">(), </span><span class="identifier">L</span><span class="plain">);</span>
        <span class="identifier">inbuild_search_result</span><span class="plain"> *</span><span class="identifier">search_result</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_LINKED_LIST</span><span class="plain">(</span><span class="identifier">search_result</span><span class="plain">, </span><span class="identifier">inbuild_search_result</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">) {</span>
            <span class="identifier">E</span><span class="plain"> = </span><span class="identifier">ExtensionManager::from_copy</span><span class="plain">(</span><span class="identifier">search_result</span><span class="plain">-&gt;</span><span class="identifier">copy</span><span class="plain">);</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">origin</span><span class="plain"> = </span><span class="identifier">Nests::get_tag</span><span class="plain">(</span><span class="identifier">search_result</span><span class="plain">-&gt;</span><span class="identifier">nest</span><span class="plain">);</span>
            <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">origin</span><span class="plain">) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">MATERIALS_NEST_TAG</span><span class="plain">:</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">EXTERNAL_NEST_TAG</span><span class="plain">:</span>
                    <span class="identifier">E</span><span class="plain">-&gt;</span><span class="identifier">loaded_from_built_in_area</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">INTERNAL_NEST_TAG</span><span class="plain">:</span>
                    <span class="identifier">E</span><span class="plain">-&gt;</span><span class="identifier">loaded_from_built_in_area</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">LinkedLists::len</span><span class="plain">(</span><span class="identifier">search_result</span><span class="plain">-&gt;</span><span class="identifier">copy</span><span class="plain">-&gt;</span><span class="identifier">errors_reading_source_text</span><span class="plain">) &gt; 0) {</span>
                <span class="functiontext">SourceFiles::issue_problems_arising</span><span class="plain">(</span><span class="identifier">search_result</span><span class="plain">-&gt;</span><span class="identifier">copy</span><span class="plain">);</span>
                <span class="identifier">E</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
                <span class="identifier">found_to_be_malformed</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">found_to_be_malformed</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">E</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span>&lt;<span class="cwebmacro">Issue a cannot-find problem</span> <span class="cwebmacronumber">5.2.1</span>&gt;
            <span class="reserved">else</span><span class="plain"> {</span>
                <span class="functiontext">SourceFiles::read</span><span class="plain">(</span><span class="identifier">E</span><span class="plain">-&gt;</span><span class="identifier">as_copy</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP5">&#167;5</a>.</p>

<p class="inwebparagraph"><a id="SP5_2_1"></a><b>&#167;5.2.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue a cannot-find problem</span> <span class="cwebmacronumber">5.2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">inbuild_requirement</span><span class="plain"> *</span><span class="identifier">req2</span><span class="plain"> = </span><span class="identifier">Requirements::any_version_of</span><span class="plain">(</span><span class="identifier">req</span><span class="plain">-&gt;</span><span class="identifier">work</span><span class="plain">);</span>
        <span class="identifier">linked_list</span><span class="plain"> *</span><span class="identifier">L</span><span class="plain"> = </span><span class="identifier">NEW_LINKED_LIST</span><span class="plain">(</span><span class="identifier">inbuild_search_result</span><span class="plain">);</span>
        <span class="identifier">Nests::search_for</span><span class="plain">(</span><span class="identifier">req2</span><span class="plain">, </span><span class="identifier">Inbuild::nest_list</span><span class="plain">(), </span><span class="identifier">L</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">LinkedLists::len</span><span class="plain">(</span><span class="identifier">L</span><span class="plain">) == 0) {</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Author: %W\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">req</span><span class="plain">-&gt;</span><span class="identifier">work</span><span class="plain">-&gt;</span><span class="identifier">author_name</span><span class="plain">);</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Title: %W\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">req</span><span class="plain">-&gt;</span><span class="identifier">work</span><span class="plain">-&gt;</span><span class="identifier">title</span><span class="plain">);</span>
            <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
            <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BogusExtension</span><span class="plain">));</span>
            <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                <span class="string">"I can't find the extension requested by: %1. %P"</span>
                <span class="string">"You can get hold of extensions which people have made public at "</span>
                <span class="string">"the Inform website, www.inform7.com, or by using the Public "</span>
                <span class="string">"Library in the Extensions panel."</span><span class="plain">);</span>
            <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">versions</span><span class="plain">);</span>
            <span class="identifier">inbuild_search_result</span><span class="plain"> *</span><span class="identifier">search_result</span><span class="plain">;</span>
            <span class="identifier">LOOP_OVER_LINKED_LIST</span><span class="plain">(</span><span class="identifier">search_result</span><span class="plain">, </span><span class="identifier">inbuild_search_result</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Str::len</span><span class="plain">(</span><span class="identifier">versions</span><span class="plain">) &gt; 0) </span><span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">versions</span><span class="plain">, </span><span class="string">" or "</span><span class="plain">);</span>
                <span class="identifier">semantic_version_number</span><span class="plain"> </span><span class="identifier">V</span><span class="plain"> = </span><span class="identifier">search_result</span><span class="plain">-&gt;</span><span class="identifier">copy</span><span class="plain">-&gt;</span><span class="identifier">edition</span><span class="plain">-&gt;</span><span class="identifier">version</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">VersionNumbers::is_null</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">)) </span><span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">versions</span><span class="plain">, </span><span class="string">"an unnumbered version"</span><span class="plain">);</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">versions</span><span class="plain">, </span><span class="string">"version %v"</span><span class="plain">, &amp;</span><span class="identifier">V</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
            <span class="identifier">Problems::quote_stream</span><span class="plain">(2, </span><span class="identifier">versions</span><span class="plain">);</span>
            <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ExtVersionTooLow</span><span class="plain">));</span>
            <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                <span class="string">"I can't find the right version of the extension requested by %1 - "</span>
                <span class="string">"I can only find %2. %P"</span>
                <span class="string">"You can get hold of extensions which people have made public at "</span>
                <span class="string">"the Inform website, www.inform7.com, or by using the Public "</span>
                <span class="string">"Library in the Extensions panel."</span><span class="plain">);</span>
            <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">versions</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP5_2">&#167;5.2</a>.</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">last_PM_ExtVersionMalformed_at</span><span class="plain"> = -1;</span>
    <span class="identifier">semantic_version_number</span><span class="plain"> </span><span class="functiontext">Extensions::Inclusion::parse_version</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">vwn</span><span class="plain">) {</span>
        <span class="identifier">semantic_version_number</span><span class="plain"> </span><span class="identifier">V</span><span class="plain"> = </span><span class="identifier">VersionNumbers::null</span><span class="plain">();</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Wordings::one_word</span><span class="plain">(</span><span class="identifier">vwn</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">version</span><span class="plain">-</span><span class="identifier">number</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="identifier">semantic_version_number_holder</span><span class="plain"> *</span><span class="identifier">H</span><span class="plain"> = (</span><span class="identifier">semantic_version_number_holder</span><span class="plain"> *) &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
            <span class="identifier">V</span><span class="plain"> = </span><span class="identifier">H</span><span class="plain">-&gt;</span><span class="identifier">version</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            &lt;<span class="cwebmacro">Issue a problem message for a malformed version number</span> <span class="cwebmacronumber">6.1</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">V</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Extensions::Inclusion::parse_version is used in <a href="#SP4_1">&#167;4.1</a>.</p>

<p class="inwebparagraph"><a id="SP6_1"></a><b>&#167;6.1.  </b>Because we tend to call <code class="display"><span class="extract">Extensions::Inclusion::parse_version</span></code> repeatedly on
the same word, we want to recover tidily from this problem, and not report it
over and over. We do this by altering the text to <code class="display"><span class="extract">1</span></code>, the lowest well-formed
version number text.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Issue a problem message for a malformed version number</span> <span class="cwebmacronumber">6.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">last_PM_ExtVersionMalformed_at</span><span class="plain"> != </span><span class="identifier">vwn</span><span class="plain">) {</span>
            <span class="identifier">last_PM_ExtVersionMalformed_at</span><span class="plain"> = </span><span class="identifier">vwn</span><span class="plain">;</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Offending word number %d &lt;%N&gt;\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">vwn</span><span class="plain">, </span><span class="identifier">vwn</span><span class="plain">);</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ExtVersionMalformed</span><span class="plain">),</span>
                <span class="string">"a version number must have the form N/DDDDDD"</span><span class="plain">,</span>
                <span class="string">"as in the example '2/040426' for release 2 made on 26 April 2004. "</span>
                <span class="string">"(The DDDDDD part is optional, so '3' is a legal version number too. "</span>
                <span class="string">"N must be between 1 and 999: in particular, there is no version 0.)"</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Checking the begins here and ends here sentences. </b>When a newly loaded extension is being sentence-broken, problem messages
will be turned up unless it contains the matching pair of "begins here"
and "ends here" sentences. Assuming it does, the sentence breaker has no
objection, but it also calls the two routines below to verify that these
sentences have the correct format. (The point of this is to catch a malformed
extension at the earliest possible moment after loading it: it's easy to
mis-install extensions, especially if doing so by hand, and the resulting
problem messages could be quite inscrutable if one extension was wrongly
identified as another.)
</p>

<p class="inwebparagraph">First, we check the "begins here" sentence. We also identify where the
version number is given (if it is), and check that we are not trying to
use an extension which is marked as not working on the current VM.
</p>

<p class="inwebparagraph">It is sufficient to try parsing the version number in order to check it:
we throw away the answer, as we can't use it yet, but this will provoke
problem messages if it is malformed.
</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>This parses the subject noun-phrase in the sentence
</p>

<blockquote>
    <p>Version 3 of Pantomime Sausages by Mr Punch begins here.</p>

</blockquote>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">begins</span><span class="plain">-</span><span class="identifier">here</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">extension</span><span class="plain">-</span><span class="identifier">title</span><span class="plain">-</span><span class="identifier">and</span><span class="plain">-</span><span class="identifier">version</span><span class="plain">&gt; </span><span class="identifier">by</span><span class="plain"> ... |	==&gt; </span><span class="identifier">R</span><span class="plain">[1]; &lt;&lt;</span><span class="identifier">auth1</span><span class="plain">&gt;&gt; = </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">WR</span><span class="plain">[1]); &lt;&lt;</span><span class="identifier">auth2</span><span class="plain">&gt;&gt; = </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">WR</span><span class="plain">[1]);</span>
        <span class="plain">...										==&gt; </span>&lt;<span class="cwebmacro">Issue problem</span> <span class="cwebmacronumber">8.1</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8_1"></a><b>&#167;8.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue problem</span> <span class="cwebmacronumber">8.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">&lt;&lt;</span><span class="identifier">auth1</span><span class="plain">&gt;&gt; = -1; &lt;&lt;</span><span class="identifier">auth2</span><span class="plain">&gt;&gt; = -1;</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">)); </span>    <span class="comment">since inbuild's scan catches this first</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"has a misworded 'begins here' sentence ('%2'), which contains "</span>
            <span class="string">"no 'by'. Recall that every extension should begin with a "</span>
            <span class="string">"sentence such as 'Quantum Mechanics by Max Planck begins "</span>
            <span class="string">"here.', and end with a matching 'Quantum Mechanics ends "</span>
            <span class="string">"here.', perhaps with documentation to follow."</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a>.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Extensions::Inclusion::check_begins_here</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">PN</span><span class="plain">, </span><span class="identifier">inform_extension</span><span class="plain"> *</span><span class="identifier">E</span><span class="plain">) {</span>
        <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">PN</span><span class="plain">; </span>    <span class="comment">in case problem messages need to be issued</span>
        <span class="functiontext">Problems::quote_extension</span><span class="plain">(1, </span><span class="identifier">E</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">PN</span><span class="plain">));</span>

        <span class="plain">&lt;</span><span class="identifier">begins</span><span class="plain">-</span><span class="identifier">here</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">PN</span><span class="plain">));</span>
        <span class="identifier">Extensions::set_VM_text</span><span class="plain">(</span><span class="identifier">E</span><span class="plain">, </span><span class="identifier">Wordings::new</span><span class="plain">(&lt;&lt;</span><span class="identifier">rest1</span><span class="plain">&gt;&gt;, &lt;&lt;</span><span class="identifier">rest2</span><span class="plain">&gt;&gt;));</span>

        &lt;<span class="cwebmacro">Check that the extension's stipulation about the virtual machine can be met</span> <span class="cwebmacronumber">9.1</span>&gt;<span class="character">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Extensions::Inclusion::check_begins_here is used in 7/ss (<a href="7-ss.html#SP4">&#167;4</a>).</p>

<p class="inwebparagraph"><a id="SP9_1"></a><b>&#167;9.1.  </b>On the other hand, we do already know what virtual machine we are compiling
for, so we can immediately object if the loaded extension cannot be used
with our VM de jour.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Check that the extension's stipulation about the virtual machine can be met</span> <span class="cwebmacronumber">9.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">compatibility_specification</span><span class="plain"> *</span><span class="identifier">C</span><span class="plain"> = </span><span class="identifier">E</span><span class="plain">-&gt;</span><span class="identifier">as_copy</span><span class="plain">-&gt;</span><span class="identifier">edition</span><span class="plain">-&gt;</span><span class="identifier">compatibility</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Compatibility::with</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="functiontext">Task::vm</span><span class="plain">()) == </span><span class="identifier">FALSE</span><span class="plain">)</span>
            &lt;<span class="cwebmacro">Issue a problem message saying that the VM does not meet requirements</span> <span class="cwebmacronumber">9.1.1</span>&gt;<span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP9">&#167;9</a>.</p>

<p class="inwebparagraph"><a id="SP9_1_1"></a><b>&#167;9.1.1.  </b>Here the problem is not that the extension is broken in some way: it's
just not what we can currently use. Therefore the correction should be a
matter of removing the inclusion, not of altering the extension, so we
report this problem at the inclusion line.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Issue a problem message saying that the VM does not meet requirements</span> <span class="cwebmacronumber">9.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">Extensions::get_inclusion_sentence</span><span class="plain">(</span><span class="identifier">E</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="functiontext">Problems::quote_copy</span><span class="plain">(2, </span><span class="identifier">E</span><span class="plain">-&gt;</span><span class="identifier">as_copy</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_stream</span><span class="plain">(3, </span><span class="identifier">C</span><span class="plain">-&gt;</span><span class="identifier">parsed_from</span><span class="plain">);</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ExtInadequateVM</span><span class="plain">));</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"You wrote %1: but my copy of %2 stipulates that it "</span>
            <span class="string">"is '%3'. That means it can only be used with certain of "</span>
            <span class="string">"the possible compiled story file formats, and at the "</span>
            <span class="string">"moment, we don't fit the requirements. (You can change "</span>
            <span class="string">"the format used for this project on the Settings panel.)"</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP9_1">&#167;9.1</a>.</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>Similarly, we check the "ends here" sentence. Here there are no
side-effects: we merely verify that the name matches the one quoted in
the "begins here". We only check this if the problem count is still 0,
since we don't want to keep on nagging somebody who has already been told
that the extension isn't the one he thinks it is.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Extensions::Inclusion::check_ends_here</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">PN</span><span class="plain">, </span><span class="identifier">inform_extension</span><span class="plain"> *</span><span class="identifier">E</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Articles::remove_the</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">PN</span><span class="plain">));</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">T</span><span class="plain"> = </span><span class="identifier">Feeds::feed_stream</span><span class="plain">(</span><span class="identifier">E</span><span class="plain">-&gt;</span><span class="identifier">as_copy</span><span class="plain">-&gt;</span><span class="identifier">edition</span><span class="plain">-&gt;</span><span class="identifier">work</span><span class="plain">-&gt;</span><span class="identifier">title</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">problem_count</span><span class="plain"> == 0) &amp;&amp; (</span><span class="identifier">Wordings::match</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
            <span class="identifier">current_sentence</span><span class="plain"> = </span><span class="identifier">PN</span><span class="plain">;</span>
            <span class="functiontext">Problems::quote_extension</span><span class="plain">(1, </span><span class="identifier">E</span><span class="plain">);</span>
            <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">PN</span><span class="plain">));</span>
            <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ExtMisidentifiedEnds</span><span class="plain">));</span>
            <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                <span class="string">"The extension %1, which your source text makes use of, seems to be "</span>
                <span class="string">"malformed: its 'begins here' sentence correctly identifies it, but "</span>
                <span class="string">"then the 'ends here' sentence calls it '%2' instead. (They need "</span>
                <span class="string">"to be a matching pair except that the end does not name the "</span>
                <span class="string">"author: for instance, 'Hocus Pocus by Jan Ackerman begins here.' "</span>
                <span class="string">"would match with 'Hocus Pocus ends here.')"</span><span class="plain">);</span>
            <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Extensions::Inclusion::check_ends_here is used in 7/ss (<a href="7-ss.html#SP4">&#167;4</a>).</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Sentence handlers for begins here and ends here. </b>The main traverses of the assertions are handled by code which calls
"sentence handler" routines on each node in turn, depending on type.
Here are the handlers for BEGINHERE and ENDHERE. As can be seen, all
we really do is start again from a clean piece of paper.
</p>

<p class="inwebparagraph">Note that, because one extension can include another, these nodes may
well be interleaved: we might find the sequence A begins, B begins,
B ends, A ends. The careful checking done so far ensures that these
will always properly nest. We don't at present make use of this, but
we might in future.
</p>


<pre class="display">
    <span class="reserved">sentence_handler</span><span class="plain"> </span><span class="identifier">BEGINHERE_SH_handler</span><span class="plain"> =</span>
        <span class="plain">{ </span><span class="identifier">BEGINHERE_NT</span><span class="plain">, -1, 0, </span><span class="functiontext">Extensions::Inclusion::handle_extension_begins</span><span class="plain"> };</span>
    <span class="reserved">sentence_handler</span><span class="plain"> </span><span class="identifier">ENDHERE_SH_handler</span><span class="plain"> =</span>
        <span class="plain">{ </span><span class="identifier">ENDHERE_NT</span><span class="plain">, -1, 0, </span><span class="functiontext">Extensions::Inclusion::handle_extension_ends</span><span class="plain"> };</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Extensions::Inclusion::handle_extension_begins</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">PN</span><span class="plain">) {</span>
        <span class="functiontext">Assertions::Traverse::new_discussion</span><span class="plain">(); </span><span class="identifier">near_start_of_extension</span><span class="plain"> = 1;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Extensions::Inclusion::handle_extension_ends</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">PN</span><span class="plain">) {</span>
        <span class="identifier">near_start_of_extension</span><span class="plain"> = 0;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Extensions::Inclusion::handle_extension_begins appears nowhere else.</p>

<p class="endnote">The function Extensions::Inclusion::handle_extension_ends appears nowhere else.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="8-ef.html">Back to 'Extension Files'</a></li><li><i>(This section ends Chapter 8: Extensions.)</i></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

