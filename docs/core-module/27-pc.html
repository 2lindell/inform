<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>27/cm</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '27/pc' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#27">Chapter 27: Bridge to Inter Module</a></li><li><b>Packaging</b></li></ul><p class="purpose">To manage requests to build Inter packages, and then to generate inames within them; and to create modules and submodules.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Package requests</a></li><li><a href="#SP10">&#167;10. Bubbles</a></li><li><a href="#SP11">&#167;11. Outside the packages</a></li><li><a href="#SP12">&#167;12. Entry and exit</a></li><li><a href="#SP13">&#167;13. Incarnation</a></li><li><a href="#SP14">&#167;14. Modules</a></li><li><a href="#SP15">&#167;15. Submodules</a></li><li><a href="#SP18">&#167;18. Functions</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Package requests. </b>In the same way that inames are created as shadows of eventual inter symbols,
and omly converted into the real thing on demand, "package requests" are
shadowy packages. The process of turning them into real inter packages is
called "incarnation".
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">MAX_PRCS_AT_ONCE</span><span class="plain"> 11</span>
</pre>

<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">package_request</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">eventual_name</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">eventual_type</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">inter_package</span><span class="plain"> *</span><span class="identifier">actual_package</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">parent_request</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">inter_bookmark</span><span class="plain"> </span><span class="identifier">write_position</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">linked_list</span><span class="plain"> *</span><span class="identifier">iname_generators</span><span class="plain">; </span>    <span class="comment">of <code class="display"><span class="extract">inter_name_generator</span></code></span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">package_request</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure package_request is accessed in 26/iti, 27/hl and here.</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b></p>


<pre class="display">
    <span class="reserved">package_request</span><span class="plain"> *</span><span class="functiontext">Packaging::request</span><span class="plain">(</span><span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">name</span><span class="plain">, </span><span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">pt</span><span class="plain">) {</span>
        <span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">R</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">package_request</span><span class="plain">);</span>
        <span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;eventual_name</span><span class="plain"> = </span><span class="identifier">name</span><span class="plain">;</span>
        <span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;eventual_type</span><span class="plain"> = </span><span class="identifier">pt</span><span class="plain">;</span>
        <span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;actual_package</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;parent_request</span><span class="plain"> = </span><span class="functiontext">InterNames::location</span><span class="plain">(</span><span class="identifier">name</span><span class="plain">);</span>
        <span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;write_position</span><span class="plain"> = </span><span class="identifier">Inter::Bookmarks::at_start_of_this_repository</span><span class="plain">(</span><span class="functiontext">Emit::repository</span><span class="plain">());</span>
        <span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;iname_generators</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">R</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::request is used in <a href="#SP14">&#167;14</a>, <a href="#SP17">&#167;17</a>, <a href="#SP18">&#167;18</a>, <a href="#SP19">&#167;19</a>, 27/hr (<a href="27-hr.html#SP5">&#167;5</a>), 27/hl (<a href="27-hl.html#SP4">&#167;4</a>, <a href="27-hl.html#SP5">&#167;5</a>).</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>In the debugging log, package requests are printed in a form looking a
little like URLs, except that they run in the reverse order, innermost first
and outermost last: to make this more visually clear, backslashes rather
than forward slashes are used as dividers.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Packaging::log</span><span class="plain">(</span><span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">R</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">R</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"&lt;null-package&gt;"</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">c</span><span class="plain"> = 0;</span>
            <span class="reserved">while</span><span class="plain"> (</span><span class="identifier">R</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">c</span><span class="plain">++ &gt; 0) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"\</span><span class="plain">\</span><span class="string">"</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;actual_package</span><span class="plain">)</span>
                    <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"%S"</span><span class="plain">, </span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;actual_package</span><span class="plain">-&gt;</span><span class="identifier">package_name</span><span class="plain">-&gt;</span><span class="identifier">symbol_name</span><span class="plain">);</span>
                <span class="reserved">else</span>
                    <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"'%n'"</span><span class="plain">, </span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;eventual_name</span><span class="plain">);</span>
                <span class="identifier">R</span><span class="plain"> = </span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;parent_request</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::log is used in 1/cm (<a href="1-cm.html#SP5">&#167;5</a>, <a href="1-cm.html#SP6_6">&#167;6.6</a>).</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>The following allows a sequence of different inames to be generated inside a
package: for example, <code class="display"><span class="extract">Packaging::make_iname_within(R, I"acorn")</span></code> produces a
sequence of inames <code class="display"><span class="extract">acorn1</span></code>, <code class="display"><span class="extract">acorn2</span></code>, ..., as it's called over and over again.
</p>


<pre class="display">
    <span class="reserved">inter_name</span><span class="plain"> *</span><span class="functiontext">Packaging::make_iname_within</span><span class="plain">(</span><span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">R</span><span class="plain">, </span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">what_for</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">R</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"no request"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;iname_generators</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)</span>
            <span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;iname_generators</span><span class="plain"> = </span><span class="identifier">NEW_LINKED_LIST</span><span class="plain">(</span><span class="reserved">inter_name_generator</span><span class="plain">);</span>

        <span class="reserved">inter_name_generator</span><span class="plain"> *</span><span class="identifier">gen</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_LINKED_LIST</span><span class="plain">(</span><span class="identifier">gen</span><span class="plain">, </span><span class="reserved">inter_name_generator</span><span class="plain">, </span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;iname_generators</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Str::eq</span><span class="plain">(</span><span class="identifier">what_for</span><span class="plain">, </span><span class="identifier">gen</span><span class="plain">-</span><span class="element">&gt;name_stem</span><span class="plain">))</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">InterNames::generated_in</span><span class="plain">(</span><span class="identifier">gen</span><span class="plain">, -1, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="identifier">R</span><span class="plain">);</span>

        <span class="identifier">gen</span><span class="plain"> = </span><span class="functiontext">InterNames::multiple_use_generator</span><span class="plain">(</span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">what_for</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="identifier">ADD_TO_LINKED_LIST</span><span class="plain">(</span><span class="identifier">gen</span><span class="plain">, </span><span class="reserved">inter_name_generator</span><span class="plain">, </span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;iname_generators</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">InterNames::generated_in</span><span class="plain">(</span><span class="identifier">gen</span><span class="plain">, -1, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="identifier">R</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::make_iname_within is used in 27/hr (<a href="27-hr.html#SP5">&#167;5</a>), 27/hl (<a href="27-hl.html#SP5">&#167;5</a>).</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>At any given time, emission of Inter is occurring to a particular position
(in some incarnated package) and in the context of a given enclosure. This
is summarised by the following state:
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">packaging_state</span><span class="plain"> {</span>
        <span class="identifier">inter_bookmark</span><span class="plain"> *</span><span class="identifier">saved_IRS</span><span class="plain">;</span>
        <span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">saved_enclosure</span><span class="plain">;</span>
    <span class="plain">} </span><span class="reserved">packaging_state</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure packaging_state is private to this section.</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>It is not legal to write to the following state, which exists only to
initialise variables to neutral contents (and thus to avoid warnings
generated because clang is not able to prove that they will not be used
in an uninitialised state &mdash; though in fact they will not).
</p>


<pre class="display">
    <span class="reserved">packaging_state</span><span class="plain"> </span><span class="functiontext">Packaging::stateless</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">packaging_state</span><span class="plain"> </span><span class="identifier">PS</span><span class="plain">;</span>
        <span class="identifier">PS</span><span class="element">.saved_IRS</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">PS</span><span class="element">.saved_enclosure</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">PS</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::stateless is used in 27/ei (<a href="27-ei.html#SP5">&#167;5</a>).</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>We will store the current state at all times in the following:
</p>


<pre class="display">
    <span class="reserved">packaging_state</span><span class="plain"> </span><span class="identifier">current_state</span><span class="plain">;</span>

    <span class="identifier">inter_bookmark</span><span class="plain"> *</span><span class="functiontext">Packaging::at</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">current_state</span><span class="element">.saved_IRS</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">package_request</span><span class="plain"> *</span><span class="functiontext">Packaging::enclosure</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">current_state</span><span class="element">.saved_enclosure</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::at is used in <a href="#SP11">&#167;11</a>, <a href="#SP13">&#167;13</a>, 17/ts (<a href="17-ts.html#SP11">&#167;11</a>), 26/iti (<a href="26-iti.html#SP9">&#167;9</a>), 27/ei (<a href="27-ei.html#SP2">&#167;2</a>, <a href="27-ei.html#SP3">&#167;3</a>, <a href="27-ei.html#SP4">&#167;4</a>, <a href="27-ei.html#SP5">&#167;5</a>).</p>

<p class="endnote">The function Packaging::enclosure is used in <a href="#SP12">&#167;12</a>, <a href="#SP13">&#167;13</a>, 27/hr (<a href="27-hr.html#SP5">&#167;5</a>), 27/ei (<a href="27-ei.html#SP5">&#167;5</a>).</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>States are intentionally very lightweight, and in particular they contain
pointers to the IBM structures rather than containing a copy thereof. But
those pointers have to point somewhere, and this is where: to a stack of
IBM structures.
</p>

<p class="inwebparagraph">The maximum here is beyond plenty: it's not the maximum hierarchical depth
of the Inter output, it's the maximum number of times that Inform interrupts
itself during compilation.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">MAX_PACKAGING_ENTRY_DEPTH</span><span class="plain"> 128</span>
</pre>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">packaging_entry_sp</span><span class="plain"> = 0;</span>
    <span class="identifier">inter_bookmark</span><span class="plain"> </span><span class="identifier">packaging_entry_stack</span><span class="plain">[</span><span class="constant">MAX_PACKAGING_ENTRY_DEPTH</span><span class="plain">];</span>

    <span class="identifier">inter_bookmark</span><span class="plain"> *</span><span class="functiontext">Packaging::push_IRS</span><span class="plain">(</span><span class="identifier">inter_bookmark</span><span class="plain"> </span><span class="identifier">IBM</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">packaging_entry_sp</span><span class="plain"> &gt;= </span><span class="constant">MAX_PACKAGING_ENTRY_DEPTH</span><span class="plain">)</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"packaging entry too deep"</span><span class="plain">);</span>
        <span class="identifier">packaging_entry_stack</span><span class="plain">[</span><span class="identifier">packaging_entry_sp</span><span class="plain">] = </span><span class="identifier">IBM</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> &amp;(</span><span class="identifier">packaging_entry_stack</span><span class="plain">[</span><span class="identifier">packaging_entry_sp</span><span class="plain">++]);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Packaging::pop_IRS</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">packaging_entry_sp</span><span class="plain"> &lt;= 0) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"package stack underflow"</span><span class="plain">);</span>
        <span class="identifier">packaging_entry_sp</span><span class="plain">--;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::push_IRS is used in <a href="#SP9">&#167;9</a>, <a href="#SP12">&#167;12</a>.</p>

<p class="endnote">The function Packaging::pop_IRS is used in <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>The current state has the following invariant: the IBM part always points to
a validly initialised <code class="display"><span class="extract">inter_bookmark</span></code>, and the enclosure part is always
either <code class="display"><span class="extract">NULL</span></code> or a package request which has an enclosing package type. (In
fact, it is null only fleetingly: as soon as the <code class="display"><span class="extract">main</span></code> package is created,
very early on, the enclosure is always an enclosing package.)
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Packaging::initialise_state</span><span class="plain">(</span><span class="identifier">inter_tree</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="identifier">current_state</span><span class="element">.saved_IRS</span><span class="plain"> = </span><span class="functiontext">Packaging::push_IRS</span><span class="plain">(</span><span class="identifier">Inter::Bookmarks::at_start_of_this_repository</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
        <span class="identifier">current_state</span><span class="element">.saved_enclosure</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Packaging::set_state</span><span class="plain">(</span><span class="identifier">inter_bookmark</span><span class="plain"> *</span><span class="identifier">to</span><span class="plain">, </span><span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">PR</span><span class="plain">) {</span>
        <span class="identifier">current_state</span><span class="element">.saved_IRS</span><span class="plain"> = </span><span class="identifier">to</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">PR</span><span class="plain">) &amp;&amp; (</span><span class="identifier">PR</span><span class="plain">-</span><span class="element">&gt;parent_request</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">Inter::Symbols::read_annotation</span><span class="plain">(</span><span class="identifier">PR</span><span class="plain">-</span><span class="element">&gt;eventual_type</span><span class="plain">, </span><span class="identifier">ENCLOSING_IANN</span><span class="plain">) != 1))</span>
            <span class="identifier">PR</span><span class="plain"> = </span><span class="identifier">PR</span><span class="plain">-</span><span class="element">&gt;parent_request</span><span class="plain">;</span>
        <span class="identifier">current_state</span><span class="element">.saved_enclosure</span><span class="plain"> = </span><span class="identifier">PR</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::initialise_state is used in 27/ei (<a href="27-ei.html#SP2">&#167;2</a>).</p>

<p class="endnote">The function Packaging::set_state is used in <a href="#SP12">&#167;12</a>, <a href="#SP13">&#167;13</a>.</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Bubbles. </b>Inter code is stored in memory as a singly-linked list. This is fast and
compact, but can make it awkward to insert material other than at the end,
particularly if one insertion leads to another close by, midway in the
process &mdash; which is exactly what can happen when incarnating a nested set
of packages.
</p>

<p class="inwebparagraph">We avoid all such difficulties by placing "bubbles" at positions in the
linked list where we will later need to return and place new material.
A bubble is simply a pair of nops (no operations); any later inserted
material will be placed between them.
</p>


<pre class="display">
    <span class="identifier">inter_bookmark</span><span class="plain"> </span><span class="functiontext">Packaging::bubble</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="functiontext">Emit::nop</span><span class="plain">();</span>
        <span class="identifier">inter_bookmark</span><span class="plain"> </span><span class="identifier">b</span><span class="plain"> = </span><span class="functiontext">Emit::bookmark</span><span class="plain">();</span>
        <span class="functiontext">Emit::nop</span><span class="plain">();</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">b</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">inter_bookmark</span><span class="plain"> </span><span class="functiontext">Packaging::bubble_at</span><span class="plain">(</span><span class="identifier">inter_bookmark</span><span class="plain"> *</span><span class="identifier">IBM</span><span class="plain">) {</span>
        <span class="functiontext">Emit::nop_at</span><span class="plain">(</span><span class="identifier">IBM</span><span class="plain">);</span>
        <span class="identifier">inter_bookmark</span><span class="plain"> </span><span class="identifier">b</span><span class="plain"> = </span><span class="functiontext">Emit::bookmark_at</span><span class="plain">(</span><span class="identifier">IBM</span><span class="plain">);</span>
        <span class="functiontext">Emit::nop_at</span><span class="plain">(</span><span class="identifier">IBM</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">b</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::bubble is used in <a href="#SP11">&#167;11</a>, <a href="#SP12">&#167;12</a>, <a href="#SP13">&#167;13</a>, 27/hr (<a href="27-hr.html#SP5">&#167;5</a>).</p>

<p class="endnote">The function Packaging::bubble_at appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Outside the packages. </b>The Inter specification calls for just a handful of resources to be placed
at the top level, outside even the <code class="display"><span class="extract">main</span></code> package. Using bubbles, we leave
room to insert those resources, then incarnate <code class="display"><span class="extract">main</span></code> and enter it.
</p>


<pre class="display">
    <span class="identifier">inter_bookmark</span><span class="plain"> </span><span class="identifier">pragmas_bookmark</span><span class="plain">;</span>
    <span class="identifier">inter_bookmark</span><span class="plain"> </span><span class="identifier">package_types_bookmark</span><span class="plain">;</span>
    <span class="identifier">inter_bookmark</span><span class="plain"> </span><span class="identifier">holdings_bookmark</span><span class="plain">;</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Packaging::outside_all_packages</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="functiontext">Emit::version</span><span class="plain">(1);</span>

        <span class="functiontext">Emit::comment</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"Package types:"</span><span class="plain">);</span>
        <span class="identifier">package_types_bookmark</span><span class="plain"> = </span><span class="functiontext">Packaging::bubble</span><span class="plain">();</span>
        <span class="functiontext">PackageTypes::get</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"_plain"</span><span class="plain">); </span>    <span class="comment">To ensure this is the first emitted ptype</span>
        <span class="functiontext">PackageTypes::get</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"_code"</span><span class="plain">); </span>    <span class="comment">And this the second</span>

        <span class="functiontext">Emit::comment</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"Pragmas:"</span><span class="plain">);</span>
        <span class="identifier">pragmas_bookmark</span><span class="plain"> = </span><span class="functiontext">Packaging::bubble</span><span class="plain">();</span>

        <span class="functiontext">Emit::comment</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"Primitives:"</span><span class="plain">);</span>
        <span class="identifier">Primitives::emit</span><span class="plain">(</span><span class="functiontext">Emit::repository</span><span class="plain">(), </span><span class="functiontext">Packaging::at</span><span class="plain">());</span>

        <span class="functiontext">Packaging::enter</span><span class="plain">(</span><span class="functiontext">Hierarchy::main</span><span class="plain">()); </span>    <span class="comment">Which we never exit</span>
        <span class="identifier">holdings_bookmark</span><span class="plain"> = </span><span class="functiontext">Packaging::bubble</span><span class="plain">();</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::outside_all_packages is used in 27/ei (<a href="27-ei.html#SP2">&#167;2</a>).</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Entry and exit. </b>Each PR contains a "write position". This is where emitted Inter code will go;
and it means that not all of the code inside a package needs to be written
at the same time. We can come and go as we please, adding code to packages
all over the hierarchy, simply by switching to the write position in the
package we wsnt to extend next.
</p>

<p class="inwebparagraph">That switching is called "entering" a package. Every entry must be followed
by a matching exit, which restores the write position to where it was before
the entry. (The one exception is that the entry into <code class="display"><span class="extract">main</span></code>, made above,
is never followed by an exit.)
</p>


<pre class="display">
    <span class="reserved">packaging_state</span><span class="plain"> </span><span class="functiontext">Packaging::enter_home_of</span><span class="plain">(</span><span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">N</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Packaging::enter</span><span class="plain">(</span><span class="functiontext">InterNames::location</span><span class="plain">(</span><span class="identifier">N</span><span class="plain">));</span>
    <span class="plain">}</span>

    <span class="reserved">packaging_state</span><span class="plain"> </span><span class="functiontext">Packaging::enter</span><span class="plain">(</span><span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">R</span><span class="plain">) {</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">PACKAGING</span><span class="plain">, </span><span class="string">"Entering $X\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">R</span><span class="plain">);</span>
        <span class="reserved">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="identifier">current_state</span><span class="plain">;</span>
        <span class="functiontext">Packaging::incarnate</span><span class="plain">(</span><span class="identifier">R</span><span class="plain">);</span>
        <span class="functiontext">Packaging::set_state</span><span class="plain">(&amp;(</span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;write_position</span><span class="plain">), </span><span class="functiontext">Packaging::enclosure</span><span class="plain">());</span>
        <span class="identifier">inter_bookmark</span><span class="plain"> *</span><span class="identifier">bubble</span><span class="plain"> = </span><span class="functiontext">Packaging::push_IRS</span><span class="plain">(</span><span class="functiontext">Packaging::bubble</span><span class="plain">());</span>
        <span class="functiontext">Packaging::set_state</span><span class="plain">(</span><span class="identifier">bubble</span><span class="plain">, </span><span class="identifier">R</span><span class="plain">);</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">PACKAGING</span><span class="plain">, </span><span class="string">"[%d] Current enclosure is $X\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">packaging_entry_sp</span><span class="plain">, </span><span class="functiontext">Packaging::enclosure</span><span class="plain">());</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">save</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Packaging::exit</span><span class="plain">(</span><span class="reserved">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain">) {</span>
        <span class="functiontext">Packaging::set_state</span><span class="plain">(</span><span class="identifier">save</span><span class="element">.saved_IRS</span><span class="plain">, </span><span class="identifier">save</span><span class="element">.saved_enclosure</span><span class="plain">);</span>
        <span class="functiontext">Packaging::pop_IRS</span><span class="plain">();</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">PACKAGING</span><span class="plain">, </span><span class="string">"[%d] Back to $X\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">packaging_entry_sp</span><span class="plain">, </span><span class="functiontext">Packaging::enclosure</span><span class="plain">());</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::enter_home_of is used in 27/in (<a href="27-in.html#SP5">&#167;5</a>), 27/ei (<a href="27-ei.html#SP2">&#167;2</a>, <a href="27-ei.html#SP3">&#167;3</a>, <a href="27-ei.html#SP5">&#167;5</a>).</p>

<p class="endnote">The function Packaging::enter is used in <a href="#SP11">&#167;11</a>, 27/hr (<a href="27-hr.html#SP5">&#167;5</a>), 27/ei (<a href="27-ei.html#SP3">&#167;3</a>).</p>

<p class="endnote">The function Packaging::exit is used in 27/hr (<a href="27-hr.html#SP5">&#167;5</a>), 27/in (<a href="27-in.html#SP5">&#167;5</a>), 27/ei (<a href="27-ei.html#SP2">&#167;2</a>, <a href="27-ei.html#SP3">&#167;3</a>, <a href="27-ei.html#SP5">&#167;5</a>).</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. Incarnation. </b>The subtlety here is that if a package is incarnated, its parent must be
incarnated first, and we need to make sure that their bubbles do not lie
inside each other: if they did, material compiled to the parent and to the
child would end up interleaved, in a way which violates the Inter
specification.
</p>


<pre class="display">
    <span class="identifier">inter_package</span><span class="plain"> *</span><span class="functiontext">Packaging::incarnate</span><span class="plain">(</span><span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">R</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">R</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"can't incarnate null request"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;actual_package</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">PACKAGING</span><span class="plain">, </span><span class="string">"Request to make incarnate $X\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">R</span><span class="plain">);</span>
            <span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">E</span><span class="plain"> = </span><span class="functiontext">Packaging::enclosure</span><span class="plain">(); </span>    <span class="comment">This will not change</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;parent_request</span><span class="plain">) {</span>
                <span class="functiontext">Packaging::incarnate</span><span class="plain">(</span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;parent_request</span><span class="plain">);</span>
                <span class="identifier">inter_bookmark</span><span class="plain"> *</span><span class="identifier">save_IRS</span><span class="plain"> = </span><span class="functiontext">Packaging::at</span><span class="plain">();</span>
                <span class="functiontext">Packaging::set_state</span><span class="plain">(&amp;(</span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;parent_request</span><span class="plain">-</span><span class="element">&gt;write_position</span><span class="plain">), </span><span class="identifier">E</span><span class="plain">);</span>
                <span class="identifier">inter_bookmark</span><span class="plain"> </span><span class="identifier">package_bubble</span><span class="plain"> = </span><span class="functiontext">Packaging::bubble</span><span class="plain">();</span>
                <span class="functiontext">Packaging::set_state</span><span class="plain">(&amp;</span><span class="identifier">package_bubble</span><span class="plain">, </span><span class="identifier">E</span><span class="plain">);</span>
                <span class="functiontext">Emit::package</span><span class="plain">(</span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;eventual_name</span><span class="plain">, </span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;eventual_type</span><span class="plain">, &amp;(</span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;actual_package</span><span class="plain">));</span>
                <span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;write_position</span><span class="plain"> = </span><span class="functiontext">Packaging::bubble</span><span class="plain">();</span>
                <span class="functiontext">Packaging::set_state</span><span class="plain">(</span><span class="identifier">save_IRS</span><span class="plain">, </span><span class="identifier">E</span><span class="plain">);</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="identifier">inter_bookmark</span><span class="plain"> </span><span class="identifier">package_bubble</span><span class="plain"> = </span><span class="functiontext">Packaging::bubble</span><span class="plain">();</span>
                <span class="identifier">package_bubble</span><span class="plain"> = </span><span class="functiontext">Packaging::bubble</span><span class="plain">();</span>
                <span class="identifier">inter_bookmark</span><span class="plain"> *</span><span class="identifier">save_IRS</span><span class="plain"> = </span><span class="functiontext">Packaging::at</span><span class="plain">();</span>
                <span class="functiontext">Packaging::set_state</span><span class="plain">(&amp;</span><span class="identifier">package_bubble</span><span class="plain">, </span><span class="identifier">E</span><span class="plain">);</span>
                <span class="functiontext">Emit::package</span><span class="plain">(</span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;eventual_name</span><span class="plain">, </span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;eventual_type</span><span class="plain">, &amp;(</span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;actual_package</span><span class="plain">));</span>
                <span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;write_position</span><span class="plain"> = </span><span class="functiontext">Packaging::bubble</span><span class="plain">();</span>
                <span class="functiontext">Packaging::set_state</span><span class="plain">(</span><span class="identifier">save_IRS</span><span class="plain">, </span><span class="identifier">E</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">PACKAGING</span><span class="plain">, </span><span class="string">"Made incarnate $X bookmark $5\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">R</span><span class="plain">, &amp;(</span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;write_position</span><span class="plain">));</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">R</span><span class="plain">-</span><span class="element">&gt;actual_package</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::incarnate is used in <a href="#SP12">&#167;12</a>, 27/hr (<a href="27-hr.html#SP5">&#167;5</a>), 27/in (<a href="27-in.html#SP7">&#167;7</a>), 27/eis (<a href="27-eis.html#SP4">&#167;4</a>), 27/ei (<a href="27-ei.html#SP2">&#167;2</a>, <a href="27-ei.html#SP3">&#167;3</a>, <a href="27-ei.html#SP5">&#167;5</a>).</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Modules. </b>With the code above, then, we can get the Inter hierarchy of packages set up
as far as creating <code class="display"><span class="extract">main</span></code>. After that the Hierarchy code takes over, but it
calls the routines below to assist. It will want to create a number of "modules"
and, within them, "submodules".
</p>

<p class="inwebparagraph">Modules are identified by name: <code class="display"><span class="extract">generic</span></code>, <code class="display"><span class="extract">Standard_Rules</span></code>, and so on. The
following creates modules on demand.
</p>


<pre class="display">
    <span class="identifier">dictionary</span><span class="plain"> *</span><span class="identifier">modules_indexed_by_name</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">modules_created</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>

    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">module_package</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">the_package</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">linked_list</span><span class="plain"> *</span><span class="identifier">submodules</span><span class="plain">; </span>    <span class="comment">of <code class="display"><span class="extract">submodule_request</span></code></span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">module_package</span><span class="plain">;</span>

    <span class="reserved">module_package</span><span class="plain"> *</span><span class="functiontext">Packaging::get_module</span><span class="plain">(</span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">name</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">modules_created</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="identifier">modules_created</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="identifier">modules_indexed_by_name</span><span class="plain"> = </span><span class="identifier">Dictionaries::new</span><span class="plain">(512, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Dictionaries::find</span><span class="plain">(</span><span class="identifier">modules_indexed_by_name</span><span class="plain">, </span><span class="identifier">name</span><span class="plain">))</span>
            <span class="reserved">return</span><span class="plain"> (</span><span class="reserved">module_package</span><span class="plain"> *) </span><span class="identifier">Dictionaries::read_value</span><span class="plain">(</span><span class="identifier">modules_indexed_by_name</span><span class="plain">, </span><span class="identifier">name</span><span class="plain">);</span>

        <span class="reserved">module_package</span><span class="plain"> *</span><span class="identifier">new_module</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">module_package</span><span class="plain">);</span>
        <span class="identifier">new_module</span><span class="plain">-</span><span class="element">&gt;the_package</span><span class="plain"> =</span>
            <span class="functiontext">Packaging::request</span><span class="plain">(</span>
                <span class="functiontext">InterNames::explicitly_named</span><span class="plain">(</span><span class="identifier">name</span><span class="plain">, </span><span class="functiontext">Hierarchy::main</span><span class="plain">()),</span>
                <span class="functiontext">PackageTypes::get</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"_module"</span><span class="plain">));</span>
        <span class="identifier">new_module</span><span class="plain">-</span><span class="element">&gt;submodules</span><span class="plain"> = </span><span class="identifier">NEW_LINKED_LIST</span><span class="plain">(</span><span class="reserved">submodule_request</span><span class="plain">);</span>
        <span class="identifier">Dictionaries::create</span><span class="plain">(</span><span class="identifier">modules_indexed_by_name</span><span class="plain">, </span><span class="identifier">name</span><span class="plain">);</span>
        <span class="identifier">Dictionaries::write_value</span><span class="plain">(</span><span class="identifier">modules_indexed_by_name</span><span class="plain">, </span><span class="identifier">name</span><span class="plain">, (</span><span class="reserved">void</span><span class="plain"> *) </span><span class="identifier">new_module</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">new_module</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::get_module is used in <a href="#SP16">&#167;16</a>, 27/hr (<a href="27-hr.html#SP5">&#167;5</a>), 27/cm (<a href="27-cm.html#SP2">&#167;2</a>), 27/ei (<a href="27-ei.html#SP2">&#167;2</a>).</p>

<p class="endnote">The structure module_package is accessed in 27/hr, 27/cm, 27/ei and here.</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15. Submodules. </b>Submodules have names such as <code class="display"><span class="extract">properties</span></code>, and the idea is that the same submodule
(or rather, submodules with the same name) can be found in multiple modules. The
different sorts of submodule are identified by <code class="display"><span class="extract">submodule_identity</span></code> pointers, though
as it turns out, this is presently just a wrapper for a name.
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">submodule_identity</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">submodule_name</span><span class="plain">;</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">submodule_identity</span><span class="plain">;</span>

    <span class="reserved">submodule_identity</span><span class="plain"> *</span><span class="functiontext">Packaging::register_submodule</span><span class="plain">(</span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">name</span><span class="plain">) {</span>
        <span class="reserved">submodule_identity</span><span class="plain"> *</span><span class="identifier">sid</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">sid</span><span class="plain">, </span><span class="reserved">submodule_identity</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Str::eq</span><span class="plain">(</span><span class="identifier">sid</span><span class="plain">-</span><span class="element">&gt;submodule_name</span><span class="plain">, </span><span class="identifier">name</span><span class="plain">))</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">sid</span><span class="plain">;</span>
        <span class="identifier">sid</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">submodule_identity</span><span class="plain">);</span>
        <span class="identifier">sid</span><span class="plain">-</span><span class="element">&gt;submodule_name</span><span class="plain"> = </span><span class="identifier">Str::duplicate</span><span class="plain">(</span><span class="identifier">name</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">sid</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::register_submodule is used in 27/hr (<a href="27-hr.html#SP1_2">&#167;1.2</a>, <a href="27-hr.html#SP1_6">&#167;1.6</a>, <a href="27-hr.html#SP1_8">&#167;1.8</a>, <a href="27-hr.html#SP1_10">&#167;1.10</a>, <a href="27-hr.html#SP1_12">&#167;1.12</a>, <a href="27-hr.html#SP1_14">&#167;1.14</a>, <a href="27-hr.html#SP1_16">&#167;1.16</a>, <a href="27-hr.html#SP1_18">&#167;1.18</a>, <a href="27-hr.html#SP1_20">&#167;1.20</a>, <a href="27-hr.html#SP1_22">&#167;1.22</a>, <a href="27-hr.html#SP1_24">&#167;1.24</a>, <a href="27-hr.html#SP1_26">&#167;1.26</a>, <a href="27-hr.html#SP1_28">&#167;1.28</a>, <a href="27-hr.html#SP1_30">&#167;1.30</a>, <a href="27-hr.html#SP1_32">&#167;1.32</a>, <a href="27-hr.html#SP1_34">&#167;1.34</a>, <a href="27-hr.html#SP1_36">&#167;1.36</a>, <a href="27-hr.html#SP1_38">&#167;1.38</a>, <a href="27-hr.html#SP1_40">&#167;1.40</a>, <a href="27-hr.html#SP1_42">&#167;1.42</a>, <a href="27-hr.html#SP1_44">&#167;1.44</a>, <a href="27-hr.html#SP1_46">&#167;1.46</a>).</p>

<p class="endnote">The structure submodule_identity is private to this section.</p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16.  </b>Once the Hierarchy code has registered a submodule, it can request an existing
module to have this submodule. It should call one of the following four functions:
</p>


<pre class="display">
    <span class="reserved">package_request</span><span class="plain"> *</span><span class="functiontext">Packaging::request_submodule</span><span class="plain">(</span><span class="reserved">compilation_module</span><span class="plain"> *</span><span class="identifier">C</span><span class="plain">, </span><span class="reserved">submodule_identity</span><span class="plain"> *</span><span class="identifier">sid</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">C</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Packaging::generic_submodule</span><span class="plain">(</span><span class="identifier">sid</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Packaging::new_submodule_inner</span><span class="plain">(</span><span class="functiontext">Modules::inter_presence</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">), </span><span class="identifier">sid</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">package_request</span><span class="plain"> *</span><span class="functiontext">Packaging::local_submodule</span><span class="plain">(</span><span class="reserved">submodule_identity</span><span class="plain"> *</span><span class="identifier">sid</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Packaging::request_submodule</span><span class="plain">(</span><span class="functiontext">Modules::find</span><span class="plain">(</span><span class="identifier">current_sentence</span><span class="plain">), </span><span class="identifier">sid</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">package_request</span><span class="plain"> *</span><span class="functiontext">Packaging::generic_submodule</span><span class="plain">(</span><span class="reserved">submodule_identity</span><span class="plain"> *</span><span class="identifier">sid</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Packaging::new_submodule_inner</span><span class="plain">(</span><span class="functiontext">Packaging::get_module</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"generic"</span><span class="plain">), </span><span class="identifier">sid</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">package_request</span><span class="plain"> *</span><span class="functiontext">Packaging::synoptic_submodule</span><span class="plain">(</span><span class="reserved">submodule_identity</span><span class="plain"> *</span><span class="identifier">sid</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Packaging::new_submodule_inner</span><span class="plain">(</span><span class="functiontext">Packaging::get_module</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"synoptic"</span><span class="plain">), </span><span class="identifier">sid</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">package_request</span><span class="plain"> *</span><span class="functiontext">Packaging::template_submodule</span><span class="plain">(</span><span class="reserved">submodule_identity</span><span class="plain"> *</span><span class="identifier">sid</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Packaging::new_submodule_inner</span><span class="plain">(</span><span class="functiontext">Packaging::get_module</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"template"</span><span class="plain">), </span><span class="identifier">sid</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::request_submodule is used in 27/hl (<a href="27-hl.html#SP5">&#167;5</a>).</p>

<p class="endnote">The function Packaging::local_submodule appears nowhere else.</p>

<p class="endnote">The function Packaging::generic_submodule is used in 27/hl (<a href="27-hl.html#SP2">&#167;2</a>).</p>

<p class="endnote">The function Packaging::synoptic_submodule is used in 27/hl (<a href="27-hl.html#SP2">&#167;2</a>).</p>

<p class="endnote">The function Packaging::template_submodule appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17.  </b>Those in turn all make use of this back-end function:
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">submodule_request</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">submodule_identity</span><span class="plain"> *</span><span class="identifier">which_submodule</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">where_found</span><span class="plain">;</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">submodule_request</span><span class="plain">;</span>

    <span class="reserved">package_request</span><span class="plain"> *</span><span class="functiontext">Packaging::new_submodule_inner</span><span class="plain">(</span><span class="reserved">module_package</span><span class="plain"> *</span><span class="identifier">M</span><span class="plain">, </span><span class="reserved">submodule_identity</span><span class="plain"> *</span><span class="identifier">sid</span><span class="plain">) {</span>
        <span class="reserved">submodule_request</span><span class="plain"> *</span><span class="identifier">sr</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_LINKED_LIST</span><span class="plain">(</span><span class="identifier">sr</span><span class="plain">, </span><span class="reserved">submodule_request</span><span class="plain">, </span><span class="identifier">M</span><span class="plain">-</span><span class="element">&gt;submodules</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sid</span><span class="plain"> == </span><span class="identifier">sr</span><span class="plain">-</span><span class="element">&gt;which_submodule</span><span class="plain">)</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">sr</span><span class="plain">-</span><span class="element">&gt;where_found</span><span class="plain">;</span>
        <span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="functiontext">InterNames::explicitly_named</span><span class="plain">(</span><span class="identifier">sid</span><span class="plain">-</span><span class="element">&gt;submodule_name</span><span class="plain">, </span><span class="identifier">M</span><span class="plain">-</span><span class="element">&gt;the_package</span><span class="plain">);</span>
        <span class="identifier">sr</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">submodule_request</span><span class="plain">);</span>
        <span class="identifier">sr</span><span class="plain">-</span><span class="element">&gt;which_submodule</span><span class="plain"> = </span><span class="identifier">sid</span><span class="plain">;</span>
        <span class="identifier">sr</span><span class="plain">-</span><span class="element">&gt;where_found</span><span class="plain"> = </span><span class="functiontext">Packaging::request</span><span class="plain">(</span><span class="identifier">iname</span><span class="plain">, </span><span class="functiontext">PackageTypes::get</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"_submodule"</span><span class="plain">));</span>
        <span class="identifier">ADD_TO_LINKED_LIST</span><span class="plain">(</span><span class="identifier">sr</span><span class="plain">, </span><span class="reserved">submodule_request</span><span class="plain">, </span><span class="identifier">M</span><span class="plain">-</span><span class="element">&gt;submodules</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">sr</span><span class="plain">-</span><span class="element">&gt;where_found</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::new_submodule_inner is used in <a href="#SP16">&#167;16</a>.</p>

<p class="endnote">The structure submodule_request is private to this section.</p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18. Functions. </b>Inter code has a standard layout for functions: an outer, enclosing, package of type
<code class="display"><span class="extract">_function</span></code>, inside which is an iname <code class="display"><span class="extract">call</span></code> for the actual code to call. All such
functions are produced by the following routines:
</p>


<pre class="display">
    <span class="reserved">inter_name</span><span class="plain"> *</span><span class="functiontext">Packaging::function</span><span class="plain">(</span><span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">function_iname</span><span class="plain">, </span><span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">temp_iname</span><span class="plain">) {</span>
        <span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain"> = </span><span class="functiontext">Packaging::request</span><span class="plain">(</span><span class="identifier">function_iname</span><span class="plain">, </span><span class="functiontext">PackageTypes::function</span><span class="plain">());</span>
        <span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="functiontext">InterNames::explicitly_named</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"call"</span><span class="plain">, </span><span class="identifier">P</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">temp_iname</span><span class="plain">) {</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">);</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">, </span><span class="string">"%n"</span><span class="plain">, </span><span class="identifier">temp_iname</span><span class="plain">);</span>
            <span class="functiontext">Emit::change_translation</span><span class="plain">(</span><span class="identifier">iname</span><span class="plain">, </span><span class="identifier">T</span><span class="plain">);</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">iname</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">inter_name</span><span class="plain"> *</span><span class="functiontext">Packaging::function_text</span><span class="plain">(</span><span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">function_iname</span><span class="plain">, </span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">translation</span><span class="plain">) {</span>
        <span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain"> = </span><span class="functiontext">Packaging::request</span><span class="plain">(</span><span class="identifier">function_iname</span><span class="plain">, </span><span class="functiontext">PackageTypes::function</span><span class="plain">());</span>
        <span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="functiontext">InterNames::explicitly_named</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"call"</span><span class="plain">, </span><span class="identifier">P</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">translation</span><span class="plain">)</span>
            <span class="functiontext">Emit::change_translation</span><span class="plain">(</span><span class="identifier">iname</span><span class="plain">, </span><span class="identifier">translation</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">iname</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Packaging::housed_in_function</span><span class="plain">(</span><span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">iname</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain"> = </span><span class="functiontext">InterNames::location</span><span class="plain">(</span><span class="identifier">iname</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">P</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;eventual_type</span><span class="plain"> == </span><span class="functiontext">PackageTypes::function</span><span class="plain">()) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::function is used in 27/hl (<a href="27-hl.html#SP3">&#167;3</a>, <a href="27-hl.html#SP3_1">&#167;3.1</a>).</p>

<p class="endnote">The function Packaging::function_text is used in 27/hl (<a href="27-hl.html#SP3">&#167;3</a>).</p>

<p class="endnote">The function Packaging::housed_in_function is used in 27/ei (<a href="27-ei.html#SP3">&#167;3</a>).</p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19.  </b>Datum is very similar.
</p>


<pre class="display">
    <span class="reserved">inter_name</span><span class="plain"> *</span><span class="functiontext">Packaging::datum_text</span><span class="plain">(</span><span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">function_iname</span><span class="plain">, </span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">translation</span><span class="plain">) {</span>
        <span class="reserved">package_request</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain"> = </span><span class="functiontext">Packaging::request</span><span class="plain">(</span><span class="identifier">function_iname</span><span class="plain">, </span><span class="functiontext">PackageTypes::get</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"_data"</span><span class="plain">));</span>
        <span class="reserved">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="functiontext">InterNames::explicitly_named</span><span class="plain">(</span><span class="identifier">translation</span><span class="plain">, </span><span class="identifier">P</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">iname</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Packaging::datum_text is used in 27/hl (<a href="27-hl.html#SP3">&#167;3</a>).</p>

<hr class="tocbar">
<ul class="toc"><li><a href="27-cm.html">Back to 'Compilation Modules'</a></li><li><a href="27-pt.html">Continue with 'Package Types'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

