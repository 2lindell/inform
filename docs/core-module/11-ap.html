<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>11/tr</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '11/ap' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#11">Chapter 11: Predicate Calculus</a></li><li><b>Atomic Propositions</b></li></ul><p class="purpose">To build and modify atoms, the syntactic pieces from which propositions are built up.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP5">&#167;5. The elements</a></li><li><a href="#SP7">&#167;7. Creating atoms</a></li><li><a href="#SP8">&#167;8. The STRUCTURAL group</a></li><li><a href="#SP11">&#167;11. The PREDICATES group</a></li><li><a href="#SP24">&#167;24. Validating atoms</a></li><li><a href="#SP25">&#167;25. Debugging log</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>As the description in the Introduction showed, propositions are complicated
data structures. Roughly speaking, they are made up of small independent pieces
which can be combined in a variety of ways into larger assemblies. In this
section, we look at the smallest pieces: some of these could be propositions in
their own right, others are only structural items needed to form up the
larger collections. But each individual piece, or "atom", is stored in
a <code class="display"><span class="extract">pcalc_prop</span></code> structure.
</p>

<p class="inwebparagraph">The question of how these are joined together is left until the next section.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">MAX_ATOM_ARITY</span><span class="plain"> 2 </span>    <span class="comment">for the moment, at any rate</span>
</pre>

<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">pcalc_prop</span><span class="plain"> {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">element</span><span class="plain">; </span>    <span class="comment">one of the constants below: always 1 or greater</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">arity</span><span class="plain">; </span>    <span class="comment">1 for quantifiers and unary predicates; 2 for BPs; 0 otherwise</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">general_pointer</span><span class="plain"> </span><span class="identifier">predicate</span><span class="plain">; </span>    <span class="comment">usually indicates which predicate structure is meant</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">terms</span><span class="plain">[</span><span class="constant">MAX_ATOM_ARITY</span><span class="plain">]; </span>    <span class="comment">terms to which the predicate applies</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">assert_kind</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">KIND_ATOM</span></code>: the kind of value of a variable</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">composited</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">KIND_ATOM</span></code>: arises from a composite determiner/noun like "somewhere"</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">unarticled</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">KIND_ATOM</span></code>: arises from an unarticled usage like "vehicle", not "a vehicle"</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">calling_name</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">CALLED_ATOM</span></code>: text of the name this is called</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">quantification_parameter</span><span class="plain">; </span>    <span class="comment"><code class="display"><span class="extract">QUANTIFIER_ATOM</span></code>: e.g., the 3 in "all three"</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">next</span><span class="plain">; </span>    <span class="comment">next atom in the list for this proposition</span>
    <span class="plain">} </span><span class="reserved">pcalc_prop</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure pcalc_prop is accessed in 3/pd, 5/lp, 5/ut, 5/un, 5/ins, 6/rlt, 6/nv, 7/ss, 7/hdn, 7/ns, 7/oaf, 7/rs, 8/ie, 8/ec, 8/ed, 9/tfa, 9/tbath, 9/rpt, 9/tc, 9/ma, 9/rk, 9/ass, 9/imp, 9/pd, 10/teav, 10/cap, 11/pr, 11/bas, 11/tc, 11/sc, 11/sm, 11/tcp, 12/ap, 12/ca, 12/dtd, 12/cad, 12/cdp, 14/rv, 14/lv, 14/cn, 14/ds, 14/ds2, 15/cp, 16/is, 16/in, 19/tb, 19/rsft, 19/tod, 20/eq, 21/rl, 21/rl2, 21/fao, 21/rps, 21/sv, 21/ac, 22/ph, 22/tp, 22/tp2, 23/ad, 24/lv, 24/sf, 25/in, 25/pi, 25/cii, 25/cp, 26/uo, 26/tti, 26/pc, 26/ts, 27/is, 27/cm and here.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>The Universe is filled with atoms, but they come in different kinds, called
elements. For us, an "element" is the identifying number, stored in the
<code class="display"><span class="extract">element</span></code> field, which tells Inform what kind of atom something is. The
following is our Periodic Table of all possible elements:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">QUANTIFIER_ATOM</span><span class="plain"> 1 </span>    <span class="comment">any generalised quantifier</span>
    <span class="definitionkeyword">define</span> <span class="constant">PREDICATE_ATOM</span><span class="plain"> 10 </span>    <span class="comment">a property-based unary predicate, or any predicate of higher arity</span>
    <span class="definitionkeyword">define</span> <span class="constant">KIND_ATOM</span><span class="plain"> 11 </span>    <span class="comment">a unary predicate K(x) associated with a kind K</span>
    <span class="definitionkeyword">define</span> <span class="constant">ISAKIND_ATOM</span><span class="plain"> 12 </span>    <span class="comment">a unary predicate asserting that x is the world-object for a kind</span>
    <span class="definitionkeyword">define</span> <span class="constant">ISAVAR_ATOM</span><span class="plain"> 13 </span>    <span class="comment">a unary predicate asserting that x is the SP for a global variable</span>
    <span class="definitionkeyword">define</span> <span class="constant">ISACONST_ATOM</span><span class="plain"> 14 </span>    <span class="comment">a unary predicate asserting that x is the SP for a named constant</span>
    <span class="definitionkeyword">define</span> <span class="constant">EVERYWHERE_ATOM</span><span class="plain"> 15 </span>    <span class="comment">a unary predicate asserting omnipresence</span>
    <span class="definitionkeyword">define</span> <span class="constant">NOWHERE_ATOM</span><span class="plain"> 16 </span>    <span class="comment">a unary predicate asserting nonpresence</span>
    <span class="definitionkeyword">define</span> <span class="constant">HERE_ATOM</span><span class="plain"> 17 </span>    <span class="comment">a unary predicate asserting presence "here"</span>
    <span class="definitionkeyword">define</span> <span class="constant">CALLED_ATOM</span><span class="plain"> 18 </span>    <span class="comment">to keep track of "(called the intruder)"-style names</span>
    <span class="definitionkeyword">define</span> <span class="constant">NEGATION_OPEN_ATOM</span><span class="plain"> 20 </span>    <span class="comment">logical negation ¬ applied to contents of group</span>
    <span class="definitionkeyword">define</span> <span class="constant">NEGATION_CLOSE_ATOM</span><span class="plain"> 30 </span>    <span class="comment">end of logical negation ¬</span>
    <span class="definitionkeyword">define</span> <span class="constant">DOMAIN_OPEN_ATOM</span><span class="plain"> 21 </span>    <span class="comment">logical negation ¬ applied to contents of group</span>
    <span class="definitionkeyword">define</span> <span class="constant">DOMAIN_CLOSE_ATOM</span><span class="plain"> 31 </span>    <span class="comment">end of logical negation ¬</span>
</pre>
<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>And as with columns in the Periodic Table, these elements come in what are
called "groups", because it often happens that atoms of different elements
behave similarly when the elements have something in common.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">STRUCTURAL_GROUP</span><span class="plain"> 10</span>
    <span class="definitionkeyword">define</span> <span class="constant">PREDICATES_GROUP</span><span class="plain"> 20</span>
    <span class="definitionkeyword">define</span> <span class="constant">OPEN_OPERATORS_GROUP</span><span class="plain"> 30</span>
    <span class="definitionkeyword">define</span> <span class="constant">CLOSE_OPERATORS_GROUP</span><span class="plain"> 40</span>
</pre>
<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. The elements. </b>Given an element, the following returns the group to which it belongs.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::element_get_group</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">element</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">element</span><span class="plain"> &lt;= 0) </span><span class="reserved">return</span><span class="plain"> 0;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">element</span><span class="plain"> &lt; </span><span class="constant">STRUCTURAL_GROUP</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">STRUCTURAL_GROUP</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">element</span><span class="plain"> &lt; </span><span class="constant">PREDICATES_GROUP</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">PREDICATES_GROUP</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">element</span><span class="plain"> &lt; </span><span class="constant">OPEN_OPERATORS_GROUP</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">OPEN_OPERATORS_GROUP</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">element</span><span class="plain"> &lt; </span><span class="constant">CLOSE_OPERATORS_GROUP</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">CLOSE_OPERATORS_GROUP</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> 0;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::element_get_group is used in <a href="#SP24">&#167;24</a>, 11/pr (<a href="11-pr.html#SP7">&#167;7</a>, <a href="11-pr.html#SP12">&#167;12</a>, <a href="11-pr.html#SP29">&#167;29</a>), 11/bas (<a href="11-bas.html#SP4">&#167;4</a>), 11/sm (<a href="11-sm.html#SP10_1">&#167;10.1</a>, <a href="11-sm.html#SP10_2">&#167;10.2</a>, <a href="11-sm.html#SP10_3">&#167;10.3</a>, <a href="11-sm.html#SP10_3_1">&#167;10.3.1</a>, <a href="11-sm.html#SP10_4">&#167;10.4</a>, <a href="11-sm.html#SP14">&#167;14</a>, <a href="11-sm.html#SP14_1">&#167;14.1</a>), 12/cdp (<a href="12-cdp.html#SP5_1">&#167;5.1</a>).</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>Some atoms occur in pairs, which have to match like opening and closing
parentheses. The following returns 0 for an element code which does not behave
like this, or else returns the opposite number to any element code which does.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::element_get_match</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">element</span><span class="plain">) {</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">element</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NEGATION_OPEN_ATOM</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">NEGATION_CLOSE_ATOM</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NEGATION_CLOSE_ATOM</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">NEGATION_OPEN_ATOM</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">DOMAIN_OPEN_ATOM</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">DOMAIN_CLOSE_ATOM</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">DOMAIN_CLOSE_ATOM</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> </span><span class="constant">DOMAIN_OPEN_ATOM</span><span class="plain">;</span>
            <span class="reserved">default</span><span class="plain">: </span><span class="reserved">return</span><span class="plain"> 0;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::element_get_match is used in 11/pr (<a href="11-pr.html#SP12">&#167;12</a>, <a href="11-pr.html#SP29">&#167;29</a>, <a href="11-pr.html#SP32">&#167;32</a>).</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Creating atoms. </b>Every atom is created by the following routine:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">element</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> = </span><span class="identifier">element</span><span class="plain">;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;composited</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;unarticled</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> = 0;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain"> = </span><span class="identifier">NULL_GENERAL_POINTER</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::new is used in <a href="#SP8">&#167;8</a>, <a href="#SP11">&#167;11</a>, <a href="#SP12">&#167;12</a>, <a href="#SP13">&#167;13</a>, <a href="#SP14">&#167;14</a>, <a href="#SP15">&#167;15</a>, <a href="#SP16">&#167;16</a>, <a href="#SP17">&#167;17</a>, <a href="#SP18">&#167;18</a>, <a href="#SP20">&#167;20</a>, <a href="#SP21">&#167;21</a>, 9/imp (<a href="9-imp.html#SP7_1_3">&#167;7.1.3</a>), 11/pr (<a href="11-pr.html#SP14">&#167;14</a>), 11/tc (<a href="11-tc.html#SP7_2">&#167;7.2</a>), 11/sc (<a href="11-sc.html#SP1_13">&#167;1.13</a>, <a href="11-sc.html#SP3_8">&#167;3.8</a>), 11/sm (<a href="11-sm.html#SP3_2">&#167;3.2</a>, <a href="11-sm.html#SP6">&#167;6</a>, <a href="11-sm.html#SP7">&#167;7</a>, <a href="11-sm.html#SP19">&#167;19</a>), 12/dtd (<a href="12-dtd.html#SP13">&#167;13</a>), 14/ds (<a href="14-ds.html#SP9">&#167;9</a>).</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. The STRUCTURAL group. </b>Some convenient routines to handle atoms of specific elements now follow:
first, <code class="display"><span class="extract">QUANTIFIER</span></code> atoms. These have arity 1, and the single term must always
be a variable, the one which is being bound. The parameter is a number
needed for some <code class="display"><span class="extract">quantifier</span></code> types to identify the range: for instance,
it would be 7 in the case of V_{=7}.
</p>

<p class="inwebparagraph">Tying specific variables to quantifiers seems to be out of fashion in
modern computer science. Contemporary theorem-proving assistants mostly
use de Bruijn's numbering scheme, in which numbers 1, 2, 3, ..., refer
to variables being quantified in an indirect way. The advantage is that
propositions are easier to construct, since the same numbers can be used
in different subexpressions of the same proposition, and there's no
worrying about clashes. But it all just moves the difficulty elsewhere,
by making it less obvious how to pair up the numbers with variables at
compilation time, and less obvious even how many variables are needed.
So we stick to the old-fashioned way of imitating ∀ x: P(x)
rather than ∀ 1. P.
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::QUANTIFIER_new</span><span class="plain">(</span><span class="identifier">quantifier</span><span class="plain"> *</span><span class="identifier">quant</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">v</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">parameter</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> = 1;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0] = </span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(</span><span class="identifier">v</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain"> = </span><span class="identifier">STORE_POINTER_quantifier</span><span class="plain">(</span><span class="identifier">quant</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;quantification_parameter</span><span class="plain"> = </span><span class="identifier">parameter</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::QUANTIFIER_new is used in 11/bas (<a href="11-bas.html#SP12">&#167;12</a>), 11/tc (<a href="11-tc.html#SP1">&#167;1</a>), 11/sm (<a href="11-sm.html#SP3_2">&#167;3.2</a>, <a href="11-sm.html#SP4">&#167;4</a>), 14/ds (<a href="14-ds.html#SP9">&#167;9</a>).</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>Quantifier atoms can be detected as follows:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::is_quantifier</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain">) &amp;&amp; (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">quantifier</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::get_quantifier</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain">) &amp;&amp; (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">RETRIEVE_POINTER_quantifier</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::get_quantification_parameter</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain">) &amp;&amp; (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;quantification_parameter</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> 0;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::is_existence_quantifier</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain">) &amp;&amp; (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">RETRIEVE_POINTER_quantifier</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain">) == </span><span class="identifier">exists_quantifier</span><span class="plain">))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::is_nonexistence_quantifier</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain">) &amp;&amp; (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">RETRIEVE_POINTER_quantifier</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain">) == </span><span class="identifier">not_exists_quantifier</span><span class="plain">))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::is_forall_quantifier</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain">) &amp;&amp; (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">RETRIEVE_POINTER_quantifier</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain">) == </span><span class="identifier">for_all_quantifier</span><span class="plain">))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::is_notall_quantifier</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain">) &amp;&amp; (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">RETRIEVE_POINTER_quantifier</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain">) == </span><span class="identifier">not_for_all_quantifier</span><span class="plain">))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::is_for_all_x</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">Calculus::Atoms::is_forall_quantifier</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.variable</span><span class="plain"> == 0)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::is_quantifier is used in 11/pr (<a href="11-pr.html#SP12">&#167;12</a>), 11/sm (<a href="11-sm.html#SP14_1">&#167;14.1</a>).</p>

<p class="endnote">The function Calculus::Atoms::get_quantifier is used in 14/ds (<a href="14-ds.html#SP9">&#167;9</a>).</p>

<p class="endnote">The function Calculus::Atoms::get_quantification_parameter is used in 12/cdp (<a href="12-cdp.html#SP2_1_6_1_2_3">&#167;2.1.6.1.2.3</a>), 14/ds (<a href="14-ds.html#SP9">&#167;9</a>).</p>

<p class="endnote">The function Calculus::Atoms::is_existence_quantifier is used in 11/pr (<a href="11-pr.html#SP12">&#167;12</a>, <a href="11-pr.html#SP27">&#167;27</a>), 11/sm (<a href="11-sm.html#SP5">&#167;5</a>, <a href="11-sm.html#SP7">&#167;7</a>, <a href="11-sm.html#SP10_2">&#167;10.2</a>, <a href="11-sm.html#SP14_1">&#167;14.1</a>), 12/dtd (<a href="12-dtd.html#SP11_1">&#167;11.1</a>).</p>

<p class="endnote">The function Calculus::Atoms::is_nonexistence_quantifier is used in 11/sm (<a href="11-sm.html#SP10_2">&#167;10.2</a>, <a href="11-sm.html#SP19">&#167;19</a>).</p>

<p class="endnote">The function Calculus::Atoms::is_forall_quantifier is used in 11/sm (<a href="11-sm.html#SP19">&#167;19</a>).</p>

<p class="endnote">The function Calculus::Atoms::is_notall_quantifier is used in 11/sm (<a href="11-sm.html#SP19">&#167;19</a>).</p>

<p class="endnote">The function Calculus::Atoms::is_for_all_x is used in 11/pr (<a href="11-pr.html#SP33">&#167;33</a>).</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>See "Determiners and Quantifiers" for what a now-assertable quantifier is:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::is_now_assertable_quantifier</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> != </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">Quantifiers::is_now_assertable</span><span class="plain">(</span><span class="identifier">RETRIEVE_POINTER_quantifier</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain">));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::is_now_assertable_quantifier is used in 12/dtd (<a href="12-dtd.html#SP11_1">&#167;11.1</a>).</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. The PREDICATES group. </b>Next, unary predicates, beginning with the <code class="display"><span class="extract">EVERYWHERE</span></code> special case.
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::EVERYWHERE_new</span><span class="plain">(</span><span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">pt</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">EVERYWHERE_ATOM</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> = 1;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0] = </span><span class="identifier">pt</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::EVERYWHERE_new is used in 11/tc (<a href="11-tc.html#SP5">&#167;5</a>), 11/sm (<a href="11-sm.html#SP19">&#167;19</a>).</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b>And <code class="display"><span class="extract">NOWHERE</span></code>:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::NOWHERE_new</span><span class="plain">(</span><span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">pt</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">NOWHERE_ATOM</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> = 1;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0] = </span><span class="identifier">pt</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::NOWHERE_new is used in 11/tc (<a href="11-tc.html#SP5">&#167;5</a>), 11/sm (<a href="11-sm.html#SP19">&#167;19</a>).</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b>And <code class="display"><span class="extract">HERE</span></code>:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::HERE_new</span><span class="plain">(</span><span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">pt</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">HERE_ATOM</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> = 1;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0] = </span><span class="identifier">pt</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::HERE_new is used in 11/tc (<a href="11-tc.html#SP5">&#167;5</a>).</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14.  </b>And <code class="display"><span class="extract">ISAKIND</span></code>:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::ISAKIND_new</span><span class="plain">(</span><span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">pt</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">ISAKIND_ATOM</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> = 1;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0] = </span><span class="identifier">pt</span><span class="plain">;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain"> = </span><span class="identifier">K</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::ISAKIND_new is used in 11/tc (<a href="11-tc.html#SP1">&#167;1</a>).</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b>And <code class="display"><span class="extract">ISAVAR</span></code>:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::ISAVAR_new</span><span class="plain">(</span><span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">pt</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">ISAVAR_ATOM</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> = 1;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0] = </span><span class="identifier">pt</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::ISAVAR_new is used in 11/tc (<a href="11-tc.html#SP1">&#167;1</a>).</p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16.  </b>And <code class="display"><span class="extract">ISACONST</span></code>:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::ISACONST_new</span><span class="plain">(</span><span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">pt</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">ISACONST_ATOM</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> = 1;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0] = </span><span class="identifier">pt</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::ISACONST_new is used in 11/tc (<a href="11-tc.html#SP1">&#167;1</a>).</p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17.  </b><code class="display"><span class="extract">CALLED</span></code> atoms are interesting because they exist only for their side-effects:
they have no effect at all on the logical status of a proposition (well, except
that they should not be applied to free variables referred to nowhere else).
They can therefore be added or removed freely. In the phrase
</p>

<blockquote>
    <p>if a woman is in a lighted room (called the den), ...</p>

</blockquote>

<p class="inwebparagraph">we need to note that the value of the bound variable corresponding to the
lighted room will need to be kept and to have a name ("the den"): this
will probably mean the inclusion of a <code class="display"><span class="extract">CALLED=den(y)</span></code> atom.
</p>

<p class="inwebparagraph">The calling data for a <code class="display"><span class="extract">CALLED</span></code> atom is the textual name by which the variable
will be called.
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::CALLED_new</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">pt</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">CALLED_ATOM</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> = 1;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0] = </span><span class="identifier">pt</span><span class="plain">;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;calling_name</span><span class="plain"> = </span><span class="identifier">W</span><span class="plain">;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain"> = </span><span class="identifier">K</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::CALLED_get_name</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;calling_name</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::CALLED_new is used in 11/tc (<a href="11-tc.html#SP1">&#167;1</a>), 14/ds (<a href="14-ds.html#SP10">&#167;10</a>).</p>

<p class="endnote">The function Calculus::Atoms::CALLED_get_name is used in <a href="#SP25">&#167;25</a>, 12/ap (<a href="12-ap.html#SP9_5_1">&#167;9.5.1</a>), 12/ca (<a href="12-ca.html#SP6_1">&#167;6.1</a>), 12/dtd (<a href="12-dtd.html#SP9_2">&#167;9.2</a>), 14/ds (<a href="14-ds.html#SP10">&#167;10</a>).</p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18.  </b>Now for a <code class="display"><span class="extract">KIND</span></code> atom. At first sight, it looks odd that a unary
predicate for a kind is represented differently from other predicates.
Isn't it a unary predicate just like any other? Well: it is, but then
again, we want to compile propositions to reasonably efficient I6 code
which determines whether or not they are true. We particularly want to
look out for patterns like
 ∀ x : ... ∧ container(x) ∧ ... 
since they allow us to consider x ranging over a smaller, and therefore
more efficiently searchable, domain: most objects aren't containers. So
<code class="display"><span class="extract">KIND_ATOM</span></code> atoms are useful in ways which other unary predicate atoms
are not.
</p>

<p class="inwebparagraph">Once again, this atom has arity 1, but the term no longer has to be a
variable; when Inform reads a sentence like
</p>

<blockquote>
    <p>Viper Pit is a room.</p>

</blockquote>

<p class="inwebparagraph">the resulting proposition will include a <code class="display"><span class="extract">KIND</span></code> atom whose term is the
constant value for the Viper Pit.
</p>

<p class="inwebparagraph">Any kind of value can be assigned, but the commonest case involves a kind
of object, so a special routine exists just to create <code class="display"><span class="extract">KIND</span></code> atoms in
that case.
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::KIND_new</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">, </span><span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">pt</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">KIND_ATOM</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> = 1;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain"> = </span><span class="identifier">K</span><span class="plain">;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0] = </span><span class="identifier">pt</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::KIND_new_composited</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">, </span><span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">pt</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">KIND_ATOM</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> = 1;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain"> = </span><span class="identifier">K</span><span class="plain">;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0] = </span><span class="identifier">pt</span><span class="plain">;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;composited</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">kind</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::get_asserted_kind</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::is_composited</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain">) &amp;&amp; (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;composited</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::set_composited</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">state</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">) </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;composited</span><span class="plain"> = </span><span class="identifier">state</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::KIND_new is used in 9/ma (<a href="9-ma.html#SP3_3_39_5">&#167;3.3.39.5</a>), 9/imp (<a href="9-imp.html#SP7_1_3">&#167;7.1.3</a>), 11/tc (<a href="11-tc.html#SP1">&#167;1</a>, <a href="11-tc.html#SP2">&#167;2</a>, <a href="11-tc.html#SP7">&#167;7</a>), 11/sc (<a href="11-sc.html#SP3_3">&#167;3.3</a>), 11/sm (<a href="11-sm.html#SP3_2">&#167;3.2</a>, <a href="11-sm.html#SP4">&#167;4</a>, <a href="11-sm.html#SP8">&#167;8</a>, <a href="11-sm.html#SP10_3_2">&#167;10.3.2</a>), 12/dtd (<a href="12-dtd.html#SP10">&#167;10</a>, <a href="12-dtd.html#SP13">&#167;13</a>), 14/ds (<a href="14-ds.html#SP3">&#167;3</a>).</p>

<p class="endnote">The function Calculus::Atoms::KIND_new_composited is used in 14/ds (<a href="14-ds.html#SP3">&#167;3</a>).</p>

<p class="endnote">The function Calculus::Atoms::get_asserted_kind appears nowhere else.</p>

<p class="endnote">The function Calculus::Atoms::is_composited is used in 11/sm (<a href="11-sm.html#SP19">&#167;19</a>).</p>

<p class="endnote">The function Calculus::Atoms::set_composited is used in 11/sc (<a href="11-sc.html#SP1_13_1">&#167;1.13.1</a>).</p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19.  </b>Likewise:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::is_unarticled</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain">) &amp;&amp; (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;unarticled</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::set_unarticled</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">state</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">) </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;unarticled</span><span class="plain"> = </span><span class="identifier">state</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::is_unarticled is used in 11/sm (<a href="11-sm.html#SP10_3_2">&#167;10.3.2</a>).</p>

<p class="endnote">The function Calculus::Atoms::set_unarticled is used in 11/sc (<a href="11-sc.html#SP3_4">&#167;3.4</a>), 11/sm (<a href="11-sm.html#SP10_3_2">&#167;10.3.2</a>).</p>

<p class="inwebparagraph"><a id="SP20"></a><b>&#167;20.  </b>That just leaves the general sort of unary predicate. In principle we ought
to be able to create U(t) for any term t, but in practice we only ever
need t=x, that is, variable 0.
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::unary_PREDICATE_from_aph</span><span class="plain">(</span><span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">negated</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">PREDICATE_ATOM</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> = 1;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0] = </span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain"> = </span><span class="identifier">STORE_POINTER_adjective_usage</span><span class="plain">(</span>
            <span class="identifier">AdjectiveUsages::new</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, (</span><span class="identifier">negated</span><span class="plain">)?</span><span class="identifier">FALSE</span><span class="plain">:</span><span class="identifier">TRUE</span><span class="plain">));</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">adjective_usage</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::au_from_unary_PREDICATE</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">RETRIEVE_POINTER_adjective_usage</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::unary_PREDICATE_from_aph is used in 9/imp (<a href="9-imp.html#SP7_1_3">&#167;7.1.3</a>), 11/pr (<a href="11-pr.html#SP35_1">&#167;35.1</a>, <a href="11-pr.html#SP35_2">&#167;35.2</a>), 11/tc (<a href="11-tc.html#SP7_2">&#167;7.2</a>), 11/sc (<a href="11-sc.html#SP3_3">&#167;3.3</a>), 14/ds (<a href="14-ds.html#SP8">&#167;8</a>), 15/ep (<a href="15-ep.html#SP9">&#167;9</a>).</p>

<p class="endnote">The function Calculus::Atoms::au_from_unary_PREDICATE is used in 11/pr (<a href="11-pr.html#SP28">&#167;28</a>).</p>

<p class="inwebparagraph"><a id="SP21"></a><b>&#167;21.  </b>And binary predicates are pretty well the same:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::binary_PREDICATE_new</span><span class="plain">(</span><span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain">,</span>
        <span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">pt1</span><span class="plain">, </span><span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">pt2</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">PREDICATE_ATOM</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> = 2;</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain"> = </span><span class="identifier">STORE_POINTER_binary_predicate</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0] = </span><span class="identifier">pt1</span><span class="plain">; </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[1] = </span><span class="identifier">pt2</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::is_binary_predicate</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> != </span><span class="constant">PREDICATE_ATOM</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> != 2) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">RETRIEVE_POINTER_binary_predicate</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::is_equality_predicate</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::is_binary_predicate</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">R_equality</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::binary_PREDICATE_new is used in <a href="#SP22">&#167;22</a>, 11/tc (<a href="11-tc.html#SP3">&#167;3</a>, <a href="11-tc.html#SP4">&#167;4</a>), 11/sc (<a href="11-sc.html#SP1_13">&#167;1.13</a>, <a href="11-sc.html#SP3_7">&#167;3.7</a>), 11/sm (<a href="11-sm.html#SP4">&#167;4</a>, <a href="11-sm.html#SP15">&#167;15</a>), 15/ma (<a href="15-ma.html#SP13">&#167;13</a>).</p>

<p class="endnote">The function Calculus::Atoms::is_binary_predicate is used in 11/sm (<a href="11-sm.html#SP3">&#167;3</a>, <a href="11-sm.html#SP8">&#167;8</a>, <a href="11-sm.html#SP11">&#167;11</a>, <a href="11-sm.html#SP12">&#167;12</a>, <a href="11-sm.html#SP13">&#167;13</a>).</p>

<p class="endnote">The function Calculus::Atoms::is_equality_predicate is used in <a href="#SP23">&#167;23</a>, 11/pr (<a href="11-pr.html#SP13">&#167;13</a>, <a href="11-pr.html#SP24">&#167;24</a>), 11/sm (<a href="11-sm.html#SP3">&#167;3</a>, <a href="11-sm.html#SP7">&#167;7</a>, <a href="11-sm.html#SP14">&#167;14</a>, <a href="11-sm.html#SP17">&#167;17</a>).</p>

<p class="inwebparagraph"><a id="SP22"></a><b>&#167;22.  </b>Given C, return the proposition is(x, C):
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::prop_x_is_constant</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::binary_PREDICATE_new</span><span class="plain">(</span><span class="identifier">R_equality</span><span class="plain">,</span>
            <span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0), </span><span class="functiontext">Calculus::Terms::new_constant</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::prop_x_is_constant is used in 11/pr (<a href="11-pr.html#SP35_3">&#167;35.3</a>), 14/ds (<a href="14-ds.html#SP5">&#167;5</a>).</p>

<p class="inwebparagraph"><a id="SP23"></a><b>&#167;23.  </b>And conversely:
</p>


<pre class="display">
    <span class="reserved">pcalc_term</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::is_x_equals</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Atoms::is_equality_predicate</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.variable</span><span class="plain"> != 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> &amp;(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[1]);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::is_x_equals is used in 11/sc (<a href="11-sc.html#SP3_4">&#167;3.4</a>).</p>

<p class="inwebparagraph"><a id="SP24"></a><b>&#167;24. Validating atoms. </b></p>


<pre class="display">
    <span class="reserved">char</span><span class="plain"> *</span><span class="functiontext">Calculus::Atoms::validate</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">group</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">group</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::element_get_group</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">group</span><span class="plain"> == 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"atom of undiscovered element"</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> &gt; </span><span class="constant">MAX_ATOM_ARITY</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"atom with overly large arity"</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> &lt; 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"atom with negative arity"</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> == 0) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">group</span><span class="plain"> == </span><span class="constant">PREDICATES_GROUP</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"predicate without terms"</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">"quantifier without variable"</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> != </span><span class="constant">PREDICATE_ATOM</span><span class="plain">) &amp;&amp; (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> != 1))</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="string">"unary atom with other than one term"</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">group</span><span class="plain"> == </span><span class="constant">OPEN_OPERATORS_GROUP</span><span class="plain">) || (</span><span class="identifier">group</span><span class="plain"> == </span><span class="constant">CLOSE_OPERATORS_GROUP</span><span class="plain">))</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="string">"parentheses with terms"</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">) &amp;&amp; (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.variable</span><span class="plain"> == -1))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="string">"missing variable in quantification"</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::validate is used in 11/pr (<a href="11-pr.html#SP12">&#167;12</a>).</p>

<p class="inwebparagraph"><a id="SP25"></a><b>&#167;25. Debugging log. </b>Logging atomic propositions divides into cases:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::log</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) { </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"&lt;null-atom&gt;"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain">; }</span>
        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">PREDICATE_ATOM</span><span class="plain">:</span>
                <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain">) {</span>
                    <span class="reserved">case</span><span class="plain"> 1: </span>&lt;<span class="cwebmacro">Log some suitable textual name for this unary predicate</span> <span class="cwebmacronumber">25.1</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                    <span class="reserved">case</span><span class="plain"> 2: </span>&lt;<span class="cwebmacro">Log some suitable textual name for this binary predicate</span> <span class="cwebmacronumber">25.2</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                    <span class="reserved">default</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"?exotic-predicate-arity=%d?"</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">: {</span>
                <span class="identifier">quantifier</span><span class="plain"> *</span><span class="identifier">quant</span><span class="plain"> = </span><span class="identifier">RETRIEVE_POINTER_quantifier</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain">);</span>
                <span class="identifier">Quantifiers::log</span><span class="plain">(</span><span class="identifier">quant</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;quantification_parameter</span><span class="plain">);</span>
                <span class="identifier">LOG</span><span class="plain">(</span><span class="string">" "</span><span class="plain">); </span>&lt;<span class="cwebmacro">Log a comma-separated list of terms for this atomic proposition</span> <span class="cwebmacronumber">25.3</span>&gt;<span class="plain">;</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">CALLED_ATOM</span><span class="plain">: {</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::CALLED_get_name</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">);</span>
                <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"called='%W'"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain">) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"($u)"</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">KIND_ATOM</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Streams::I6_escapes_enabled</span><span class="plain">(</span><span class="identifier">DL</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"kind="</span><span class="plain">);</span>
                <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"$u"</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Streams::I6_escapes_enabled</span><span class="plain">(</span><span class="identifier">DL</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;composited</span><span class="plain">)) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"_c"</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Streams::I6_escapes_enabled</span><span class="plain">(</span><span class="identifier">DL</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;unarticled</span><span class="plain">)) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"_u"</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">ISAKIND_ATOM</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"is-a-kind"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">ISAVAR_ATOM</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"is-a-var"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">ISACONST_ATOM</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"is-a-const"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">EVERYWHERE_ATOM</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"everywhere"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOWHERE_ATOM</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"nowhere"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">HERE_ATOM</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"here"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NEGATION_OPEN_ATOM</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"NOT["</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NEGATION_CLOSE_ATOM</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"NOT]"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">DOMAIN_OPEN_ATOM</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"IN["</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">DOMAIN_CLOSE_ATOM</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"IN]"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">default</span><span class="plain">: </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"?bad-atom?"</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> &gt; 0) {</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"("</span><span class="plain">); </span>&lt;<span class="cwebmacro">Log a comma-separated list of terms for this atomic proposition</span> <span class="cwebmacronumber">25.3</span>&gt;<span class="plain">; </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">")"</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::log is used in 1/cm (<a href="1-cm.html#SP5">&#167;5</a>, <a href="1-cm.html#SP6_6">&#167;6.6</a>), 11/pr (<a href="11-pr.html#SP9">&#167;9</a>).</p>

<p class="inwebparagraph"><a id="SP25_1"></a><b>&#167;25.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Log some suitable textual name for this unary predicate</span> <span class="cwebmacronumber">25.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">adjective_usage</span><span class="plain"> *</span><span class="identifier">tr</span><span class="plain"> = </span><span class="identifier">RETRIEVE_POINTER_adjective_usage</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">AdjectiveUsages::get_parity</span><span class="plain">(</span><span class="identifier">tr</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"not-"</span><span class="plain">);</span>
        <span class="identifier">Adjectives::log</span><span class="plain">(</span><span class="identifier">AdjectiveUsages::get_aph</span><span class="plain">(</span><span class="identifier">tr</span><span class="plain">));</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP25">&#167;25</a>.</p>

<p class="inwebparagraph"><a id="SP25_2"></a><b>&#167;25.2.  </b>And more easily:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Log some suitable textual name for this binary predicate</span> <span class="cwebmacronumber">25.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain"> = </span><span class="identifier">RETRIEVE_POINTER_binary_predicate</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"?bad-bp?"</span><span class="plain">); </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"%S"</span><span class="plain">, </span><span class="functiontext">BinaryPredicates::get_log_name</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">));</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP25">&#167;25</a>.</p>

<p class="inwebparagraph"><a id="SP25_3"></a><b>&#167;25.3.  </b>Just a diagnostic way of printing the terms in an atomic proposition, by
their index numbers. (They are numbered from 0 to A-1, where A is the
arity.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Log a comma-separated list of terms for this atomic proposition</span> <span class="cwebmacronumber">25.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">t</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">t</span><span class="plain">=0; </span><span class="identifier">t</span><span class="plain">&lt;</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain">; </span><span class="identifier">t</span><span class="plain">++) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">t</span><span class="plain">&gt;0) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">", "</span><span class="plain">);</span>
            <span class="functiontext">Calculus::Terms::log</span><span class="plain">(&amp;(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[</span><span class="identifier">t</span><span class="plain">]));</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP25">&#167;25</a> (twice).</p>

<hr class="tocbar">
<ul class="toc"><li><a href="11-tr.html">Back to 'Terms'</a></li><li><a href="11-pr.html">Continue with 'Propositions'</a></li></ul><hr class="tocbar">
<!--End of weave: 512 lines from a web of 93250-->
	</body>
</html>

