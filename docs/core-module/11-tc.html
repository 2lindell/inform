<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>11/bas</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '11/tc' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#11">Chapter 11: Predicate Calculus</a></li><li><b>Tree Conversions</b></li></ul><p class="purpose">The second of the three sources of propositions to conjure with: those which arise from subtrees constructed by the A-parser.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Elementary propositions</a></li><li><a href="#SP6">&#167;6. Property setting</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Elementary propositions. </b>The S-parser attacks whole sentences, but the A-parser more cautiously takes
on only fragments, and so it makes much shorter propositions &mdash; usually with
a single free variable representing an object or value to which something
must be done.
</p>

<p class="inwebparagraph">We start with some elementary propositions which create things, by asserting
their existence.
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::Abstract::to_make_a_kind</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::ISAKIND_new</span><span class="plain">(</span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0), </span><span class="identifier">K</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::Abstract::to_make_a_var</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::ISAVAR_new</span><span class="plain">(</span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0));</span>
    <span class="plain">}</span>

    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::Abstract::to_make_a_const</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::ISACONST_new</span><span class="plain">(</span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0));</span>
    <span class="plain">}</span>

    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::Abstract::to_create_something</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::QUANTIFIER_new</span><span class="plain">(</span><span class="identifier">exists_quantifier</span><span class="plain">, 0, 0);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">K</span><span class="plain">) &amp;&amp; (</span><span class="identifier">Kinds::Compare::eq</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">))</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::concatenate</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">,</span>
                <span class="functiontext">Calculus::Atoms::KIND_new</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0)));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::concatenate</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">,</span>
                <span class="functiontext">Calculus::Atoms::CALLED_new</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0), </span><span class="identifier">K</span><span class="plain">));</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::Abstract::to_make_a_kind is used in 9/tc (<a href="9-tc.html#SP5_4_1_1">&#167;5.4.1.1</a>, <a href="9-tc.html#SP5_4_2_1">&#167;5.4.2.1</a>), 15/cp (<a href="15-cp.html#SP3">&#167;3</a>).</p>

<p class="endnote">The function Calculus::Propositions::Abstract::to_make_a_var is used in 9/tc (<a href="9-tc.html#SP5_4_2_2">&#167;5.4.2.2</a>).</p>

<p class="endnote">The function Calculus::Propositions::Abstract::to_make_a_const is used in 9/tc (<a href="9-tc.html#SP5_4_2_2">&#167;5.4.2.2</a>).</p>

<p class="endnote">The function Calculus::Propositions::Abstract::to_create_something is used in 3/nl (<a href="3-nl.html#SP5">&#167;5</a>), 9/tc (<a href="9-tc.html#SP5_4_1_1">&#167;5.4.1.1</a>, <a href="9-tc.html#SP5_4_2_1">&#167;5.4.2.1</a>, <a href="9-tc.html#SP5_4_2_2">&#167;5.4.2.2</a>, <a href="9-tc.html#SP5_4_2_3">&#167;5.4.2.3</a>, <a href="9-tc.html#SP8_4_1">&#167;8.4.1</a>), 9/pd (<a href="9-pd.html#SP5_11">&#167;5.11</a>), 15/cp (<a href="15-cp.html#SP3">&#167;3</a>).</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>A proposition to assert that an object has a given kind:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::Abstract::prop_to_set_kind</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">k</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::KIND_new</span><span class="plain">(</span><span class="identifier">k</span><span class="plain">, </span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0));</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::Abstract::assert_kind_of_object</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">k</span><span class="plain">) {</span>
        <span class="functiontext">Calculus::Propositions::Assert::assert_true_about</span><span class="plain">(</span><span class="functiontext">Calculus::Propositions::Abstract::prop_to_set_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">k</span><span class="plain">),</span>
            <span class="functiontext">Instances::as_subject</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">), </span><span class="identifier">prevailing_mood</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::Abstract::assert_kind_of_subject</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">inst</span><span class="plain">, </span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">new</span><span class="plain">,</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">subject_to</span><span class="plain">) {</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::domain</span><span class="plain">(</span><span class="identifier">new</span><span class="plain">);</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::KIND_new</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">subject_to</span><span class="plain">) </span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::concatenate</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">subject_to</span><span class="plain">);</span>
        <span class="functiontext">Calculus::Propositions::Assert::assert_true_about</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">inst</span><span class="plain">, </span><span class="identifier">prevailing_mood</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::Abstract::prop_to_set_kind appears nowhere else.</p>

<p class="endnote">The function Calculus::Propositions::Abstract::assert_kind_of_object appears nowhere else.</p>

<p class="endnote">The function Calculus::Propositions::Abstract::assert_kind_of_subject is used in 9/tc (<a href="9-tc.html#SP5_2_1">&#167;5.2.1</a>), 9/ma (<a href="9-ma.html#SP3_3_8">&#167;3.3.8</a>).</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>Now propositions to assert that relations hold:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::Abstract::to_set_simple_relation</span><span class="plain">(</span><span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain">, </span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain">) </span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Rvalues::from_instance</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Rvalues::new_nothing_object_constant</span><span class="plain">();</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::binary_PREDICATE_new</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">,</span>
            <span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0), </span><span class="functiontext">Calculus::Terms::new_constant</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
    <span class="plain">}</span>

    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::Abstract::to_set_relation</span><span class="plain">(</span><span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain">,</span>
        <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs0</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec0</span><span class="plain">, </span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs1</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec1</span><span class="plain">) {</span>
        <span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">pt0</span><span class="plain">, </span><span class="identifier">pt1</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">infs0</span><span class="plain">) </span><span class="identifier">pt0</span><span class="plain"> = </span><span class="functiontext">Calculus::Terms::new_constant</span><span class="plain">(</span><span class="functiontext">InferenceSubjects::as_constant</span><span class="plain">(</span><span class="identifier">infs0</span><span class="plain">));</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">pt0</span><span class="plain"> = </span><span class="functiontext">Calculus::Terms::new_constant</span><span class="plain">(</span><span class="identifier">spec0</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">infs1</span><span class="plain">) </span><span class="identifier">pt1</span><span class="plain"> = </span><span class="functiontext">Calculus::Terms::new_constant</span><span class="plain">(</span><span class="functiontext">InferenceSubjects::as_constant</span><span class="plain">(</span><span class="identifier">infs1</span><span class="plain">));</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">pt1</span><span class="plain"> = </span><span class="functiontext">Calculus::Terms::new_constant</span><span class="plain">(</span><span class="identifier">spec1</span><span class="plain">);</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::binary_PREDICATE_new</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">, </span><span class="identifier">pt0</span><span class="plain">, </span><span class="identifier">pt1</span><span class="plain">);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">dummy</span><span class="plain">;</span>
        <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Simplifications::make_kinds_of_value_explicit</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, &amp;</span><span class="identifier">dummy</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::Abstract::to_set_simple_relation appears nowhere else.</p>

<p class="endnote">The function Calculus::Propositions::Abstract::to_set_relation is used in 9/pk (<a href="9-pk.html#SP2">&#167;2</a>), 9/rk (<a href="9-rk.html#SP3">&#167;3</a>), 25/ci (<a href="25-ci.html#SP3_2_3_4_1_1_1">&#167;3.2.3.4.1.1.1</a>), 25/cp (<a href="25-cp.html#SP5_3_5_3">&#167;5.3.5.3</a>).</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>Property provision is itself a relation:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::Abstract::to_provide_property</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::binary_PREDICATE_new</span><span class="plain">(</span><span class="identifier">R_provision</span><span class="plain">,</span>
            <span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0), </span><span class="functiontext">Calculus::Terms::new_constant</span><span class="plain">(</span><span class="functiontext">Rvalues::from_property</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">)));</span>
    <span class="plain">}</span>

    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::Abstract::to_set_property</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">val</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">val</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Properties::Valued::get_setting_bp</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">) == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"no BP for this property"</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::binary_PREDICATE_new</span><span class="plain">(</span><span class="functiontext">Properties::Valued::get_setting_bp</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">),</span>
            <span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0), </span><span class="functiontext">Calculus::Terms::new_constant</span><span class="plain">(</span><span class="identifier">val</span><span class="plain">));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::Abstract::to_provide_property is used in 6/rlt (<a href="6-rlt.html#SP9">&#167;9</a>), 9/pd (<a href="9-pd.html#SP5_9">&#167;5.9</a>, <a href="9-pd.html#SP5_10">&#167;5.10</a>, <a href="9-pd.html#SP6_1">&#167;6.1</a>), 19/tod (<a href="19-tod.html#SP6_4">&#167;6.4</a>).</p>

<p class="endnote">The function Calculus::Propositions::Abstract::to_set_property is used in <a href="#SP6">&#167;6</a>, 15/vp (<a href="15-vp.html#SP10">&#167;10</a>).</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>"Everywhere", "nowhere" and "here":
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::Abstract::to_put_everywhere</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::EVERYWHERE_new</span><span class="plain">(</span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0));</span>
    <span class="plain">}</span>

    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::Abstract::to_put_nowhere</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::NOWHERE_new</span><span class="plain">(</span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0));</span>
    <span class="plain">}</span>

    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::Abstract::to_put_here</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::HERE_new</span><span class="plain">(</span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::Abstract::to_put_everywhere appears nowhere else.</p>

<p class="endnote">The function Calculus::Propositions::Abstract::to_put_nowhere appears nowhere else.</p>

<p class="endnote">The function Calculus::Propositions::Abstract::to_put_here is used in 9/rk (<a href="9-rk.html#SP1_2">&#167;1.2</a>).</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Property setting. </b>Sometimes the A-parser wants to assert that a given property has the value
whose text can be found in a node <code class="display"><span class="extract">py</span></code>...
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::Abstract::from_property_subtree</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">py</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::Abstract::to_set_property</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">, </span><span class="functiontext">Assertions::PropertyKnowledge::property_value_from_property_subtree</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">py</span><span class="plain">));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::Abstract::from_property_subtree is used in <a href="#SP7_1">&#167;7.1</a>, 9/pk (<a href="9-pk.html#SP3">&#167;3</a>).</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>...and sometimes it wants to assert a more elaborate list, such as "carrying
capacity 10 and weight 4kg" or "lockable unlocked". This is a syntax
allowed by the A-parser but not the S-parser, and here is where we deal
with it.
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::Abstract::from_property_list</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">) {</span>
            <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">)) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">AND_NT</span><span class="plain">:</span>
                    <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">; </span><span class="identifier">p</span><span class="plain">; </span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)</span>
                        <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::conjoin</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="functiontext">Calculus::Propositions::Abstract::from_property_list</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">));</span>
                    <span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="identifier">PROPERTY_LIST_NT</span><span class="plain">:</span>
                    &lt;<span class="cwebmacro">Conjoin atoms to assert from a property list</span> <span class="cwebmacronumber">7.1</span>&gt;<span class="plain">;</span>
                    <span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">ADJECTIVE_NT</span><span class="plain">:</span>
                    &lt;<span class="cwebmacro">Conjoin atoms to assert from an adjective node</span> <span class="cwebmacronumber">7.2</span>&gt;<span class="plain">;</span>
                    <span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">default</span><span class="plain">: </span><span class="identifier">internal_error_on_node_type</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>

        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain">) &amp;&amp; (</span><span class="identifier">K</span><span class="plain">)) {</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::conjoin</span><span class="plain">(</span>
                <span class="functiontext">Calculus::Atoms::KIND_new</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0)), </span><span class="identifier">prop</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::Abstract::from_property_list is used in <a href="#SP7_2">&#167;7.2</a>, 9/pk (<a href="9-pk.html#SP3">&#167;3</a>).</p>

<p class="inwebparagraph"><a id="SP7_1"></a><b>&#167;7.1.  </b>Recall that a <code class="display"><span class="extract">PROPERTY_LIST_NT</span></code> node is unannotated, as yet, and we have to
parse the text to find what which property is referred to.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Conjoin atoms to assert from a property list</span> <span class="cwebmacronumber">7.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="identifier">VW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        &lt;<span class="cwebmacro">Divide the property list entry into property name and value text</span> <span class="cwebmacronumber">7.1.1</span>&gt;<span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">PW</span><span class="plain">)) &amp;&amp; (&lt;</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt;(</span><span class="identifier">PW</span><span class="plain">))) </span><span class="identifier">prn</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prn</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span>&lt;<span class="cwebmacro">Issue a problem message for no-such-property</span> <span class="cwebmacronumber">7.1.2</span>&gt;<span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">VW</span><span class="plain">)) { </span>    <span class="comment">a value is supplied...</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Properties::is_either_or</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">)) {</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">));</span>
                <span class="functiontext">Problems::quote_property</span><span class="plain">(3, </span><span class="identifier">prn</span><span class="plain">);</span>
                <span class="identifier">Problems::quote_wording</span><span class="plain">(4, </span><span class="identifier">VW</span><span class="plain">);</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_WithEitherOrValue</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"The sentence '%1' seems to be trying to create something which "</span>
                    <span class="string">"has '%2', where the %3 property is being set equal to %4. But "</span>
                    <span class="string">"this made no sense to me, because %3 is an either/or property "</span>
                    <span class="string">"and cannot have a value."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;(</span><span class="identifier">VW</span><span class="plain">);</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
            <span class="functiontext">Assertions::Refiner::refine</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="constant">FORBID_CREATION</span><span class="plain">);</span>
            <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::Abstract::from_property_subtree</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">pn</span><span class="plain">);</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::conjoin</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">P</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> { </span>    <span class="comment">no value is supplied...</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Properties::is_either_or</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">));</span>
                <span class="functiontext">Problems::quote_property</span><span class="plain">(3, </span><span class="identifier">prn</span><span class="plain">);</span>
                <span class="functiontext">Problems::quote_kind</span><span class="plain">(4, </span><span class="functiontext">Properties::Valued::kind</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">));</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_WithValuelessValue</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"The sentence '%1' seems to be trying to create something which "</span>
                    <span class="string">"has '%2', where the %3 property is being set in some way. But "</span>
                    <span class="string">"this made no sense to me, because %3 is a value property (it "</span>
                    <span class="string">"needs to be %4) and no value for it was given here."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::conjoin</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="functiontext">Calculus::Propositions::Abstract::from_property_subtree</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">));</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7">&#167;7</a>.</p>

<p class="inwebparagraph"><a id="SP7_1_1"></a><b>&#167;7.1.1.  </b>The node has text in the form "property name property value", with no
obvious division of punctuation between the two. What makes matters worse
is that we do not yet know all the property names, nor do we have the
ability to discern values. So we seek the division by
</p>

<ul class="items"><li>(i) trying to find the longest known property name at the start of the
text; if there is no known name,
</li><li>(ii) we see if the final word of the text is a literal, such as a number or
a quoted text, and if so we assume this is the entire property value and
that the rest is property name; and otherwise
</li><li>(iii) we assume the property name is one word only.
</li></ul>

<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Divide the property list entry into property name and value text</span> <span class="cwebmacronumber">7.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Articles::remove_the</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="identifier">Problems::Issue::assertion_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">),</span>
                <span class="string">"this looked to me as if it might be trying to create something "</span>
                <span class="string">"which has certain properties"</span><span class="plain">,</span>
                <span class="string">"and that made no sense on investigation. This sometimes happens "</span>
                <span class="string">"if a sentence uses 'to have' oddly?"</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">name_length</span><span class="plain"> = </span><span class="functiontext">Properties::match_longest</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">name_length</span><span class="plain"> &lt; 0) {</span>
            <span class="identifier">name_length</span><span class="plain"> = 1;</span>
            <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">literal</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) </span><span class="identifier">name_length</span><span class="plain"> = </span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">) - 1;</span>
        <span class="plain">}</span>
        <span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">Wordings::up_to</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">) + </span><span class="identifier">name_length</span><span class="plain"> - 1);</span>
        <span class="identifier">VW</span><span class="plain"> = </span><span class="identifier">Wordings::from</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">) + </span><span class="identifier">name_length</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7_1">&#167;7.1</a>.</p>

<p class="inwebparagraph"><a id="SP7_1_2"></a><b>&#167;7.1.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue a problem message for no-such-property</span> <span class="cwebmacronumber">7.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Failed property list: pname = &lt;%W&gt;; pval = &lt;%W&gt;\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">PW</span><span class="plain">, </span><span class="identifier">VW</span><span class="plain">);</span>
        <span class="identifier">Problems::Issue::assertion_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BadPropertyList</span><span class="plain">),</span>
            <span class="string">"this looked to me as if it might be trying to create something "</span>
            <span class="string">"which has certain properties"</span><span class="plain">,</span>
            <span class="string">"and that made no sense on investigation. This sometimes happens "</span>
            <span class="string">"if a sentence uses 'with' a little too liberally, or to specify "</span>
            <span class="string">"a never-declared property. For instance, 'An antique is a kind of "</span>
            <span class="string">"thing with an age.' would not be the right way to declare the "</span>
            <span class="string">"property 'age' (because it does not tell Inform what kind of "</span>
            <span class="string">"value this would be). Instead, try 'An antique is a kind of "</span>
            <span class="string">"thing. An antique has a number called age.' It would then be all "</span>
            <span class="string">"right to say 'The Louis Quinze chair is an antique with age 241.'"</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7_1">&#167;7.1</a>.</p>

<p class="inwebparagraph"><a id="SP7_2"></a><b>&#167;7.2.  </b>An <code class="display"><span class="extract">ADJECTIVE_NT</span></code> node, on the other hand, is annotated with a valid
property name <code class="display"><span class="extract">property</span></code> already, and may also have a value ready to put
into that property, stored in <code class="display"><span class="extract">evaluation</span></code>. Nodes like this have been
created from descriptions like "open openable door in the kitchen", and
it's important not to lose the location information ("in the kitchen"),
which is by now inside the "creation proposition".
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Conjoin atoms to assert from an adjective node</span> <span class="cwebmacronumber">7.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">negate_me</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="constant">negated_boolean_ANNOT</span><span class="plain">)) </span><span class="identifier">negate_me</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_aph</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">) == </span><span class="identifier">NULL</span><span class="plain">)</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"Bogus adjective at Calculus::Propositions::Abstract::from_property_list"</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_creation_proposition</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">))</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::conjoin</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">ParseTree::get_creation_proposition</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">negate_me</span><span class="plain">) </span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::conjoin</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">NEGATION_OPEN_ATOM</span><span class="plain">));</span>
        <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::conjoin</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="functiontext">Calculus::Atoms::unary_PREDICATE_from_aph</span><span class="plain">(</span><span class="identifier">ParseTree::get_aph</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">), </span><span class="identifier">FALSE</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">negate_me</span><span class="plain">) </span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::conjoin</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(</span><span class="constant">NEGATION_CLOSE_ATOM</span><span class="plain">));</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP7">&#167;7</a>.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="11-bas.html">Back to 'Binding and Substitution'</a></li><li><a href="11-sc.html">Continue with 'Sentence Conversions'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

