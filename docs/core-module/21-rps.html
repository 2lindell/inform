<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>21/fao</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '21/rps' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#21">Chapter 21: Rules and Rulebooks</a></li><li><b>Rule Placement Sentences</b></li></ul><p class="purpose">To parse and act upon explicit sentences like "The fire alarm rule is listed after the burglar alarm rule in the House Security rules."</p>

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1.  </b>Booked rules can be declared wrapping I6 routines which we assume
are defined either in the I6 template or in an I6 inclusion.
</p>

<p class="inwebparagraph">The following is called early in the run on sentences like "The can't act
in the dark rule translates into I6 as <code class="display"><span class="extract">"CANT_ACT_IN_THE_DARK_R"</span></code>." The
node <code class="display"><span class="extract">p-&gt;down-&gt;next</span></code> is the I7 name, and <code class="display"><span class="extract">p-&gt;down-&gt;next-&gt;next</span></code> is the I6
name, whose double-quotes have already been removed.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Rules::Placement::declare_I6_written_rule</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p2</span><span class="plain">) {</span>
        <span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">I6_name</span><span class="plain"> = </span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p2</span><span class="plain">)));</span>
        <span class="reserved">rule</span><span class="plain"> *</span><span class="identifier">R</span><span class="plain"> = </span><span class="functiontext">Rules::new</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
        <span class="functiontext">Rules::set_I6_definition</span><span class="plain">(</span><span class="identifier">R</span><span class="plain">, </span><span class="identifier">I6_name</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Rules::Placement::declare_I6_written_rule is used in 26/tti (<a href="26-tti.html#SP5_1">&#167;5.1</a>).</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>In order to parse sentences about how rules are placed in rulebooks, we
need to be able to parse the relevant names. (The definite article can
optionally be used.)
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="reserved">rulebook</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Articles::remove_the</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">ExParser::parse_excerpt</span><span class="plain">(</span><span class="constant">RULEBOOK_MC</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Rvalues::is_CONSTANT_construction</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">CON_rulebook</span><span class="plain">)) {</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Rvalues::to_rulebook</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="plain">&lt;</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Articles::remove_the</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">rule</span><span class="plain"> *</span><span class="identifier">R</span><span class="plain"> = </span><span class="functiontext">Rules::by_name</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">R</span><span class="plain">) {</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">R</span><span class="plain">;</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>This handles the special meaning "X is listed in...".
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">listed</span><span class="plain">-</span><span class="identifier">in</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt; ::=</span>
        <span class="identifier">listed</span><span class="plain"> &lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt; |					==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="identifier">not</span><span class="plain"> </span><span class="identifier">listed</span><span class="plain"> &lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt;					==&gt; </span><span class="identifier">FALSE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Rules::Placement::listed_in_SMF</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">NPs</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[0]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[1]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) { </span>    <span class="comment">"The time passes rule is listed in the turn sequence rulebook."</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ACCEPT_SMFT</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> ((&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">)) &amp;&amp; (&lt;</span><span class="identifier">listed</span><span class="plain">-</span><span class="identifier">in</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">))) {</span>
                    <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="constant">SPECIAL_MEANING_VB</span><span class="plain">);</span>
                    <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">listing_sense_ANNOT</span><span class="plain">, &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;);</span>
                    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">O</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">O</span><span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TRAVERSE_FOR_RULE_FILING_SMFT</span><span class="plain">:</span>
                <span class="functiontext">Rules::Placement::place_in_rulebook</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">,</span>
                    <span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">listing_sense_ANNOT</span><span class="plain">));</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Rules::Placement::listed_in_SMF is used in 6/nv (<a href="6-nv.html#SP16">&#167;16</a>).</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>And this is where we parse lists of rule names. The verbs "to be listed",
"to substitute for" and "to do nothing" are a little too common to accept
them in all circumstances, so we require their subjects to be plausible as rule
names. All rule names end in "rule", whereas other names mostly don't, so the
following won't pick up many false positives.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; ::=</span>
        <span class="plain">... |											==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">preform_lookahead_mode</span><span class="plain">; </span>    <span class="comment">match only when looking ahead</span>
        <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="reserved">rule</span><span class="plain">&gt; &lt;</span><span class="identifier">np</span><span class="plain">-</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; |			==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NounPhrases::PN_pair</span><span class="plain">(</span><span class="identifier">AND_NT</span><span class="plain">, </span><span class="identifier">Wordings::one_word</span><span class="plain">(</span><span class="identifier">R</span><span class="plain">[2]), </span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">RP</span><span class="plain">[2])</span>
        <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="reserved">rule</span><span class="plain">&gt;								==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">np</span><span class="plain">-</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">tail</span><span class="plain">&gt; ::=</span>
        <span class="plain">, {</span><span class="identifier">_and</span><span class="plain">} &lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt; |				==&gt; </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">); *</span><span class="identifier">XP</span><span class="plain">= </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">{</span><span class="identifier">_</span><span class="plain">,/</span><span class="identifier">and</span><span class="plain">} &lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt;					==&gt; </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">); *</span><span class="identifier">XP</span><span class="plain">= </span><span class="identifier">RP</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="reserved">rule</span><span class="plain">&gt; ::=</span>
        <span class="plain">... </span><span class="reserved">rule</span><span class="plain">										==&gt; </span><span class="identifier">GENERATE_RAW_NP</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>This handles the special meaning "X substitutes for Y".
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">substitutes</span><span class="plain">-</span><span class="reserved">for</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="reserved">rule</span><span class="plain">&gt; |							==&gt; </span><span class="identifier">NOT_APPLICABLE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="reserved">rule</span><span class="plain">&gt; </span><span class="reserved">if</span><span class="plain">/</span><span class="identifier">when</span><span class="plain"> &lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt; |	==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]; ((</span><span class="identifier">parse_node</span><span class="plain"> *) </span><span class="identifier">RP</span><span class="plain">[1])-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2];</span>
        <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="reserved">rule</span><span class="plain">&gt; </span><span class="identifier">unless</span><span class="plain"> &lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt;		==&gt; </span><span class="identifier">FALSE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]; ((</span><span class="identifier">parse_node</span><span class="plain"> *) </span><span class="identifier">RP</span><span class="plain">[1])-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Rules::Placement::substitutes_for_SMF</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">NPs</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[0]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[1]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) { </span>    <span class="comment">"The time passes slowly rule substitutes for the time passes rule."</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ACCEPT_SMFT</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> ((&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">)) &amp;&amp; (&lt;</span><span class="identifier">substitutes</span><span class="plain">-</span><span class="reserved">for</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">))) {</span>
                    <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="constant">SPECIAL_MEANING_VB</span><span class="plain">);</span>
                    <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">listing_sense_ANNOT</span><span class="plain">, &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;);</span>
                    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">O</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">O</span><span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TRAVERSE_FOR_RULE_FILING_SMFT</span><span class="plain">:</span>
                <span class="functiontext">Rules::Placement::request_substitute</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">,</span>
                    <span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">listing_sense_ANNOT</span><span class="plain">));</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Rules::Placement::substitutes_for_SMF is used in 6/nv (<a href="6-nv.html#SP16">&#167;16</a>).</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>A sentence in the form:
</p>

<blockquote>
    <p>The print fancy final score rule substitutes for the print final score rule.</p>

</blockquote>

<p class="inwebparagraph">It also exists in a form with a condition attached:
</p>

<blockquote>
    <p>The print fancy final score rule substitutes for the print final score rule when ...</p>

</blockquote>

<p class="inwebparagraph">This optional tail is eventually required to match &lt;spec-condition&gt;,
but that parsing is done later on. For now, we only parse for rules in both the
subject and object NPs.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">substitutes</span><span class="plain">-</span><span class="reserved">for</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |											==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="plain">...														==&gt; </span>&lt;<span class="cwebmacro">Issue PM_NoSuchRuleExists problem</span> <span class="cwebmacronumber">8.1</span>&gt;

    <span class="plain">&lt;</span><span class="identifier">substitutes</span><span class="plain">-</span><span class="reserved">for</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">inner</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |											==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="plain">...														==&gt; </span>&lt;<span class="cwebmacro">Issue PM_NoSuchRuleExists problem</span> <span class="cwebmacronumber">8.1</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8_1"></a><b>&#167;8.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_NoSuchRuleExists problem</span> <span class="cwebmacronumber">8.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_NoSuchRuleExists</span><span class="plain">));</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"In %1, you gave '%2' where a rule was required."</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP8">&#167;8</a> (twice), <a href="#SP10">&#167;10</a>, <a href="#SP16">&#167;16</a>, <a href="#SP17">&#167;17</a> (three times).</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Rules::Placement::request_substitute</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p1</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p2</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p3</span><span class="plain">,</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">sense</span><span class="plain">) {</span>
        <span class="plain">&lt;</span><span class="identifier">substitutes</span><span class="plain">-</span><span class="reserved">for</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p1</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt; == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">rule</span><span class="plain"> *</span><span class="identifier">new_rule</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
        <span class="plain">&lt;</span><span class="identifier">substitutes</span><span class="plain">-</span><span class="reserved">for</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">inner</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p2</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt; == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">rule</span><span class="plain"> *</span><span class="identifier">old_rule</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">CW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p3</span><span class="plain">) </span><span class="identifier">CW</span><span class="plain"> = </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p3</span><span class="plain">);</span>
        <span class="functiontext">Rules::impose_constraint</span><span class="plain">(</span><span class="identifier">new_rule</span><span class="plain">, </span><span class="identifier">old_rule</span><span class="plain">, </span><span class="identifier">CW</span><span class="plain">, (</span><span class="identifier">sense</span><span class="plain">)?</span><span class="identifier">FALSE</span><span class="plain">:</span><span class="identifier">TRUE</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Rules::Placement::request_substitute is used in <a href="#SP7">&#167;7</a>.</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>A sentence in the form:
</p>

<blockquote>
    <p>The print final score rule does nothing.</p>

</blockquote>

<blockquote>
    <p>The print final score rule does nothing unless ....</p>

</blockquote>

<p class="inwebparagraph">is parsed similarly. The subject NP is an articled list, each entry of which
must be a rule, and the optional condition is put aside for later, but must
eventually match &lt;spec-condition&gt;.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">does</span><span class="plain">-</span><span class="identifier">nothing</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt; ::=</span>
        <span class="identifier">nothing</span>

    <span class="plain">&lt;</span><span class="identifier">does</span><span class="plain">-</span><span class="identifier">nothing</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |											==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="plain">...														==&gt; </span>&lt;<span class="cwebmacro">Issue PM_NoSuchRuleExists problem</span> <span class="cwebmacronumber">8.1</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Rules::Placement::does_nothing_SMF</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">NPs</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[0]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[1]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) { </span>    <span class="comment">"The time passes rule does nothing."</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ACCEPT_SMFT</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> ((&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">)) &amp;&amp; (&lt;</span><span class="identifier">does</span><span class="plain">-</span><span class="identifier">nothing</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">))) {</span>
                    <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="constant">SPECIAL_MEANING_VB</span><span class="plain">);</span>
                    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">O</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">O</span><span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TRAVERSE_FOR_RULE_FILING_SMFT</span><span class="plain">:</span>
                <span class="functiontext">Rules::Placement::constrain_effect</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NOT_APPLICABLE</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Rules::Placement::does_nothing_SMF is used in 6/nv (<a href="6-nv.html#SP16">&#167;16</a>).</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Rules::Placement::does_nothing_if_SMF</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">NPs</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[0]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[2]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">CW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[1]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) { </span>    <span class="comment">"The time passes rule does nothing if ..."</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ACCEPT_SMFT</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> ((&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">)) &amp;&amp; (&lt;</span><span class="identifier">does</span><span class="plain">-</span><span class="identifier">nothing</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">))) {</span>
                    <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="constant">SPECIAL_MEANING_VB</span><span class="plain">);</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt;(</span><span class="identifier">CW</span><span class="plain">);</span>
                    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">O</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">O</span><span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TRAVERSE_FOR_RULE_FILING_SMFT</span><span class="plain">:</span>
                <span class="functiontext">Rules::Placement::constrain_effect</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Rules::Placement::does_nothing_if_SMF is used in 6/nv (<a href="6-nv.html#SP16">&#167;16</a>).</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Rules::Placement::does_nothing_unless_SMF</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">NPs</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[0]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[2]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">CW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[1]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) { </span>    <span class="comment">"The time passes rule does nothing unless ..."</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ACCEPT_SMFT</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> ((&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">)) &amp;&amp; (&lt;</span><span class="identifier">does</span><span class="plain">-</span><span class="identifier">nothing</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">))) {</span>
                    <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="constant">SPECIAL_MEANING_VB</span><span class="plain">);</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt;(</span><span class="identifier">CW</span><span class="plain">);</span>
                    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">O</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">O</span><span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TRAVERSE_FOR_RULE_FILING_SMFT</span><span class="plain">:</span>
                <span class="functiontext">Rules::Placement::constrain_effect</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Rules::Placement::does_nothing_unless_SMF is used in 6/nv (<a href="6-nv.html#SP16">&#167;16</a>).</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Rules::Placement::constrain_effect</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p1</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p2</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">sense</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">p1</span><span class="plain">) == </span><span class="identifier">AND_NT</span><span class="plain">) {</span>
            <span class="functiontext">Rules::Placement::constrain_effect</span><span class="plain">(</span><span class="identifier">p1</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">, </span><span class="identifier">p2</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">);</span>
            <span class="functiontext">Rules::Placement::constrain_effect</span><span class="plain">(</span><span class="identifier">p1</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">p2</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="plain">&lt;</span><span class="identifier">does</span><span class="plain">-</span><span class="identifier">nothing</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p1</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt; == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">rule</span><span class="plain"> *</span><span class="identifier">existing_rule</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p2</span><span class="plain">)</span>
            <span class="functiontext">Rules::impose_constraint</span><span class="plain">(</span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">existing_rule</span><span class="plain">, </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p2</span><span class="plain">), </span><span class="identifier">sense</span><span class="plain">);</span>
        <span class="reserved">else</span>
            <span class="functiontext">Rules::impose_constraint</span><span class="plain">(</span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">existing_rule</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Rules::Placement::constrain_effect is used in <a href="#SP11">&#167;11</a>, <a href="#SP12">&#167;12</a>, <a href="#SP13">&#167;13</a>.</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b></p>


<pre class="display">
    <span class="reserved">rule</span><span class="plain"> *</span><span class="identifier">relative_to_which</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16.  </b>Explicit listing sentences allow the source text to control which rulebook(s)
a given rule appears in, and (within limits) where. A simple example:
</p>

<blockquote>
    <p>The can't act in the dark rule is not listed in the visibility rules.</p>

</blockquote>

<p class="inwebparagraph">The subject noun phrase is an articled list, each entry of which must match:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">listed</span><span class="plain">-</span><span class="identifier">in</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |								==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="plain">...											==&gt; </span><span class="identifier">FALSE</span><span class="plain">; </span>&lt;<span class="cwebmacro">Issue PM_NoSuchRuleExists problem</span> <span class="cwebmacronumber">8.1</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17.  </b>The object NP is more flexible:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">listed</span><span class="plain">-</span><span class="identifier">in</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">inner</span><span class="plain">&gt; ::=</span>
        <span class="identifier">in</span><span class="plain"> </span><span class="identifier">any</span><span class="plain"> </span><span class="reserved">rulebook</span><span class="plain"> |							==&gt; </span><span class="constant">ANY_RULE_PLACEMENT</span>
        <span class="identifier">in</span><span class="plain"> &lt;</span><span class="identifier">destination</span><span class="plain">-</span><span class="reserved">rulebook</span><span class="plain">&gt; |					==&gt; </span><span class="constant">MIDDLE_PLACEMENT</span><span class="plain"> + 1000*</span><span class="constant">IN_SIDE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="identifier">first</span><span class="plain"> </span><span class="identifier">in</span><span class="plain"> &lt;</span><span class="identifier">destination</span><span class="plain">-</span><span class="reserved">rulebook</span><span class="plain">&gt; |			==&gt; </span><span class="constant">FIRST_PLACEMENT</span><span class="plain">  + 1000*</span><span class="constant">IN_SIDE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="identifier">last</span><span class="plain"> </span><span class="identifier">in</span><span class="plain"> &lt;</span><span class="identifier">destination</span><span class="plain">-</span><span class="reserved">rulebook</span><span class="plain">&gt; |			==&gt; </span><span class="constant">LAST_PLACEMENT</span><span class="plain">   + 1000*</span><span class="constant">IN_SIDE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="identifier">instead</span><span class="plain"> </span><span class="identifier">of</span><span class="plain"> &lt;</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">in</span><span class="plain"> &lt;</span><span class="reserved">rulebook</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |	==&gt; </span><span class="constant">MIDDLE_PLACEMENT</span><span class="plain"> + 1000*</span><span class="constant">INSTEAD_SIDE</span><span class="plain">; </span><span class="identifier">relative_to_which</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2];</span>
        <span class="identifier">instead</span><span class="plain"> </span><span class="identifier">of</span><span class="plain"> &lt;</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">in</span><span class="plain"> ... |				==&gt; </span>&lt;<span class="cwebmacro">Issue PM_NoSuchRulebookPlacement problem</span> <span class="cwebmacronumber">17.3</span>&gt;
        <span class="identifier">instead</span><span class="plain"> </span><span class="identifier">of</span><span class="plain"> ... </span><span class="identifier">in</span><span class="plain"> ... |						==&gt; </span>&lt;<span class="cwebmacro">Issue PM_NoSuchRuleExists problem</span> <span class="cwebmacronumber">8.1</span>&gt;
        <span class="identifier">before</span><span class="plain"> &lt;</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">in</span><span class="plain"> &lt;</span><span class="reserved">rulebook</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |		==&gt; </span><span class="constant">MIDDLE_PLACEMENT</span><span class="plain"> + 1000*</span><span class="constant">BEFORE_SIDE</span><span class="plain">; </span><span class="identifier">relative_to_which</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2];</span>
        <span class="identifier">before</span><span class="plain"> &lt;</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">in</span><span class="plain"> ... |					==&gt; </span>&lt;<span class="cwebmacro">Issue PM_NoSuchRulebookPlacement problem</span> <span class="cwebmacronumber">17.3</span>&gt;
        <span class="identifier">before</span><span class="plain"> ... </span><span class="identifier">in</span><span class="plain"> ... |							==&gt; </span>&lt;<span class="cwebmacro">Issue PM_NoSuchRuleExists problem</span> <span class="cwebmacronumber">8.1</span>&gt;
        <span class="identifier">after</span><span class="plain"> &lt;</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">in</span><span class="plain"> &lt;</span><span class="reserved">rulebook</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |		==&gt; </span><span class="constant">MIDDLE_PLACEMENT</span><span class="plain"> + 1000*</span><span class="constant">AFTER_SIDE</span><span class="plain">; </span><span class="identifier">relative_to_which</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2];</span>
        <span class="identifier">after</span><span class="plain"> &lt;</span><span class="reserved">rule</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">in</span><span class="plain"> ... |					==&gt; </span>&lt;<span class="cwebmacro">Issue PM_NoSuchRulebookPlacement problem</span> <span class="cwebmacronumber">17.3</span>&gt;
        <span class="identifier">after</span><span class="plain"> ... </span><span class="identifier">in</span><span class="plain"> ... |							==&gt; </span>&lt;<span class="cwebmacro">Issue PM_NoSuchRuleExists problem</span> <span class="cwebmacronumber">8.1</span>&gt;
        <span class="identifier">instead</span><span class="plain"> </span><span class="identifier">of</span><span class="plain"> ... |							==&gt; </span>&lt;<span class="cwebmacro">Issue PM_UnspecifiedRulebookPlacement problem</span> <span class="cwebmacronumber">17.1</span>&gt;
        <span class="identifier">before</span><span class="plain"> ... |								==&gt; </span>&lt;<span class="cwebmacro">Issue PM_UnspecifiedRulebookPlacement problem</span> <span class="cwebmacronumber">17.1</span>&gt;
        <span class="identifier">after</span><span class="plain"> ... |									==&gt; </span>&lt;<span class="cwebmacro">Issue PM_UnspecifiedRulebookPlacement problem</span> <span class="cwebmacronumber">17.1</span>&gt;
        <span class="plain">...											==&gt; </span>&lt;<span class="cwebmacro">Issue PM_ImproperRulePlacement problem</span> <span class="cwebmacronumber">17.2</span>&gt;

    <span class="plain">&lt;</span><span class="identifier">destination</span><span class="plain">-</span><span class="reserved">rulebook</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="reserved">rulebook</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |							==&gt; 0; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="plain">...											==&gt; </span>&lt;<span class="cwebmacro">Issue PM_NoSuchRulebookPlacement problem</span> <span class="cwebmacronumber">17.3</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP17_1"></a><b>&#167;17.1.  </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">ANY_RULE_PLACEMENT</span><span class="plain"> 1000001</span>
    <span class="definitionkeyword">define</span> <span class="constant">BAD_RULE_PLACEMENT</span><span class="plain"> 1000000</span>

    <p class="macrodefinition"><code class="display">
    &lt;<span class="cwebmacrodefn">Issue PM_UnspecifiedRulebookPlacement problem</span> <span class="cwebmacronumber">17.1</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">BAD_RULE_PLACEMENT</span><span class="plain">;</span>
            <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
            <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_UnspecifiedRulebookPlacement</span><span class="plain">));</span>
            <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                <span class="string">"In %1, you didn't specify in which rulebook the rule was to "</span>
                <span class="string">"be listed, only which existing rule it should go before or "</span>
                <span class="string">"after."</span><span class="plain">);</span>
            <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP17">&#167;17</a> (three times).</p>

    <p class="inwebparagraph"><a id="SP17_2"></a><b>&#167;17.2.  </b><code class="display">
    &lt;<span class="cwebmacrodefn">Issue PM_ImproperRulePlacement problem</span> <span class="cwebmacronumber">17.2</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">BAD_RULE_PLACEMENT</span><span class="plain">;</span>
            &lt;<span class="cwebmacro">Actually issue PM_ImproperRulePlacement problem</span> <span class="cwebmacronumber">17.2.1</span>&gt;<span class="plain">;</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP17">&#167;17</a>.</p>

    <p class="inwebparagraph"><a id="SP17_2_1"></a><b>&#167;17.2.1.  </b><code class="display">
    &lt;<span class="cwebmacrodefn">Actually issue PM_ImproperRulePlacement problem</span> <span class="cwebmacronumber">17.2.1</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
            <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ImproperRulePlacement</span><span class="plain">));</span>
            <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                <span class="string">"In %1, you used the special verb 'to be listed' - which specifies "</span>
                <span class="string">"how rules are listed in rulebooks - in a way I didn't recognise. "</span>
                <span class="string">"The usual form is: 'The summer breeze rule is listed in the "</span>
                <span class="string">"meadow noises rulebook'."</span><span class="plain">);</span>
            <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP17_2">&#167;17.2</a>, <a href="#SP18">&#167;18</a>.</p>

    <p class="inwebparagraph"><a id="SP17_3"></a><b>&#167;17.3.  </b><code class="display">
    &lt;<span class="cwebmacrodefn">Issue PM_NoSuchRulebookPlacement problem</span> <span class="cwebmacronumber">17.3</span>&gt; =
    </code></p>


    <pre class="displaydefn">
            <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
            <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
            <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_NoSuchRulebookPlacement</span><span class="plain">));</span>
            <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                <span class="string">"In %1, you gave '%2' where a rulebook was required."</span><span class="plain">);</span>
            <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">This code is used in <a href="#SP17">&#167;17</a> (four times).</p>

    <p class="inwebparagraph"><a id="SP18"></a><b>&#167;18.  </b></p>


    <pre class="display">
        <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Rules::Placement::place_in_rulebook</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p1</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p2</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">sense</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">p1</span><span class="plain">) == </span><span class="identifier">AND_NT</span><span class="plain">) {</span>
                <span class="functiontext">Rules::Placement::place_in_rulebook</span><span class="plain">(</span><span class="identifier">p1</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">, </span><span class="identifier">p2</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">);</span>
                <span class="functiontext">Rules::Placement::place_in_rulebook</span><span class="plain">(</span><span class="identifier">p1</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">p2</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>

            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">side</span><span class="plain">, </span><span class="identifier">new_rule_placement</span><span class="plain">;</span>
            <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">RULE_ATTACHMENTS</span><span class="plain">, </span><span class="string">"Placement sentence (%d):\</span><span class="plain">n</span><span class="string">p1=$T\</span><span class="plain">n</span><span class="string">p2=$T\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">sense</span><span class="plain">, </span><span class="identifier">p1</span><span class="plain">, </span><span class="identifier">p2</span><span class="plain">);</span>

            <span class="identifier">relative_to_which</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">pc</span><span class="plain"> = </span><span class="identifier">problem_count</span><span class="plain">;</span>
            <span class="plain">&lt;</span><span class="identifier">listed</span><span class="plain">-</span><span class="identifier">in</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">inner</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p2</span><span class="plain">));</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> &gt; </span><span class="identifier">pc</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
            <span class="reserved">rulebook</span><span class="plain"> *</span><span class="identifier">the_rulebook</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">pair</span><span class="plain"> = &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pair</span><span class="plain"> == </span><span class="constant">BAD_RULE_PLACEMENT</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pair</span><span class="plain"> == </span><span class="constant">ANY_RULE_PLACEMENT</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sense</span><span class="plain"> == </span><span class="identifier">TRUE</span><span class="plain">) {</span>
                    &lt;<span class="cwebmacro">Actually issue PM_ImproperRulePlacement problem</span> <span class="cwebmacronumber">17.2.1</span>&gt;<span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="identifier">new_rule_placement</span><span class="plain"> = </span><span class="constant">MIDDLE_PLACEMENT</span><span class="plain">; </span><span class="identifier">side</span><span class="plain"> = </span><span class="constant">IN_SIDE</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="identifier">new_rule_placement</span><span class="plain"> = </span><span class="identifier">pair</span><span class="plain">%1000; </span><span class="identifier">side</span><span class="plain"> = </span><span class="identifier">pair</span><span class="plain">/1000;</span>
            <span class="plain">}</span>

            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">sense</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp;</span>
                <span class="plain">((</span><span class="identifier">new_rule_placement</span><span class="plain"> != </span><span class="constant">MIDDLE_PLACEMENT</span><span class="plain">) || (</span><span class="identifier">side</span><span class="plain"> != </span><span class="constant">IN_SIDE</span><span class="plain">))) {</span>
                <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BadRulePlacementNegation</span><span class="plain">));</span>
                <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                    <span class="string">"In %1, you used the special verb 'to be listed' - which specifies "</span>
                    <span class="string">"how rules are listed in rulebooks - in a way too complicated to "</span>
                    <span class="string">"be accompanied by 'not', so that the result was too vague. "</span>
                    <span class="string">"The usual form is: 'The summer breeze rule is not listed in the "</span>
                    <span class="string">"meadow noises rulebook'."</span><span class="plain">);</span>
                <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>

            <span class="plain">&lt;</span><span class="identifier">listed</span><span class="plain">-</span><span class="identifier">in</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p1</span><span class="plain">));</span>
            <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt; == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
            <span class="reserved">rule</span><span class="plain"> *</span><span class="identifier">existing_rule</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>

            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pair</span><span class="plain"> == </span><span class="constant">ANY_RULE_PLACEMENT</span><span class="plain">) {</span>
                <span class="reserved">rulebook</span><span class="plain"> *</span><span class="identifier">rb</span><span class="plain">;</span>
                <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">rb</span><span class="plain">, </span><span class="reserved">rulebook</span><span class="plain">) </span><span class="functiontext">Rulebooks::detach_rule</span><span class="plain">(</span><span class="identifier">rb</span><span class="plain">, </span><span class="identifier">existing_rule</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>

            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sense</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                <span class="functiontext">Rulebooks::affected_by_placement</span><span class="plain">(</span><span class="identifier">the_rulebook</span><span class="plain">, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="functiontext">Rulebooks::detach_rule</span><span class="plain">(</span><span class="identifier">the_rulebook</span><span class="plain">, </span><span class="identifier">existing_rule</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>

            <span class="reserved">booking</span><span class="plain"> *</span><span class="identifier">new_rule_booking</span><span class="plain"> = </span><span class="functiontext">Rules::Bookings::new</span><span class="plain">(</span><span class="identifier">existing_rule</span><span class="plain">);</span>
            <span class="functiontext">Rules::set_kind_from</span><span class="plain">(</span><span class="identifier">existing_rule</span><span class="plain">, </span><span class="identifier">the_rulebook</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">relative_to_which</span><span class="plain">) {</span>
                <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">RULE_ATTACHMENTS</span><span class="plain">, </span><span class="string">"Relative to which = %W\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">relative_to_which</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain">);</span>
                <span class="functiontext">Rulebooks::affected_by_placement</span><span class="plain">(</span><span class="identifier">the_rulebook</span><span class="plain">, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Rulebooks::rule_in_rulebook</span><span class="plain">(</span><span class="identifier">relative_to_which</span><span class="plain">, </span><span class="identifier">the_rulebook</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                    <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                    <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">the_rulebook</span><span class="plain">-</span><span class="element">&gt;primary_name</span><span class="plain">);</span>
                    <span class="identifier">Problems::quote_wording</span><span class="plain">(3, </span><span class="identifier">relative_to_which</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain">);</span>
                    <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_PlaceWithMissingRule</span><span class="plain">));</span>
                    <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                        <span class="string">"In %1, you talk about the position of the rule '%3' "</span>
                        <span class="string">"in the rulebook '%2', but in fact that rule isn't in this "</span>
                        <span class="string">"rulebook, so the placing instruction makes no sense."</span><span class="plain">);</span>
                    <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                    <span class="reserved">return</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="functiontext">Rulebooks::attach_rule</span><span class="plain">(</span><span class="identifier">the_rulebook</span><span class="plain">, </span><span class="identifier">new_rule_booking</span><span class="plain">, </span><span class="identifier">new_rule_placement</span><span class="plain">,</span>
                <span class="identifier">side</span><span class="plain">, </span><span class="identifier">relative_to_which</span><span class="plain">);</span>
        <span class="plain">}</span>
    </pre>

    <p class="inwebparagraph"></p>

    <p class="endnote">The function Rules::Placement::place_in_rulebook is used in <a href="#SP4">&#167;4</a>.</p>

    <hr class="tocbar">
    <ul class="toc"><li><a href="21-fao.html">Back to 'Focus and Outcome'</a></li><li><a href="21-sv.html">Continue with 'Stacked Variables'</a></li></ul><hr class="tocbar">
    <!--End of weave: 445 lines from a web of 94125-->
    	</body>
    </html>

