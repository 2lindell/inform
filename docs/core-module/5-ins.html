<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>5/un</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../compiler.html"><b>compiler</b></a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul>
<h2>Compiler Webs</h2>
<ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul>
<h2>Inbuild Modules</h2>
<ul>
<li><a href="../inbuild-module/index.html">inbuild</a></li>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../html-module/index.html">html</a></li>
</ul>
<h2>Inform7 Modules</h2>
<ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul>
<h2>Inter Modules</h2>
<ul>
<li><a href="../inter-module/index.html">inter</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of '5/ins' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="../compiler.html">Compiler Modules</a></li><li><a href="index.html">core</a></li><li><a href="index.html#5">Chapter 5: Nouns</a></li><li><b>Instances</b></li></ul><p class="purpose">To manage constant values of enumerated kinds, including kinds of object.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP6">&#167;6. Creation</a></li><li><a href="#SP9">&#167;9. Coincidence with property names</a></li><li><a href="#SP12">&#167;12. Logging</a></li><li><a href="#SP13">&#167;13. As subjects</a></li><li><a href="#SP14">&#167;14. As mere names</a></li><li><a href="#SP15">&#167;15. Writer</a></li><li><a href="#SP16">&#167;16. Parsing (instances only)</a></li><li><a href="#SP18">&#167;18. The kind of an instance</a></li><li><a href="#SP21">&#167;21. Iteration schemes</a></li><li><a href="#SP23">&#167;23. Connections</a></li><li><a href="#SP24">&#167;24. Indexing count</a></li><li><a href="#SP27">&#167;27. As subjects</a></li><li><a href="#SP35">&#167;35. Adjectival uses of instances</a></li><li><a href="#SP38">&#167;38. Adjectival domains</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>Instances are named constants of kinds which have a finite range (unlike
"number", say), and where the possibilities are entirely up to the source
text to specify (unlike "truth state", say), and where the values form
part of the model world, so that inferences can be made about them, and
properties attached to them, and so on (unlike "rulebook", say). For
example, in
</p>

<blockquote>
    <p>Colour is a kind of value. The colours are red, blue and green.</p>

</blockquote>

<p class="inwebparagraph">three instances are created: "red", "blue" and "green", which are
constants of kind "colour" made to differ from all other known "colour"
values (including each other). Objects are instances too:
</p>

<blockquote>
    <p>Peter carries a blue ball.</p>

</blockquote>

<p class="inwebparagraph">creates two instances of "object" (though the world-model-completion code
will eventually make them instances of the subkind "thing" unless other
evidence turns up to suggest otherwise).
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">instance</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">noun</span><span class="plain"> *</span><span class="identifier">tag</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">package_request</span><span class="plain"> *</span><span class="identifier">instance_package</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">instance_iname</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">instance_emitted</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">creating_sentence</span><span class="plain">; </span>    <span class="comment">sentence creating the instance</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">instance_of_set_at</span><span class="plain">; </span>    <span class="comment">and identifying its kind</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">as_subject</span><span class="plain">;</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">enumeration_index</span><span class="plain">; </span>    <span class="comment">within each kind, named constants are counted from 1</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">general_pointer</span><span class="plain"> </span><span class="identifier">connection</span><span class="plain">; </span>    <span class="comment">to the data structure for a constant of a kind significant to Inform</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">usage_as_aph</span><span class="plain">; </span>    <span class="comment">if this is a noun used adjectivally, like "red"</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">index_appearances</span><span class="plain">; </span>    <span class="comment">how many times have I appeared thus far in the World index?</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">instance_usage</span><span class="plain"> *</span><span class="identifier">first_noted_usage</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">instance_usage</span><span class="plain"> *</span><span class="identifier">last_noted_usage</span><span class="plain">;</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">instance</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure instance is private to this section.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>We are going to record uses of these in the index, so:
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">instance_usage</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">where_instance_used</span><span class="plain">;</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">instance_usage</span><span class="plain"> *</span><span class="identifier">next</span><span class="plain">;</span>
    <span class="plain">} </span><span class="reserved">instance_usage</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure instance_usage is accessed in 3/pd, 5/lp, 5/ut, 5/un, 6/rlt, 6/nv, 7/ns, 7/oaf, 7/rs, 9/tfa, 9/tbath, 9/rpt, 9/tc, 9/ma, 9/rk, 9/ass, 9/imp, 9/pd, 10/teav, 10/cap, 11/ap, 11/pr, 11/bas, 11/tc, 11/sm, 12/dtd, 12/cdp, 14/rv, 14/lv, 14/cn, 14/ds, 14/ds2, 15/cp, 16/is, 16/in, 19/tb, 19/rsft, 19/tod, 20/eq, 21/rl, 21/rl2, 21/fao, 21/rps, 21/sv, 21/ac, 22/ph, 22/tp, 22/tp2, 23/ad, 24/lv, 24/sf, 25/in, 25/pi, 25/cii, 25/cp, 26/uo, 26/tti, 26/pc, 26/ts, 27/cm and here.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>We record the one most recently made:
</p>


<pre class="display">
    <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">latest_instance</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>We also need to keep track of three in particular:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">NO_GRAMMATICAL_GENDERS</span><span class="plain"> 3</span>
</pre>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">no_ggs_recorded</span><span class="plain"> = 0;</span>
    <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">grammatical_genders</span><span class="plain">[</span><span class="constant">NO_GRAMMATICAL_GENDERS</span><span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Creation. </b>Since this is the first of several "protected model procedures" in the
Inform source, a brief explanation. Inform's world model is brought into being
by assertion sentences; these are converted to logical propositions; and
the propositions then "asserted", a formal process of arranging the world
so that they become true. Since some propositions assert the existence of
instances, the process sometimes means calling the following routine.
What makes it "protected" is that it is not allowed to be called from
anywhere else, and any attempt to do so will throw an internal error. (This
ensures that we don't accidentally break the rule that the model world is
fully specified by the propositions concerning it.)
</p>


<pre class="display">
    <span class="reserved">instance</span><span class="plain"> *</span><span class="functiontext">Instances::new</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="constant">PROTECTED_MODEL_PROCEDURE</span><span class="plain">;</span>
        &lt;<span class="cwebmacro">Simplify the initial kind of the instance</span> <span class="cwebmacronumber">6.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">cp</span><span class="plain"> = </span><span class="functiontext">Properties::Conditions::get_coinciding_property</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">Initialise the instance except for its noun</span> <span class="cwebmacronumber">6.2</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Make a noun for the new instance</span> <span class="cwebmacronumber">6.3</span>&gt;<span class="plain">;</span>
        <span class="functiontext">Instances::set_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">);</span>
        &lt;<span class="cwebmacro">Add the new instance to its enumeration</span> <span class="cwebmacronumber">6.4</span>&gt;<span class="plain">;</span>
        <span class="functiontext">Instances::iname</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
        <span class="identifier">latest_instance</span><span class="plain"> = </span><span class="identifier">I</span><span class="plain">;</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">OBJECT_CREATIONS</span><span class="plain">, </span><span class="string">"Created instance: $O (kind $u) (inter %n)\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">, </span><span class="functiontext">Instances::iname</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
        <span class="functiontext">Plugins::Call::new_named_instance_notify</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Kinds::Compare::eq</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_grammatical_gender</span><span class="plain">)) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">no_ggs_recorded</span><span class="plain"> &lt; </span><span class="constant">NO_GRAMMATICAL_GENDERS</span><span class="plain">))</span>
            <span class="identifier">grammatical_genders</span><span class="plain">[</span><span class="identifier">no_ggs_recorded</span><span class="plain">++] = </span><span class="identifier">I</span><span class="plain">;</span>
        <span class="functiontext">Assertions::Assemblies::satisfies_generalisations</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;as_subject</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">I</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::new is used in 12/ap (<a href="12-ap.html#SP9_5_2">&#167;9.5.2</a>).</p>

<p class="inwebparagraph"><a id="SP6_1"></a><b>&#167;6.1.  </b>If we don't know the kind, we assume "object"; if we're asked for a kind
more specific than "object", we make it just "object". (It will be refined
later on.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Simplify the initial kind of the instance</span> <span class="cwebmacronumber">6.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">K</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">K_object</span><span class="plain">;</span>
        <span class="identifier">K</span><span class="plain"> = </span><span class="identifier">Kinds::weaken</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_2"></a><b>&#167;6.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Initialise the instance except for its noun</span> <span class="cwebmacronumber">6.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_package</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_iname</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_emitted</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;creating_sentence</span><span class="plain"> = </span><span class="identifier">current_sentence</span><span class="plain">;</span>
        <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_of_set_at</span><span class="plain"> = </span><span class="identifier">current_sentence</span><span class="plain">;</span>
        <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;usage_as_aph</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;enumeration_index</span><span class="plain"> = 0;</span>
        <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;connection</span><span class="plain"> = </span><span class="identifier">NULL_GENERAL_POINTER</span><span class="plain">;</span>
        <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;index_appearances</span><span class="plain"> = 0;</span>
        <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;first_noted_usage</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;last_noted_usage</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;as_subject</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::new</span><span class="plain">(</span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">),</span>
            <span class="constant">INST_SUB</span><span class="plain">, </span><span class="identifier">STORE_POINTER_instance</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">), </span><span class="identifier">CERTAIN_CE</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_3"></a><b>&#167;6.3.  </b>When we create instances of a kind whose name coincides with a property
used as a condition, as here:
</p>

<blockquote>
    <p>A door can be ajar, sealed or wedged open.</p>

</blockquote>

<p class="inwebparagraph">we will need "ajar" and so on to be (in most contexts) adjectives rather
than nouns; so, even though they are instances, we give them blank nametags
to prevent them being parsed as nouns.
</p>

<p class="inwebparagraph">Otherwise, we have a choice of whether to allow ambiguous references or not.
Inform traditionally allows these for instances of object, but not for other
instances: thus "submarine green" (a colour, say) must be spelled out in
full, whereas a "tuna fish" (an object) can be called just "tuna".
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Make a noun for the new instance</span> <span class="cwebmacronumber">6.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">exact_parsing</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">any_parsing</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">cp</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">Properties::Conditions::of_what</span><span class="plain">(</span><span class="identifier">cp</span><span class="plain">))) </span><span class="identifier">any_parsing</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)) </span><span class="identifier">exact_parsing</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">any_parsing</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">exact_parsing</span><span class="plain">)</span>
                <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;tag</span><span class="plain"> =</span>
                    <span class="identifier">Nouns::new_proper_noun</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">NEUTER_GENDER</span><span class="plain">,</span>
                        <span class="identifier">REGISTER_SINGULAR_NTOPT</span><span class="plain"> + </span><span class="identifier">PARSE_EXACTLY_NTOPT</span><span class="plain"> + </span><span class="identifier">ATTACH_TO_SEARCH_LIST_NTOPT</span><span class="plain">,</span>
                        <span class="constant">NAMED_CONSTANT_MC</span><span class="plain">, </span><span class="functiontext">Rvalues::from_instance</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
            <span class="reserved">else</span>
                <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;tag</span><span class="plain"> =</span>
                    <span class="identifier">Nouns::new_proper_noun</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">NEUTER_GENDER</span><span class="plain">,</span>
                        <span class="identifier">REGISTER_SINGULAR_NTOPT</span><span class="plain"> + </span><span class="identifier">ATTACH_TO_SEARCH_LIST_NTOPT</span><span class="plain">,</span>
                        <span class="identifier">NOUN_MC</span><span class="plain">, </span><span class="functiontext">Rvalues::from_instance</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;tag</span><span class="plain"> = </span><span class="identifier">Nouns::new_proper_noun</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">NEUTER_GENDER</span><span class="plain">,</span>
                <span class="identifier">REGISTER_SINGULAR_NTOPT</span><span class="plain"> + </span><span class="identifier">PARSE_EXACTLY_NTOPT</span><span class="plain"> + </span><span class="identifier">ATTACH_TO_SEARCH_LIST_NTOPT</span><span class="plain">,</span>
                <span class="identifier">NOUN_HAS_NO_MC</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_4"></a><b>&#167;6.4.  </b>The values in an enumerated kind such as our perpetual "colour" example
are numbered 1, 2, 3, ..., in order of creation. This is where we assign
those numbers, and also where we give corresponding adjectival meanings
in the kind in question is also a property.
</p>

<p class="inwebparagraph">There are two reasons why we don't do the same for objects: firstly, because
"object" has a whole hierarchy of subkinds, there's no unique numbering &mdash;
the same object may be thing number 17 but vehicle number 3 &mdash; and secondly,
because we won't know the exact kind of objects until much later on; for now
the only thing we are sure of is that they are indeed objects. Enumerations
for objects within kinds is certainly useful, but it's harder to do and will
be done later on: see the "Instance Counts" plugin.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Add the new instance to its enumeration</span> <span class="cwebmacronumber">6.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (!(</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">))) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Behaviour::has_named_constant_values</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)</span>
                <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to make an instance value for impossible kind"</span><span class="plain">);</span>
            <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;enumeration_index</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::new_enumerated_value</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">K</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">cp</span><span class="plain">) </span><span class="functiontext">Instances::register_as_adjectival_constant</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">cp</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b></p>


<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">Instances::get_creating_sentence</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;creating_sentence</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::get_creating_sentence is used in 2/sq (<a href="2-sq.html#SP2">&#167;2</a>), 5/ipw (<a href="5-ipw.html#SP3_5">&#167;3.5</a>, <a href="5-ipw.html#SP4">&#167;4</a>), 8/ef (<a href="8-ef.html#SP12_2">&#167;12.2</a>).</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b></p>


<pre class="display">
    <span class="identifier">source_file</span><span class="plain"> *</span><span class="functiontext">Instances::get_creating_file</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">Lexer::file_of_origin</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;creating_sentence</span><span class="plain">)));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::get_creating_file appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Coincidence with property names. </b>Suppose, as always, we have:
</p>

<blockquote>
    <p>Colour is a kind of value. The colours are red, white and blue. A door has a colour.</p>

</blockquote>

<p class="inwebparagraph">The third sentence causes the following to be called, for the kind "colour"
and the property "colour", whose names coincide:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::make_kind_coincident</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">, </span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain">) {</span>
        <span class="functiontext">Properties::Conditions::set_coinciding_property</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">P</span><span class="plain">);</span>
        <span class="functiontext">Instances::update_adjectival_forms</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::make_kind_coincident is used in 15/vp (<a href="15-vp.html#SP6">&#167;6</a>).</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>That causes us to "update adjectival forms" for the property "colour",
a sort of general round-up to make sure that all of its possible applications
are covered by suitable adjectives. For instance, "red" must be registered
as an adjectival constant to cover doors. We will call this again if a further
use of colour turns up subsequently, e.g., in response to:
</p>

<blockquote>
    <p>A vehicle has a colour.</p>

</blockquote>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::update_adjectival_forms</span><span class="plain">(</span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Properties::is_either_or</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">) == </span><span class="identifier">TRUE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">Properties::Valued::kind</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">P</span><span class="plain"> == </span><span class="functiontext">Properties::Conditions::get_coinciding_property</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">)) {</span>
            <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">;</span>
            <span class="identifier">LOOP_OVER_INSTANCES</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">)</span>
                <span class="functiontext">Instances::register_as_adjectival_constant</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">P</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::update_adjectival_forms is used in <a href="#SP9">&#167;9</a>, 15/tpr (<a href="15-tpr.html#SP6">&#167;6</a>).</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b>So here is where we need to make "red", "white" or "blue" adjectives
specifying colour. And we will also call this if a further instance of colour
turns up subsequently, e.g., in response to
</p>

<blockquote>
    <p>Mauve is a colour.</p>

</blockquote>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::register_as_adjectival_constant</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">, </span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain">) {</span>
        <span class="reserved">property_permission</span><span class="plain"> *</span><span class="identifier">pp</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_PERMISSIONS_FOR_PROPERTY</span><span class="plain">(</span><span class="identifier">pp</span><span class="plain">, </span><span class="identifier">P</span><span class="plain">) {</span>
            <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain"> = </span><span class="functiontext">World::Permissions::get_subject</span><span class="plain">(</span><span class="identifier">pp</span><span class="plain">);</span>
            <span class="functiontext">InferenceSubjects::make_adj_const_domain</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">, </span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">P</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::register_as_adjectival_constant is used in <a href="#SP6_4">&#167;6.4</a>, <a href="#SP10">&#167;10</a>.</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Logging. </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::log</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain">== </span><span class="identifier">NULL</span><span class="plain">) { </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"&lt;null instance&gt;"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain">; }</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Streams::I6_escapes_enabled</span><span class="plain">(</span><span class="identifier">DL</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"I%d"</span><span class="plain">, </span><span class="identifier">I</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain">);</span>
        <span class="identifier">Nouns::log</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;tag</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (!(</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">), </span><span class="identifier">K_object</span><span class="plain">)))</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"[$u]"</span><span class="plain">, </span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::log is used in 1/cm (<a href="1-cm.html#SP5">&#167;5</a>, <a href="1-cm.html#SP6_6">&#167;6.6</a>).</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. As subjects. </b>Instances can be reasoned about, so they correspond to inference subjects.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Instances::get_numerical_value</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;enumeration_index</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="functiontext">Instances::as_subject</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;as_subject</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::get_numerical_value is used in 3/nl (<a href="3-nl.html#SP5">&#167;5</a>), 14/rv (<a href="14-rv.html#SP3">&#167;3</a>).</p>

<p class="endnote">The function Instances::as_subject is used in <a href="#SP33">&#167;33</a>, 3/nl (<a href="3-nl.html#SP5">&#167;5</a>), 4/am (<a href="4-am.html#SP22">&#167;22</a>), 5/ipw (<a href="5-ipw.html#SP3_7">&#167;3.7</a>, <a href="5-ipw.html#SP3_9">&#167;3.9</a>), 6/rlt (<a href="6-rlt.html#SP26">&#167;26</a>), 9/rpt (<a href="9-rpt.html#SP9_5_1">&#167;9.5.1</a>, <a href="9-rpt.html#SP10_1">&#167;10.1</a>), 9/tc (<a href="9-tc.html#SP5_4">&#167;5.4</a>, <a href="9-tc.html#SP5_4_1_1">&#167;5.4.1.1</a>, <a href="9-tc.html#SP8_4_1">&#167;8.4.1</a>), 9/ma (<a href="9-ma.html#SP3_3_41_5">&#167;3.3.41.5</a>), 11/tc (<a href="11-tc.html#SP2">&#167;2</a>), 12/ap (<a href="12-ap.html#SP9_5_2">&#167;9.5.2</a>, <a href="12-ap.html#SP12">&#167;12</a>), 14/ds2 (<a href="14-ds2.html#SP11_9_1_1_5_1_3">&#167;11.9.1.1.5.1.3</a>), 15/pr (<a href="15-pr.html#SP27">&#167;27</a>), 15/pov (<a href="15-pov.html#SP4">&#167;4</a>), 16/is (<a href="16-is.html#SP6">&#167;6</a>, <a href="16-is.html#SP12">&#167;12</a>, <a href="16-is.html#SP17">&#167;17</a>), 16/in (<a href="16-in.html#SP19">&#167;19</a>), 16/ic (<a href="16-ic.html#SP8">&#167;8</a>, <a href="16-ic.html#SP12_1">&#167;12.1</a>, <a href="16-ic.html#SP12_3_1">&#167;12.3.1</a>, <a href="16-ic.html#SP12_3_2">&#167;12.3.2</a>, <a href="16-ic.html#SP12_3_3">&#167;12.3.3</a>).</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. As mere names. </b></p>


<pre class="display">
    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">Instances::get_name</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">plural</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">I</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;tag</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">Nouns::get_name</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;tag</span><span class="plain">, </span><span class="identifier">plural</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">Instances::get_name_in_play</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">plural</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">I</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;tag</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">Nouns::get_name_in_play</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;tag</span><span class="plain">, </span><span class="identifier">plural</span><span class="plain">, </span><span class="identifier">Projects::get_language_of_play</span><span class="plain">(</span><span class="functiontext">Task::project</span><span class="plain">()));</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Instances::full_name_includes</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">vocabulary_entry</span><span class="plain"> *</span><span class="identifier">wd</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">Nouns::full_name_includes</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;tag</span><span class="plain">, </span><span class="identifier">wd</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="identifier">noun</span><span class="plain"> *</span><span class="functiontext">Instances::get_noun</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;tag</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">text_stream</span><span class="plain"> *</span><span class="functiontext">Instances::identifier</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">I</span><span class="string">"nothing"</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">UseNouns::identifier</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;tag</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="functiontext">Instances::iname</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_iname</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_package</span><span class="plain"> = </span><span class="functiontext">Hierarchy::local_package</span><span class="plain">(</span><span class="constant">INSTANCES_HAP</span><span class="plain">);</span>
            <span class="functiontext">UseNouns::noun_compose_identifier</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_package</span><span class="plain">, </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;tag</span><span class="plain">, </span><span class="identifier">I</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain">);</span>
            <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_iname</span><span class="plain"> = </span><span class="functiontext">UseNouns::iname</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;tag</span><span class="plain">);</span>
            <span class="functiontext">Hierarchy::markup_wording</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_package</span><span class="plain">, </span><span class="constant">INSTANCE_NAME_HMD</span><span class="plain">, </span><span class="identifier">Nouns::get_name</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;tag</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">));</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_iname</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::get_name is used in <a href="#SP15_1">&#167;15.1</a>, <a href="#SP15_2">&#167;15.2</a>, <a href="#SP27">&#167;27</a>, <a href="#SP37">&#167;37</a>, <a href="#SP38_2">&#167;38.2</a>, 2/sq (<a href="2-sq.html#SP2">&#167;2</a>), 5/ipw (<a href="5-ipw.html#SP2_2_1">&#167;2.2.1</a>), 8/ef (<a href="8-ef.html#SP12_2">&#167;12.2</a>, <a href="8-ef.html#SP12_4">&#167;12.4</a>), 9/rpt (<a href="9-rpt.html#SP9_5_1">&#167;9.5.1</a>), 9/tc (<a href="9-tc.html#SP5_4_1">&#167;5.4.1</a>), 14/rv (<a href="14-rv.html#SP3">&#167;3</a>).</p>

<p class="endnote">The function Instances::get_name_in_play is used in <a href="#SP25">&#167;25</a>, 13/rsfk (<a href="13-rsfk.html#SP24_3">&#167;24.3</a>).</p>

<p class="endnote">The function Instances::full_name_includes appears nowhere else.</p>

<p class="endnote">The function Instances::get_noun is used in 5/un (<a href="5-un.html#SP5">&#167;5</a>), 5/ipw (<a href="5-ipw.html#SP3">&#167;3</a>).</p>

<p class="endnote">The function Instances::identifier appears nowhere else.</p>

<p class="endnote">The function Instances::iname is used in <a href="#SP6">&#167;6</a>, <a href="#SP15">&#167;15</a>, <a href="#SP29">&#167;29</a>, <a href="#SP34">&#167;34</a>, 13/rsfk (<a href="13-rsfk.html#SP4">&#167;4</a>, <a href="13-rsfk.html#SP24_3">&#167;24.3</a>), 25/cii (<a href="25-cii.html#SP8">&#167;8</a>), 26/ts (<a href="26-ts.html#SP10">&#167;10</a>).</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15. Writer. </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::writer</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">char</span><span class="plain"> *</span><span class="identifier">format_string</span><span class="plain">, </span><span class="reserved">void</span><span class="plain"> *</span><span class="identifier">vI</span><span class="plain">) {</span>
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain"> = (</span><span class="reserved">instance</span><span class="plain"> *) </span><span class="identifier">vI</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"nothing"</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">format_string</span><span class="plain">[0]) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="character">'I'</span><span class="plain">: </span>    <span class="comment">bare <code class="display"><span class="extract">%I</span></code> means the same as <code class="display"><span class="extract">%+I</span></code>, so fall through to...</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="character">'+'</span><span class="plain">: </span>&lt;<span class="cwebmacro">Write the instance raw</span> <span class="cwebmacronumber">15.1</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="character">'-'</span><span class="plain">: </span>&lt;<span class="cwebmacro">Write the instance with normalised casing</span> <span class="cwebmacronumber">15.2</span>&gt;<span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="character">'~'</span><span class="plain">: {</span>
                <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">N</span><span class="plain"> = </span><span class="functiontext">Instances::iname</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Str::len</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;tag</span><span class="plain">-&gt;</span><span class="identifier">nt_I6_identifier</span><span class="plain">) &gt; 0) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%S"</span><span class="plain">, </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;tag</span><span class="plain">-&gt;</span><span class="identifier">nt_I6_identifier</span><span class="plain">);</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%n"</span><span class="plain">, </span><span class="identifier">N</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">default</span><span class="plain">: </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"bad %I modifier"</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::writer is used in 1/cm (<a href="1-cm.html#SP6_3">&#167;6.3</a>).</p>

<p class="inwebparagraph"><a id="SP15_1"></a><b>&#167;15.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Write the instance raw</span> <span class="cwebmacronumber">15.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="functiontext">Instances::get_name</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"nameless "</span><span class="plain">);</span>
            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
            <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_name</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP15">&#167;15</a>.</p>

<p class="inwebparagraph"><a id="SP15_2"></a><b>&#167;15.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Write the instance with normalised casing</span> <span class="cwebmacronumber">15.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="functiontext">Instances::get_name</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%W"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"nameless "</span><span class="plain">);</span>
            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
            <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_name</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%W"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP15">&#167;15</a>.</p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16. Parsing (instances only). </b>Ordinarily these constants are read by the S-parser in the normal way that
all constants are read &mdash; see the next chapter &mdash; but it's occasionally
useful to bypass that and just parse text as an instance name and nothing
else. (We don't need to filter explicitly for the kind because only
instances have excerpts registered under <code class="display"><span class="extract">NOUN_MC</span></code>.)
</p>


<pre class="display">
    <span class="reserved">instance</span><span class="plain"> *</span><span class="functiontext">Instances::parse_object</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">literal</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">p</span><span class="plain"> = </span><span class="identifier">ExParser::parse_excerpt</span><span class="plain">(</span><span class="identifier">NOUN_MC</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">noun</span><span class="plain"> *</span><span class="identifier">nt</span><span class="plain"> = </span><span class="identifier">Nouns::disambiguate</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">MAX_NOUN_PRIORITY</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">nt</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Nouns::priority</span><span class="plain">(</span><span class="identifier">nt</span><span class="plain">) != </span><span class="identifier">LOW_NOUN_PRIORITY</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain"> = </span><span class="identifier">RETRIEVE_POINTER_parse_node</span><span class="plain">(</span><span class="identifier">Nouns::tag_holder</span><span class="plain">(</span><span class="identifier">nt</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::is</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">, </span><span class="constant">CONSTANT_NT</span><span class="plain">)) {</span>
            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">ParseTree::get_kind_of_value</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">))</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">ParseTree::get_constant_instance</span><span class="plain">(</span><span class="identifier">pn</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::parse_object is used in <a href="#SP17">&#167;17</a>, 9/tc (<a href="9-tc.html#SP5_4_1">&#167;5.4.1</a>), 25/cii (<a href="25-cii.html#SP8">&#167;8</a>).</p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17.  </b>The first internal matches only instances of kinds within the objects;
the second matches the others; and the third all instances, of whatever kind.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="reserved">instance</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain"> = </span><span class="functiontext">Instances::parse_object</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain">) { *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">I</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">; }</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="plain">&lt;</span><span class="reserved">instance</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">-</span><span class="identifier">non</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">ExParser::parse_excerpt</span><span class="plain">(</span><span class="constant">NAMED_CONSTANT_MC</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain"> = </span><span class="functiontext">Rvalues::to_instance</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain">) { *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">I</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">; }</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="plain">&lt;</span><span class="reserved">instance</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">literal</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Articles::remove_the</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain"> = </span><span class="functiontext">Instances::parse_object</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain">) { *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">I</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">; }</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">ExParser::parse_excerpt</span><span class="plain">(</span><span class="constant">NAMED_CONSTANT_MC</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">I</span><span class="plain"> = </span><span class="functiontext">Rvalues::to_instance</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain">) { *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">I</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">; }</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18. The kind of an instance. </b>By this of course we mean the most specific kind to which an instance
belongs: if we write
</p>

<blockquote>
    <p>Kathy is a woman.</p>

</blockquote>

<p class="inwebparagraph">then the Kathy instance is also a person, a thing, an object and a value,
but when we talk about the kind of Kathy, we mean "woman".
</p>

<p class="inwebparagraph">Note that this is not stored as a field in the instance structure, because
that would be redundant. Inform already knows which subjects are more
specialised than which other ones, and by making a call, we can find out.
</p>


<pre class="display">
    <span class="identifier">kind</span><span class="plain"> *</span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">inherits_from</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::narrowest_broader_subject</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;as_subject</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">InferenceSubjects::as_kind</span><span class="plain">(</span><span class="identifier">inherits_from</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Instances::of_kind</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">match</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">I</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">match</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">), </span><span class="identifier">match</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::to_kind is used in <a href="#SP12">&#167;12</a>, <a href="#SP15_1">&#167;15.1</a>, <a href="#SP15_2">&#167;15.2</a>, <a href="#SP19">&#167;19</a>, <a href="#SP21">&#167;21</a>, <a href="#SP25">&#167;25</a>, <a href="#SP33">&#167;33</a>, <a href="#SP34">&#167;34</a>, <a href="#SP36">&#167;36</a>, <a href="#SP37">&#167;37</a>, <a href="#SP38_1">&#167;38.1</a>, 2/sq (<a href="2-sq.html#SP2">&#167;2</a>, <a href="2-sq.html#SP4">&#167;4</a>), 4/am (<a href="4-am.html#SP22">&#167;22</a>), 5/ipw (<a href="5-ipw.html#SP3_3_1">&#167;3.3.1</a>, <a href="5-ipw.html#SP3_3_1_1">&#167;3.3.1.1</a>, <a href="5-ipw.html#SP3_4">&#167;3.4</a>, <a href="5-ipw.html#SP3_8">&#167;3.8</a>), 8/ef (<a href="8-ef.html#SP12_2">&#167;12.2</a>), 9/ma (<a href="9-ma.html#SP3_3_40_1">&#167;3.3.40.1</a>, <a href="9-ma.html#SP3_3_41_5">&#167;3.3.41.5</a>), 11/pr (<a href="11-pr.html#SP35_1">&#167;35.1</a>), 12/ap (<a href="12-ap.html#SP9_10">&#167;9.10</a>), 14/rv (<a href="14-rv.html#SP3">&#167;3</a>, <a href="14-rv.html#SP23_1">&#167;23.1</a>), 14/ds2 (<a href="14-ds2.html#SP11_9_1_1_5_1_1">&#167;11.9.1.1.5.1.1</a>, <a href="14-ds2.html#SP11_9_1_1_5_1_2">&#167;11.9.1.1.5.1.2</a>), 15/cp (<a href="15-cp.html#SP3">&#167;3</a>), 15/epv (<a href="15-epv.html#SP1_1">&#167;1.1</a>, <a href="15-epv.html#SP1_1_1">&#167;1.1.1</a>), 16/is (<a href="16-is.html#SP19">&#167;19</a>), 16/ic (<a href="16-ic.html#SP12_3">&#167;12.3</a>, <a href="16-ic.html#SP12_3_1">&#167;12.3.1</a>), 25/cp (<a href="25-cp.html#SP5_3_5">&#167;5.3.5</a>).</p>

<p class="endnote">The function Instances::of_kind is used in <a href="#SP21">&#167;21</a>, 5/ipw (<a href="5-ipw.html#SP3">&#167;3</a>), 16/ic (<a href="16-ic.html#SP8">&#167;8</a>).</p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19.  </b>Ordinarily, instances never change their kind, but instances of "object"
are allowed to refine it. Such revisions are allowed to specialise the kind
(e.g., by changing a "person" to a "man") but not to contradict it
(e.g., by changing a "supporter" to a "container").
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::set_kind</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">new</span><span class="plain">) {</span>
        <span class="constant">PROTECTED_MODEL_PROCEDURE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Tried to set kind to $u\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">new</span><span class="plain">);</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"Tried to set the kind of a null object"</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">existing</span><span class="plain"> = </span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">m</span><span class="plain"> = </span><span class="identifier">Kinds::Compare::compatible</span><span class="plain">(</span><span class="identifier">existing</span><span class="plain">, </span><span class="identifier">new</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">m</span><span class="plain"> == </span><span class="identifier">ALWAYS_MATCH</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">m</span><span class="plain"> == </span><span class="identifier">NEVER_MATCH</span><span class="plain">) {</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Tried to set kind of $O (existing $u) to $u\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">existing</span><span class="plain">, </span><span class="identifier">new</span><span class="plain">);</span>
            &lt;<span class="cwebmacro">Issue a problem message for a contradictory change of kind</span> <span class="cwebmacronumber">19.1</span>&gt;<span class="plain">;</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="functiontext">Plugins::Call::set_kind_notify</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">new</span><span class="plain">);</span>
        <span class="functiontext">InferenceSubjects::falls_within</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;as_subject</span><span class="plain">, </span><span class="functiontext">Kinds::Knowledge::as_subject</span><span class="plain">(</span><span class="identifier">new</span><span class="plain">));</span>
        <span class="functiontext">Assertions::Assemblies::satisfies_generalisations</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;as_subject</span><span class="plain">);</span>
        <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_of_set_at</span><span class="plain"> = </span><span class="identifier">current_sentence</span><span class="plain">;</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">KIND_CHANGES</span><span class="plain">, </span><span class="string">"Setting kind of $O to $u\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">new</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::set_kind is used in <a href="#SP6">&#167;6</a>, 12/ap (<a href="12-ap.html#SP9_6">&#167;9.6</a>, <a href="12-ap.html#SP10">&#167;10</a>).</p>

<p class="inwebparagraph"><a id="SP19_1"></a><b>&#167;19.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue a problem message for a contradictory change of kind</span> <span class="cwebmacronumber">19.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">current_sentence</span><span class="plain"> != </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_of_set_at</span><span class="plain">) {</span>
            <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
            <span class="identifier">Problems::quote_source</span><span class="plain">(2, </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_of_set_at</span><span class="plain">);</span>
            <span class="functiontext">Problems::quote_kind</span><span class="plain">(3, </span><span class="identifier">new</span><span class="plain">);</span>
            <span class="functiontext">Problems::quote_kind</span><span class="plain">(4, </span><span class="identifier">existing</span><span class="plain">);</span>
            <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_KindsIncompatible</span><span class="plain">));</span>
            <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                <span class="string">"You wrote %1, but that seems to contradict %2, as %3 and %4 "</span>
                <span class="string">"are incompatible. (If %3 were a kind of %4 or vice versa "</span>
                <span class="string">"there'd be no problem, but they aren't.)"</span><span class="plain">);</span>
            <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
            <span class="functiontext">Problems::quote_object</span><span class="plain">(2, </span><span class="identifier">I</span><span class="plain">);</span>
            <span class="functiontext">Problems::quote_kind</span><span class="plain">(3, </span><span class="identifier">new</span><span class="plain">);</span>
            <span class="functiontext">Problems::quote_kind</span><span class="plain">(4, </span><span class="identifier">existing</span><span class="plain">);</span>
            <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="functiontext">Task::syntax_tree</span><span class="plain">(), </span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">));</span>
            <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                <span class="string">"You wrote %1, which made me think the kind of %2 was %4, "</span>
                <span class="string">"but for other reasons I now think it ought to be %3, and those "</span>
                <span class="string">"are incompatible. (If %3 were a kind of %4 or vice versa "</span>
                <span class="string">"there'd be no problem, but they aren't.)"</span><span class="plain">);</span>
            <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP19">&#167;19</a>.</p>

<p class="inwebparagraph"><a id="SP20"></a><b>&#167;20.  </b></p>


<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">Instances::get_kind_set_sentence</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_of_set_at</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::get_kind_set_sentence is used in 5/ipw (<a href="5-ipw.html#SP3_8">&#167;3.8</a>).</p>

<p class="inwebparagraph"><a id="SP21"></a><b>&#167;21. Iteration schemes. </b></p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="identifier">LOOP_OVER_INSTANCES</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">)</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="reserved">instance</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Instances::of_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">))</span>
    <span class="definitionkeyword">define</span> <span class="identifier">LOOP_OVER_ENUMERATION_INSTANCES</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">)</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="reserved">instance</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Behaviour::is_an_enumeration</span><span class="plain">(</span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">)))</span>
    <span class="definitionkeyword">define</span> <span class="identifier">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">)</span>
        <span class="identifier">LOOP_OVER_INSTANCES</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">)</span>
</pre>
<p class="inwebparagraph"><a id="SP22"></a><b>&#167;22.  </b>The number of instances of a given kind makes a neat example:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Instances::count</span><span class="plain">(</span><span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">c</span><span class="plain"> = 0;</span>
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_INSTANCES</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">) </span><span class="identifier">c</span><span class="plain">++;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">c</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::count is used in <a href="#SP37">&#167;37</a>, 5/ipw (<a href="5-ipw.html#SP3_3">&#167;3.3</a>), 13/rsfk (<a href="13-rsfk.html#SP24">&#167;24</a>), 13/ki (<a href="13-ki.html#SP4">&#167;4</a>), 19/tb (<a href="19-tb.html#SP26_3">&#167;26.3</a>).</p>

<p class="inwebparagraph"><a id="SP23"></a><b>&#167;23. Connections. </b>Some of Inform's plugins give special meanings to particular kinds, in such
a way that they need to be given additional structure. For example, the
Scenes plugin needs to make instances of "scene" more than mere names:
each one has to have rulebooks attached, and conditions for starting and
ending, and so on. To achieve this, each instance is allowed to have a
single pointer to another data structure.
</p>

<p class="inwebparagraph">This mechanism is used only by plugins. For instances of Inform's core
kinds, including "object", the connection is always blank.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::set_connection</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">general_pointer</span><span class="plain"> </span><span class="identifier">gp</span><span class="plain">) {</span>
        <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;connection</span><span class="plain"> = </span><span class="identifier">gp</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">general_pointer</span><span class="plain"> </span><span class="functiontext">Instances::get_connection</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;connection</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::set_connection appears nowhere else.</p>

<p class="endnote">The function Instances::get_connection appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP24"></a><b>&#167;24. Indexing count. </b>This simply avoids repetitions in the World index.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::increment_indexing_count</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;index_appearances</span><span class="plain">++;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Instances::indexed_yet</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;index_appearances</span><span class="plain"> &gt; 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::increment_indexing_count is used in 5/ipw (<a href="5-ipw.html#SP2_1">&#167;2.1</a>, <a href="5-ipw.html#SP2_2">&#167;2.2</a>, <a href="5-ipw.html#SP3">&#167;3</a>).</p>

<p class="endnote">The function Instances::indexed_yet is used in 5/ipw (<a href="5-ipw.html#SP2_3">&#167;2.3</a>, <a href="5-ipw.html#SP2_4">&#167;2.4</a>).</p>

<p class="inwebparagraph"><a id="SP25"></a><b>&#167;25.  </b>Not every instance has a name, which is a nuisance for the index:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::index_name</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="functiontext">Instances::get_name_in_play</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
        <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Kinds::Behaviour::get_name_in_play</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">Projects::get_language_of_play</span><span class="plain">(</span><span class="functiontext">Task::project</span><span class="plain">()));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%+W"</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"nameless"</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::index_name is used in 5/ipw (<a href="5-ipw.html#SP3_8">&#167;3.8</a>, <a href="5-ipw.html#SP4">&#167;4</a>), 13/ki (<a href="13-ki.html#SP5_1">&#167;5.1</a>).</p>

<p class="inwebparagraph"><a id="SP26"></a><b>&#167;26.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::note_usage</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">NB</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;last_noted_usage</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">NB</span><span class="plain"> == </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;last_noted_usage</span><span class="plain">-</span><span class="element">&gt;where_instance_used</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">instance_usage</span><span class="plain"> *</span><span class="identifier">IU</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">instance_usage</span><span class="plain">);</span>
        <span class="identifier">IU</span><span class="plain">-</span><span class="element">&gt;where_instance_used</span><span class="plain"> = </span><span class="identifier">NB</span><span class="plain">;</span>
        <span class="identifier">IU</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;last_noted_usage</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;first_noted_usage</span><span class="plain"> = </span><span class="identifier">IU</span><span class="plain">;</span>
            <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;last_noted_usage</span><span class="plain"> = </span><span class="identifier">IU</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;last_noted_usage</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">IU</span><span class="plain">;</span>
            <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;last_noted_usage</span><span class="plain"> = </span><span class="identifier">IU</span><span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::index_usages</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">k</span><span class="plain"> = 0;</span>
        <span class="reserved">instance_usage</span><span class="plain"> *</span><span class="identifier">IU</span><span class="plain"> = </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;first_noted_usage</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (; </span><span class="identifier">IU</span><span class="plain">; </span><span class="identifier">IU</span><span class="plain"> = </span><span class="identifier">IU</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">) {</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">at</span><span class="plain"> = </span><span class="identifier">IU</span><span class="plain">-</span><span class="element">&gt;where_instance_used</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">at</span><span class="plain">) {</span>
                <span class="identifier">source_file</span><span class="plain"> *</span><span class="identifier">sf</span><span class="plain"> = </span><span class="identifier">Lexer::file_of_origin</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">at</span><span class="plain">)));</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Projects::draws_from_source_file</span><span class="plain">(</span><span class="functiontext">Task::project</span><span class="plain">(), </span><span class="identifier">sf</span><span class="plain">)) {</span>
                    <span class="identifier">k</span><span class="plain">++;</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">k</span><span class="plain"> == 1) {</span>
                        <span class="identifier">HTMLFiles::open_para</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, 1, </span><span class="string">"tight"</span><span class="plain">);</span>
                        <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;i&gt;mentioned in rules:&lt;/i&gt; "</span><span class="plain">);</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"; "</span><span class="plain">);</span>
                    <span class="identifier">Index::link</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">at</span><span class="plain">)));</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">k</span><span class="plain"> &gt; 0) </span><span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::note_usage is used in 14/rv (<a href="14-rv.html#SP24_3">&#167;24.3</a>).</p>

<p class="endnote">The function Instances::index_usages is used in 5/ipw (<a href="5-ipw.html#SP3">&#167;3</a>).</p>

<p class="inwebparagraph"><a id="SP27"></a><b>&#167;27. As subjects. </b>Some methods for instances as inference subjects:
</p>


<pre class="display">
    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">Instances::SUBJ_get_name_text</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">from</span><span class="plain">) {</span>
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::as_nc</span><span class="plain">(</span><span class="identifier">from</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Instances::get_name</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="identifier">general_pointer</span><span class="plain"> </span><span class="functiontext">Instances::SUBJ_new_permission_granted</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">from</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">STORE_POINTER_property_of_value_storage</span><span class="plain">(</span>
            <span class="functiontext">Properties::OfValues::get_storage</span><span class="plain">());</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::SUBJ_complete_model</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">) {</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::SUBJ_check_model</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">) {</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::SUBJ_get_name_text is used in 16/is (<a href="16-is.html#SP24">&#167;24</a>).</p>

<p class="endnote">The function Instances::SUBJ_new_permission_granted is used in 16/is (<a href="16-is.html#SP25">&#167;25</a>).</p>

<p class="endnote">The function Instances::SUBJ_complete_model is used in 16/is (<a href="16-is.html#SP27">&#167;27</a>).</p>

<p class="endnote">The function Instances::SUBJ_check_model is used in 16/is (<a href="16-is.html#SP28">&#167;28</a>).</p>

<p class="inwebparagraph"><a id="SP28"></a><b>&#167;28.  </b>See below.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::SUBJ_make_adj_const_domain</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">S</span><span class="plain">,</span>
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">, </span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain">) {</span>
        <span class="functiontext">Instances::make_adj_const_domain</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">P</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="functiontext">InferenceSubjects::as_instance</span><span class="plain">(</span><span class="identifier">S</span><span class="plain">));</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::SUBJ_make_adj_const_domain is used in 16/is (<a href="16-is.html#SP26">&#167;26</a>).</p>

<p class="inwebparagraph"><a id="SP29"></a><b>&#167;29.  </b>Since all instances are single values, testing for inclusion under such a
subject is very simple:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Instances::SUBJ_emit_element_of_condition</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">, </span><span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">t0_s</span><span class="plain">) {</span>
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::as_nc</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">);</span>
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">t0_s</span><span class="plain">);</span>
            <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Instances::iname</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::SUBJ_emit_element_of_condition is used in 16/is (<a href="16-is.html#SP29">&#167;29</a>).</p>

<p class="inwebparagraph"><a id="SP30"></a><b>&#167;30.  </b>Here's how to place the instance objects in order. The ordering is used not
only for compilation, but also for instance counting (e.g., marking the
black gate as the 8th instance of "door"), so it's needed earlier than
the compilation phase, too.
</p>

<p class="inwebparagraph">Code wanting to create an ordering should first call <code class="display"><span class="extract">begin_sequencing_objects</span></code>
and then send the objects, in turn, via <code class="display"><span class="extract">place_this_object_next</span></code>.
</p>

<p class="inwebparagraph">They are stored as a linked list with the links in an array indexed by the
allocation IDs of the objects.
</p>


<pre class="display">
    <span class="reserved">instance</span><span class="plain"> **</span><span class="identifier">objects_in_compilation_list</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">first_object_in_compilation_list</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">last_object_in_compilation_list</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::begin_sequencing_objects</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">nc</span><span class="plain"> = </span><span class="identifier">NUMBER_CREATED</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">objects_in_compilation_list</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">objects_in_compilation_list</span><span class="plain"> = (</span><span class="reserved">instance</span><span class="plain"> **)</span>
                <span class="plain">(</span><span class="identifier">Memory::I7_calloc</span><span class="plain">(</span><span class="identifier">nc</span><span class="plain">, </span><span class="reserved">sizeof</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *), </span><span class="constant">OBJECT_COMPILATION_MREASON</span><span class="plain">));</span>
        <span class="plain">}</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">nc</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) </span><span class="identifier">objects_in_compilation_list</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">] = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">first_object_in_compilation_list</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">last_object_in_compilation_list</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::place_this_object_next</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">last_object_in_compilation_list</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)</span>
            <span class="identifier">first_object_in_compilation_list</span><span class="plain"> = </span><span class="identifier">I</span><span class="plain">;</span>
        <span class="reserved">else</span>
            <span class="identifier">objects_in_compilation_list</span><span class="plain">[</span><span class="identifier">last_object_in_compilation_list</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain">] = </span><span class="identifier">I</span><span class="plain">;</span>
        <span class="identifier">last_object_in_compilation_list</span><span class="plain"> = </span><span class="identifier">I</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::begin_sequencing_objects is used in <a href="#SP31">&#167;31</a>.</p>

<p class="endnote">The function Instances::place_this_object_next is used in <a href="#SP31">&#167;31</a>.</p>

<p class="inwebparagraph"><a id="SP31"></a><b>&#167;31.  </b>For instance, here we put them in order of definition, which is the default.
Note that only instances, not kinds, appear.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::place_objects_in_definition_sequence</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="functiontext">Instances::begin_sequencing_objects</span><span class="plain">();</span>
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_OBJECT_INSTANCES</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">)</span>
            <span class="functiontext">Instances::place_this_object_next</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::place_objects_in_definition_sequence is used in 1/htc (<a href="1-htc.html#SP2_5">&#167;2.5</a>).</p>

<p class="inwebparagraph"><a id="SP32"></a><b>&#167;32.  </b>And we read the order back using these macros:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">FIRST_IN_COMPILATION_SEQUENCE</span><span class="plain"> </span><span class="identifier">first_object_in_compilation_list</span>
    <span class="definitionkeyword">define</span> <span class="identifier">NEXT_IN_COMPILATION_SEQUENCE</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">) </span><span class="identifier">objects_in_compilation_list</span><span class="plain">[</span><span class="identifier">I</span><span class="plain">-&gt;</span><span class="identifier">allocation_id</span><span class="plain">]</span>
    <span class="definitionkeyword">define</span> <span class="identifier">LOOP_OVER_OBJECTS_IN_COMPILATION_SEQUENCE</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">)</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain">=</span><span class="constant">FIRST_IN_COMPILATION_SEQUENCE</span><span class="plain">; </span><span class="identifier">I</span><span class="plain">; </span><span class="identifier">I</span><span class="plain">=</span><span class="identifier">NEXT_IN_COMPILATION_SEQUENCE</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">))</span>
</pre>
<p class="inwebparagraph"><a id="SP33"></a><b>&#167;33.  </b>Compilation looks tricky only because we need to compile instances in a
set order which is not the order of their creation. (This is because objects
must be compiled in containment-tree traversal order in the final Inform 6
code.) So in reply to a request to compile all instances, we first delegate
the object instances, then compile the non-object ones (all just constant
declarations) and finally return <code class="display"><span class="extract">TRUE</span></code> to indicate that the task is finished.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Instances::SUBJ_compile_all</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER_OBJECTS_IN_COMPILATION_SEQUENCE</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">)</span>
            <span class="functiontext">Instances::SUBJ_compile</span><span class="plain">(</span><span class="functiontext">Instances::as_subject</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="reserved">instance</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::le</span><span class="plain">(</span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">), </span><span class="identifier">K_object</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)</span>
                <span class="functiontext">Instances::SUBJ_compile</span><span class="plain">(</span><span class="functiontext">Instances::as_subject</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="identifier">PL::Naming::compile_small_names</span><span class="plain">();</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::SUBJ_compile_all is used in 16/is (<a href="16-is.html#SP30">&#167;30</a>).</p>

<p class="inwebparagraph"><a id="SP34"></a><b>&#167;34.  </b>Either way, the actual compilation happens here:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::SUBJ_compile</span><span class="plain">(</span><span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs</span><span class="plain">) {</span>
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain"> = </span><span class="functiontext">InferenceSubjects::as_nc</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">);</span>
        <span class="functiontext">Instances::emitted_iname</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
        <span class="functiontext">Properties::emit_instance_permissions</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
        <span class="functiontext">Properties::Emit::emit_subject</span><span class="plain">(</span><span class="identifier">infs</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="identifier">inter_name</span><span class="plain"> *</span><span class="functiontext">Instances::emitted_iname</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="functiontext">Instances::iname</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_emitted</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
            <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_emitted</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="functiontext">Emit::instance</span><span class="plain">(</span><span class="identifier">iname</span><span class="plain">, </span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">), </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;enumeration_index</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">iname</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">package_request</span><span class="plain"> *</span><span class="functiontext">Instances::package</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="functiontext">Instances::iname</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">); </span>    <span class="comment">Thus forcing this to exist...</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;instance_package</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::SUBJ_compile is used in <a href="#SP33">&#167;33</a>, 16/is (<a href="16-is.html#SP30">&#167;30</a>).</p>

<p class="endnote">The function Instances::emitted_iname is used in 13/rsfk (<a href="13-rsfk.html#SP5">&#167;5</a>), 14/rv (<a href="14-rv.html#SP24_2">&#167;24.2</a>, <a href="14-rv.html#SP24_3">&#167;24.3</a>), 15/pr (<a href="15-pr.html#SP27">&#167;27</a>), 15/epv (<a href="15-epv.html#SP1">&#167;1</a>), 16/ic (<a href="16-ic.html#SP10">&#167;10</a>), 27/ei (<a href="27-ei.html#SP3">&#167;3</a>).</p>

<p class="endnote">The function Instances::package is used in 15/epv (<a href="15-epv.html#SP2">&#167;2</a>).</p>

<p class="inwebparagraph"><a id="SP35"></a><b>&#167;35. Adjectival uses of instances. </b>Some constant names can be used adjectivally, but not others. This happens
when their kind's name coincides with a name for a property, as might for
instance happen with "colour". In other words, because it is reasonable
that a ball might have a colour, we can declare that "the ball is green",
or speak of "something blue": whereas we are not allowed to use "score to
beat" adjectivally since (a) it is a variable, and (b) "number" is not a
coinciding property: we would not ordinarily write "the ball is 4". (A
quirk in English does allow this, implicitly construing number as an age
property, but we don't go there in Inform.)
</p>

<p class="inwebparagraph">These adjectives are easy to handle:
</p>


<pre class="display">
    <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="functiontext">Instances::get_adjectival_phrase</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;usage_as_aph</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="functiontext">Instances::ADJ_parse</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pn</span><span class="plain">,</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">sense</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">AW</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">DNW</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">CONW</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">CALLW</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::ADJ_compiling_soon</span><span class="plain">(</span><span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain">, </span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">T</span><span class="plain">) {</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Instances::ADJ_compile</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">T</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">emit_flag</span><span class="plain">, </span><span class="reserved">ph_stack_frame</span><span class="plain"> *</span><span class="identifier">phsf</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::get_adjectival_phrase is used in 10/varc (<a href="10-varc.html#SP9_1">&#167;9.1</a>), 11/tr (<a href="11-tr.html#SP9">&#167;9</a>), 11/pr (<a href="11-pr.html#SP35_1">&#167;35.1</a>).</p>

<p class="endnote">The function Instances::ADJ_parse is used in 4/am (<a href="4-am.html#SP37">&#167;37</a>).</p>

<p class="endnote">The function Instances::ADJ_compiling_soon is used in 4/am (<a href="4-am.html#SP38">&#167;38</a>).</p>

<p class="endnote">The function Instances::ADJ_compile is used in 4/am (<a href="4-am.html#SP39">&#167;39</a>).</p>

<p class="inwebparagraph"><a id="SP36"></a><b>&#167;36.  </b>Asserting such an adjective simply asserts its property. We refuse to assert
the falseness of such an adjective since it's unclear what to infer from, e.g.,
"the ball is not green": we would need to give it a colour, and there's no
good basis for choosing which.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Instances::ADJ_assert</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">,</span>
        <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">infs_to_assert_on</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">val_to_assert_on</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">parity</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">parity</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain"> = </span><span class="functiontext">Properties::Conditions::get_coinciding_property</span><span class="plain">(</span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">P</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"enumerative adjective on non-property"</span><span class="plain">);</span>
        <span class="functiontext">World::Inferences::draw_property</span><span class="plain">(</span><span class="identifier">infs_to_assert_on</span><span class="plain">, </span><span class="identifier">P</span><span class="plain">, </span><span class="functiontext">Rvalues::from_instance</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::ADJ_assert is used in 4/am (<a href="4-am.html#SP40">&#167;40</a>).</p>

<p class="inwebparagraph"><a id="SP37"></a><b>&#167;37.  </b>Some pretty-printing for the index, and we're done.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Instances::ADJ_index</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">) {</span>
        <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain"> = </span><span class="functiontext">Properties::Conditions::get_coinciding_property</span><span class="plain">(</span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Properties::Conditions::of_what</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">) == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Properties::permission_list</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">)) {</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"(of "</span><span class="plain">); </span><span class="functiontext">World::Permissions::index</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">P</span><span class="plain">); </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">") "</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"having this %+W"</span><span class="plain">, </span><span class="identifier">P</span><span class="plain">-</span><span class="element">&gt;name</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"a condition which is otherwise "</span><span class="plain">);</span>
            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">);</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">no_alts</span><span class="plain"> = </span><span class="functiontext">Instances::count</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">) - 1, </span><span class="identifier">i</span><span class="plain"> = 0;</span>
            <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">alt</span><span class="plain">;</span>
            <span class="identifier">LOOP_OVER_INSTANCES</span><span class="plain">(</span><span class="identifier">alt</span><span class="plain">, </span><span class="identifier">K</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">alt</span><span class="plain"> != </span><span class="identifier">I</span><span class="plain">) {</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;/i&gt;"</span><span class="plain">);</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%+W"</span><span class="plain">, </span><span class="functiontext">Instances::get_name</span><span class="plain">(</span><span class="identifier">alt</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">));</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;i&gt;"</span><span class="plain">);</span>
                    <span class="identifier">i</span><span class="plain">++;</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain"> == </span><span class="identifier">no_alts</span><span class="plain">-1) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" or "</span><span class="plain">);</span>
                    <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain"> &lt; </span><span class="identifier">no_alts</span><span class="plain">) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">", "</span><span class="plain">);</span>
                <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::ADJ_index is used in 4/am (<a href="4-am.html#SP41">&#167;41</a>).</p>

<p class="inwebparagraph"><a id="SP38"></a><b>&#167;38. Adjectival domains. </b>Let's reconstruct the chain of events, shall we? It has been found that an
instance, though a noun, must be used as an adjective: for example, "red".
Inform has run through the permissions for the property ("colour") in
question, and found that, say, it's a property of doors, scenes and also
a single piece of litmus paper. Each of these three is an inference subject,
so <code class="display"><span class="extract">InferenceSubjects::make_adj_const_domain</span></code> was called for each in turn.
By different means, those calls all ended up by passing the buck onto the
following routine: twice with the domain <code class="display"><span class="extract">set</span></code> being a kind (door and then
scene), once with <code class="display"><span class="extract">set</span></code> being null and <code class="display"><span class="extract">singleton</span></code> being an instance
(the litmus paper).
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Instances::make_adj_const_domain</span><span class="plain">(</span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain">, </span><span class="reserved">property</span><span class="plain"> *</span><span class="identifier">P</span><span class="plain">,</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">set</span><span class="plain">, </span><span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">singleton</span><span class="plain">) {</span>
        <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">D</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        &lt;<span class="cwebmacro">Find the kind domain within which the adjective applies</span> <span class="cwebmacronumber">38.1</span>&gt;<span class="plain">;</span>
        <span class="reserved">adjective_meaning</span><span class="plain"> *</span><span class="identifier">am</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        &lt;<span class="cwebmacro">Create the adjective meaning for this use of the instance</span> <span class="cwebmacronumber">38.2</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Write I6 schemas for asserting and testing this use of the instance</span> <span class="cwebmacronumber">38.3</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Instances::make_adj_const_domain is used in <a href="#SP28">&#167;28</a>, 13/kak (<a href="13-kak.html#SP4">&#167;4</a>).</p>

<p class="inwebparagraph"><a id="SP38_1"></a><b>&#167;38.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Find the kind domain within which the adjective applies</span> <span class="cwebmacronumber">38.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">singleton</span><span class="plain">) </span><span class="identifier">D</span><span class="plain"> = </span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">singleton</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">set</span><span class="plain">) </span><span class="identifier">D</span><span class="plain"> = </span><span class="identifier">set</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">D</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"No adjectival constant domain"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP38">&#167;38</a>.</p>

<p class="inwebparagraph"><a id="SP38_2"></a><b>&#167;38.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Create the adjective meaning for this use of the instance</span> <span class="cwebmacronumber">38.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">NW</span><span class="plain"> = </span><span class="functiontext">Instances::get_name</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="identifier">am</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::new</span><span class="plain">(</span><span class="constant">ENUMERATIVE_KADJ</span><span class="plain">,</span>
            <span class="identifier">STORE_POINTER_instance</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">), </span><span class="identifier">NW</span><span class="plain">);</span>
        <span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;usage_as_aph</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::declare</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">NW</span><span class="plain">, 4);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">singleton</span><span class="plain">) </span><span class="functiontext">Adjectives::Meanings::set_domain_from_instance</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">singleton</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">set</span><span class="plain">) </span><span class="functiontext">Adjectives::Meanings::set_domain_from_kind</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="identifier">set</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP38">&#167;38</a>.</p>

<p class="inwebparagraph"><a id="SP38_3"></a><b>&#167;38.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Write I6 schemas for asserting and testing this use of the instance</span> <span class="cwebmacronumber">38.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">i6_schema</span><span class="plain"> *</span><span class="identifier">sch</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::set_i6_schema</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="constant">TEST_ADJECTIVE_TASK</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">,</span>
            <span class="string">"GProperty(%k, *1, %n) == %d"</span><span class="plain">,</span>
                <span class="identifier">D</span><span class="plain">, </span><span class="functiontext">Properties::iname</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">), </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;enumeration_index</span><span class="plain">);</span>
        <span class="identifier">sch</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::set_i6_schema</span><span class="plain">(</span><span class="identifier">am</span><span class="plain">, </span><span class="constant">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">,</span>
            <span class="string">"WriteGProperty(%k, *1, %n, %d)"</span><span class="plain">,</span>
                <span class="identifier">D</span><span class="plain">, </span><span class="functiontext">Properties::iname</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">), </span><span class="identifier">I</span><span class="plain">-</span><span class="element">&gt;enumeration_index</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP38">&#167;38</a>.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="5-un.html">Back to 'Using Nametags'</a></li><li><a href="5-nv.html">Continue with 'Nonlocal Variables'</a></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

