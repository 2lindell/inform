<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>12/is</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '12/ca' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#12">Chapter 12: Use of Propositions</a></li><li><b>Compile Atoms</b></li></ul><p class="purpose">In this section, given an atom of a proposition we compile I6 code as required for any of three possible outcomes: (i) to test whether it is true, (ii) to make it henceforth true, or (iii) to make it henceforth false.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP5_1">&#167;5.1. Stage 1</a></li><li><a href="#SP5_2">&#167;5.2. Stage 2</a></li><li><a href="#SP6">&#167;6. Constructing the schema</a></li><li><a href="#SP8">&#167;8. An unannotated one</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>The compilation method is to look at the atom, work out a suitable I6
schema involving code to be applied to the one or two terms attaching to
the atom, and then expand this. In some circumstances, the process of
finding the schema will reveal that we need to apply it to different terms
from those originally found in the atom, however, so we also need to keep
track of that; and also of whether a condition is being regarded
negatively.
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">annotated_i6_schema</span><span class="plain"> {</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">i6_schema</span><span class="plain"> *</span><span class="identifier">schema</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">negate_schema</span><span class="plain">; </span>    <span class="comment">true if atom is to be tested with the opposite parity</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">pt0</span><span class="plain">; </span>    <span class="comment">terms on which the I6 schema is to be expanded</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">pt1</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">involves_action_variables</span><span class="plain">;</span>
    <span class="plain">} </span><span class="reserved">annotated_i6_schema</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure annotated_i6_schema is accessed in 6/bp, 6/tur, 12/ter, 12/qr, 15/tpr, 15/cr, 15/spr2 and here.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>Some constants to enumerate the three cases of what we are to do. This
looks asymmetrical &mdash; shouldn't we also test to see whether an atom is false,
a fourth case?
</p>

<p class="inwebparagraph">The answer is that there's no need, since "test false" can be done by
compiling "test true" and applying the I7 negation operator <code class="display"><span class="extract">~~</span></code> to the
result. No similar trick can be used to combine making something
true or false into a single operation.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">TEST_ATOM_TASK</span><span class="plain"> 1</span>
    <span class="definitionkeyword">define</span> <span class="constant">NOW_ATOM_TRUE_TASK</span><span class="plain"> 2</span>
    <span class="definitionkeyword">define</span> <span class="constant">NOW_ATOM_FALSE_TASK</span><span class="plain"> 3</span>
</pre>
<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>For its internal purposes, Inform is sometimes able to compile atoms which
wouldn't be allowed in a typical use of "now" from the source text; so it
can suppress the following problem messages:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">suppress_C14CantChangeKind</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">suppress_C14ActionVarsPastTense</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>So, then:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::Compile::emit</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">pl</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">with_semicolon</span><span class="plain">) {</span>
        <span class="identifier">value_holster</span><span class="plain"> </span><span class="identifier">VH</span><span class="plain"> = </span><span class="identifier">Holsters::new</span><span class="plain">(</span><span class="identifier">INTER_VAL_VHMODE</span><span class="plain">);</span>
        <span class="functiontext">Calculus::Atoms::Compile::compile</span><span class="plain">(&amp;</span><span class="identifier">VH</span><span class="plain">, </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">pl</span><span class="plain">, </span><span class="identifier">with_semicolon</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::Compile::compile</span><span class="plain">(</span><span class="identifier">value_holster</span><span class="plain"> *</span><span class="identifier">VH</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">pl</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">with_semicolon</span><span class="plain">) {</span>
        <span class="reserved">i6_schema</span><span class="plain"> </span><span class="identifier">sch</span><span class="plain">;</span>
        <span class="reserved">annotated_i6_schema</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>

        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TEST_ATOM_TASK</span><span class="plain">: </span><span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">PREDICATE_CALCULUS_WORKINGS</span><span class="plain">, </span><span class="string">"Compiling condition: $o\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">pl</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOW_ATOM_TRUE_TASK</span><span class="plain">: </span><span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">PREDICATE_CALCULUS_WORKINGS</span><span class="plain">, </span><span class="string">"Compiling 'now': $o\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">pl</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOW_ATOM_FALSE_TASK</span><span class="plain">: </span><span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">PREDICATE_CALCULUS_WORKINGS</span><span class="plain">, </span><span class="string">"Compiling 'now' false: $o\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">pl</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">default</span><span class="plain">: </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"unknown compile task"</span><span class="plain">);</span>
        <span class="plain">}</span>

        &lt;<span class="cwebmacro">Stage 1: make an annotated schema from the atom</span> <span class="cwebmacronumber">5.1</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Stage 2: expand that schema to the output stream</span> <span class="cwebmacronumber">5.2</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::Compile::emit is used in 12/dtd (<a href="12-dtd.html#SP11">&#167;11</a>), 12/cdp (<a href="12-cdp.html#SP2_1_6_1_2_3_2">&#167;2.1.6.1.2.3.2</a>, <a href="12-cdp.html#SP2_1_6_1_2_3_4">&#167;2.1.6.1.2.3.4</a>).</p>

<p class="endnote">The function Calculus::Atoms::Compile::compile is used in 12/dtd (<a href="12-dtd.html#SP8">&#167;8</a>).</p>

<p class="inwebparagraph"><a id="SP5_1"></a><b>&#167;5.1. Stage 1. </b></p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Stage 1: make an annotated schema from the atom</span> <span class="cwebmacronumber">5.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">asch</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::Compile::i6_schema_of_atom</span><span class="plain">(&amp;</span><span class="identifier">sch</span><span class="plain">, </span><span class="identifier">pl</span><span class="plain">, </span><span class="identifier">task</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">asch</span><span class="element">.schema</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> == 0)</span>
                &lt;<span class="cwebmacro">Issue a fallback problem message, since the schema-maker evidently didn't</span> <span class="cwebmacronumber">5.1.1</span>&gt;<span class="character">;</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        &lt;<span class="cwebmacro">Reject all discussion of the action variables in the past tense</span> <span class="cwebmacronumber">5.1.2</span>&gt;<span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP5">&#167;5</a>.</p>

<p class="inwebparagraph"><a id="SP5_1_1"></a><b>&#167;5.1.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue a fallback problem message, since the schema-maker evidently didn't</span> <span class="cwebmacronumber">5.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Failed on task: $o\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">pl</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain"> == </span><span class="constant">TEST_ATOM_TASK</span><span class="plain">)</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">),</span>
                <span class="string">"this is not a condition I am able to test"</span><span class="plain">,</span>
                <span class="string">"or at any rate not during play."</span><span class="plain">);</span>
        <span class="reserved">else</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_CantForceRelation</span><span class="plain">),</span>
                <span class="string">"this is not something I can make true with 'now'"</span><span class="plain">,</span>
                <span class="string">"because it is too vague about the underlying cause which would "</span>
                <span class="string">"need to be arranged."</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP5_1">&#167;5.1</a>.</p>

<p class="inwebparagraph"><a id="SP5_1_2"></a><b>&#167;5.1.2.  </b>This is in the user's own best interest.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Reject all discussion of the action variables in the past tense</span> <span class="cwebmacronumber">5.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">asch</span><span class="element">.involves_action_variables</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="functiontext">Frames::used_for_past_tense</span><span class="plain">()) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">suppress_C14ActionVarsPastTense</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">problem_count</span><span class="plain"> == 0)</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_ActionVarsPastTense</span><span class="plain">),</span>
                    <span class="string">"it is misleading to talk about the noun, the second noun "</span>
                    <span class="string">"or the person asked to do something in past tenses"</span><span class="plain">,</span>
                    <span class="string">"because in the past, those were different things and "</span>
                    <span class="string">"people, or may have been nothing at all. Writing "</span>
                    <span class="string">"'if the noun has been unlocked' tends not to do what we "</span>
                    <span class="string">"might hope because the value of 'noun' changes every turn. "</span>
                    <span class="string">"So such conditions are not allowed, although to get around "</span>
                    <span class="string">"this we can instead write 'if we have unlocked the noun', "</span>
                    <span class="string">"which uses a special mechanism to remember everything which "</span>
                    <span class="string">"has happened to every object."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP5_1">&#167;5.1</a>.</p>

<p class="inwebparagraph"><a id="SP5_2"></a><b>&#167;5.2. Stage 2. </b>A valid I6 condition has to be bracketed, so we surround the output with
brackets if testing; and a valid I6 statement has to end with a semicolon,
so we terminate with that if making true or false.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Stage 2: expand that schema to the output stream</span> <span class="cwebmacronumber">5.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">asch</span><span class="element">.negate_schema</span><span class="plain">) {</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">NOT_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="plain">}</span>
        <span class="functiontext">Calculus::Schemas::emit_expand_from_terms</span><span class="plain">(</span><span class="identifier">asch</span><span class="element">.schema</span><span class="plain">, &amp;(</span><span class="identifier">asch</span><span class="element">.pt0</span><span class="plain">), &amp;(</span><span class="identifier">asch</span><span class="element">.pt1</span><span class="plain">), </span><span class="identifier">with_semicolon</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">asch</span><span class="element">.negate_schema</span><span class="plain">) {</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP5">&#167;5</a>.</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Constructing the schema. </b></p>


<pre class="display">
    <span class="reserved">annotated_i6_schema</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::Compile::i6_schema_of_atom</span><span class="plain">(</span><span class="reserved">i6_schema</span><span class="plain"> *</span><span class="identifier">sch</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">pl</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">) {</span>
        <span class="reserved">annotated_i6_schema</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>

        <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">" "</span><span class="plain">); </span>    <span class="comment">a non-NULL return in case problems occur</span>
        <span class="identifier">asch</span><span class="element">.schema</span><span class="plain"> = </span><span class="identifier">sch</span><span class="plain">;</span>
        <span class="identifier">asch</span><span class="element">.negate_schema</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">asch</span><span class="element">.pt0</span><span class="plain"> = </span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]; </span><span class="identifier">asch</span><span class="element">.pt1</span><span class="plain"> = </span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[1];</span>
        <span class="identifier">asch</span><span class="element">.involves_action_variables</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::Compile::atom_involves_action_variables</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">);</span>

        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">CALLED_ATOM</span><span class="plain">: </span>&lt;<span class="cwebmacro">Make an annotated schema for a CALLED atom</span> <span class="cwebmacronumber">6.1</span>&gt;<span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">KIND_ATOM</span><span class="plain">: </span>&lt;<span class="cwebmacro">Make an annotated schema for a KIND atom</span> <span class="cwebmacronumber">6.2</span>&gt;<span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">EVERYWHERE_ATOM</span><span class="plain">: </span>&lt;<span class="cwebmacro">Make an annotated schema for an EVERYWHERE atom</span> <span class="cwebmacronumber">6.3</span>&gt;<span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOWHERE_ATOM</span><span class="plain">: </span>&lt;<span class="cwebmacro">Make an annotated schema for a NOWHERE atom</span> <span class="cwebmacronumber">6.4</span>&gt;<span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">HERE_ATOM</span><span class="plain">: </span>&lt;<span class="cwebmacro">Make an annotated schema for a HERE atom</span> <span class="cwebmacronumber">6.5</span>&gt;<span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">PREDICATE_ATOM</span><span class="plain">:</span>
                <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain">) {</span>
                    <span class="reserved">case</span><span class="plain"> 1: </span>&lt;<span class="cwebmacro">Make an annotated schema for a unary predicate</span> <span class="cwebmacronumber">6.6</span>&gt;<span class="plain">;</span>
                    <span class="reserved">case</span><span class="plain"> 2: </span>&lt;<span class="cwebmacro">Make an annotated schema for a binary predicate</span> <span class="cwebmacronumber">6.7</span>&gt;<span class="plain">;</span>
                <span class="plain">}</span>
        <span class="plain">}</span>

        <span class="identifier">asch</span><span class="element">.schema</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">signal that the atom cannot be compiled simply</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::Compile::i6_schema_of_atom is used in <a href="#SP5_1">&#167;5.1</a>.</p>

<p class="inwebparagraph"><a id="SP6_1"></a><b>&#167;6.1.  </b>We are now able to look at the different types of atom one at a time.
</p>

<p class="inwebparagraph">CALLED atoms cannot be asserted, and to test them, we simply copy the
value into the local variable of the given name. Note then that here
the I6 <code class="display"><span class="extract">=</span></code> (set equal) operator is being used in a condition context:
there's a good chance that the value set is non-zero (since all objects
and enumerated values are non-zero), but it isn't necessarily so &mdash;
in Inform it's legal to quantify over times and truth states, for
instance, where 0 is a legal I6 value. So we use the comma operator
to throw away the result of the assignment, and evaluate the condition
to <code class="display"><span class="extract">true</span></code>.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Make an annotated schema for a CALLED atom</span> <span class="cwebmacronumber">6.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">task</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TEST_ATOM_TASK</span><span class="plain">: {</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::CALLED_get_name</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">);</span>
                <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"(%L=(*1), true)"</span><span class="plain">,</span>
                    <span class="functiontext">LocalVariables::ensure_called_local</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain">));</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">default</span><span class="plain">: </span><span class="identifier">asch</span><span class="element">.schema</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_2"></a><b>&#167;6.2.  </b>In any type-checked proposition, a <code class="display"><span class="extract">KIND</span></code> atom can only exist where it is
always at least sometimes true. In particular, if K is a kind of value, then
the atom K(v) can only exist where v is of that kind of value, so that the
atom is always true when tested. But if K is a kind of object, then K(O)
may occur in the proposition for any object O, where O need not belong
to K at all: so there is something substantive to check, which we do using
the I6 <code class="display"><span class="extract">ofclass</span></code> operator.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Make an annotated schema for a KIND atom</span> <span class="cwebmacronumber">6.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">task</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TEST_ATOM_TASK</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::Compare::lt</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain">, </span><span class="identifier">K_object</span><span class="plain">))</span>
                    <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"*1 ofclass %n"</span><span class="plain">,</span>
                        <span class="functiontext">Kinds::RunTime::I6_classname</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain">));</span>
                <span class="reserved">else</span><span class="plain"> {</span>
                    <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Kinds::get_construct</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain">) == </span><span class="identifier">CON_list_of</span><span class="plain">) &amp;&amp; (</span><span class="identifier">problem_count</span><span class="plain"> == 0)) {</span>
                        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
                        <span class="functiontext">Problems::quote_kind</span><span class="plain">(2, </span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain">);</span>
                        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_CantCheckListContents</span><span class="plain">));</span>
                        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
                            <span class="string">"In %1, you use a list which might or might not match a "</span>
                            <span class="string">"definition requiring %2. But there's no efficient way to "</span>
                            <span class="string">"tell during play whether the list actually contains that, "</span>
                            <span class="string">"without laboriously checking every entry. Because "</span>
                            <span class="string">"in general this would be a bad idea, this usage is "</span>
                            <span class="string">"not allowed."</span><span class="plain">);</span>
                        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
                    <span class="plain">}</span>
                    <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"true"</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOW_ATOM_TRUE_TASK</span><span class="plain">:</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOW_ATOM_FALSE_TASK</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">suppress_C14CantChangeKind</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                    <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_CantChangeKind</span><span class="plain">),</span>
                        <span class="string">"the kind of something is fixed"</span><span class="plain">,</span>
                        <span class="string">"and cannot be changed during play with a 'now'."</span><span class="plain">);</span>
                    <span class="identifier">asch</span><span class="element">.schema</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">" "</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_3"></a><b>&#167;6.3.  </b>An easy case. Note that <code class="display"><span class="extract">FoundEverywhere</span></code> is a template routine existing
to provide a common value of the I6 <code class="display"><span class="extract">found_in</span></code> property &mdash; common that is
to all backdrops which are currently everywhere.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Make an annotated schema for an EVERYWHERE atom</span> <span class="cwebmacronumber">6.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">task</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TEST_ATOM_TASK</span><span class="plain">:</span>
                <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"BackdropEverywhere(*1)"</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOW_ATOM_TRUE_TASK</span><span class="plain">:</span>
                <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"MoveObject(*1, FoundEverywhere); MoveFloatingObjects();"</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOW_ATOM_FALSE_TASK</span><span class="plain">:</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_CantChangeEverywhere</span><span class="plain">),</span>
                    <span class="string">"not being 'everywhere' is not something which can be changed "</span>
                    <span class="string">"during play using 'now'"</span><span class="plain">,</span>
                    <span class="string">"because it's not exact enough about what needs to be done."</span><span class="plain">);</span>
                <span class="identifier">asch</span><span class="element">.schema</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_4"></a><b>&#167;6.4.  </b>And another.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Make an annotated schema for a NOWHERE atom</span> <span class="cwebmacronumber">6.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">task</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TEST_ATOM_TASK</span><span class="plain">:</span>
                <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"LocationOf(*1) == nothing"</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOW_ATOM_TRUE_TASK</span><span class="plain">:</span>
                <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"RemoveFromPlay(*1);"</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOW_ATOM_FALSE_TASK</span><span class="plain">:</span>
                <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"MoveObject(*1, real_location, 1, false);"</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_5"></a><b>&#167;6.5.  </b>And another. (In fact, at present <code class="display"><span class="extract">HERE</span></code> atoms are never included in
propositions to be compiled, so this code is never used.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Make an annotated schema for a HERE atom</span> <span class="cwebmacronumber">6.5</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">task</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TEST_ATOM_TASK</span><span class="plain">:</span>
                <span class="functiontext">Calculus::Schemas::modify</span><span class="plain">(</span><span class="identifier">sch</span><span class="plain">, </span><span class="string">"LocationOf(*1) == location"</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOW_ATOM_TRUE_TASK</span><span class="plain">:</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOW_ATOM_FALSE_TASK</span><span class="plain">:</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">),</span>
                    <span class="string">"being 'here' is not something which can be changed during play"</span><span class="plain">,</span>
                    <span class="string">"so it cannot be brought about or cancelled out with 'now'."</span><span class="plain">);</span>
                <span class="identifier">asch</span><span class="element">.schema</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_6"></a><b>&#167;6.6.  </b>The last unary atom is an adjective, for which we hand over to the general
adjective apparatus.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Make an annotated schema for a unary predicate</span> <span class="cwebmacronumber">6.6</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">atask</span><span class="plain"> = 0; </span>    <span class="comment">redundant assignment to appease <code class="display"><span class="extract">gcc -O2</span></code></span>
        <span class="identifier">adjective_usage</span><span class="plain"> *</span><span class="identifier">tr</span><span class="plain"> = </span><span class="identifier">RETRIEVE_POINTER_adjective_usage</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain">);</span>
        <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain"> = </span><span class="identifier">AdjectiveUsages::get_aph</span><span class="plain">(</span><span class="identifier">tr</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">AdjectiveUsages::get_parity</span><span class="plain">(</span><span class="identifier">tr</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">asch</span><span class="element">.negate_schema</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.constant</span><span class="plain">) &amp;&amp; (</span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.term_checked_as_kind</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">))</span>
            <span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.term_checked_as_kind</span><span class="plain"> = </span><span class="functiontext">Specifications::to_kind</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.constant</span><span class="plain">);</span>

        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">task</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TEST_ATOM_TASK</span><span class="plain">: </span><span class="identifier">atask</span><span class="plain"> = </span><span class="constant">TEST_ADJECTIVE_TASK</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOW_ATOM_TRUE_TASK</span><span class="plain">: </span><span class="identifier">atask</span><span class="plain"> = </span><span class="constant">NOW_ADJECTIVE_TRUE_TASK</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">NOW_ATOM_FALSE_TASK</span><span class="plain">: </span><span class="identifier">atask</span><span class="plain"> = </span><span class="constant">NOW_ADJECTIVE_FALSE_TASK</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>

        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">PREDICATE_CALCULUS_WORKINGS</span><span class="plain">, </span><span class="string">"Unary predicate: $o, on: $u\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">pl</span><span class="plain">, </span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.term_checked_as_kind</span><span class="plain">);</span>
        <span class="identifier">asch</span><span class="element">.schema</span><span class="plain"> = </span><span class="functiontext">Adjectives::Meanings::get_i6_schema</span><span class="plain">(</span><span class="identifier">aph</span><span class="plain">, </span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.term_checked_as_kind</span><span class="plain">, </span><span class="identifier">atask</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_7"></a><b>&#167;6.7.  </b>Delegation is similarly the art of compiling a BP:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Make an annotated schema for a binary predicate</span> <span class="cwebmacronumber">6.7</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain"> = </span><span class="identifier">RETRIEVE_POINTER_binary_predicate</span><span class="plain">(</span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain">);</span>
        <span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp_to_assert</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>

        &lt;<span class="cwebmacro">Undo any functional simplification of the relation</span> <span class="cwebmacronumber">6.7.1</span>&gt;<span class="plain">;</span>
        <span class="identifier">asch</span><span class="element">.schema</span><span class="plain"> = </span><span class="functiontext">BinaryPredicates::get_i6_schema</span><span class="plain">(</span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">bp_to_assert</span><span class="plain">, &amp;</span><span class="identifier">asch</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP6_7_1"></a><b>&#167;6.7.1.  </b>When a relation R(x, y) has been simplified to is(x, f_R(y))
or is(g_R(x), y), it can be tested but not asserted true or false;
we have to re-establish R(x, y) before we can proceed.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Undo any functional simplification of the relation</span> <span class="cwebmacronumber">6.7.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">task</span><span class="plain"> != </span><span class="constant">TEST_ATOM_TASK</span><span class="plain">) &amp;&amp; (</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">R_equality</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.function</span><span class="plain">) {</span>
                <span class="identifier">bp_to_assert</span><span class="plain"> = </span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.function</span><span class="plain">-</span><span class="element">&gt;bp</span><span class="plain">;</span>
                <span class="identifier">asch</span><span class="element">.pt0</span><span class="plain"> = </span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.function</span><span class="plain">-</span><span class="element">&gt;fn_of</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[1]</span><span class="element">.function</span><span class="plain">) {</span>
                <span class="identifier">bp_to_assert</span><span class="plain"> = </span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[1]</span><span class="element">.function</span><span class="plain">-</span><span class="element">&gt;bp</span><span class="plain">;</span>
                <span class="identifier">asch</span><span class="element">.pt1</span><span class="plain"> = </span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[1]</span><span class="element">.function</span><span class="plain">-</span><span class="element">&gt;fn_of</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp_to_assert</span><span class="plain"> == </span><span class="identifier">R_equality</span><span class="plain">)</span>
                <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"contraction of predicate applied to equality"</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp_to_assert</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">bp_to_assert</span><span class="plain"> = </span><span class="identifier">bp</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP6_7">&#167;6.7</a>.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::Compile::atom_involves_action_variables</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">pl</span><span class="plain">) {</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) {</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">operand</span><span class="plain"> = </span><span class="functiontext">Calculus::Terms::constant_underlying</span><span class="plain">(&amp;(</span><span class="identifier">pl</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]));</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">PL::Actions::Patterns::is_an_action_variable</span><span class="plain">(</span><span class="identifier">operand</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::Compile::atom_involves_action_variables is used in <a href="#SP6">&#167;6</a>.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. An unannotated one. </b></p>


<pre class="display">
    <span class="reserved">annotated_i6_schema</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::Compile::blank_asch</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="reserved">annotated_i6_schema</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
        <span class="identifier">asch</span><span class="element">.schema</span><span class="plain"> = </span><span class="functiontext">Calculus::Schemas::new</span><span class="plain">(</span><span class="string">" "</span><span class="plain">);</span>
        <span class="identifier">asch</span><span class="element">.negate_schema</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">asch</span><span class="element">.pt0</span><span class="plain"> = </span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0);</span>
        <span class="identifier">asch</span><span class="element">.pt1</span><span class="plain"> = </span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0);</span>
        <span class="identifier">asch</span><span class="element">.involves_action_variables</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">asch</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Atoms::Compile::blank_asch is used in 6/rlt (<a href="6-rlt.html#SP15_2_2">&#167;15.2.2</a>, <a href="6-rlt.html#SP15_2_3">&#167;15.2.3</a>, <a href="6-rlt.html#SP15_2_4">&#167;15.2.4</a>).</p>

<hr class="tocbar">
<ul class="toc"><li><a href="12-is.html">Back to 'I6 Schemas'</a></li><li><a href="12-dtd.html">Continue with 'Deciding to Defer'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

