<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>10/cad</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '10/teav' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#10">Chapter 10: The S-Parser</a></li><li><b>Type Expressions and Values</b></li></ul><p class="purpose">To parse two forms of noun: a noun phrase in a sentence, and a description of what text can be written in a given situation.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP3">&#167;3. Type expressions</a></li><li><a href="#SP10">&#167;10. Values</a></li><li><a href="#SP14">&#167;14. Variables</a></li><li><a href="#SP21">&#167;21. Table references</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>Inform recognises many noun-like constructions, some of which &mdash; out of a noun
context &mdash; look like adjectives, actions or other excerpts which aren't at all
evidently nouns. These many ways to describe nouns are gathered up into two
central constructions. A "type expression" specifies what sort of excerpt
should appear in a given place, whereas a "value" means anything which
can be a noun phrase for a verb. There is considerable overlap between the
two, but they are not the same.
</p>

<p class="inwebparagraph">The following example sentences have the relevant phrases in bold.
</p>

<blockquote>
    <p>[1] if the idea of the gizmo is {\bf taking the fish}, ...</p>

</blockquote>

<blockquote>
    <p>[2] if there are {\bf three women} in the Nunnery, ...</p>

</blockquote>

<blockquote>
    <p>[3a: as description] Before taking {\bf the harmonium}, ...</p>

</blockquote>

<blockquote>
    <p>[3b: as constant] let X be {\bf the harmonium};</p>

</blockquote>

<blockquote>
    <p>[4] now Y is {\bf the can't reach inside rooms rule};</p>

</blockquote>

<blockquote>
    <p>[5] now Z is {\bf the time of day};</p>

</blockquote>

<blockquote>
    <p>[6] let N be {\bf the number of entries in L};</p>

</blockquote>

<blockquote>
    <p>[7] Understand "turn to [{\bf number}]" as combination-setting.</p>

</blockquote>

<blockquote>
    <p>[8] To repeat until (C - {\bf condition}): ...</p>

</blockquote>

<blockquote>
    <p>[9] The Zeppelin countdown is a {\bf number that varies}.</p>

</blockquote>

<blockquote>
    <p>[10] The little red car is a {\bf vehicle}.</p>

</blockquote>

<blockquote>
    <p>[11] The weight of the Space Shuttle is {\bf 68585 kg}.</p>

</blockquote>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Type expressions. </b>A "type expression" specifies what sort of excerpt of text should appear
in a given context. Sometimes it asks for a particular value, sometimes any
value matching a given description.
</p>

<p class="inwebparagraph">This is a concept which does not exist for conventional programming languages,
which would see it as a sort of half-way position between "value" and
"type". In particular, a "type expression" is used to lay out what a
parameter in a phrase definition should be, though it has other uses elsewhere.
That certainly includes cases which traditional programming languages would
call types, so
</p>

<blockquote>
    <p>To adjust (X - closed door) by (N - number): ...</p>

</blockquote>

<p class="inwebparagraph">includes two type expressions, "closed door" and "number". But a type
expression can also be a constant, which languages like C (for instance) would
consider a value and not a type at all:
</p>

<blockquote>
    <p>To adjust (X - closed door) by (N - 11): ...</p>

</blockquote>

<p class="inwebparagraph">gives a definition to be used only where the second parameter evaluates to
11. In this way any constant value is regarded as being a type &mdash; the narrow
type representing only its own value.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">article</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">-</span><span class="identifier">unarticled</span><span class="plain">&gt; |		==&gt; </span><span class="identifier">RP</span><span class="plain">[2]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">-</span><span class="identifier">unarticled</span><span class="plain">&gt;					==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">-</span><span class="identifier">unarticled</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">-</span><span class="identifier">scope</span><span class="plain">&gt; </span><span class="identifier">variable</span><span class="plain">/</span><span class="identifier">variables</span><span class="plain"> |			==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">-</span><span class="identifier">scope</span><span class="plain">&gt; </span><span class="identifier">that</span><span class="plain">/</span><span class="identifier">which</span><span class="plain"> </span><span class="identifier">vary</span><span class="plain">/</span><span class="identifier">varies</span><span class="plain">	|	==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">&gt; |										==&gt; </span><span class="functiontext">Specifications::from_kind</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1])</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">literal</span><span class="plain">&gt; |									==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">constant</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">&gt; |							==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">description</span><span class="plain">-</span><span class="identifier">uncomposite</span><span class="plain">&gt; |					==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">action</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">&gt; |					==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">description</span><span class="plain">&gt;									==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>Note that a list of adjectives with no noun does not qualify as a type
expression. It looks as if it never should, on the face of it &mdash; "opaque"
does not make clear what kind of object is to be opaque &mdash; but once again we
are up against the problem that Inform needs to allow some slightly noun-like
adjectives. For instance, this:
</p>

<blockquote>
    <p>To adjust (X - scenery): ...</p>

</blockquote>

<p class="inwebparagraph">is allowed even though "scenery" is an adjective in Inform.
</p>

<p class="inwebparagraph">To allow this, we have a minor variation:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">descriptive</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">article</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">descriptive</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">-</span><span class="identifier">unarticled</span><span class="plain">&gt; |		==&gt; </span><span class="identifier">RP</span><span class="plain">[2]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">descriptive</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">-</span><span class="identifier">unarticled</span><span class="plain">&gt;					==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">descriptive</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">-</span><span class="identifier">unarticled</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">desc</span><span class="plain">&gt; |					==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">type</span><span class="plain">-</span><span class="identifier">expression</span><span class="plain">-</span><span class="identifier">unarticled</span><span class="plain">&gt;					==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>And now we parse descriptions of variables such as the one appearing in
</p>

<blockquote>
    <p>To increment (V - existing number variable)</p>

</blockquote>

<p class="inwebparagraph">where &lt;s-variable-scope&gt; matches "existing number variable".
</p>

<p class="inwebparagraph">Note that these forms recurse, so that syntactically we allow "T that
varies" for any type expression T. This would include contradictions in terms
such as "15 that varies" or "number that varies that varies that varies",
but we want to allow the parse here so that a problem message can be issued
higher up in Inform. Ultimately, the text must match &lt;k-kind&gt; in each case.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">-</span><span class="identifier">scope</span><span class="plain">&gt; ::=</span>
        <span class="identifier">global</span><span class="plain"> |										==&gt; </span><span class="functiontext">Specifications::new_new_variable_like</span><span class="plain">(</span><span class="identifier">NULL</span><span class="plain">)</span>
        <span class="identifier">global</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">-</span><span class="identifier">contents</span><span class="plain">&gt; |					==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">-</span><span class="identifier">contents</span><span class="plain">&gt;							==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">-</span><span class="identifier">contents</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">k</span><span class="plain">-</span><span class="identifier">kind</span><span class="plain">&gt; |										==&gt; </span><span class="functiontext">Specifications::new_new_variable_like</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1])</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">literal</span><span class="plain">&gt; |									==&gt; </span>&lt;<span class="cwebmacro">Issue PM_TypeCantVary problem</span> <span class="cwebmacronumber">5.1</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">constant</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">&gt; |							==&gt; </span>&lt;<span class="cwebmacro">Issue PM_TypeCantVary problem</span> <span class="cwebmacronumber">5.1</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">description</span><span class="plain">-</span><span class="identifier">uncomposite</span><span class="plain">&gt; |					==&gt; </span>&lt;<span class="cwebmacro">Issue PM_TypeUnmaintainable problem</span> <span class="cwebmacronumber">5.2</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">description</span><span class="plain">&gt;									==&gt; </span>&lt;<span class="cwebmacro">Issue PM_TypeUnmaintainable problem</span> <span class="cwebmacronumber">5.2</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5_1"></a><b>&#167;5.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_TypeCantVary problem</span> <span class="cwebmacronumber">5.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_TypeCantVary</span><span class="plain">));</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"In %1, '%2' is not a kind of value which a variable can safely have, "</span>
            <span class="string">"as it cannot ever vary."</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::new_new_variable_like</span><span class="plain">(</span><span class="identifier">K_object</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP5">&#167;5</a> (twice).</p>

<p class="inwebparagraph"><a id="SP5_2"></a><b>&#167;5.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_TypeUnmaintainable problem</span> <span class="cwebmacronumber">5.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Problems::quote_source</span><span class="plain">(1, </span><span class="identifier">current_sentence</span><span class="plain">);</span>
        <span class="identifier">Problems::quote_wording</span><span class="plain">(2, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">Problems::Issue::handmade_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_TypeUnmaintainable</span><span class="plain">));</span>
        <span class="identifier">Problems::issue_problem_segment</span><span class="plain">(</span>
            <span class="string">"In %1, '%2' is not a kind of value which a variable can safely have, "</span>
            <span class="string">"as it cannot be guaranteed that the contents will always meet "</span>
            <span class="string">"this criterion."</span><span class="plain">);</span>
        <span class="identifier">Problems::issue_problem_end</span><span class="plain">();</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Specifications::new_new_variable_like</span><span class="plain">(</span><span class="identifier">K_object</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP5">&#167;5</a> (twice).</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>Two pieces of context:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">let_equation_mode</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">probable_noun_phrase_context</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>That's it for type expressions, and we move on to values. There are
three special circumstances in which we parse differently: while we could write
variant grammars for these situations, they would be very large and almost
identical to &lt;s-value&gt; anyway, so instead we simply use &lt;s-value&gt;.
</p>

<p class="inwebparagraph">The following matches only if we are in an equation written out in the phrase:
for example,
</p>

<blockquote>
    <p>let V be given by V = fl;</p>

</blockquote>

<p class="inwebparagraph">As mentioned earlier, this changes our conventions on word-breaking.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">let</span><span class="plain">-</span><span class="reserved">equation</span><span class="plain">-</span><span class="identifier">mode</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> 0 {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">let_equation_mode</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>Next, we are sometimes in a situation where a local variable exists which
can be referred to by a pronoun like "it"; if so, we will enable the use
of possessives like "its" to refer to properties.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">pronoun</span><span class="plain">-</span><span class="identifier">present</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> 0 {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">LocalVariables::is_possessive_form_of_it_enabled</span><span class="plain">()) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>The other possible contexts are where we are expecting a table column or
a property name. This enables us to resolve ambiguities in a helpful way,
but otherwise changes little.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="reserved">table</span><span class="plain">-</span><span class="identifier">column</span><span class="plain">-</span><span class="identifier">expected</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> 0 {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::get_construct</span><span class="plain">(</span><span class="identifier">probable_noun_phrase_context</span><span class="plain">) == </span><span class="identifier">CON_table_column</span><span class="plain">)</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">expected</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> 0 {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Kinds::get_construct</span><span class="plain">(</span><span class="identifier">probable_noun_phrase_context</span><span class="plain">) == </span><span class="identifier">CON_property</span><span class="plain">)</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Values. </b>The boldface terms here are all parsed as values:
</p>

<blockquote>
    <p>{\bf The cat} is in {\bf the bag}. The {\bf time of day} is {\bf 11:10 AM}.</p>

</blockquote>

<blockquote>
    <p>award {\bf six} points;</p>

</blockquote>

<blockquote>
    <p>if {\bf more than three animals} are in {\bf the kennel}, ...</p>

</blockquote>

<p class="inwebparagraph">The sequence here is important, in that it resolves ambiguities:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(b) Variable names have highest priority, in order to allow temporary "let"
names to mask existing meanings.
</li></ul>
<ul class="items"><li>(c) Constants come next: these include literals, but also named constants,
such as names of rooms or things.
</li></ul>
<ul class="items"><li>(d) Equations are an oddball exceptional case, seldom arising.
</li></ul>
<ul class="items"><li>(f) Property names are not constants and, as values, they are usually read
as implicitly referring to a property value of something, not as a reference
to the property itself: thus "description" means the actual description of
some object clear from context, not the description property in the abstract.
</li></ul>
<ul class="items"><li>(g) Table column names present a particular ambiguity arising from tables
which are used to construct instances. In tables like that, the column names
become names of properties owned by those instances; and then there are also
ambiguities like those with property names, as between the column's identity
and the actual contents of the current row.
</li></ul>
<ul class="items"><li>(i) Phrases to decide a value whose wording mimics a property cause trouble.
I sometimes think it would be better to penalise this sort of wording by
treating it badly, but since the Standard Rules are as guilty as anyone else,
Inform instead tries to cope. Here we parse any phrase whose wording doesn't
look like a property lookup in the form "X of Y"; later we will pick up
any phrase whose wording does.
</li></ul>
<ul class="items"><li>(k) Similarly we parse descriptions in two rounds: those referring to
physical objects, and others later on. This is because English tends to give
metaphorically physical names to abstract things: for example, the word
"table" for an array of data. We want to make sure sentences like "The
ball is on the table" are not misread through parsing "table" as the
name of the kind. (Type expressions have the opposite convention: there,
kind names always take priority over mere names of things. See above.)
</li></ul>
<ul class="items"><li>(m) The "member of..." productions are to make it possible to write
description comprehensions without ambiguity or grammatical oddness; for
instance if a "let" name "D" holds a description, it enables us to
write "members of D" instead of just "D", making the wording of some
phrases much more natural. It's the difference between a set and its
membership, which is to say, really just a syntactic difference.
</li></ul>

<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt; ::=</span>
        <span class="plain">( &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt; ) |											==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt; |														==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">W</span><span class="plain">)</span>
        <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="reserved">table</span><span class="plain">-</span><span class="identifier">column</span><span class="plain">-</span><span class="identifier">expected</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">table</span><span class="plain">-</span><span class="identifier">column</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |					==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[2], </span><span class="identifier">W</span><span class="plain">)</span>
        <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">-</span><span class="identifier">expected</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |						==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[2], </span><span class="identifier">W</span><span class="plain">)</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">constant</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">&gt;	|												==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">W</span><span class="plain">)</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">equation</span><span class="plain">-</span><span class="identifier">usage</span><span class="plain">&gt; |												==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |													==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">W</span><span class="plain">)</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">action</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">&gt; |										==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">W</span><span class="plain">)</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">non</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">&gt; |											==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">W</span><span class="plain">)</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">list</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">desc</span><span class="plain">&gt; |										==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">W</span><span class="plain">)</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">purely</span><span class="plain">-</span><span class="identifier">physical</span><span class="plain">-</span><span class="identifier">description</span><span class="plain">&gt; |									==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">W</span><span class="plain">)</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">table</span><span class="plain">-</span><span class="identifier">reference</span><span class="plain">&gt; |												==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">W</span><span class="plain">)</span>
        <span class="identifier">member</span><span class="plain">/</span><span class="identifier">members</span><span class="plain"> </span><span class="identifier">of</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">description</span><span class="plain">&gt; |									==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">W</span><span class="plain">)</span>
        <span class="identifier">member</span><span class="plain">/</span><span class="identifier">members</span><span class="plain"> </span><span class="identifier">of</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">local</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt; |								==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">W</span><span class="plain">)</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">of</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt; |							==&gt; </span>&lt;<span class="cwebmacro">Make a belonging-to-V property</span> <span class="cwebmacronumber">10.2</span>&gt;
        <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">pronoun</span><span class="plain">-</span><span class="identifier">present</span><span class="plain">&gt; &lt;</span><span class="identifier">possessive</span><span class="plain">-</span><span class="identifier">third</span><span class="plain">-</span><span class="identifier">person</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |	==&gt; </span>&lt;<span class="cwebmacro">Make a belonging-to-it property</span> <span class="cwebmacronumber">10.1</span>&gt;
        <span class="identifier">entry</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt; </span><span class="identifier">of</span><span class="plain">/</span><span class="identifier">in</span><span class="plain">/</span><span class="identifier">from</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt; |			==&gt; </span>&lt;<span class="cwebmacro">Make a list entry</span> <span class="cwebmacronumber">10.3</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">description</span><span class="plain">&gt; |													==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">W</span><span class="plain">)</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">table</span><span class="plain">-</span><span class="identifier">column</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; |												==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">W</span><span class="plain">)</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">&gt;													==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">W</span><span class="plain">)</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b></p>


<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">v</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">) {</span>
        <span class="identifier">ParseTree::set_text</span><span class="plain">(</span><span class="identifier">v</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">v</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ExParser::val is used in <a href="#SP10">&#167;10</a>, <a href="#SP12_1">&#167;12.1</a>, <a href="#SP12_2">&#167;12.2</a>, <a href="#SP12_3">&#167;12.3</a>, <a href="#SP10_1">&#167;10.1</a>, <a href="#SP10_2">&#167;10.2</a>, <a href="#SP10_3">&#167;10.3</a>, <a href="#SP14">&#167;14</a>, 10/varc (<a href="10-varc.html#SP7">&#167;7</a>).</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b></p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">equation</span><span class="plain">-</span><span class="identifier">usage</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">let</span><span class="plain">-</span><span class="reserved">equation</span><span class="plain">-</span><span class="identifier">mode</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">plain</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">-</span><span class="identifier">with</span><span class="plain">-</span><span class="identifier">equals</span><span class="plain">&gt; </span><span class="identifier">where</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">plain</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">&gt; |	==&gt; </span>&lt;<span class="cwebmacro">Make an equation</span> <span class="cwebmacronumber">12.1</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt; </span><span class="identifier">where</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">plain</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">&gt; |					==&gt; </span>&lt;<span class="cwebmacro">Make an equation, if the kinds are right</span> <span class="cwebmacronumber">12.2</span>&gt;
        <span class="plain">&lt;</span><span class="reserved">if</span><span class="plain">-</span><span class="identifier">let</span><span class="plain">-</span><span class="reserved">equation</span><span class="plain">-</span><span class="identifier">mode</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">plain</span><span class="plain">-</span><span class="identifier">text</span><span class="plain">-</span><span class="identifier">with</span><span class="plain">-</span><span class="identifier">equals</span><span class="plain">&gt;	==&gt; </span>&lt;<span class="cwebmacro">Make an inline equation</span> <span class="cwebmacronumber">12.3</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP12_1"></a><b>&#167;12.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make an equation</span> <span class="cwebmacronumber">12.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">equation</span><span class="plain"> *</span><span class="identifier">eqn</span><span class="plain"> = </span><span class="functiontext">Equations::new</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">((</span><span class="identifier">parse_node</span><span class="plain"> *) </span><span class="identifier">RP</span><span class="plain">[2]), </span><span class="identifier">TRUE</span><span class="plain">);</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">eq</span><span class="plain"> = </span><span class="functiontext">Rvalues::from_equation</span><span class="plain">(</span><span class="identifier">eqn</span><span class="plain">);</span>
        <span class="functiontext">Equations::set_wherewithal</span><span class="plain">(</span><span class="identifier">eqn</span><span class="plain">, </span><span class="identifier">ParseTree::get_text</span><span class="plain">((</span><span class="identifier">parse_node</span><span class="plain"> *) </span><span class="identifier">RP</span><span class="plain">[3]));</span>
        <span class="functiontext">Equations::declare_local_variables</span><span class="plain">(</span><span class="identifier">eqn</span><span class="plain">);</span>
        <span class="functiontext">Equations::examine</span><span class="plain">(</span><span class="identifier">eqn</span><span class="plain">);</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">eq</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP12_2"></a><b>&#167;12.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make an equation, if the kinds are right</span> <span class="cwebmacronumber">12.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="reserved">if</span><span class="plain"> (!(</span><span class="functiontext">Rvalues::is_CONSTANT_of_kind</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">K_equation</span><span class="plain">))) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">eq</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">;</span>
        <span class="reserved">equation</span><span class="plain"> *</span><span class="identifier">eqn</span><span class="plain"> = </span><span class="functiontext">Rvalues::to_equation</span><span class="plain">(</span><span class="identifier">eq</span><span class="plain">);</span>
        <span class="functiontext">Equations::set_usage_notes</span><span class="plain">(</span><span class="identifier">eqn</span><span class="plain">, </span><span class="identifier">ParseTree::get_text</span><span class="plain">((</span><span class="identifier">parse_node</span><span class="plain"> *) </span><span class="identifier">RP</span><span class="plain">[2]));</span>
        <span class="functiontext">Equations::declare_local_variables</span><span class="plain">(</span><span class="identifier">eqn</span><span class="plain">);</span>
        <span class="functiontext">Equations::examine</span><span class="plain">(</span><span class="identifier">eqn</span><span class="plain">);</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">eq</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP12_3"></a><b>&#167;12.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make an inline equation</span> <span class="cwebmacronumber">12.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">equation</span><span class="plain"> *</span><span class="identifier">eqn</span><span class="plain"> = </span><span class="functiontext">Equations::new</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">((</span><span class="identifier">parse_node</span><span class="plain"> *) </span><span class="identifier">RP</span><span class="plain">[2]), </span><span class="identifier">TRUE</span><span class="plain">);</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">eq</span><span class="plain"> = </span><span class="functiontext">Rvalues::from_equation</span><span class="plain">(</span><span class="identifier">eqn</span><span class="plain">);</span>
        <span class="functiontext">Equations::declare_local_variables</span><span class="plain">(</span><span class="identifier">eqn</span><span class="plain">);</span>
        <span class="functiontext">Equations::examine</span><span class="plain">(</span><span class="identifier">eqn</span><span class="plain">);</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">eq</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>

</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP12">&#167;12</a>.</p>

<p class="inwebparagraph"><a id="SP10_1"></a><b>&#167;10.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make a belonging-to-it property</span> <span class="cwebmacronumber">10.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">lvspec</span><span class="plain"> =</span>
            <span class="functiontext">Lvalues::new_LOCAL_VARIABLE</span><span class="plain">(</span><span class="identifier">EMPTY_WORDING</span><span class="plain">,</span>
                <span class="functiontext">LocalVariables::it_variable</span><span class="plain">());</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">val</span><span class="plain"> = </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">lvspec</span><span class="plain">, </span><span class="identifier">EMPTY_WORDING</span><span class="plain">);</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="functiontext">ExParser::p_o_val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[3], </span><span class="identifier">val</span><span class="plain">), </span><span class="identifier">W</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP10">&#167;10</a>.</p>

<p class="inwebparagraph"><a id="SP10_2"></a><b>&#167;10.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make a belonging-to-V property</span> <span class="cwebmacronumber">10.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="functiontext">ExParser::p_o_val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">RP</span><span class="plain">[2]), </span><span class="identifier">W</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP10">&#167;10</a>.</p>

<p class="inwebparagraph"><a id="SP10_3"></a><b>&#167;10.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make a list entry</span> <span class="cwebmacronumber">10.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">val</span><span class="plain"> = </span><span class="functiontext">Lvalues::new_LIST_ENTRY</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[2], </span><span class="identifier">RP</span><span class="plain">[1]);</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">val</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP10">&#167;10</a>.</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b></p>


<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">ExParser::p_o_val</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">A</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">B</span><span class="plain">) {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pts</span><span class="plain"> =</span>
            <span class="plain">(</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">A</span><span class="plain">) == </span><span class="constant">UNKNOWN_NT</span><span class="plain">) ?</span>
                <span class="functiontext">Specifications::new_UNKNOWN</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">A</span><span class="plain">)) :</span>
                <span class="identifier">A</span><span class="plain">;</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">vts</span><span class="plain"> = </span><span class="identifier">B</span><span class="plain">;</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Lvalues::new_PROPERTY_VALUE</span><span class="plain">(</span><span class="identifier">pts</span><span class="plain">, </span><span class="identifier">vts</span><span class="plain">);</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">A</span><span class="plain">);</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">VW</span><span class="plain"> = </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">B</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">PW</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">VW</span><span class="plain">))) {</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">MW</span><span class="plain"> = </span><span class="identifier">PW</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">MW</span><span class="plain">) &gt; </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">VW</span><span class="plain">))</span>
                <span class="identifier">MW</span><span class="plain"> = </span><span class="identifier">Wordings::from</span><span class="plain">(</span><span class="identifier">MW</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">VW</span><span class="plain">));</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">MW</span><span class="plain">) &lt; </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">VW</span><span class="plain">))</span>
                <span class="identifier">MW</span><span class="plain"> = </span><span class="identifier">Wordings::up_to</span><span class="plain">(</span><span class="identifier">MW</span><span class="plain">, </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">VW</span><span class="plain">));</span>
            <span class="identifier">ParseTree::set_text</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">MW</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">spec</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ExParser::p_o_val is used in <a href="#SP10_1">&#167;10.1</a>, <a href="#SP10_2">&#167;10.2</a>.</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Variables. </b>Internally there
are three sources of these: locals, defined by "let" or "repeat" phrases;
stacked variables, which belong to rulebooks, actions or activities; and
global variables. The narrower in scope take priority over the broader: so
if there are both local and global variables called "grand total", then
the text "grand total" is parsed as the local.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">definite</span><span class="plain">-</span><span class="identifier">article</span><span class="plain">&gt; &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt; |				==&gt; </span><span class="identifier">RP</span><span class="plain">[2]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">local</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt; |							==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">stacked</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt; |							==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">global</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt;								==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">nonglobal</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt; ::=</span>
        <span class="plain">( &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">nonglobal</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt; ) |					==&gt; </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">local</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt; |							==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">W</span><span class="plain">)</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">stacked</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt;							==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">W</span><span class="plain">)</span>

    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt;									==&gt; </span><span class="functiontext">ExParser::val</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1], </span><span class="identifier">W</span><span class="plain">)</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b>This requires three internals:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">local</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="reserved">local_variable</span><span class="plain"> *</span><span class="identifier">lvar</span><span class="plain"> = </span><span class="functiontext">LocalVariables::parse</span><span class="plain">(</span><span class="functiontext">Frames::current_stack_frame</span><span class="plain">(), </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">lvar</span><span class="plain">) {</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Lvalues::new_LOCAL_VARIABLE</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">lvar</span><span class="plain">);</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16.  </b>And similarly:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">stacked</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="reserved">ph_stack_frame</span><span class="plain"> *</span><span class="identifier">phsf</span><span class="plain"> = </span><span class="functiontext">Frames::current_stack_frame</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">phsf</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">stacked_variable</span><span class="plain"> *</span><span class="identifier">stv</span><span class="plain"> = </span><span class="functiontext">StackedVariables::parse_from_owner_list</span><span class="plain">(</span>
            <span class="functiontext">Frames::get_stvol</span><span class="plain">(), </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">stv</span><span class="plain">) {</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Lvalues::new_actual_NONLOCAL_VARIABLE</span><span class="plain">(</span>
                <span class="functiontext">StackedVariables::get_variable</span><span class="plain">(</span><span class="identifier">stv</span><span class="plain">));</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17.  </b>And:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">global</span><span class="plain">-</span><span class="identifier">variable</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">ExParser::parse_excerpt</span><span class="plain">(</span><span class="constant">VARIABLE_MC</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">) { *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">; }</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18.  </b>As noted above, we want to parse phrases containing "of" cautiously in
cases where the excerpt being parsed looks as if it might be a property
rather than use of a phrase. Here's how we tell whether it looks that way:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">-</span><span class="identifier">shape</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">of</span><span class="plain"> ...</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19.  </b>We implement this by telling the excerpt parser, temporarily, not to match
anything including the word "of":
</p>


<pre class="display">
    <span class="identifier">vocabulary_entry</span><span class="plain"> *</span><span class="identifier">property_word_to_suppress</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP20"></a><b>&#167;20.  </b>And here are the relevant internals:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">-</span><span class="identifier">non</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Articles::remove_the</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">vocabulary_entry</span><span class="plain"> *</span><span class="identifier">suppression</span><span class="plain"> = </span><span class="identifier">word_to_suppress_in_phrases</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">-</span><span class="identifier">shape</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">property_word_to_suppress</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)</span>
                <span class="identifier">property_word_to_suppress</span><span class="plain"> = </span><span class="identifier">Preform::Nonparsing::word</span><span class="plain">(&lt;</span><span class="reserved">property</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">-</span><span class="identifier">shape</span><span class="plain">&gt;, 0);</span>
            <span class="identifier">word_to_suppress_in_phrases</span><span class="plain"> = </span><span class="identifier">property_word_to_suppress</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">ExParser::parse_excerpt</span><span class="plain">(</span><span class="constant">VALUE_PHRASE_MC</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">word_to_suppress_in_phrases</span><span class="plain"> = </span><span class="identifier">suppression</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">) {</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">ParseTree::new_with_words</span><span class="plain">(</span><span class="constant">PHRASE_TO_DECIDE_VALUE_NT</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
            <span class="functiontext">ExParser::add_ilist</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">);</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="reserved">phrase</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Articles::remove_the</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">ExParser::parse_excerpt</span><span class="plain">(</span><span class="constant">VALUE_PHRASE_MC</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">) {</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">ParseTree::new_with_words</span><span class="plain">(</span><span class="constant">PHRASE_TO_DECIDE_VALUE_NT</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">);</span>
            <span class="functiontext">ExParser::add_ilist</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">);</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP21"></a><b>&#167;21. Table references. </b>Table references come in five different forms:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(a) For instance, "atomic number entry", meaning the entry in that column
and implicitly in the table and row currently selected.
</li><li>(b) For instance, "atomic number in row 4 of the Table of Elements".
</li><li>(c) For instance, "an atomic number listed in the Table of Elements" in the
sentence "if 101 is an atomic number listed in the Table of Elements". This
is part of a condition, and can't evaluate.
</li><li>(d) For instance, "atomic weight corresponding to an atomic number of 57 in
the Table of Elements".
</li><li>(e) For instance, "atomic weight of 20 in the Table of Elements" in the
sentence "if there is an atomic weight of 20 in the Table of Elements".
Again, this is part of a condition, and can't evaluate.
</li></ul>

<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">table</span><span class="plain">-</span><span class="identifier">reference</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">table</span><span class="plain">-</span><span class="identifier">column</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">entry</span><span class="plain"> |																				==&gt; </span>&lt;<span class="cwebmacro">Make table entry value</span> <span class="cwebmacronumber">21.1</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">table</span><span class="plain">-</span><span class="identifier">column</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">in</span><span class="plain"> </span><span class="identifier">row</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt; </span><span class="identifier">of</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt; |										==&gt; </span>&lt;<span class="cwebmacro">Make table in row of value</span> <span class="cwebmacronumber">21.2</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">table</span><span class="plain">-</span><span class="identifier">column</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">listed</span><span class="plain"> </span><span class="identifier">in</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt; |														==&gt; </span>&lt;<span class="cwebmacro">Make table listed in value</span> <span class="cwebmacronumber">21.3</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">table</span><span class="plain">-</span><span class="identifier">column</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">corresponding</span><span class="plain"> </span><span class="identifier">to</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">table</span><span class="plain">-</span><span class="identifier">column</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">of</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt; </span><span class="identifier">in</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt; |	==&gt; </span>&lt;<span class="cwebmacro">Make table corresponding to value</span> <span class="cwebmacronumber">21.4</span>&gt;
        <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="reserved">table</span><span class="plain">-</span><span class="identifier">column</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">of</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt; </span><span class="identifier">in</span><span class="plain"> &lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">-</span><span class="identifier">uncached</span><span class="plain">&gt;											==&gt; </span>&lt;<span class="cwebmacro">Make table of in value</span> <span class="cwebmacronumber">21.5</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP21_1"></a><b>&#167;21.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make table entry value</span> <span class="cwebmacronumber">21.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Lvalues::new_TABLE_ENTRY</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">spec</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">LocalVariables::are_we_using_table_lookup</span><span class="plain">() == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">problem_count</span><span class="plain"> == 0)) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_NoRowSelected</span><span class="plain">),</span>
                <span class="string">"no row seems to have been chosen at this point"</span><span class="plain">,</span>
                <span class="string">"so it doesn't make sense to talk about the entries "</span>
                <span class="string">"within it. (By 'at this point', I mean the point "</span>
                <span class="string">"when the table will have to be looked at. This "</span>
                <span class="string">"might be at another time altogether if we are "</span>
                <span class="string">"storing away instructions for later in a text "</span>
                <span class="string">"substitution, e.g., writing 'now the description "</span>
                <span class="string">"of the player is \</span><span class="plain">"</span><span class="string">Thoroughly [vanity entry].\</span><span class="plain">"</span><span class="string">;' "</span>
                <span class="string">"- remember that the substitution is acted on "</span>
                <span class="string">"when the text is printed, which could be at any "</span>
                <span class="string">"time, and no row will be chosen then.)"</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP21">&#167;21</a>.</p>

<p class="inwebparagraph"><a id="SP21_2"></a><b>&#167;21.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make table in row of value</span> <span class="cwebmacronumber">21.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Lvalues::new_TABLE_ENTRY</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">spec</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> = </span><span class="functiontext">ExParser::arg</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1]);</span>
        <span class="identifier">spec</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="functiontext">ExParser::arg</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[2]);</span>
        <span class="identifier">spec</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="functiontext">ExParser::arg</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[3]);</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP21">&#167;21</a>.</p>

<p class="inwebparagraph"><a id="SP21_3"></a><b>&#167;21.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make table listed in value</span> <span class="cwebmacronumber">21.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Lvalues::new_TABLE_ENTRY</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">spec</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> = </span><span class="functiontext">ExParser::arg</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1]);</span>
        <span class="identifier">spec</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="functiontext">ExParser::arg</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[2]);</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP21">&#167;21</a>.</p>

<p class="inwebparagraph"><a id="SP21_4"></a><b>&#167;21.4.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make table corresponding to value</span> <span class="cwebmacronumber">21.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Lvalues::new_TABLE_ENTRY</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">spec</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> = </span><span class="functiontext">ExParser::arg</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1]);</span>
        <span class="identifier">spec</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="functiontext">ExParser::arg</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[2]);</span>
        <span class="identifier">spec</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="functiontext">ExParser::arg</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[3]);</span>
        <span class="identifier">spec</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="functiontext">ExParser::arg</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[4]);</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP21">&#167;21</a>.</p>

<p class="inwebparagraph"><a id="SP21_5"></a><b>&#167;21.5.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make table of in value</span> <span class="cwebmacronumber">21.5</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">Lvalues::new_TABLE_ENTRY</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">spec</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> = </span><span class="functiontext">ExParser::arg</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1]);</span>
        <span class="identifier">spec</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="functiontext">ExParser::arg</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1]);</span>
        <span class="identifier">spec</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="functiontext">ExParser::arg</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[2]);</span>
        <span class="identifier">spec</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="functiontext">ExParser::arg</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[3]);</span>
        <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">spec</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP21">&#167;21</a>.</p>

<p class="inwebparagraph"><a id="SP22"></a><b>&#167;22.  </b></p>


<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">ExParser::arg</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">val</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">val</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Specifications::new_UNKNOWN</span><span class="plain">(</span><span class="identifier">EMPTY_WORDING</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">ParseTree::duplicate</span><span class="plain">(</span><span class="identifier">val</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function ExParser::arg is used in <a href="#SP21_2">&#167;21.2</a>, <a href="#SP21_3">&#167;21.3</a>, <a href="#SP21_4">&#167;21.4</a>, <a href="#SP21_5">&#167;21.5</a>.</p>

<p class="inwebparagraph"><a id="SP23"></a><b>&#167;23.  </b>Action patterns, such as "taking a container" or "opening a closed door",
are parsed by code in the chapter on Actions; all we do here is to wrap the
result.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">s</span><span class="plain">-</span><span class="identifier">action</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">-</span><span class="identifier">as</span><span class="plain">-</span><span class="identifier">value</span><span class="plain">&gt; </span><span class="identifier">internal</span><span class="plain"> {</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::mismatched_brackets</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Lexer::word</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) == </span><span class="identifier">OPENBRACE_V</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">pto</span><span class="plain"> = </span><span class="identifier">permit_trying_omission</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">definite</span><span class="plain">-</span><span class="identifier">article</span><span class="plain">&gt;(</span><span class="identifier">Wordings::first_word</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">permit_trying_omission</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">r</span><span class="plain"> = &lt;</span><span class="identifier">action</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="identifier">permit_trying_omission</span><span class="plain"> = </span><span class="identifier">pto</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">r</span><span class="plain">) {</span>
            <span class="identifier">action_pattern</span><span class="plain"> *</span><span class="identifier">ap</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">ap</span><span class="plain">-&gt;</span><span class="identifier">actor_spec</span><span class="plain">) &amp;&amp;</span>
                <span class="plain">(</span><span class="functiontext">Dash::validate_parameter</span><span class="plain">(</span><span class="identifier">ap</span><span class="plain">-&gt;</span><span class="identifier">actor_spec</span><span class="plain">, </span><span class="identifier">K_person</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
                <span class="identifier">r</span><span class="plain"> = &lt;</span><span class="identifier">action</span><span class="plain">-</span><span class="identifier">pattern</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">r</span><span class="plain">) {</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">Conditions::new_TEST_ACTION</span><span class="plain">(&lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;, </span><span class="identifier">W</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="10-cad.html">Back to 'Constants and Descriptions'</a></li><li><a href="10-varc.html">Continue with 'Verbal and Relative Clauses'</a></li></ul><hr class="tocbar">
<!--End of weave: 562 lines from a web of 94125-->
	</body>
</html>

