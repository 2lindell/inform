<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Type Expressions and Values</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Preform-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../compiler.html">compiler tools</a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul><h2>Compiler Webs</h2><ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul><h2>Inbuild Modules</h2><ul>
<li><a href="../supervisor-module/index.html">supervisor</a></li>
</ul><h2>Inform7 Modules</h2><ul>
<li><a href="index.html"><span class="selectedlink">core</span></a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul><h2>Inter Modules</h2><ul>
<li><a href="../bytecode-module/index.html">bytecode</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul><h2>Services</h2><ul>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../html-module/index.html">html</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Type Expressions and Values' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../compiler.html">Inform7 Modules</a></li><li><a href="index.html">core</a></li><li><a href="index.html#10">Chapter 10: The S-Parser</a></li><li><b>Type Expressions and Values</b></li></ul></div>
<p class="purpose">To parse two forms of noun: a noun phrase in a sentence, and a description of what text can be written in a given situation.</p>

<ul class="toc"><li><a href="10-teav.html#SP1">&#167;1. Definitions</a></li><li><a href="10-teav.html#SP3">&#167;3. Type expressions</a></li><li><a href="10-teav.html#SP10">&#167;10. Values</a></li><li><a href="10-teav.html#SP14">&#167;14. Variables</a></li><li><a href="10-teav.html#SP21">&#167;21. Table references</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="commentary firstcommentary"><a id="SP2"></a><b>&#167;2.  </b>Inform recognises many noun-like constructions, some of which &mdash; out of a noun
context &mdash; look like adjectives, actions or other excerpts which aren't at all
evidently nouns. These many ways to describe nouns are gathered up into two
central constructions. A "type expression" specifies what sort of excerpt
should appear in a given place, whereas a "value" means anything which
can be a noun phrase for a verb. There is considerable overlap between the
two, but they are not the same.
</p>

<p class="commentary">The following example sentences have the relevant phrases in bold.
</p>

<blockquote>
    <p>[1] if the idea of the gizmo is {\bf taking the fish}, ...</p>
</blockquote>

<blockquote>
    <p>[2] if there are {\bf three women} in the Nunnery, ...</p>
</blockquote>

<blockquote>
    <p>[3a: as description] Before taking {\bf the harmonium}, ...</p>
</blockquote>

<blockquote>
    <p>[3b: as constant] let X be {\bf the harmonium};</p>
</blockquote>

<blockquote>
    <p>[4] now Y is {\bf the can't reach inside rooms rule};</p>
</blockquote>

<blockquote>
    <p>[5] now Z is {\bf the time of day};</p>
</blockquote>

<blockquote>
    <p>[6] let N be {\bf the number of entries in L};</p>
</blockquote>

<blockquote>
    <p>[7] Understand "turn to [{\bf number}]" as combination-setting.</p>
</blockquote>

<blockquote>
    <p>[8] To repeat until (C - {\bf condition}): ...</p>
</blockquote>

<blockquote>
    <p>[9] The Zeppelin countdown is a {\bf number that varies}.</p>
</blockquote>

<blockquote>
    <p>[10] The little red car is a {\bf vehicle}.</p>
</blockquote>

<blockquote>
    <p>[11] The weight of the Space Shuttle is {\bf 68585 kg}.</p>
</blockquote>

<p class="commentary firstcommentary"><a id="SP3"></a><b>&#167;3. Type expressions. </b>A "type expression" specifies what sort of excerpt of text should appear
in a given context. Sometimes it asks for a particular value, sometimes any
value matching a given description.
</p>

<p class="commentary">This is a concept which does not exist for conventional programming languages,
which would see it as a sort of half-way position between "value" and
"type". In particular, a "type expression" is used to lay out what a
parameter in a phrase definition should be, though it has other uses elsewhere.
That certainly includes cases which traditional programming languages would
call types, so
</p>

<blockquote>
    <p>To adjust (X - closed door) by (N - number): ...</p>
</blockquote>

<p class="commentary">includes two type expressions, "closed door" and "number". But a type
expression can also be a constant, which languages like C (for instance) would
consider a value and not a type at all:
</p>

<blockquote>
    <p>To adjust (X - closed door) by (N - 11): ...</p>
</blockquote>

<p class="commentary">gives a definition to be used only where the second parameter evaluates to
11. In this way any constant value is regarded as being a type &mdash; the narrow
type representing only its own value.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-type-expression-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-type-expression-unarticled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">   </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 2 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-type-expression-unarticled&gt;</span><span class="Preform-plain-syntax">               </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>

<span class="Preform-function-syntax">&lt;s-type-expression-unarticled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-variable-scope&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">variable/variables</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">      </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-variable-scope&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">that/which</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">vary/varies</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;k-kind&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                   </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Specifications::from_kind(RP[1]) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-literal&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-constant-value&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                         </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-description-uncomposite&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-action-pattern-as-value&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-description&gt;</span><span class="Preform-plain-syntax">                              </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP4"></a><b>&#167;4.  </b>Note that a list of adjectives with no noun does not qualify as a type
expression. It looks as if it never should, on the face of it &mdash; "opaque"
does not make clear what kind of object is to be opaque &mdash; but once again we
are up against the problem that Inform needs to allow some slightly noun-like
adjectives. For instance, this:
</p>

<blockquote>
    <p>To adjust (X - scenery): ...</p>
</blockquote>

<p class="commentary">is allowed even though "scenery" is an adjective in Inform.
</p>

<p class="commentary">To allow this, we have a minor variation:
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-descriptive-type-expression-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-descriptive-type-expression-unarticled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 2 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-descriptive-type-expression-unarticled&gt;</span><span class="Preform-plain-syntax">              </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>

<span class="Preform-function-syntax">&lt;s-descriptive-type-expression-unarticled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-adjective-list-as-desc&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-type-expression-unarticled&gt;</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP5"></a><b>&#167;5.  </b>And now we parse descriptions of variables such as the one appearing in
</p>

<blockquote>
    <p>To increment (V - existing number variable)</p>
</blockquote>

<p class="commentary">where &lt;s-variable-scope&gt; matches "existing number variable".
</p>

<p class="commentary">Note that these forms recurse, so that syntactically we allow "T that
varies" for any type expression T. This would include contradictions in terms
such as "15 that varies" or "number that varies that varies that varies",
but we want to allow the parse here so that a problem message can be issued
higher up in Inform. Ultimately, the text must match &lt;k-kind&gt; in each case.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-variable-scope&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">global</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                        </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Specifications::new_new_variable_like(NULL) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">global</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-variable-contents&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-variable-contents&gt;</span><span class="Preform-plain-syntax">           </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>

<span class="Preform-function-syntax">&lt;s-variable-contents&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;k-kind&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                      </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, Specifications::new_new_variable_like(RP[1]) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-literal&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                   </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-teav.html#SP5_1" class="named-paragraph-link"><span class="named-paragraph">Issue PM_TypeCantVary problem</span><span class="named-paragraph-number">5.1</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-constant-value&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">            </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-teav.html#SP5_1" class="named-paragraph-link"><span class="named-paragraph">Issue PM_TypeCantVary problem</span><span class="named-paragraph-number">5.1</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-description-uncomposite&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">   </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-teav.html#SP5_2" class="named-paragraph-link"><span class="named-paragraph">Issue PM_TypeUnmaintainable problem</span><span class="named-paragraph-number">5.2</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-description&gt;</span><span class="Preform-plain-syntax">                 </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-teav.html#SP5_2" class="named-paragraph-link"><span class="named-paragraph">Issue PM_TypeUnmaintainable problem</span><span class="named-paragraph-number">5.2</span></a></span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP5_1"></a><b>&#167;5.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue PM_TypeCantVary problem</span><span class="named-paragraph-number">5.1</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::quote_source</span><span class="plain-syntax">(1, </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::quote_wording</span><span class="plain-syntax">(2, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::handmade_problem</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_TypeCantVary</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::issue_problem_segment</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="string-syntax">"In %1, '%2' is not a kind of value which a variable can safely have, "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"as it cannot ever vary."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::issue_problem_end</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    ==&gt; { -, </span><a href="14-sp.html#SP5" class="function-link"><span class="function-syntax">Specifications::new_new_variable_like</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">K_object</span><span class="plain-syntax">) };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-teav.html#SP5">&#167;5</a> (twice).</li></ul>
<p class="commentary firstcommentary"><a id="SP5_2"></a><b>&#167;5.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue PM_TypeUnmaintainable problem</span><span class="named-paragraph-number">5.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::quote_source</span><span class="plain-syntax">(1, </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::quote_wording</span><span class="plain-syntax">(2, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::handmade_problem</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_TypeUnmaintainable</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::issue_problem_segment</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="string-syntax">"In %1, '%2' is not a kind of value which a variable can safely have, "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"as it cannot be guaranteed that the contents will always meet "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"this criterion."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Problems::issue_problem_end</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    ==&gt; { -, </span><a href="14-sp.html#SP5" class="function-link"><span class="function-syntax">Specifications::new_new_variable_like</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">K_object</span><span class="plain-syntax">) };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-teav.html#SP5">&#167;5</a> (twice).</li></ul>
<p class="commentary firstcommentary"><a id="SP6"></a><b>&#167;6.  </b>Two pieces of context:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">let_equation_mode</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">probable_noun_phrase_context</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP7"></a><b>&#167;7.  </b>That's it for type expressions, and we move on to values. There are
three special circumstances in which we parse differently: while we could write
variant grammars for these situations, they would be very large and almost
identical to &lt;s-value&gt; anyway, so instead we simply use &lt;s-value&gt;.
</p>

<p class="commentary">The following matches only if we are in an equation written out in the phrase:
for example,
</p>

<blockquote>
    <p>let V be given by V = fl;</p>
</blockquote>

<p class="commentary">As mentioned earlier, this changes our conventions on word-breaking.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;if-let-equation-mode&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">0</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">let_equation_mode</span><span class="Preform-plain-syntax">) </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP8"></a><b>&#167;8.  </b>Next, we are sometimes in a situation where a local variable exists which
can be referred to by a pronoun like "it"; if so, we will enable the use
of possessives like "its" to refer to properties.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;if-pronoun-present&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">0</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><a href="24-lv.html#SP27" class="function-link"><span class="Preform-function-syntax">LocalVariables::is_possessive_form_of_it_enabled</span></a><span class="Preform-plain-syntax">()) </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP9"></a><b>&#167;9.  </b>The other possible contexts are where we are expecting a table column or
a property name. This enables us to resolve ambiguities in a helpful way,
but otherwise changes little.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;if-table-column-expected&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">0</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">Kinds::get_construct</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">probable_noun_phrase_context</span><span class="Preform-plain-syntax">) == </span><span class="Preform-identifier-syntax">CON_table_column</span><span class="Preform-plain-syntax">)</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>

<span class="Preform-function-syntax">&lt;if-property-name-expected&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">0</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">Kinds::get_construct</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">probable_noun_phrase_context</span><span class="Preform-plain-syntax">) == </span><span class="Preform-identifier-syntax">CON_property</span><span class="Preform-plain-syntax">)</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP10"></a><b>&#167;10. Values. </b>The boldface terms here are all parsed as values:
</p>

<blockquote>
    <p>{\bf The cat} is in {\bf the bag}. The {\bf time of day} is {\bf 11:10 AM}.</p>
</blockquote>

<blockquote>
    <p>award {\bf six} points;</p>
</blockquote>

<blockquote>
    <p>if {\bf more than three animals} are in {\bf the kennel}, ...</p>
</blockquote>

<p class="commentary">The sequence here is important, in that it resolves ambiguities:
</p>

<ul class="items"><li>(b) Variable names have highest priority, in order to allow temporary "let"
names to mask existing meanings.
</li><li>(c) Constants come next: these include literals, but also named constants,
such as names of rooms or things.
</li><li>(d) Equations are an oddball exceptional case, seldom arising.
</li><li>(f) Property names are not constants and, as values, they are usually read
as implicitly referring to a property value of something, not as a reference
to the property itself: thus "description" means the actual description of
some object clear from context, not the description property in the abstract.
</li><li>(g) Table column names present a particular ambiguity arising from tables
which are used to construct instances. In tables like that, the column names
become names of properties owned by those instances; and then there are also
ambiguities like those with property names, as between the column's identity
and the actual contents of the current row.
</li><li>(i) Phrases to decide a value whose wording mimics a property cause trouble.
I sometimes think it would be better to penalise this sort of wording by
treating it badly, but since the Standard Rules are as guilty as anyone else,
Inform instead tries to cope. Here we parse any phrase whose wording doesn't
look like a property lookup in the form "X of Y"; later we will pick up
any phrase whose wording does.
</li><li>(k) Similarly we parse descriptions in two rounds: those referring to
physical objects, and others later on. This is because English tends to give
metaphorically physical names to abstract things: for example, the word
"table" for an array of data. We want to make sure sentences like "The
ball is on the table" are not misread through parsing "table" as the
name of the kind. (Type expressions have the opposite convention: there,
kind names always take priority over mere names of things. See above.)
</li><li>(m) The "member of..." productions are to make it possible to write
description comprehensions without ambiguity or grammatical oddness; for
instance if a "let" name "D" holds a description, it enables us to
write "members of D" instead of just "D", making the wording of some
phrases much more natural. It's the difference between a set and its
membership, which is to say, really just a syntactic difference.
</li></ul>
<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-value-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">(</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-value-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">)</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                            </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-variable&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                                      </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;if-table-column-expected&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-table-column-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[2], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;if-property-name-expected&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-property-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                     </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[2], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-constant-value&gt;</span><span class="Preform-plain-syntax">	</span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                               </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-equation-usage&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                                </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-property-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                                 </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-action-pattern-as-value&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                       </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-value-phrase-non-of&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                           </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-adjective-list-as-desc&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                        </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-purely-physical-description&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                   </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-table-reference&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                               </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">member/members</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">of</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-description&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                 </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">member/members</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">of</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-local-variable&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                              </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-property-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">of</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-value-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                           </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-teav.html#SP10_2" class="named-paragraph-link"><span class="named-paragraph">Make a belonging-to-V property</span><span class="named-paragraph-number">10.2</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;if-pronoun-present&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;possessive-third-person&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-property-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-teav.html#SP10_1" class="named-paragraph-link"><span class="named-paragraph">Make a belonging-to-it property</span><span class="named-paragraph-number">10.1</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">entry</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-value-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">of/in/from</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-value-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">            </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-teav.html#SP10_3" class="named-paragraph-link"><span class="named-paragraph">Make a list entry</span><span class="named-paragraph-number">10.3</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-description&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                                   </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-table-column-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                             </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-value-phrase&gt;</span><span class="Preform-plain-syntax">                                                    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[1], W) }</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP11"></a><b>&#167;11.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">ExParser::val</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">ExParser::val</span></span>:<br/><a href="10-teav.html#SP10">&#167;10</a>, <a href="10-teav.html#SP12_1">&#167;12.1</a>, <a href="10-teav.html#SP12_2">&#167;12.2</a>, <a href="10-teav.html#SP12_3">&#167;12.3</a>, <a href="10-teav.html#SP10_1">&#167;10.1</a>, <a href="10-teav.html#SP10_2">&#167;10.2</a>, <a href="10-teav.html#SP10_3">&#167;10.3</a>, <a href="10-teav.html#SP14">&#167;14</a><br/>Verbal and Relative Clauses - <a href="10-varc.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">v</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">v</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">v</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP12"></a><b>&#167;12.  </b></p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-equation-usage&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;if-let-equation-mode&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-plain-text-with-equals&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">where</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-plain-text&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-teav.html#SP12_1" class="named-paragraph-link"><span class="named-paragraph">Make an equation</span><span class="named-paragraph-number">12.1</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-value-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">where</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-plain-text&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                                 </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-teav.html#SP12_2" class="named-paragraph-link"><span class="named-paragraph">Make an equation, if the kinds are right</span><span class="named-paragraph-number">12.2</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;if-let-equation-mode&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-plain-text-with-equals&gt;</span><span class="Preform-plain-syntax">                         </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-teav.html#SP12_3" class="named-paragraph-link"><span class="named-paragraph">Make an inline equation</span><span class="named-paragraph-number">12.3</span></a></span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP12_1"></a><b>&#167;12.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make an equation</span><span class="named-paragraph-number">12.1</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">equation</span><span class="plain-syntax"> *</span><span class="identifier-syntax">eqn</span><span class="plain-syntax"> = </span><a href="20-eq.html#SP9_1" class="function-link"><span class="function-syntax">Equations::new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">((</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *) </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]), </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">eq</span><span class="plain-syntax"> = </span><a href="14-rv.html#SP1" class="function-link"><span class="function-syntax">Rvalues::from_equation</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">eqn</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="20-eq.html#SP10" class="function-link"><span class="function-syntax">Equations::set_wherewithal</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">eqn</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">((</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *) </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[3]));</span>
<span class="plain-syntax">    </span><a href="20-eq.html#SP19" class="function-link"><span class="function-syntax">Equations::declare_local_variables</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">eqn</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="20-eq.html#SP12" class="function-link"><span class="function-syntax">Equations::examine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">eqn</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    ==&gt; { -, </span><a href="10-teav.html#SP11" class="function-link"><span class="function-syntax">ExParser::val</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">eq</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">) };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-teav.html#SP12">&#167;12</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP12_2"></a><b>&#167;12.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make an equation, if the kinds are right</span><span class="named-paragraph-number">12.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1];</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (!(</span><a href="14-rv.html#SP19" class="function-link"><span class="function-syntax">Rvalues::is_CONSTANT_of_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_equation</span><span class="plain-syntax">))) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">eq</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">equation</span><span class="plain-syntax"> *</span><span class="identifier-syntax">eqn</span><span class="plain-syntax"> = </span><a href="14-rv.html#SP2" class="function-link"><span class="function-syntax">Rvalues::to_equation</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">eq</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="20-eq.html#SP44" class="function-link"><span class="function-syntax">Equations::set_usage_notes</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">eqn</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">((</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *) </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]));</span>
<span class="plain-syntax">    </span><a href="20-eq.html#SP19" class="function-link"><span class="function-syntax">Equations::declare_local_variables</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">eqn</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="20-eq.html#SP12" class="function-link"><span class="function-syntax">Equations::examine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">eqn</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    ==&gt; { -, </span><a href="10-teav.html#SP11" class="function-link"><span class="function-syntax">ExParser::val</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">eq</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">) };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-teav.html#SP12">&#167;12</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP12_3"></a><b>&#167;12.3.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make an inline equation</span><span class="named-paragraph-number">12.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">equation</span><span class="plain-syntax"> *</span><span class="identifier-syntax">eqn</span><span class="plain-syntax"> = </span><a href="20-eq.html#SP9_1" class="function-link"><span class="function-syntax">Equations::new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">((</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *) </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]), </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">eq</span><span class="plain-syntax"> = </span><a href="14-rv.html#SP1" class="function-link"><span class="function-syntax">Rvalues::from_equation</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">eqn</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="20-eq.html#SP19" class="function-link"><span class="function-syntax">Equations::declare_local_variables</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">eqn</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="20-eq.html#SP12" class="function-link"><span class="function-syntax">Equations::examine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">eqn</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    ==&gt; { -, </span><a href="10-teav.html#SP11" class="function-link"><span class="function-syntax">ExParser::val</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">eq</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">) };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-teav.html#SP12">&#167;12</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP10_1"></a><b>&#167;10.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make a belonging-to-it property</span><span class="named-paragraph-number">10.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lvspec</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">        </span><a href="14-lv.html#SP2" class="function-link"><span class="function-syntax">Lvalues::new_LOCAL_VARIABLE</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><a href="24-lv.html#SP26" class="function-link"><span class="function-syntax">LocalVariables::it_variable</span></a><span class="plain-syntax">());</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">val</span><span class="plain-syntax"> = </span><a href="10-teav.html#SP11" class="function-link"><span class="function-syntax">ExParser::val</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">lvspec</span><span class="plain-syntax">, </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    ==&gt; { -, </span><a href="10-teav.html#SP11" class="function-link"><span class="function-syntax">ExParser::val</span></a><span class="plain-syntax">(</span><a href="10-teav.html#SP13" class="function-link"><span class="function-syntax">ExParser::p_o_val</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[3], </span><span class="identifier-syntax">val</span><span class="plain-syntax">), </span><span class="identifier-syntax">W</span><span class="plain-syntax">) };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-teav.html#SP10">&#167;10</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP10_2"></a><b>&#167;10.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make a belonging-to-V property</span><span class="named-paragraph-number">10.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    ==&gt; { -, </span><a href="10-teav.html#SP11" class="function-link"><span class="function-syntax">ExParser::val</span></a><span class="plain-syntax">(</span><a href="10-teav.html#SP13" class="function-link"><span class="function-syntax">ExParser::p_o_val</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]), </span><span class="identifier-syntax">W</span><span class="plain-syntax">) };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-teav.html#SP10">&#167;10</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP10_3"></a><b>&#167;10.3.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make a list entry</span><span class="named-paragraph-number">10.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">val</span><span class="plain-syntax"> = </span><a href="14-lv.html#SP4" class="function-link"><span class="function-syntax">Lvalues::new_LIST_ENTRY</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2], </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">    ==&gt; { -, </span><a href="10-teav.html#SP11" class="function-link"><span class="function-syntax">ExParser::val</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">val</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">) };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-teav.html#SP10">&#167;10</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP13"></a><b>&#167;13.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">ExParser::p_o_val</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">ExParser::p_o_val</span></span>:<br/><a href="10-teav.html#SP10_1">&#167;10.1</a>, <a href="10-teav.html#SP10_2">&#167;10.2</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">B</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pts</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">) == </span><span class="identifier-syntax">UNKNOWN_NT</span><span class="plain-syntax">) ?</span>
<span class="plain-syntax">            </span><a href="14-sp.html#SP8" class="function-link"><span class="function-syntax">Specifications::new_UNKNOWN</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">)) :</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">A</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">vts</span><span class="plain-syntax"> = </span><span class="identifier-syntax">B</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="14-lv.html#SP5" class="function-link"><span class="function-syntax">Lvalues::new_PROPERTY_VALUE</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">pts</span><span class="plain-syntax">, </span><span class="identifier-syntax">vts</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">PW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">VW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">B</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">PW</span><span class="plain-syntax">)) &amp;&amp; (</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">VW</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">MW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">PW</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::first_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">MW</span><span class="plain-syntax">) &gt; </span><span class="identifier-syntax">Wordings::first_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">VW</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">MW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Wordings::from</span><span class="plain-syntax">(</span><span class="identifier-syntax">MW</span><span class="plain-syntax">, </span><span class="identifier-syntax">Wordings::first_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">VW</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::last_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">MW</span><span class="plain-syntax">) &lt; </span><span class="identifier-syntax">Wordings::last_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">VW</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">MW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Wordings::up_to</span><span class="plain-syntax">(</span><span class="identifier-syntax">MW</span><span class="plain-syntax">, </span><span class="identifier-syntax">Wordings::last_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">VW</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">MW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">spec</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP14"></a><b>&#167;14. Variables. </b>Internally there
are three sources of these: locals, defined by "let" or "repeat" phrases;
stacked variables, which belong to rulebooks, actions or activities; and
global variables. The narrower in scope take priority over the broader: so
if there are both local and global variables called "grand total", then
the text "grand total" is parsed as the local.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-variable&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;definite-article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-variable&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 2 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-local-variable&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">               </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-stacked-variable&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">             </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-global-variable&gt;</span><span class="Preform-plain-syntax">                </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>

<span class="Preform-function-syntax">&lt;s-nonglobal-variable&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">(</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-nonglobal-variable&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">)</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-local-variable&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">          </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[1], W) }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-stacked-variable&gt;</span><span class="Preform-plain-syntax">          </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[1], W) }</span>

<span class="Preform-function-syntax">&lt;s-variable-as-value&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-variable&gt;</span><span class="Preform-plain-syntax">                  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -, ExParser::val(RP[1], W) }</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP15"></a><b>&#167;15.  </b>This requires three internals:
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-local-variable&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">local_variable</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">lvar</span><span class="Preform-plain-syntax"> = </span><a href="24-lv.html#SP24" class="function-link"><span class="Preform-function-syntax">LocalVariables::parse</span></a><span class="Preform-plain-syntax">(</span><a href="24-sf.html#SP8" class="function-link"><span class="Preform-function-syntax">Frames::current_stack_frame</span></a><span class="Preform-plain-syntax">(), </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">lvar</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax"> = </span><a href="14-lv.html#SP2" class="function-link"><span class="Preform-function-syntax">Lvalues::new_LOCAL_VARIABLE</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">lvar</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        ==&gt; { -, </span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax"> }; </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP16"></a><b>&#167;16.  </b>And similarly:
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-stacked-variable&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">ph_stack_frame</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">phsf</span><span class="Preform-plain-syntax"> = </span><a href="24-sf.html#SP8" class="function-link"><span class="Preform-function-syntax">Frames::current_stack_frame</span></a><span class="Preform-plain-syntax">();</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">phsf</span><span class="Preform-plain-syntax"> == </span><span class="Preform-identifier-syntax">NULL</span><span class="Preform-plain-syntax">) { ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> }; }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">stacked_variable</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">stv</span><span class="Preform-plain-syntax"> = </span><a href="21-sv.html#SP3" class="function-link"><span class="Preform-function-syntax">StackedVariables::parse_from_owner_list</span></a><span class="Preform-plain-syntax">(</span>
<span class="Preform-plain-syntax">        </span><a href="24-sf.html#SP11" class="function-link"><span class="Preform-function-syntax">Frames::get_stvol</span></a><span class="Preform-plain-syntax">(), </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">stv</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax"> = </span><a href="14-lv.html#SP2" class="function-link"><span class="Preform-function-syntax">Lvalues::new_actual_NONLOCAL_VARIABLE</span></a><span class="Preform-plain-syntax">(</span>
<span class="Preform-plain-syntax">            </span><a href="21-sv.html#SP3" class="function-link"><span class="Preform-function-syntax">StackedVariables::get_variable</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">stv</span><span class="Preform-plain-syntax">));</span>
<span class="Preform-plain-syntax">        ==&gt; { -, </span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax"> }; </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP17"></a><b>&#167;17.  </b>And:
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-global-variable&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Lexicon::retrieve</span><span class="Preform-plain-syntax">(</span><span class="Preform-constant-syntax">VARIABLE_MC</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">) { ==&gt; { -, </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> }; </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">; }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP18"></a><b>&#167;18.  </b>As noted above, we want to parse phrases containing "of" cautiously in
cases where the excerpt being parsed looks as if it might be a property
rather than use of a phrase. Here's how we tell whether it looks that way:
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;property-of-shape&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-property-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">of</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">...</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP19"></a><b>&#167;19.  </b>We implement this by telling the excerpt parser, temporarily, not to match
anything including the word "of":
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">vocabulary_entry</span><span class="plain-syntax"> *</span><span class="identifier-syntax">property_word_to_suppress</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP20"></a><b>&#167;20.  </b>And here are the relevant internals:
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-value-phrase-non-of&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Articles::remove_the</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">vocabulary_entry</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">suppression</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">word_to_suppress_in_phrases</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-function-syntax">&lt;property-of-shape&gt;</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">)) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">property_word_to_suppress</span><span class="Preform-plain-syntax"> == </span><span class="Preform-identifier-syntax">NULL</span><span class="Preform-plain-syntax">)</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-identifier-syntax">property_word_to_suppress</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">PreformUtilities::word</span><span class="Preform-plain-syntax">(</span><span class="Preform-function-syntax">&lt;property-of-shape&gt;</span><span class="Preform-plain-syntax">, </span><span class="Preform-constant-syntax">0</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">word_to_suppress_in_phrases</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">property_word_to_suppress</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Lexicon::retrieve</span><span class="Preform-plain-syntax">(</span><span class="Preform-constant-syntax">VALUE_PHRASE_MC</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">word_to_suppress_in_phrases</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">suppression</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Node::new_with_words</span><span class="Preform-plain-syntax">(</span><span class="Preform-constant-syntax">PHRASE_TO_DECIDE_VALUE_NT</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><a href="10-cap.html#SP12" class="function-link"><span class="Preform-function-syntax">ExParser::add_ilist</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        ==&gt; { -, </span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax"> }; </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>

<span class="Preform-function-syntax">&lt;s-value-phrase&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Articles::remove_the</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Lexicon::retrieve</span><span class="Preform-plain-syntax">(</span><span class="Preform-constant-syntax">VALUE_PHRASE_MC</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">parse_node</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">Node::new_with_words</span><span class="Preform-plain-syntax">(</span><span class="Preform-constant-syntax">PHRASE_TO_DECIDE_VALUE_NT</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        </span><a href="10-cap.html#SP12" class="function-link"><span class="Preform-function-syntax">ExParser::add_ilist</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">p</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        ==&gt; { -, </span><span class="Preform-identifier-syntax">spec</span><span class="Preform-plain-syntax"> }; </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP21"></a><b>&#167;21. Table references. </b>Table references come in five different forms:
</p>

<ul class="items"><li>(a) For instance, "atomic number entry", meaning the entry in that column
and implicitly in the table and row currently selected.
</li><li>(b) For instance, "atomic number in row 4 of the Table of Elements".
</li><li>(c) For instance, "an atomic number listed in the Table of Elements" in the
sentence "if 101 is an atomic number listed in the Table of Elements". This
is part of a condition, and can't evaluate.
</li><li>(d) For instance, "atomic weight corresponding to an atomic number of 57 in
the Table of Elements".
</li><li>(e) For instance, "atomic weight of 20 in the Table of Elements" in the
sentence "if there is an atomic weight of 20 in the Table of Elements".
Again, this is part of a condition, and can't evaluate.
</li></ul>
<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-table-reference&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-table-column-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">entry</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-teav.html#SP21_1" class="named-paragraph-link"><span class="named-paragraph">Make table entry value</span><span class="named-paragraph-number">21.1</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-table-column-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">in</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">row</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-value-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">of</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-value-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-teav.html#SP21_2" class="named-paragraph-link"><span class="named-paragraph">Make table in row of value</span><span class="named-paragraph-number">21.2</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-table-column-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">listed</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">in</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-value-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-teav.html#SP21_3" class="named-paragraph-link"><span class="named-paragraph">Make table listed in value</span><span class="named-paragraph-number">21.3</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-table-column-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">corresponding</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">to</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-table-column-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">of</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-value-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">in</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-value-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-teav.html#SP21_4" class="named-paragraph-link"><span class="named-paragraph">Make table corresponding to value</span><span class="named-paragraph-number">21.4</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-table-column-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">of</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-value-uncached&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">in</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-value-uncached&gt;</span><span class="Preform-plain-syntax">											</span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="10-teav.html#SP21_5" class="named-paragraph-link"><span class="named-paragraph">Make table of in value</span><span class="named-paragraph-number">21.5</span></a></span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP21_1"></a><b>&#167;21.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make table entry value</span><span class="named-paragraph-number">21.1</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="14-lv.html#SP3" class="function-link"><span class="function-syntax">Lvalues::new_TABLE_ENTRY</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1];</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><a href="24-lv.html#SP22" class="function-link"><span class="function-syntax">LocalVariables::are_we_using_table_lookup</span></a><span class="plain-syntax">() == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">problem_count</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><a href="1-wtc.html#SP5" class="function-link"><span class="function-syntax">Task::syntax_tree</span></a><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_NoRowSelected</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"no row seems to have been chosen at this point"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"so it doesn't make sense to talk about the entries "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"within it. (By 'at this point', I mean the point "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"when the table will have to be looked at. This "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"might be at another time altogether if we are "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"storing away instructions for later in a text "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"substitution, e.g., writing 'now the description "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"of the player is \"Thoroughly [vanity entry].\";' "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"- remember that the substitution is acted on "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"when the text is printed, which could be at any "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"time, and no row will be chosen then.)"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    ==&gt; { -, </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-teav.html#SP21">&#167;21</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP21_2"></a><b>&#167;21.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make table in row of value</span><span class="named-paragraph-number">21.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="14-lv.html#SP3" class="function-link"><span class="function-syntax">Lvalues::new_TABLE_ENTRY</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><a href="10-teav.html#SP22" class="function-link"><span class="function-syntax">ExParser::arg</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><a href="10-teav.html#SP22" class="function-link"><span class="function-syntax">ExParser::arg</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><a href="10-teav.html#SP22" class="function-link"><span class="function-syntax">ExParser::arg</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[3]);</span>
<span class="plain-syntax">    ==&gt; { -, </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-teav.html#SP21">&#167;21</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP21_3"></a><b>&#167;21.3.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make table listed in value</span><span class="named-paragraph-number">21.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="14-lv.html#SP3" class="function-link"><span class="function-syntax">Lvalues::new_TABLE_ENTRY</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><a href="10-teav.html#SP22" class="function-link"><span class="function-syntax">ExParser::arg</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><a href="10-teav.html#SP22" class="function-link"><span class="function-syntax">ExParser::arg</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]);</span>
<span class="plain-syntax">    ==&gt; { -, </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-teav.html#SP21">&#167;21</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP21_4"></a><b>&#167;21.4.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make table corresponding to value</span><span class="named-paragraph-number">21.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="14-lv.html#SP3" class="function-link"><span class="function-syntax">Lvalues::new_TABLE_ENTRY</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><a href="10-teav.html#SP22" class="function-link"><span class="function-syntax">ExParser::arg</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><a href="10-teav.html#SP22" class="function-link"><span class="function-syntax">ExParser::arg</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><a href="10-teav.html#SP22" class="function-link"><span class="function-syntax">ExParser::arg</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[3]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><a href="10-teav.html#SP22" class="function-link"><span class="function-syntax">ExParser::arg</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[4]);</span>
<span class="plain-syntax">    ==&gt; { -, </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-teav.html#SP21">&#167;21</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP21_5"></a><b>&#167;21.5.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make table of in value</span><span class="named-paragraph-number">21.5</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="14-lv.html#SP3" class="function-link"><span class="function-syntax">Lvalues::new_TABLE_ENTRY</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><a href="10-teav.html#SP22" class="function-link"><span class="function-syntax">ExParser::arg</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><a href="10-teav.html#SP22" class="function-link"><span class="function-syntax">ExParser::arg</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><a href="10-teav.html#SP22" class="function-link"><span class="function-syntax">ExParser::arg</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><a href="10-teav.html#SP22" class="function-link"><span class="function-syntax">ExParser::arg</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[3]);</span>
<span class="plain-syntax">    ==&gt; { -, </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="10-teav.html#SP21">&#167;21</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP22"></a><b>&#167;22.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">ExParser::arg</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">ExParser::arg</span></span>:<br/><a href="10-teav.html#SP21_2">&#167;21.2</a>, <a href="10-teav.html#SP21_3">&#167;21.3</a>, <a href="10-teav.html#SP21_4">&#167;21.4</a>, <a href="10-teav.html#SP21_5">&#167;21.5</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">val</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">val</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="14-sp.html#SP8" class="function-link"><span class="function-syntax">Specifications::new_UNKNOWN</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">Node::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">val</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP23"></a><b>&#167;23.  </b>Action patterns, such as "taking a container" or "opening a closed door",
are parsed by code in the chapter on Actions; all we do here is to wrap the
result.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-action-pattern-as-value&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    #</span><span class="Preform-identifier-syntax">ifdef</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">IF_MODULE</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">Wordings::mismatched_brackets</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">)) { ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> }; }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">Lexer::word</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">Wordings::first_wn</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">)) == </span><span class="Preform-identifier-syntax">OPENBRACE_V</span><span class="Preform-plain-syntax">) { ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> }; }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">int</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">pto</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">permit_trying_omission</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-function-syntax">&lt;definite-article&gt;</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">Wordings::first_word</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">)) == </span><span class="Preform-identifier-syntax">FALSE</span><span class="Preform-plain-syntax">) </span><span class="Preform-identifier-syntax">permit_trying_omission</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">int</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">r</span><span class="Preform-plain-syntax"> = </span><span class="Preform-function-syntax">&lt;action-pattern&gt;</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-identifier-syntax">permit_trying_omission</span><span class="Preform-plain-syntax"> = </span><span class="Preform-identifier-syntax">pto</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">r</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-identifier-syntax">action_pattern</span><span class="Preform-plain-syntax"> *</span><span class="Preform-identifier-syntax">ap</span><span class="Preform-plain-syntax"> = </span><span class="Preform-function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> ((</span><span class="Preform-identifier-syntax">ap</span><span class="Preform-plain-syntax">-&gt;</span><span class="Preform-identifier-syntax">actor_spec</span><span class="Preform-plain-syntax">) &amp;&amp;</span>
<span class="Preform-plain-syntax">            (</span><a href="14-ds2.html#SP25" class="function-link"><span class="Preform-function-syntax">Dash::validate_parameter</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">ap</span><span class="Preform-plain-syntax">-&gt;</span><span class="Preform-identifier-syntax">actor_spec</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">K_person</span><span class="Preform-plain-syntax">) == </span><span class="Preform-identifier-syntax">FALSE</span><span class="Preform-plain-syntax">)) {</span>
<span class="Preform-plain-syntax">            </span><span class="Preform-identifier-syntax">r</span><span class="Preform-plain-syntax"> = </span><span class="Preform-function-syntax">&lt;action-pattern&gt;</span><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">        }</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">r</span><span class="Preform-plain-syntax">) {</span>
<span class="Preform-plain-syntax">        ==&gt; { -, </span><a href="14-cn.html#SP10" class="function-link"><span class="Preform-function-syntax">Conditions::new_TEST_ACTION</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">) };</span>
<span class="Preform-plain-syntax">        </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">    }</span>
<span class="Preform-plain-syntax">    #</span><span class="Preform-identifier-syntax">endif</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> };</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="10-cad.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-cm.html">1</a></li><li class="progresschapter"><a href="2-up.html">2</a></li><li class="progresschapter"><a href="3-bv.html">3</a></li><li class="progresschapter"><a href="4-dlr.html">4</a></li><li class="progresschapter"><a href="5-rpt.html">5</a></li><li class="progresschapter"><a href="6-lp.html">6</a></li><li class="progresschapter"><a href="7-up.html">7</a></li><li class="progresschapter"><a href="8-ptu.html">8</a></li><li class="progresschapter"><a href="9-ef.html">9</a></li><li class="progresscurrentchapter">10</li><li class="progresssection"><a href="10-its.html">its</a></li><li class="progresssection"><a href="10-aots.html">aots</a></li><li class="progresssection"><a href="10-pl.html">pl</a></li><li class="progresssection"><a href="10-cad.html">cad</a></li><li class="progresscurrent">teav</li><li class="progresssection"><a href="10-varc.html">varc</a></li><li class="progresssection"><a href="10-cap.html">cap</a></li><li class="progresschapter"><a href="11-itpc.html">11</a></li><li class="progresschapter"><a href="12-ter.html">12</a></li><li class="progresschapter"><a href="13-kak.html">13</a></li><li class="progresschapter"><a href="14-sp.html">14</a></li><li class="progresschapter"><a href="15-pr.html">15</a></li><li class="progresschapter"><a href="16-is.html">16</a></li><li class="progresschapter"><a href="17-tl.html">17</a></li><li class="progresschapter"><a href="18-lc.html">18</a></li><li class="progresschapter"><a href="19-tc.html">19</a></li><li class="progresschapter"><a href="20-eq.html">20</a></li><li class="progresschapter"><a href="21-rl.html">21</a></li><li class="progresschapter"><a href="22-itp.html">22</a></li><li class="progresschapter"><a href="23-ad.html">23</a></li><li class="progresschapter"><a href="24-lv.html">24</a></li><li class="progresschapter"><a href="25-in.html">25</a></li><li class="progresschapter"><a href="26-fc.html">26</a></li><li class="progresschapter"><a href="27-hr.html">27</a></li><li class="progressnext"><a href="10-varc.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

