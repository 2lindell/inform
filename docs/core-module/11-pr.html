<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>11/ap</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../compiler.html"><b>compiler tools</b></a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul>
<h2>Compiler Webs</h2>
<ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul>
<h2>Inbuild Modules</h2>
<ul>
<li><a href="../inbuild-module/index.html">inbuild</a></li>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../html-module/index.html">html</a></li>
</ul>
<h2>Inform7 Modules</h2>
<ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul>
<h2>Inter Modules</h2>
<ul>
<li><a href="../inter-module/index.html">inter</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of '11/pr' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="../compiler.html">Compiler Modules</a></li><li><a href="index.html">core</a></li><li><a href="index.html#11">Chapter 11: Predicate Calculus</a></li><li><b>Propositions</b></li></ul><p class="purpose">To build and modify structures representing propositions in predicate calculus.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP7">&#167;7. Implied conjunction</a></li><li><a href="#SP10">&#167;10. Validity</a></li><li><a href="#SP13">&#167;13. Complexity</a></li><li><a href="#SP14">&#167;14. Primitive operations on propositions</a></li><li><a href="#SP17">&#167;17. Inserting and deleting atoms</a></li><li><a href="#SP19">&#167;19. Inspecting contents</a></li><li><a href="#SP20">&#167;20. Matching sequences of atoms</a></li><li><a href="#SP21">&#167;21. Seeking atoms</a></li><li><a href="#SP29">&#167;29. Bracketed groups</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>We now begin on the data structures to hold propositions. Now a properly
constructed proposition has a natural tree structure &mdash; one can regard
quantification, negation, and conjunction as higher nodes, and predicates
as leaves. So the idea of storing propositions as trees has a certain elegance.
At first it seems an advantage that any such tree is necessarily a valid
proposition. But in fact this is not so helpful, because we want to build
propositions gradually, and in particular intermediate states need to exist
which are not yet valid but will be. If we used a tree representation, we
would also need some cursor-position-like marker for the region of current
growth, and that could all become complicated. We will also find that the
main operation we need to perform is a depth-first traverse of the tree,
which is a little tiresome to do in a conventional loop (it lends itself to
recursion, but that's inconvenient).
</p>

<p class="inwebparagraph">So we will instead store propositions in a linked list, imitating the notation
used by mathematicians who write them along in a single line. Now there's a
natural way to store incomplete propositions and a natural build-point (at
the end), and depth-first traverses are easy &mdash; just work along from left
to right. The disadvantage is that it's also easy to make malformed
propositions, so we have to build carefully.
</p>

<p class="inwebparagraph">For instance, "Test sentence (internal) with no man can see the box."
produces:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">1. no man can see the box</span>
        <span class="plain">[ DoesNotExist x IN[ man(x) IN] : can-see(x, 'box') ]</span>
</pre>

<p class="inwebparagraph">The proposition is stored as a linked list of atoms, of elements like so:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">QUANTIFIER --&gt; DOMAIN_OPEN --&gt; PREDICATE --&gt; DOMAIN_CLOSE --&gt; PREDICATE</span>
</pre>

<p class="inwebparagraph">In short: a proposition is a linked list of <code class="display"><span class="extract">pcalc_prop</span></code> atoms, joined by
their <code class="display"><span class="extract">next</span></code> fields. The present section contains routines to help build
and edit such lists.
</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>In particular:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(a) The empty list, a <code class="display"><span class="extract">NULL</span></code> pointer, represents the universally true
proposition T. Asserting it does nothing; testing it at run-time always
evaluates to <code class="display"><span class="extract">true</span></code>.
</li></ul>
<ul class="items"><li>(b) The conjunction φ∧ψ is just the concatenation of their
linked lists.
</li></ul>
<ul class="items"><li>(c) Negation ¬(φ) is the concatenation <code class="display"><span class="extract">NEGATION_OPEN --&gt; P --&gt; NEGATION_CLOSE</span></code>,
where <code class="display"><span class="extract">P</span></code> is the linked list for φ.
</li></ul>
<ul class="items"><li>(d) The quantifier Q v∈ { v|φ(v)} is
<code class="display"><span class="extract">QUANTIFIER --&gt; DOMAIN_OPEN --&gt; P --&gt; DOMAIN_CLOSE</span></code>.
</li></ul>
<p class="inwebparagraph">In this section, we'll call a segment of the list representing a pair of
matched brackets, like <code class="display"><span class="extract">DOMAIN_OPEN --&gt; P --&gt; DOMAIN_CLOSE</span></code>, a "group".
</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>We sometimes need to indicate a position within a proposition &mdash; a
position not of an atom, but between atoms. Consider the possible places
where letters could be inserted into the word "rap": before the "r"
(trap), between "r" and "a" (reap), between "a" and "p" (ramp),
after the "p" (rapt). Though "rap" is a three-letter word, there are
four possible insertion points &mdash; so they can't exactly correspond to
letters. The convention used with Inform propositions is that a position
marker points to the <code class="display"><span class="extract">pcalc_prop</span></code> structure for the atom before
the position meant: and a <code class="display"><span class="extract">NULL</span></code> pointer in this context means the
front position, before the opening atom.
</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>The code needed to perform a depth-first traverse of a proposition is
abstracted by the following macros. Note that we often need to remember
the atom before the current one, so we keep that in a spare variable
during each traverse. (This saves us having to maintain the proposition
data structure as a doubly linked list, which would be harder to edit.)
</p>

<p class="inwebparagraph">One macro declares the name of a marker variable to be used when traversing;
the other is the necessary loop head. Note that we do not assume that <code class="display"><span class="extract">p</span></code>
will still be non-<code class="display"><span class="extract">NULL</span></code> at the end of a loop iteration, just because it
was at the beginning: local edits are sometimes performed in the traverse,
and it can happen that an edit truncates the proposition so savagely that the
loop finds its ground cut out from under it.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="identifier">TRAVERSE_VARIABLE</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">)</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">, *</span><span class="identifier">p</span><span class="plain">##</span><span class="identifier">_prev</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">p</span><span class="plain">##</span><span class="identifier">_repeat</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="definitionkeyword">define</span> <span class="identifier">TRAVERSE_PROPOSITION</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">start</span><span class="plain">)</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">=</span><span class="identifier">start</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">##</span><span class="identifier">_prev</span><span class="plain">=</span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">##</span><span class="identifier">_repeat</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="identifier">p</span><span class="plain">;</span>
            <span class="plain">(</span><span class="identifier">p</span><span class="plain">##</span><span class="identifier">_repeat</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)?(</span><span class="identifier">p</span><span class="plain">##</span><span class="identifier">_prev</span><span class="plain">=</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">=(</span><span class="identifier">p</span><span class="plain">)?(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">):</span><span class="identifier">NULL</span><span class="plain">):0, </span><span class="identifier">p</span><span class="plain">##</span><span class="identifier">_repeat</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">)</span>
</pre>
<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>An edit which happens during a traverse is permitted to make any change
to the proposition at and beyond the marker position <code class="display"><span class="extract">p</span></code>, but not allowed
to change what came before. Since such an edit might leave <code class="display"><span class="extract">p</span></code> pointing
to an atom which has been cut, or moved later, we must perform the following
macro after edits to restore <code class="display"><span class="extract">p</span></code>. We know that the atom which was before
<code class="display"><span class="extract">p</span></code> at the start of the loop has not been changed &mdash; since edits aren't
allowed there &mdash; so <code class="display"><span class="extract">p_prev</span></code> must be correct, and we therefore restore
<code class="display"><span class="extract">p</span></code> to the next atom after <code class="display"><span class="extract">p_prev</span></code>.
</p>

<p class="inwebparagraph">There is a catch, however: if our edit consists only of deleting some
atoms then using <code class="display"><span class="extract">PROPOSITION_EDITED</span></code> correctly resets <code class="display"><span class="extract">p</span></code> to the current
atom at the marker position, and that will be the first atom after the
ones deleted. If we then just go around the loop, we move on to the next
atom; as a result, the first atom after the deleted ones is skipped over.
We can avoid this by using <code class="display"><span class="extract">PROPOSITION_EDITED_REPEATING_CURRENT</span></code> instead.
</p>

<p class="inwebparagraph">Every routine which simplifies a proposition is expected to have an <code class="display"><span class="extract">int *</span></code>
argument called <code class="display"><span class="extract">changed</span></code>: on exit, the <code class="display"><span class="extract">int</span></code> variable this points to
should be set if and only if a change has been made to the proposition.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="identifier">PROPOSITION_EDITED</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">)</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">##</span><span class="identifier">_prev</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">; </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">##</span><span class="identifier">_prev</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
        <span class="plain">*</span><span class="identifier">changed</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="definitionkeyword">define</span> <span class="identifier">PROPOSITION_EDITED_REPEATING_CURRENT</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">)</span>
        <span class="identifier">PROPOSITION_EDITED</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">)</span>
        <span class="identifier">p</span><span class="plain">##</span><span class="identifier">_repeat</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
</pre>
<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Implied conjunction. </b>Conjunction (logical "and") occurs so densely in propositions arising from
natural language that our data structures would grow large and unmanageable
if we wrote all of them out. So we adopt a convention similar to the one
in algebra, where the formula
 xy+w(v-1) 
is understood to mean multiplication of x by y, and of w by (v-1).
Note that if we were to write it out as a sequence of symbols
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">x y + w ( v - 1 )</span>
</pre>

<p class="inwebparagraph">then multiplication would only be understood at two positions, not between
every pair of symbols. In the same way, the following routine looks at a
pair of adjacent atoms and decides whether or not conjunction should be
understood between them.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::implied_conjunction_between</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">p1</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">p2</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">p1</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">p2</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Atoms::element_get_group</span><span class="plain">(</span><span class="identifier">p1</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain">) == </span><span class="constant">OPEN_OPERATORS_GROUP</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Atoms::element_get_group</span><span class="plain">(</span><span class="identifier">p2</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain">) == </span><span class="constant">CLOSE_OPERATORS_GROUP</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p1</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p1</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">DOMAIN_CLOSE_ATOM</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::implied_conjunction_between is used in <a href="#SP8">&#167;8</a>, 12/dtd (<a href="12-dtd.html#SP8">&#167;8</a>).</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>Purely decoratively, we print some punctuation when logging a proposition;
this is chosen to look like standard mathematical notation.
</p>


<pre class="display">
    <span class="reserved">char</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::debugging_log_text_between</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">p1</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">p2</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">p1</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">p2</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">""</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p1</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p2</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">DOMAIN_OPEN_ATOM</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">""</span><span class="plain">;</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="string">":"</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p1</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">DOMAIN_CLOSE_ATOM</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="string">":"</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Propositions::implied_conjunction_between</span><span class="plain">(</span><span class="identifier">p1</span><span class="plain">, </span><span class="identifier">p2</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Streams::I6_escapes_enabled</span><span class="plain">(</span><span class="identifier">DL</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain">(</span><span class="string">"&amp;"</span><span class="plain">); </span>    <span class="comment">since <code class="display"><span class="extract">^</span></code> in I6 strings means newline</span>
            <span class="reserved">return</span><span class="plain"> (</span><span class="string">"^"</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="string">""</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::debugging_log_text_between is used in <a href="#SP9">&#167;9</a>.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>So we may as well complete the debugging log code now. Note that T is
logged as just <code class="display"><span class="extract">[ ]</span></code>.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">log_addresses</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::log</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="identifier">TRAVERSE_VARIABLE</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"[ "</span><span class="plain">);</span>
        <span class="identifier">TRAVERSE_PROPOSITION</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">) {</span>
            <span class="reserved">char</span><span class="plain"> *</span><span class="identifier">bridge</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::debugging_log_text_between</span><span class="plain">(</span><span class="identifier">p_prev</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bridge</span><span class="plain">[0]) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"%s "</span><span class="plain">, </span><span class="identifier">bridge</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">log_addresses</span><span class="plain">) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"%08x="</span><span class="plain">, (</span><span class="reserved">unsigned</span><span class="plain"> </span><span class="reserved">int</span><span class="plain">) </span><span class="identifier">p</span><span class="plain">);</span>
            <span class="functiontext">Calculus::Atoms::log</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">" "</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"]"</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::log is used in 1/cm (<a href="1-cm.html#SP5">&#167;5</a>, <a href="1-cm.html#SP6_6">&#167;6.6</a>).</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Validity. </b>Since the proposition data structure lets us build all kinds of nonsense,
we'll be much safer if we can check our working &mdash; if we can verify that a
proposition is valid. But what does that mean? We might mean:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(i) a proposition is good if its sequence of <code class="display"><span class="extract">next</span></code> pointers all correctly
point to <code class="display"><span class="extract">pcalc_prop</span></code> structures, and don't loop around into a circle;
</li><li>(ii) a proposition is good if (i) is true, and it is correctly punctuated;
</li><li>(iii) a proposition is good if (ii) is true, and it never confuses
together two different variables by giving both the same letter;
</li><li>(iv) a proposition is good if (iii) is true, and all of its predicates
can safely be applied to all of their terms, and we can identify what
kind of value each variable ranges over.
</li></ul>
<p class="inwebparagraph">These are steadily stronger conditions. The first is a basic invariant of
our data structures: nothing failing (i) will ever be allowed to exist,
provided the routines in this section are free of bugs. Condition (ii) is
called syntactic validity; (iii) is well-formedness; (iv) is
type safety. Correct source text eventually makes propositions which
have all four properties, but intermediate half-built states often satisfy
only (i).
</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b>The following examples illustrate the differences. This one is not even
syntactically valid:
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">DOMAIN_OPEN_ATOM --&gt; NEGATION_CLOSE_ATOM --&gt; NEGATION_CLOSE_ATOM</span></code>
</p>

<p class="inwebparagraph">This one is syntactically valid, but not well-formed:
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">EVERYWHERE_ATOM(x) --&gt; QUANTIFIER=for-all(x) --&gt; PREDICATE=open(x)</span></code>
</p>

<p class="inwebparagraph">(If <code class="display"><span class="extract">x</span></code> ranges over all objects at the middle of the proposition, it had
better not already have a value, but if it doesn't, what can that first
atom mean? It would be like writing the formula n + Σ_{n=1}^{10} n^2,
where clearly two different things have been called n.)
</p>

<p class="inwebparagraph">And this proposition is well-formed but not type-safe:
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">QUANTIFIER=for-all(x) --&gt; KIND=number(x) --&gt; EVERYWHERE(x)</span></code>
</p>

<p class="inwebparagraph">(Here <code class="display"><span class="extract">x</span></code> is supposed to be a number, and therefore has no location, but
<code class="display"><span class="extract">EVERYWHERE</span></code> can validly be applied only to backdrop objects, so what
could <code class="display"><span class="extract">EVERYWHERE(x)</span></code> possibly mean?)
</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b>Well-formedness and type safety are left to later sections in this chapter,
but we can at least test syntactic validity here.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">MAX_PROPOSITION_GROUP_NESTING</span><span class="plain"> 100 </span>    <span class="comment">vastly more than could realistically be used</span>
</pre>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::is_syntactically_valid</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="identifier">TRAVERSE_VARIABLE</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">groups_stack</span><span class="plain">[</span><span class="constant">MAX_PROPOSITION_GROUP_NESTING</span><span class="plain">], </span><span class="identifier">group_sp</span><span class="plain"> = 0;</span>
        <span class="identifier">TRAVERSE_PROPOSITION</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">) {</span>
            <span class="comment">(1) each individual atom has to be properly built:</span>
            <span class="reserved">char</span><span class="plain"> *</span><span class="identifier">err</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::validate</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">err</span><span class="plain">) { </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Atom error: %s: $o\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">err</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">); </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">; }</span>
            <span class="comment">(2) every open bracket must be matched by a close bracket of the same kind:</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Atoms::element_get_group</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain">) == </span><span class="constant">OPEN_OPERATORS_GROUP</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">group_sp</span><span class="plain"> &gt;= </span><span class="constant">MAX_PROPOSITION_GROUP_NESTING</span><span class="plain">) {</span>
                    <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Group nesting too deep\</span><span class="plain">n</span><span class="string">"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="identifier">groups_stack</span><span class="plain">[</span><span class="identifier">group_sp</span><span class="plain">++] = </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Atoms::element_get_group</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain">) == </span><span class="constant">CLOSE_OPERATORS_GROUP</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">group_sp</span><span class="plain"> &lt;= 0) { </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Too many close groups\</span><span class="plain">n</span><span class="string">"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">; }</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Atoms::element_get_match</span><span class="plain">(</span><span class="identifier">groups_stack</span><span class="plain">[--</span><span class="identifier">group_sp</span><span class="plain">]) != </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain">) {</span>
                    <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Group open/close doesn't match\</span><span class="plain">n</span><span class="string">"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="comment">(3) every quantifier except "exists" must be followed by domain brackets, which occur nowhere else:</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">Calculus::Atoms::is_quantifier</span><span class="plain">(</span><span class="identifier">p_prev</span><span class="plain">)) &amp;&amp; (</span><span class="functiontext">Calculus::Atoms::is_existence_quantifier</span><span class="plain">(</span><span class="identifier">p_prev</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> != </span><span class="constant">DOMAIN_OPEN_ATOM</span><span class="plain">) { </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Quant without domain\</span><span class="plain">n</span><span class="string">"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">; }</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">DOMAIN_OPEN_ATOM</span><span class="plain">) { </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Domain without quant\</span><span class="plain">n</span><span class="string">"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">; }</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) &amp;&amp;</span>
                <span class="plain">(</span><span class="functiontext">Calculus::Atoms::is_quantifier</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">)) &amp;&amp; (</span><span class="functiontext">Calculus::Atoms::is_existence_quantifier</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
                <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Ends without domain of final quantifier\</span><span class="plain">n</span><span class="string">"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="comment">(4) a proposition must end with all its brackets closed:</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">group_sp</span><span class="plain"> != 0) { </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"%d group(s) open\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">group_sp</span><span class="plain">); </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">; }</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::is_syntactically_valid is used in 11/bas (<a href="11-bas.html#SP5">&#167;5</a>).</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. Complexity. </b>Simple propositions contain only unary predicates or assertions that the
free variable has a given kind, or a given value. For example, "a closed
lockable door" is a simple proposition, but "four women in a lighted room"
is complex.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::is_complex</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">; </span><span class="identifier">p</span><span class="plain">; </span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">NEGATION_OPEN_ATOM</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">NEGATION_CLOSE_ATOM</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">DOMAIN_OPEN_ATOM</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">DOMAIN_CLOSE_ATOM</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">PREDICATE_ATOM</span><span class="plain">) &amp;&amp; (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> == 2)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Atoms::is_equality_predicate</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="reserved">if</span><span class="plain"> (!(((</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.variable</span><span class="plain"> == 0) &amp;&amp; (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[1]</span><span class="element">.constant</span><span class="plain">)) ||</span>
                    <span class="plain">((</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[1]</span><span class="element">.variable</span><span class="plain"> == 0) &amp;&amp; (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.constant</span><span class="plain">)))) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::is_complex is used in 14/ds (<a href="14-ds.html#SP7">&#167;7</a>).</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Primitive operations on propositions. </b>First, copying, which means copying not just the current atom, but all
subsequent ones.
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::copy</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">original</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">first</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">, *</span><span class="identifier">last</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">, *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="identifier">original</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">) {</span>
            <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">copied_atom</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::new</span><span class="plain">(0);</span>
            <span class="plain">*</span><span class="identifier">copied_atom</span><span class="plain"> = *</span><span class="identifier">prop</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">j</span><span class="plain">=0; </span><span class="identifier">j</span><span class="plain">&lt;</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain">; </span><span class="identifier">j</span><span class="plain">++)</span>
                <span class="identifier">copied_atom</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">] = </span><span class="functiontext">Calculus::Terms::copy</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[</span><span class="identifier">j</span><span class="plain">]);</span>
            <span class="identifier">copied_atom</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">first</span><span class="plain">) </span><span class="identifier">last</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">copied_atom</span><span class="plain">;</span>
            <span class="reserved">else</span><span class="plain"> </span><span class="identifier">first</span><span class="plain"> = </span><span class="identifier">copied_atom</span><span class="plain">;</span>
            <span class="identifier">last</span><span class="plain"> = </span><span class="identifier">copied_atom</span><span class="plain">;</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">first</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::copy is used in 7/ptu (<a href="7-ptu.html#SP2">&#167;2</a>), 9/rpt (<a href="9-rpt.html#SP2">&#167;2</a>), 11/sc (<a href="11-sc.html#SP3">&#167;3</a>, <a href="11-sc.html#SP3_4">&#167;3.4</a>), 12/dtd (<a href="12-dtd.html#SP7">&#167;7</a>), 12/cdp (<a href="12-cdp.html#SP2_1">&#167;2.1</a>, <a href="12-cdp.html#SP2_1_6">&#167;2.1.6</a>), 14/ds (<a href="14-ds.html#SP6">&#167;6</a>, <a href="14-ds.html#SP9">&#167;9</a>).</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b>Now to concatenate propositions. If E and T are both syntactically valid,
the result will be, too; but the same is not true of well-formedness, so we
need to be careful in using this.
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::concatenate</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">existing_body</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">tail</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">end</span><span class="plain"> = </span><span class="identifier">existing_body</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">end</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">tail</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">sc</span><span class="plain"> = 0;</span>
        <span class="reserved">while</span><span class="plain"> (</span><span class="identifier">end</span><span class="plain"> &amp;&amp; (</span><span class="identifier">end</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sc</span><span class="plain">++ == 100000) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"malformed proposition"</span><span class="plain">);</span>
            <span class="identifier">end</span><span class="plain"> = </span><span class="identifier">end</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">end</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">tail</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">existing_body</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::concatenate is used in <a href="#SP16">&#167;16</a>, 9/tc (<a href="9-tc.html#SP5_4_1_1">&#167;5.4.1.1</a>, <a href="9-tc.html#SP5_4_2_1">&#167;5.4.2.1</a>, <a href="9-tc.html#SP5_4_2_2">&#167;5.4.2.2</a>, <a href="9-tc.html#SP5_4_2_3">&#167;5.4.2.3</a>), 9/imp (<a href="9-imp.html#SP7_1_3">&#167;7.1.3</a>), 11/tc (<a href="11-tc.html#SP1">&#167;1</a>, <a href="11-tc.html#SP2">&#167;2</a>), 11/sc (<a href="11-sc.html#SP1_13">&#167;1.13</a>, <a href="11-sc.html#SP3_7">&#167;3.7</a>, <a href="11-sc.html#SP3_8">&#167;3.8</a>), 12/dtd (<a href="12-dtd.html#SP10">&#167;10</a>, <a href="12-dtd.html#SP13">&#167;13</a>), 14/ds (<a href="14-ds.html#SP8">&#167;8</a>, <a href="14-ds.html#SP9">&#167;9</a>, <a href="14-ds.html#SP10">&#167;10</a>), 15/cp (<a href="15-cp.html#SP3">&#167;3</a>).</p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16.  </b>And here is a version which protects us:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::conjoin</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">existing_body</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">tail</span><span class="plain">) {</span>
        <span class="identifier">TRAVERSE_VARIABLE</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="identifier">TRAVERSE_PROPOSITION</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">existing_body</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain"> == </span><span class="identifier">tail</span><span class="plain">) {</span>
                &lt;<span class="cwebmacro">Report failure to log</span> <span class="cwebmacronumber">16.1</span>&gt;<span class="plain">;</span>
                <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"conjoin proposition to a subset of itself"</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="identifier">TRAVERSE_PROPOSITION</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">tail</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain"> == </span><span class="identifier">existing_body</span><span class="plain">) {</span>
                &lt;<span class="cwebmacro">Report failure to log</span> <span class="cwebmacronumber">16.1</span>&gt;<span class="plain">;</span>
                <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"conjoin proposition to a superset of itself"</span><span class="plain">);</span>
            <span class="plain">}</span>

        <span class="functiontext">Calculus::Variables::renumber_bound</span><span class="plain">(</span><span class="identifier">tail</span><span class="plain">, </span><span class="identifier">existing_body</span><span class="plain">, -1);</span>
        <span class="identifier">existing_body</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::concatenate</span><span class="plain">(</span><span class="identifier">existing_body</span><span class="plain">, </span><span class="identifier">tail</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">existing_body</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::conjoin is used in 11/tc (<a href="11-tc.html#SP7">&#167;7</a>, <a href="11-tc.html#SP7_1">&#167;7.1</a>, <a href="11-tc.html#SP7_2">&#167;7.2</a>).</p>

<p class="inwebparagraph"><a id="SP16_1"></a><b>&#167;16.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Report failure to log</span> <span class="cwebmacronumber">16.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Seriously misguided attempt to conjoin propositions:\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
        <span class="identifier">log_addresses</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Existing body: $D\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">existing_body</span><span class="plain">);</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Tail:          $D\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">tail</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP16">&#167;16</a> (twice).</p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17. Inserting and deleting atoms. </b>Here we insert an atom at a given position, or at the front if the position
is <code class="display"><span class="extract">NULL</span></code>.
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::insert_atom</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">position</span><span class="plain">,</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">new_atom</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">position</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">new_atom</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">;</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">new_atom</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"inserting atom nowhere"</span><span class="plain">);</span>
            <span class="identifier">new_atom</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">position</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
            <span class="identifier">position</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">new_atom</span><span class="plain">;</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::insert_atom is used in 11/bas (<a href="11-bas.html#SP12">&#167;12</a>), 11/sm (<a href="11-sm.html#SP3_2">&#167;3.2</a>, <a href="11-sm.html#SP4">&#167;4</a>, <a href="11-sm.html#SP6">&#167;6</a>, <a href="11-sm.html#SP7">&#167;7</a>, <a href="11-sm.html#SP8">&#167;8</a>, <a href="11-sm.html#SP10_3_2">&#167;10.3.2</a>, <a href="11-sm.html#SP15">&#167;15</a>, <a href="11-sm.html#SP19">&#167;19</a>).</p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18.  </b>And similarly, with the deleted atom the one after the position given:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::delete_atom</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">position</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">position</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"deleting atom nowhere"</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">position</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"deleting atom off end"</span><span class="plain">);</span>
            <span class="identifier">position</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">position</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::delete_atom is used in <a href="#SP32">&#167;32</a>, <a href="#SP33">&#167;33</a>, <a href="#SP34">&#167;34</a>, 11/sm (<a href="11-sm.html#SP10_3_1">&#167;10.3.1</a>, <a href="11-sm.html#SP10_3_2">&#167;10.3.2</a>, <a href="11-sm.html#SP10_4">&#167;10.4</a>, <a href="11-sm.html#SP14">&#167;14</a>, <a href="11-sm.html#SP15">&#167;15</a>, <a href="11-sm.html#SP17_1">&#167;17.1</a>, <a href="11-sm.html#SP19">&#167;19</a>), 12/cdp (<a href="12-cdp.html#SP5">&#167;5</a>, <a href="12-cdp.html#SP5_1_1_1">&#167;5.1.1.1</a>), 14/ds (<a href="14-ds.html#SP10">&#167;10</a>).</p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19. Inspecting contents. </b>First, we count the number of atoms in a given proposition. This is used by
other parts of Inform as a crude measure of how complicated it is; though in
fact it is not all that crude so long as it is applied to a proposition
which has been simplified.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::length</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">n</span><span class="plain"> = 0;</span>
        <span class="identifier">TRAVERSE_VARIABLE</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="identifier">TRAVERSE_PROPOSITION</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">) </span><span class="identifier">n</span><span class="plain">++;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">n</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::length is used in 14/cn (<a href="14-cn.html#SP15">&#167;15</a>), 14/ds (<a href="14-ds.html#SP7">&#167;7</a>, <a href="14-ds.html#SP12_1">&#167;12.1</a>).</p>

<p class="inwebparagraph"><a id="SP20"></a><b>&#167;20. Matching sequences of atoms. </b>The following sneakily variable-argument-length function can be used to
detect subsequences within a proposition: say, the sequence
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">QUANTIFIER --&gt; PREDICATE --&gt; anything --&gt; CALLED</span></code>
</p>

<p class="inwebparagraph">starting at the current position, which could be tested with:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Calculus::Propositions::match(p, 4, QUANTIFIER_ATOM, NULL, PREDICATE_ATOM, NULL,</span>
        <span class="plain">	ANY_ATOM_HERE, NULL, CALLED_ATOM, &amp;cp);</span>
</pre>

<p class="inwebparagraph">As can be seen, each atom is tested with an element number and an optional
pointer; when a successful match is made, the optional pointer is set to
the atom making the match. (So if the routine returns <code class="display"><span class="extract">TRUE</span></code> then we can
be certain that <code class="display"><span class="extract">cp</span></code> points to the <code class="display"><span class="extract">CALLED_ATOM</span></code> at the end of the run of
four.) There are two special pseudo-element-numbers:
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">ANY_ATOM_HERE</span><span class="plain"> 0 </span>    <span class="comment">match any atom, but don't match beyond the end of the proposition</span>
    <span class="definitionkeyword">define</span> <span class="constant">END_PROP_HERE</span><span class="plain"> -1 </span>    <span class="comment">a sentinel meaning "the proposition must end at this point"</span>
</pre>

<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::match</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">c</span><span class="plain">, ...) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">outcome</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">va_list</span><span class="plain"> </span><span class="identifier">ap</span><span class="plain">; </span>    <span class="comment">the variable argument list signified by the dots</span>
        <span class="identifier">va_start</span><span class="plain">(</span><span class="identifier">ap</span><span class="plain">, </span><span class="identifier">c</span><span class="plain">); </span>    <span class="comment">macro to begin variable argument processing</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain"> = 0; </span><span class="identifier">i</span><span class="plain"> &lt; </span><span class="identifier">c</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">a</span><span class="plain"> = </span><span class="identifier">va_arg</span><span class="plain">(</span><span class="identifier">ap</span><span class="plain">, </span><span class="reserved">int</span><span class="plain">);</span>
            <span class="reserved">pcalc_prop</span><span class="plain"> **</span><span class="identifier">atom_p</span><span class="plain"> = </span><span class="identifier">va_arg</span><span class="plain">(</span><span class="identifier">ap</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain"> **);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">atom_p</span><span class="plain"> != </span><span class="identifier">NULL</span><span class="plain">) *</span><span class="identifier">atom_p</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">;</span>
            <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">a</span><span class="plain">) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">ANY_ATOM_HERE</span><span class="plain">: </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">outcome</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">END_PROP_HERE</span><span class="plain">: </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain"> != </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">outcome</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">default</span><span class="plain">: </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">outcome</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
                    <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> != </span><span class="identifier">a</span><span class="plain">) </span><span class="identifier">outcome</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
                    <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">) </span><span class="identifier">prop</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">va_end</span><span class="plain">(</span><span class="identifier">ap</span><span class="plain">); </span>    <span class="comment">macro to end variable argument processing</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">outcome</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::match is used in <a href="#SP33">&#167;33</a>, 11/sc (<a href="11-sc.html#SP3_4">&#167;3.4</a>), 11/sm (<a href="11-sm.html#SP5">&#167;5</a>, <a href="11-sm.html#SP6">&#167;6</a>, <a href="11-sm.html#SP7">&#167;7</a>, <a href="11-sm.html#SP10_2">&#167;10.2</a>, <a href="11-sm.html#SP15">&#167;15</a>, <a href="11-sm.html#SP19">&#167;19</a>).</p>

<p class="inwebparagraph"><a id="SP21"></a><b>&#167;21. Seeking atoms. </b>Here we run through the proposition looking for either a given element, or
a given arity, or both:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::prop_seek_atom</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">atom_req</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">arity_req</span><span class="plain">) {</span>
        <span class="identifier">TRAVERSE_VARIABLE</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="identifier">TRAVERSE_PROPOSITION</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (((</span><span class="identifier">atom_req</span><span class="plain"> &lt; 0) || (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="identifier">atom_req</span><span class="plain">)) &amp;&amp;</span>
                <span class="plain">((</span><span class="identifier">arity_req</span><span class="plain"> &lt; 0) || (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> == </span><span class="identifier">arity_req</span><span class="plain">)))</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">p</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::prop_seek_atom is used in <a href="#SP22">&#167;22</a>, <a href="#SP23">&#167;23</a>, <a href="#SP25">&#167;25</a>, <a href="#SP28">&#167;28</a>.</p>

<p class="inwebparagraph"><a id="SP22"></a><b>&#167;22.  </b>Seeking different kinds of atom is now easy:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::contains_binary_predicate</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Propositions::prop_seek_atom</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="constant">PREDICATE_ATOM</span><span class="plain">, 2)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::contains_quantifier</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Propositions::prop_seek_atom</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">, -1)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::composited_kind</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">k_atom</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::prop_seek_atom</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="constant">KIND_ATOM</span><span class="plain">, -1);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">k_atom</span><span class="plain">) &amp;&amp; (</span><span class="identifier">k_atom</span><span class="plain">-</span><span class="element">&gt;composited</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) </span><span class="identifier">k_atom</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">k_atom</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::contains_nonexistence_quantifier</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::prop_seek_atom</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">, 1)) != </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">quantifier</span><span class="plain"> *</span><span class="identifier">quant</span><span class="plain"> = </span><span class="identifier">RETRIEVE_POINTER_quantifier</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">quant</span><span class="plain"> != </span><span class="identifier">exists_quantifier</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::contains_callings</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Propositions::prop_seek_atom</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="constant">CALLED_ATOM</span><span class="plain">, -1)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::contains_binary_predicate is used in 9/pk (<a href="9-pk.html#SP3_2">&#167;3.2</a>).</p>

<p class="endnote">The function Calculus::Propositions::contains_quantifier is used in 12/dtd (<a href="12-dtd.html#SP7">&#167;7</a>), 19/tod (<a href="19-tod.html#SP6_1_2">&#167;6.1.2</a>).</p>

<p class="endnote">The function Calculus::Propositions::composited_kind is used in 11/sc (<a href="11-sc.html#SP1_13_1">&#167;1.13.1</a>).</p>

<p class="endnote">The function Calculus::Propositions::contains_nonexistence_quantifier is used in 12/ap (<a href="12-ap.html#SP9">&#167;9</a>).</p>

<p class="endnote">The function Calculus::Propositions::contains_callings is used in 12/dtd (<a href="12-dtd.html#SP6">&#167;6</a>, <a href="12-dtd.html#SP9_1">&#167;9.1</a>, <a href="12-dtd.html#SP16">&#167;16</a>, <a href="12-dtd.html#SP23">&#167;23</a>), 14/ds (<a href="14-ds.html#SP10">&#167;10</a>), 24/ch (<a href="24-ch.html#SP7_4_1">&#167;7.4.1</a>).</p>

<p class="inwebparagraph"><a id="SP23"></a><b>&#167;23.  </b>Here we try to find out the kind of value of variable 0 without the full
expense of typechecking the proposition:
</p>


<pre class="display">
    <span class="identifier">kind</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::describes_kind</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">p</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::prop_seek_atom</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="constant">ISAKIND_ATOM</span><span class="plain">, 1)) != </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">Calculus::Terms::variable_underlying</span><span class="plain">(&amp;(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0])) == 0) &amp;&amp;</span>
                <span class="plain">(</span><span class="identifier">Kinds::Compare::eq</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain">, </span><span class="identifier">K_value</span><span class="plain">))) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain">;</span>
            <span class="identifier">p</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">p</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">p</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::prop_seek_atom</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="constant">KIND_ATOM</span><span class="plain">, 1)) != </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Terms::variable_underlying</span><span class="plain">(&amp;(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0])) == 0) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain">;</span>
            <span class="identifier">p</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">val</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::describes_value</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">val</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Specifications::to_kind</span><span class="plain">(</span><span class="identifier">val</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::describes_kind is used in 12/dtd (<a href="12-dtd.html#SP18">&#167;18</a>), 14/ds (<a href="14-ds.html#SP4">&#167;4</a>).</p>

<p class="inwebparagraph"><a id="SP24"></a><b>&#167;24.  </b>And, similarly, the actual value it must have:
</p>


<pre class="display">
    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::describes_value</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">; </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">bl</span><span class="plain"> = 0;</span>
        <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">; </span><span class="identifier">p</span><span class="plain">; </span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)</span>
            <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain">) {</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">NEGATION_OPEN_ATOM</span><span class="plain">: </span><span class="identifier">bl</span><span class="plain">++; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">NEGATION_CLOSE_ATOM</span><span class="plain">: </span><span class="identifier">bl</span><span class="plain">--; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">DOMAIN_OPEN_ATOM</span><span class="plain">: </span><span class="identifier">bl</span><span class="plain">++; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">case</span><span class="plain"> </span><span class="constant">DOMAIN_CLOSE_ATOM</span><span class="plain">: </span><span class="identifier">bl</span><span class="plain">--; </span><span class="reserved">break</span><span class="plain">;</span>
                <span class="reserved">default</span><span class="plain">:</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bl</span><span class="plain"> == 0) {</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Atoms::is_equality_predicate</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">)) {</span>
                            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.variable</span><span class="plain"> == 0) &amp;&amp; (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[1]</span><span class="element">.constant</span><span class="plain">))</span>
                                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[1]</span><span class="element">.constant</span><span class="plain">;</span>
                            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[1]</span><span class="element">.variable</span><span class="plain"> == 0) &amp;&amp; (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.constant</span><span class="plain">))</span>
                                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0]</span><span class="element">.constant</span><span class="plain">;</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                    <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::describes_value is used in <a href="#SP23">&#167;23</a>, 9/rpt (<a href="9-rpt.html#SP1">&#167;1</a>), 14/ds (<a href="14-ds.html#SP5">&#167;5</a>).</p>

<p class="inwebparagraph"><a id="SP25"></a><b>&#167;25.  </b>Finding an adjective is easy: it's a predicate of arity 1.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::contains_adjective</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Propositions::prop_seek_atom</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="constant">PREDICATE_ATOM</span><span class="plain">, 1)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::count_unary_predicates</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">ac</span><span class="plain"> = 0;</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">;</span>
        <span class="reserved">while</span><span class="plain"> ((</span><span class="identifier">p</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::prop_seek_atom</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="constant">PREDICATE_ATOM</span><span class="plain">, 1)) != </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Terms::variable_underlying</span><span class="plain">(&amp;(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0])) == 0) </span><span class="identifier">ac</span><span class="plain">++;</span>
            <span class="identifier">p</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">ac</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::contains_adjective is used in 9/pk (<a href="9-pk.html#SP3_2">&#167;3.2</a>).</p>

<p class="endnote">The function Calculus::Propositions::count_unary_predicates is used in 14/ds (<a href="14-ds.html#SP8">&#167;8</a>).</p>

<p class="inwebparagraph"><a id="SP26"></a><b>&#167;26.  </b>The following searches not for an atom, but for the lexically earliest
term in the proposition:
</p>


<pre class="display">
    <span class="reserved">pcalc_term</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::get_first_cited_term</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="identifier">TRAVERSE_VARIABLE</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="identifier">TRAVERSE_PROPOSITION</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> &gt; 0)</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;terms</span><span class="plain">[0];</span>
        <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"Calculus::Propositions::get_first_cited_term on termless proposition"</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0); </span>    <span class="comment">never executed, but needed to prevent <code class="display"><span class="extract">gcc</span></code> warnings</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::get_first_cited_term is used in 11/sc (<a href="11-sc.html#SP3_4">&#167;3.4</a>).</p>

<p class="inwebparagraph"><a id="SP27"></a><b>&#167;27.  </b>Here we attempt, if possible, to read a proposition as being either
adjective(v) or ∃ v: adjective(v), where the adjective
can be also be read as a noun, and if so we return a constant term t for
that noun; or if the proposition isn't in that form, we return t=x, that
is, variable 0.
</p>


<pre class="display">
    <span class="reserved">pcalc_term</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::convert_adj_to_noun</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">pcalc_term</span><span class="plain"> </span><span class="identifier">pct</span><span class="plain"> = </span><span class="functiontext">Calculus::Terms::new_variable</span><span class="plain">(0);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">pct</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Atoms::is_existence_quantifier</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">)) </span><span class="identifier">prop</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">pct</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> != </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">pct</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">PREDICATE_ATOM</span><span class="plain">) &amp;&amp; (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;arity</span><span class="plain"> == 1)) {</span>
            <span class="identifier">adjective_usage</span><span class="plain"> *</span><span class="identifier">tr</span><span class="plain"> = </span><span class="identifier">RETRIEVE_POINTER_adjective_usage</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;predicate</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Terms::adj_to_noun_conversion</span><span class="plain">(</span><span class="identifier">tr</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">KIND_ATOM</span><span class="plain">) {</span>
            <span class="identifier">kind</span><span class="plain"> *</span><span class="identifier">K</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;assert_kind</span><span class="plain">;</span>
            <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">pname</span><span class="plain"> = </span><span class="functiontext">Properties::Conditions::get_coinciding_property</span><span class="plain">(</span><span class="identifier">K</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pname</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Terms::new_constant</span><span class="plain">(</span><span class="functiontext">Rvalues::from_property</span><span class="plain">(</span><span class="identifier">pname</span><span class="plain">));</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">pct</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::convert_adj_to_noun is used in 11/sc (<a href="11-sc.html#SP3_6">&#167;3.6</a>).</p>

<p class="inwebparagraph"><a id="SP28"></a><b>&#167;28.  </b>We often form propositions which are really lists of adjectives, and the
following are useful for looping through them:
</p>


<pre class="display">
    <span class="identifier">adjective_usage</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::first_adjective_usage</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain"> **</span><span class="identifier">ppp</span><span class="plain">) {</span>
        <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::prop_seek_atom</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="constant">PREDICATE_ATOM</span><span class="plain">, 1);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ppp</span><span class="plain">) *</span><span class="identifier">ppp</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::au_from_unary_PREDICATE</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="identifier">adjective_usage</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::next_adjective_usage</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> **</span><span class="identifier">ppp</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ppp</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"bad ppp"</span><span class="plain">);</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::prop_seek_atom</span><span class="plain">((*</span><span class="identifier">ppp</span><span class="plain">)-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="constant">PREDICATE_ATOM</span><span class="plain">, 1);</span>
        <span class="plain">*</span><span class="identifier">ppp</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Atoms::au_from_unary_PREDICATE</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::first_adjective_usage is used in 14/ds (<a href="14-ds.html#SP8">&#167;8</a>).</p>

<p class="endnote">The function Calculus::Propositions::next_adjective_usage is used in 14/ds (<a href="14-ds.html#SP8">&#167;8</a>).</p>

<p class="inwebparagraph"><a id="SP29"></a><b>&#167;29. Bracketed groups. </b>The following routine tests whether the entire proposition is a single
bracketed group. For instance:
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">NEGATION_OPEN --&gt; PREDICATE --&gt; KIND --&gt; NEGATION_CLOSE</span></code>
</p>

<p class="inwebparagraph">would qualify. Note that detection succeeds only if the parentheses match,
and that they may be nested.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::is_a_group</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">governing</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">match</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::element_get_match</span><span class="plain">(</span><span class="identifier">governing</span><span class="plain">), </span><span class="identifier">level</span><span class="plain"> = 0;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">match</span><span class="plain"> == 0) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"Calculus::Propositions::is_a_group called on unmatchable"</span><span class="plain">);</span>
        <span class="identifier">TRAVERSE_VARIABLE</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> != </span><span class="identifier">governing</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">TRAVERSE_PROPOSITION</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Atoms::element_get_group</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain">) == </span><span class="constant">OPEN_OPERATORS_GROUP</span><span class="plain">) </span><span class="identifier">level</span><span class="plain">++;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Atoms::element_get_group</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain">) == </span><span class="constant">CLOSE_OPERATORS_GROUP</span><span class="plain">) </span><span class="identifier">level</span><span class="plain">--;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">p_prev</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="identifier">match</span><span class="plain">) &amp;&amp; (</span><span class="identifier">level</span><span class="plain"> == 0)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::is_a_group is used in <a href="#SP30">&#167;30</a>, <a href="#SP31">&#167;31</a>, 12/dtd (<a href="12-dtd.html#SP7_1_1">&#167;7.1.1</a>).</p>

<p class="inwebparagraph"><a id="SP30"></a><b>&#167;30.  </b>The following removes matched parentheses, leaving just the interior:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::remove_topmost_group</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="identifier">TRAVERSE_VARIABLE</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">prop</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="functiontext">Calculus::Propositions::is_a_group</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">))</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to remove topmost group which wasn't there"</span><span class="plain">);</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">PREDICATE_CALCULUS_WORKINGS</span><span class="plain">, </span><span class="string">"ungrouping proposition: $D\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">);</span>
        <span class="identifier">prop</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
        <span class="identifier">TRAVERSE_PROPOSITION</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">) &amp;&amp; (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">)) { </span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">; </span><span class="reserved">break</span><span class="plain">; }</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">PREDICATE_CALCULUS_WORKINGS</span><span class="plain">, </span><span class="string">"to ungrouped result: $D\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::remove_topmost_group is used in <a href="#SP31">&#167;31</a>, 12/dtd (<a href="12-dtd.html#SP7_1_1">&#167;7.1.1</a>).</p>

<p class="inwebparagraph"><a id="SP31"></a><b>&#167;31.  </b>The main application of which is to remove negation:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::unnegate</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Calculus::Propositions::is_a_group</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="constant">NEGATION_OPEN_ATOM</span><span class="plain">))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::remove_topmost_group</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::unnegate appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP32"></a><b>&#167;32.  </b>More ambitiously, this removes matched parentheses found at any given
point in a proposition (which can continue after the close bracket).
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::ungroup_after</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">position</span><span class="plain">, </span><span class="reserved">pcalc_prop</span><span class="plain"> **</span><span class="identifier">last</span><span class="plain">) {</span>
        <span class="identifier">TRAVERSE_VARIABLE</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">from</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">opener</span><span class="plain">, </span><span class="identifier">closer</span><span class="plain">, </span><span class="identifier">level</span><span class="plain">;</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">PREDICATE_CALCULUS_WORKINGS</span><span class="plain">, </span><span class="string">"removing frontmost group from proposition: $D\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">position</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">from</span><span class="plain"> = </span><span class="identifier">prop</span><span class="plain">; </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">from</span><span class="plain"> = </span><span class="identifier">position</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
        <span class="identifier">opener</span><span class="plain"> = </span><span class="identifier">from</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain">;</span>
        <span class="identifier">closer</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::element_get_match</span><span class="plain">(</span><span class="identifier">opener</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">closer</span><span class="plain"> == 0) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to remove frontmost group which doesn't open"</span><span class="plain">);</span>
        <span class="identifier">from</span><span class="plain"> = </span><span class="identifier">from</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">;</span>
        <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::delete_atom</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">position</span><span class="plain">); </span>    <span class="comment">remove opening atom</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">from</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="identifier">closer</span><span class="plain">) { </span>    <span class="comment">the special case of an empty group</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::delete_atom</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">position</span><span class="plain">); </span>    <span class="comment">remove opening atom</span>
            <span class="reserved">goto</span><span class="plain"> </span><span class="identifier">Ungrouped</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">level</span><span class="plain"> = 0;</span>
        <span class="identifier">TRAVERSE_PROPOSITION</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">from</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="identifier">opener</span><span class="plain">) </span><span class="identifier">level</span><span class="plain">++;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="identifier">closer</span><span class="plain">) </span><span class="identifier">level</span><span class="plain">--;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">level</span><span class="plain"> &lt; 0) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">last</span><span class="plain">) *</span><span class="identifier">last</span><span class="plain"> = </span><span class="identifier">p_prev</span><span class="plain">;</span>
                <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::delete_atom</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">p_prev</span><span class="plain">); </span>    <span class="comment">remove closing atom</span>
                <span class="reserved">goto</span><span class="plain"> </span><span class="identifier">Ungrouped</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"tried to remove frontmost group which doesn't close"</span><span class="plain">);</span>
        <span class="identifier">Ungrouped</span><span class="plain">:</span>
        <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">PREDICATE_CALCULUS_WORKINGS</span><span class="plain">, </span><span class="string">"to ungrouped result: $D\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::ungroup_after is used in <a href="#SP33">&#167;33</a>, 11/sm (<a href="11-sm.html#SP6">&#167;6</a>, <a href="11-sm.html#SP15">&#167;15</a>), 14/ds (<a href="14-ds.html#SP9">&#167;9</a>).</p>

<p class="inwebparagraph"><a id="SP33"></a><b>&#167;33.  </b>Occasionally we want to strip away a "for all", and since that is always
followed by a domain specification, we must also ungroup this:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::trim_universal_quantifier</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">Calculus::Atoms::is_for_all_x</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">)) &amp;&amp;</span>
            <span class="plain">(</span><span class="functiontext">Calculus::Propositions::match</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, 2, </span><span class="constant">QUANTIFIER_ATOM</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="constant">DOMAIN_OPEN_ATOM</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">))) {</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::ungroup_after</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
            <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Propositions::delete_atom</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
            <span class="identifier">LOGIF</span><span class="plain">(</span><span class="identifier">PREDICATE_CALCULUS_WORKINGS</span><span class="plain">, </span><span class="string">"Calculus::Propositions::trim_universal_quantifier: $D\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::trim_universal_quantifier is used in 14/ds (<a href="14-ds.html#SP6">&#167;6</a>).</p>

<p class="inwebparagraph"><a id="SP34"></a><b>&#167;34.  </b>Less ambitiously:
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::remove_final_close_domain</span><span class="plain">(</span><span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">move_domain</span><span class="plain">) {</span>
        <span class="plain">*</span><span class="identifier">move_domain</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="identifier">TRAVERSE_VARIABLE</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
            <span class="identifier">TRAVERSE_PROPOSITION</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">prop</span><span class="plain">)</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) &amp;&amp; (</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;element</span><span class="plain"> == </span><span class="constant">DOMAIN_CLOSE_ATOM</span><span class="plain">)) {</span>
                    <span class="plain">*</span><span class="identifier">move_domain</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Calculus::Propositions::delete_atom</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="identifier">p_prev</span><span class="plain">);</span>
                <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::remove_final_close_domain is used in 11/sc (<a href="11-sc.html#SP1_13">&#167;1.13</a>).</p>

<p class="inwebparagraph"><a id="SP35"></a><b>&#167;35.  </b>The following routine takes a SP and returns the best proposition it can,
with a single unbound variable, to represent SP.
</p>


<pre class="display">
    <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="functiontext">Calculus::Propositions::from_spec</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">spec</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">NULL</span><span class="plain">; </span>    <span class="comment">the null description is universally true</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Specifications::is_description</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="functiontext">Descriptions::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>

        <span class="reserved">pcalc_prop</span><span class="plain"> *</span><span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Specifications::to_proposition</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prop</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">; </span>    <span class="comment">a propositional form is already made</span>

        &lt;<span class="cwebmacro">If this is an instance of a kind, but can be used adjectivally, convert it as such</span> <span class="cwebmacronumber">35.1</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">If it's an either-or property name, it must be being used adjectivally</span> <span class="cwebmacronumber">35.2</span>&gt;<span class="character">;</span>
        &lt;<span class="cwebmacro">It must be an ordinary noun</span> <span class="cwebmacronumber">35.3</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Calculus::Propositions::from_spec is used in 11/sc (<a href="11-sc.html#SP1_3">&#167;1.3</a>, <a href="11-sc.html#SP3_4">&#167;3.4</a>), 12/dtd (<a href="12-dtd.html#SP10">&#167;10</a>, <a href="12-dtd.html#SP13">&#167;13</a>, <a href="12-dtd.html#SP15">&#167;15</a>, <a href="12-dtd.html#SP17">&#167;17</a>, <a href="12-dtd.html#SP18">&#167;18</a>, <a href="12-dtd.html#SP19">&#167;19</a>, <a href="12-dtd.html#SP20">&#167;20</a>, <a href="12-dtd.html#SP21">&#167;21</a>, <a href="12-dtd.html#SP22">&#167;22</a>, <a href="12-dtd.html#SP23">&#167;23</a>), 14/ds (<a href="14-ds.html#SP9">&#167;9</a>).</p>

<p class="inwebparagraph"><a id="SP35_1"></a><b>&#167;35.1.  </b>For example, if we have written:
</p>

<blockquote>
    <p>Colour is a kind of value. The colours are pink, green and black. A thing has a colour.</p>

</blockquote>

<p class="inwebparagraph">then "pink" is both a noun and an adjective. If SP is its representation as a
noun, we return the proposition testing it adjectivally: pink(x).
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">If this is an instance of a kind, but can be used adjectivally, convert it as such</span> <span class="cwebmacronumber">35.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">instance</span><span class="plain"> *</span><span class="identifier">I</span><span class="plain"> = </span><span class="functiontext">Rvalues::to_instance</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">I</span><span class="plain">) {</span>
            <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">pname</span><span class="plain"> = </span><span class="functiontext">Properties::Conditions::get_coinciding_property</span><span class="plain">(</span><span class="functiontext">Instances::to_kind</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">));</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pname</span><span class="plain">) {</span>
                <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::unary_PREDICATE_from_aph</span><span class="plain">(</span><span class="functiontext">Instances::get_adjectival_phrase</span><span class="plain">(</span><span class="identifier">I</span><span class="plain">), </span><span class="identifier">FALSE</span><span class="plain">);</span>
                &lt;<span class="cwebmacro">Typecheck the propositional form, and return</span> <span class="cwebmacronumber">35.1.1</span>&gt;<span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP35">&#167;35</a>.</p>

<p class="inwebparagraph"><a id="SP35_2"></a><b>&#167;35.2.  </b>For example, if the SP is "scenery", we return the proposition scenery(x).
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">If it's an either-or property name, it must be being used adjectivally</span> <span class="cwebmacronumber">35.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Rvalues::is_CONSTANT_construction</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">, </span><span class="identifier">CON_property</span><span class="plain">)) {</span>
            <span class="reserved">property</span><span class="plain"> *</span><span class="identifier">prn</span><span class="plain"> = </span><span class="functiontext">Rvalues::to_property</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Properties::is_either_or</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">)) {</span>
                <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::unary_PREDICATE_from_aph</span><span class="plain">(</span>
                        <span class="functiontext">Properties::EitherOr::get_aph</span><span class="plain">(</span><span class="identifier">prn</span><span class="plain">), </span><span class="identifier">FALSE</span><span class="plain">);</span>
                &lt;<span class="cwebmacro">Typecheck the propositional form, and return</span> <span class="cwebmacronumber">35.1.1</span>&gt;<span class="plain">;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP35">&#167;35</a>.</p>

<p class="inwebparagraph"><a id="SP35_3"></a><b>&#167;35.3.  </b>For example, if the SP is the number 17, we return the proposition is(x, 17).
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">It must be an ordinary noun</span> <span class="cwebmacronumber">35.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">prop</span><span class="plain"> = </span><span class="functiontext">Calculus::Atoms::prop_x_is_constant</span><span class="plain">(</span><span class="identifier">ParseTree::duplicate</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">));</span>
        &lt;<span class="cwebmacro">Typecheck the propositional form, and return</span> <span class="cwebmacronumber">35.1.1</span>&gt;<span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP35">&#167;35</a>.</p>

<p class="inwebparagraph"><a id="SP35_1_1"></a><b>&#167;35.1.1.  </b>In all cases, we finish by doing the following. In the one-atom noun cases
it's a formality, but we want to enforce the rule that all propositions
created in Inform go through type-checking, so:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Typecheck the propositional form, and return</span> <span class="cwebmacronumber">35.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="functiontext">Calculus::Propositions::Checker::type_check</span><span class="plain">(</span><span class="identifier">prop</span><span class="plain">, </span><span class="functiontext">Calculus::Propositions::Checker::tc_no_problem_reporting</span><span class="plain">());</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">prop</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP35_1">&#167;35.1</a>, <a href="#SP35_2">&#167;35.2</a>, <a href="#SP35_3">&#167;35.3</a>.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="11-ap.html">Back to 'Atomic Propositions'</a></li><li><a href="11-bas.html">Continue with 'Binding and Substitution'</a></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

