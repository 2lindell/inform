<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>6/tur</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '6/nv' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#6">Chapter 6: Verbs</a></li><li><b>New Verbs</b></li></ul><p class="purpose">To define verbal forms for relations, in different tenses and numbers.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP4">&#167;4. Inequalities as operator verbs</a></li><li><a href="#SP5">&#167;5. Parsing new verb declarations</a></li><li><a href="#SP14_1">&#167;14.1. I: Semantics</a></li><li><a href="#SP14_2">&#167;14.2. IIa: Syntax of a new verb usage</a></li><li><a href="#SP15">&#167;15. Bootstrapping</a></li><li><a href="#SP17">&#167;17. Runtime conjugation</a></li><li><a href="#SP24">&#167;24. Debug log</a></li><li><a href="#SP25">&#167;25. Index tabulation</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>A single English verb, such as "to contain", produces numerous <code class="display"><span class="extract">verb_usage</span></code>
objects, since we have one for each combination of tense, number and negation
&mdash; "contains", "had not contained", etc. These have upper limits on their
sizes, not so much from the language definition as from limitations on our
implementation of it. But in practice they should never be reached.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">MAX_WORDS_IN_VERB</span><span class="plain"> (</span><span class="identifier">MAX_WORDS_IN_ASSEMBLAGE</span><span class="plain"> - 4)</span>
</pre>
<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b></p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">special_meaning_holder</span><span class="plain"> {</span>
        <span class="reserved">int</span><span class="plain"> (*</span><span class="identifier">sm_func</span><span class="plain">)(</span><span class="reserved">int</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *, </span><span class="identifier">wording</span><span class="plain"> *); </span>    <span class="comment">(for tangling reasons, can't use typedef here)</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">sm_name</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">verb_priority</span><span class="plain">;</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">special_meaning_holder</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure special_meaning_holder is private to this section.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Inequalities as operator verbs. </b>Note that numerical comparisons are handled by two methods. Verbally, they are
prepositions: "less than", for instance, is combined with "to be", giving us
"A is less than B" and similar forms. These wordy forms are therefore defined
as prepositional usages and created as such in the Standard Rules. But we also
permit the use of the familiar mathematical symbols <code class="display"><span class="extract">&lt;</span></code>, <code class="display"><span class="extract">&gt;</span></code>, <code class="display"><span class="extract">&lt;=</span></code> and <code class="display"><span class="extract">&gt;=</span></code>.
Inform treats these as "operator verbs" without tense, so registers them as
verb usages, but without the full conjugation given to a conventional verb;
and they are also excluded from the lexicon in the Phrasebook index, being
notation rather than words. (This is why the variable <code class="display"><span class="extract">current_main_verb</span></code> is
cleared.)
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">inequality</span><span class="plain">-</span><span class="identifier">conjugations</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt; |			</span>    <span class="comment">implies the numerically-less-than relation</span>
        <span class="plain">&gt; |			</span>    <span class="comment">implies the numerically-greater-than relation</span>
        <span class="plain">&lt;= |		</span>    <span class="comment">implies the numerically-less-than-or-equal-to relation</span>
        <span class="plain">&gt;=			</span>    <span class="comment">implies the numerically-greater-than-or-equal-to relation</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">NewVerbs::add_inequalities</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="functiontext">NewVerbs::add_inequalities_inner</span><span class="plain">(</span>
            <span class="functiontext">NewVerbs::ineq_vm</span><span class="plain">(</span><span class="identifier">R_numerically_less_than</span><span class="plain">),</span>
            <span class="functiontext">NewVerbs::ineq_vm</span><span class="plain">(</span><span class="identifier">R_numerically_greater_than</span><span class="plain">),</span>
            <span class="functiontext">NewVerbs::ineq_vm</span><span class="plain">(</span><span class="identifier">R_numerically_less_than_or_equal_to</span><span class="plain">),</span>
            <span class="functiontext">NewVerbs::ineq_vm</span><span class="plain">(</span><span class="identifier">R_numerically_greater_than_or_equal_to</span><span class="plain">));</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">NewVerbs::add_inequalities_inner</span><span class="plain">(</span><span class="identifier">verb_meaning</span><span class="plain"> </span><span class="identifier">lt</span><span class="plain">, </span><span class="identifier">verb_meaning</span><span class="plain"> </span><span class="identifier">gt</span><span class="plain">, </span><span class="identifier">verb_meaning</span><span class="plain"> </span><span class="identifier">le</span><span class="plain">, </span><span class="identifier">verb_meaning</span><span class="plain"> </span><span class="identifier">ge</span><span class="plain">) {</span>
        <span class="identifier">set_where_created</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">current_main_verb</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">VerbUsages::register_single_usage</span><span class="plain">(</span><span class="identifier">Preform::Nonparsing::wording</span><span class="plain">(&lt;</span><span class="identifier">inequality</span><span class="plain">-</span><span class="identifier">conjugations</span><span class="plain">&gt;, 0),</span>
            <span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">IS_TENSE</span><span class="plain">, </span><span class="identifier">ACTIVE_MOOD</span><span class="plain">, </span><span class="identifier">Verbs::new_operator_verb</span><span class="plain">(</span><span class="identifier">lt</span><span class="plain">), </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="identifier">VerbUsages::register_single_usage</span><span class="plain">(</span><span class="identifier">Preform::Nonparsing::wording</span><span class="plain">(&lt;</span><span class="identifier">inequality</span><span class="plain">-</span><span class="identifier">conjugations</span><span class="plain">&gt;, 1),</span>
            <span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">IS_TENSE</span><span class="plain">, </span><span class="identifier">ACTIVE_MOOD</span><span class="plain">, </span><span class="identifier">Verbs::new_operator_verb</span><span class="plain">(</span><span class="identifier">gt</span><span class="plain">), </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="identifier">VerbUsages::register_single_usage</span><span class="plain">(</span><span class="identifier">Preform::Nonparsing::wording</span><span class="plain">(&lt;</span><span class="identifier">inequality</span><span class="plain">-</span><span class="identifier">conjugations</span><span class="plain">&gt;, 2),</span>
            <span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">IS_TENSE</span><span class="plain">, </span><span class="identifier">ACTIVE_MOOD</span><span class="plain">, </span><span class="identifier">Verbs::new_operator_verb</span><span class="plain">(</span><span class="identifier">le</span><span class="plain">), </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="identifier">VerbUsages::register_single_usage</span><span class="plain">(</span><span class="identifier">Preform::Nonparsing::wording</span><span class="plain">(&lt;</span><span class="identifier">inequality</span><span class="plain">-</span><span class="identifier">conjugations</span><span class="plain">&gt;, 3),</span>
            <span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">IS_TENSE</span><span class="plain">, </span><span class="identifier">ACTIVE_MOOD</span><span class="plain">, </span><span class="identifier">Verbs::new_operator_verb</span><span class="plain">(</span><span class="identifier">ge</span><span class="plain">), </span><span class="identifier">FALSE</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="identifier">verb_meaning</span><span class="plain"> </span><span class="functiontext">NewVerbs::ineq_vm</span><span class="plain">(</span><span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">VerbMeanings::new</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function NewVerbs::add_inequalities is used in 1/mr (<a href="1-mr.html#SP4_9">&#167;4.9</a>).</p>

<p class="endnote">The function NewVerbs::add_inequalities_inner appears nowhere else.</p>

<p class="endnote">The function NewVerbs::ineq_vm appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Parsing new verb declarations. </b>In addition to the built-in stock, new verbs can be declared from the
source text. This is where such text is parsed and acted upon.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">PROP_VERBM</span><span class="plain"> 1</span>
    <span class="definitionkeyword">define</span> <span class="constant">REL_VERBM</span><span class="plain"> 2</span>
    <span class="definitionkeyword">define</span> <span class="constant">VM_VERBM</span><span class="plain"> 3</span>
    <span class="definitionkeyword">define</span> <span class="constant">BUILTIN_VERBM</span><span class="plain"> 4</span>
    <span class="definitionkeyword">define</span> <span class="constant">NONE_VERBM</span><span class="plain"> 5</span>
</pre>
<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b>This is the grammar for parsing new verb declarations:
</p>

<blockquote>
    <p>The verb to suspect (he suspects, they suspect, he suspected, it is suspected, he is suspecting) implies the suspecting relation.</p>

</blockquote>

<blockquote>
    <p>The verb to be suspicious of implies the suspecting relation.</p>

</blockquote>

<p class="inwebparagraph">The "Verb Phrases" section left this sentence with the text after
"The verb to..." as the subject, and the text after "implies the"
as the object.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">implies</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt; ::=</span>
        <span class="identifier">in</span><span class="plain"> &lt;</span><span class="identifier">natural</span><span class="plain">-</span><span class="identifier">language</span><span class="plain">&gt; &lt;</span><span class="identifier">infinitive</span><span class="plain">-</span><span class="identifier">declaration</span><span class="plain">&gt; |	==&gt; </span><span class="identifier">R</span><span class="plain">[2]; &lt;&lt;</span><span class="reserved">natural_language</span><span class="plain">:</span><span class="identifier">nl</span><span class="plain">&gt;&gt; = (</span><span class="reserved">natural_language</span><span class="plain"> *) (</span><span class="identifier">RP</span><span class="plain">[1]);</span>
        <span class="plain">&lt;</span><span class="identifier">infinitive</span><span class="plain">-</span><span class="identifier">declaration</span><span class="plain">&gt;							==&gt; </span><span class="identifier">R</span><span class="plain">[1]; &lt;&lt;</span><span class="reserved">natural_language</span><span class="plain">:</span><span class="identifier">nl</span><span class="plain">&gt;&gt; = </span><span class="identifier">English_language</span><span class="plain">;</span>

    <span class="plain">&lt;</span><span class="identifier">infinitive</span><span class="plain">-</span><span class="identifier">declaration</span><span class="plain">&gt; ::=</span>
        <span class="identifier">to</span><span class="plain"> &lt;</span><span class="identifier">infinitive</span><span class="plain">-</span><span class="identifier">usage</span><span class="plain">&gt; ( ... ) |		==&gt; </span><span class="identifier">R</span><span class="plain">[1]; &lt;&lt;</span><span class="identifier">giving</span><span class="plain">-</span><span class="identifier">parts</span><span class="plain">&gt;&gt; = </span><span class="identifier">TRUE</span>
        <span class="identifier">to</span><span class="plain"> &lt;</span><span class="identifier">infinitive</span><span class="plain">-</span><span class="identifier">usage</span><span class="plain">&gt; |				==&gt; </span><span class="identifier">R</span><span class="plain">[1]; &lt;&lt;</span><span class="identifier">giving</span><span class="plain">-</span><span class="identifier">parts</span><span class="plain">&gt;&gt; = </span><span class="identifier">FALSE</span>
        <span class="plain">&lt;</span><span class="identifier">infinitive</span><span class="plain">-</span><span class="identifier">usage</span><span class="plain">&gt; ( ... ) |		==&gt; </span><span class="identifier">R</span><span class="plain">[1]; &lt;&lt;</span><span class="identifier">giving</span><span class="plain">-</span><span class="identifier">parts</span><span class="plain">&gt;&gt; = </span><span class="identifier">TRUE</span>
        <span class="plain">&lt;</span><span class="identifier">infinitive</span><span class="plain">-</span><span class="identifier">usage</span><span class="plain">&gt;					==&gt; </span><span class="identifier">R</span><span class="plain">[1]; &lt;&lt;</span><span class="identifier">giving</span><span class="plain">-</span><span class="identifier">parts</span><span class="plain">&gt;&gt; = </span><span class="identifier">FALSE</span>

    <span class="plain">&lt;</span><span class="identifier">infinitive</span><span class="plain">-</span><span class="identifier">usage</span><span class="plain">&gt; ::=</span>
        <span class="plain">{</span><span class="identifier">be</span><span class="plain"> </span><span class="identifier">able</span><span class="plain"> </span><span class="identifier">to</span><span class="plain"> ...} |					==&gt; </span><span class="identifier">TRUE</span>
        <span class="plain">{</span><span class="identifier">be</span><span class="plain"> </span><span class="identifier">able</span><span class="plain"> </span><span class="identifier">to</span><span class="plain">} |						==&gt; </span><span class="identifier">TRUE</span>
        <span class="plain">...									==&gt; </span><span class="identifier">FALSE</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>The text in brackets, if given, is a comma-separated list of conjugations
of the verb. Each one is matched against this:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">conjugation</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">nominative</span><span class="plain">-</span><span class="identifier">pronoun</span><span class="plain">&gt; </span><span class="identifier">is</span><span class="plain">/</span><span class="identifier">are</span><span class="plain"> ... |	==&gt; </span><span class="identifier">R</span><span class="plain">[1]; &lt;&lt;</span><span class="identifier">is</span><span class="plain">-</span><span class="identifier">participle</span><span class="plain">&gt;&gt; = </span><span class="identifier">TRUE</span>
        <span class="plain">&lt;</span><span class="identifier">nominative</span><span class="plain">-</span><span class="identifier">pronoun</span><span class="plain">&gt; ...			==&gt; </span><span class="identifier">R</span><span class="plain">[1]; &lt;&lt;</span><span class="identifier">is</span><span class="plain">-</span><span class="identifier">participle</span><span class="plain">&gt;&gt; = </span><span class="identifier">FALSE</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>This syntax was a design mistake. It generalises badly to other languages,
and doesn't even work perfectly for English. The problem is that the source
text is allowed to give only a selection of the parts of the verb, and
Inform has to guess which parts. So how does it distinguish "X is suspected"
from "X is suspecting"? It needs to know which is the present participle,
and it does this by looking for an -ing ending on either the first or
last word. The following nonterminal matches for that.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">participle</span><span class="plain">-</span><span class="identifier">like</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">probable</span><span class="plain">-</span><span class="identifier">participle</span><span class="plain">&gt; *** |</span>
        <span class="plain">*** &lt;</span><span class="identifier">probable</span><span class="plain">-</span><span class="identifier">participle</span><span class="plain">&gt;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b>And now for the object noun phrase in the sentence.
</p>

<p class="inwebparagraph">The use of <code class="display"><span class="extract">... property</span></code> perhaps looks odd. What happens if the user typed
</p>

<blockquote>
    <p>The verb to be mystified by implies the arfle barfle gloop property.</p>

</blockquote>

<p class="inwebparagraph">when there is no property of that name? The answer is that we can't check this
at the time we're parsing this sentence, because verb definitions are read long
before properties come into existence. The check will be made later on, and for
now absolutely any non-empty word range is accepted as the property name.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">implies</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt; ::=</span>
        <span class="identifier">reversed</span><span class="plain"> &lt;</span><span class="identifier">relation</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">relation</span><span class="plain"> |		==&gt; </span><span class="constant">REL_VERBM</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="functiontext">BinaryPredicates::get_reversal</span><span class="plain">(</span><span class="identifier">RP</span><span class="plain">[1])</span>
        <span class="plain">&lt;</span><span class="identifier">relation</span><span class="plain">-</span><span class="identifier">name</span><span class="plain">&gt; </span><span class="identifier">relation</span><span class="plain"> |				==&gt; </span><span class="constant">REL_VERBM</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="identifier">to</span><span class="plain"> &lt;</span><span class="reserved">instance</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">-</span><span class="identifier">infinitive</span><span class="plain">-</span><span class="identifier">form</span><span class="plain">&gt; |		==&gt; </span>&lt;<span class="cwebmacro">Use verb infinitive as shorthand</span> <span class="cwebmacronumber">9.4</span>&gt;
        <span class="plain">... </span><span class="reserved">property</span><span class="plain"> |							==&gt; </span><span class="constant">PROP_VERBM</span>
        <span class="identifier">built</span><span class="plain">-</span><span class="identifier">in</span><span class="plain"> ... </span><span class="identifier">meaning</span><span class="plain"> |					==&gt; </span><span class="constant">BUILTIN_VERBM</span>
        <span class="plain">... </span><span class="identifier">relation</span><span class="plain"> |							==&gt; </span>&lt;<span class="cwebmacro">Issue PM_VerbRelationUnknown problem</span> <span class="cwebmacronumber">9.1</span>&gt;
        <span class="plain">{</span><span class="identifier">relation</span><span class="plain">} |							==&gt; </span>&lt;<span class="cwebmacro">Issue PM_VerbRelationVague problem</span> <span class="cwebmacronumber">9.2</span>&gt;
        <span class="plain">...										==&gt; </span>&lt;<span class="cwebmacro">Issue PM_VerbUnknownMeaning problem</span> <span class="cwebmacronumber">9.3</span>&gt;
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9_1"></a><b>&#167;9.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_VerbRelationUnknown problem</span> <span class="cwebmacronumber">9.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">NONE_VERBM</span><span class="plain">;</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_VerbRelationUnknown</span><span class="plain">),</span>
            <span class="string">"new verbs can only be defined in terms of existing relations"</span><span class="plain">,</span>
            <span class="string">"all of which have names ending 'relation': thus '...implies the "</span>
            <span class="string">"possession relation' is an example of a valid definition, this "</span>
            <span class="string">"being one of the relations built into Inform."</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP9">&#167;9</a>.</p>

<p class="inwebparagraph"><a id="SP9_2"></a><b>&#167;9.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_VerbRelationVague problem</span> <span class="cwebmacronumber">9.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">NONE_VERBM</span><span class="plain">;</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_VerbRelationVague</span><span class="plain">),</span>
            <span class="string">"that's too vague"</span><span class="plain">,</span>
            <span class="string">"calling a relation simply 'relation'."</span><span class="plain">);</span>

</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP9">&#167;9</a>.</p>

<p class="inwebparagraph"><a id="SP9_3"></a><b>&#167;9.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue PM_VerbUnknownMeaning problem</span> <span class="cwebmacronumber">9.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">NONE_VERBM</span><span class="plain">;</span>
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_VerbUnknownMeaning</span><span class="plain">),</span>
            <span class="string">"I don't see what the meaning of this verb ought to be"</span><span class="plain">,</span>
            <span class="string">"because it doesn't take any of the three forms I know: a relation "</span>
            <span class="string">"name ('...means the wearing relation'), a property name ('...means "</span>
            <span class="string">"the matching key property'), or another verb ('...means to wear.')."</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP9">&#167;9</a>.</p>

<p class="inwebparagraph"><a id="SP9_4"></a><b>&#167;9.4.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Use verb infinitive as shorthand</span> <span class="cwebmacronumber">9.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">VM_VERBM</span><span class="plain">;</span>
        <span class="identifier">verb_form</span><span class="plain"> *</span><span class="identifier">vf</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="identifier">verb_meaning</span><span class="plain"> *</span><span class="identifier">vm</span><span class="plain"> = </span><span class="identifier">Verbs::regular_meaning_from_form</span><span class="plain">(</span><span class="identifier">vf</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vm</span><span class="plain">) {</span>
            <span class="plain">*</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">vm</span><span class="plain">;</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="plain">*</span><span class="identifier">X</span><span class="plain"> = </span><span class="constant">NONE_VERBM</span><span class="plain">;</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">),</span>
                <span class="string">"that's another verb which has no meaning at present"</span><span class="plain">,</span>
                <span class="string">"so this doesn't help me."</span><span class="plain">);</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP9">&#167;9</a>.</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>This handles the special meaning "X is a verb...".
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">new</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">indefinite</span><span class="plain">-</span><span class="identifier">article</span><span class="plain">&gt; &lt;</span><span class="identifier">new</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">unarticled</span><span class="plain">&gt; |	==&gt; </span><span class="identifier">R</span><span class="plain">[2]; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2]</span>
        <span class="plain">&lt;</span><span class="identifier">new</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">unarticled</span><span class="plain">&gt;							==&gt; </span><span class="identifier">R</span><span class="plain">[1]; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">new</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">unarticled</span><span class="plain">&gt; ::=</span>
        <span class="identifier">verb</span><span class="plain"> |															==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">verb</span><span class="plain"> </span><span class="identifier">implying</span><span class="plain">/</span><span class="identifier">meaning</span><span class="plain"> &lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">definite</span><span class="plain">&gt;						==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">NewVerbs::new_verb_SMF</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">NPs</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[0]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[1]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) { </span>    <span class="comment">"To grow is a verb."</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ACCEPT_SMFT</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">new</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">)) {</span>
                    <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt; == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
                    <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="constant">SPECIAL_MEANING_VB</span><span class="plain">);</span>
                    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">O</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">O</span><span class="plain">;</span>
                    <span class="functiontext">NewVerbs::parse_new</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function NewVerbs::new_verb_SMF is used in <a href="#SP16">&#167;16</a>.</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b>And this handles the special meaning "The verb X means...".
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">means</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">definite</span><span class="plain">-</span><span class="identifier">article</span><span class="plain">&gt; &lt;</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">means</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">-</span><span class="identifier">unarticled</span><span class="plain">&gt; |	==&gt; </span><span class="identifier">R</span><span class="plain">[2]; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2]</span>
        <span class="plain">&lt;</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">means</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">-</span><span class="identifier">unarticled</span><span class="plain">&gt;							==&gt; </span><span class="identifier">R</span><span class="plain">[1]; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">means</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">-</span><span class="identifier">unarticled</span><span class="plain">&gt; ::=</span>
        <span class="identifier">verb</span><span class="plain"> </span><span class="identifier">to</span><span class="plain"> |														==&gt; </span><span class="identifier">FALSE</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FAIL_NONTERMINAL</span><span class="plain">;</span>
        <span class="identifier">verb</span><span class="plain"> &lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt; </span><span class="identifier">in</span><span class="plain"> </span><span class="identifier">the</span><span class="plain"> </span><span class="identifier">imperative</span><span class="plain"> |							==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
        <span class="identifier">verb</span><span class="plain"> &lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt;												==&gt; </span><span class="identifier">FALSE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">NewVerbs::verb_means_SMF</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">NPs</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[0]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[1]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) { </span>    <span class="comment">"The verb to grow means the growing relation."</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ACCEPT_SMFT</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">means</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">)) {</span>
                    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">imperative_flag</span><span class="plain"> = &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;;</span>
                    <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="constant">SPECIAL_MEANING_VB</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">articled</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="functiontext">NewVerbs::parse_new</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">imperative_flag</span><span class="plain">);</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function NewVerbs::verb_means_SMF is used in <a href="#SP16">&#167;16</a>.</p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="identifier">new_verb_sequence_count</span><span class="plain"> = 0;</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">NewVerbs::parse_new</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">PN</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">imperative</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">; </span>    <span class="comment">wording of the parts of speech</span>
        <span class="identifier">verb_meaning</span><span class="plain"> </span><span class="identifier">vm</span><span class="plain"> = </span><span class="identifier">VerbMeanings::meaninglessness</span><span class="plain">(); </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">meaning_given</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">priority</span><span class="plain"> = -1;</span>
        <span class="identifier">set_where_created</span><span class="plain"> = </span><span class="identifier">current_sentence</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">PN</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">)</span>
            &lt;<span class="cwebmacro">Find the underlying relation of the new verb or preposition</span> <span class="cwebmacronumber">14.1</span>&gt;<span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">implies</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">PN</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">))) {</span>
            <span class="reserved">natural_language</span><span class="plain"> *</span><span class="identifier">nl</span><span class="plain"> = &lt;&lt;</span><span class="reserved">natural_language</span><span class="plain">:</span><span class="identifier">nl</span><span class="plain">&gt;&gt;;</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">r</span><span class="plain"> = &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;;</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">infinitive</span><span class="plain">-</span><span class="identifier">usage</span><span class="plain">&gt;, 1);</span>
            <span class="reserved">if</span><span class="plain"> (&lt;&lt;</span><span class="identifier">giving</span><span class="plain">-</span><span class="identifier">parts</span><span class="plain">&gt;&gt;) </span><span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">infinitive</span><span class="plain">-</span><span class="identifier">declaration</span><span class="plain">&gt;, 1);</span>

            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">unexpected_upper_casing_used</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            &lt;<span class="cwebmacro">Determine if unexpected upper casing is used in wording</span> <span class="cwebmacronumber">14.4</span>&gt;<span class="plain">;</span>

            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">V</span><span class="plain"> = </span><span class="identifier">W</span><span class="plain">;</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">P</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SP</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">divided</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Lexer::word</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">) == </span><span class="identifier">PLUS_V</span><span class="plain">) &amp;&amp;</span>
                    <span class="plain">(</span><span class="identifier">pos</span><span class="plain"> &gt; </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) &amp;&amp; (</span><span class="identifier">pos</span><span class="plain"> &lt; </span><span class="identifier">Wordings::last_wn</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">))) {</span>
                    <span class="identifier">divided</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                    <span class="identifier">SP</span><span class="plain"> = </span><span class="identifier">Wordings::from</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">pos</span><span class="plain">+1);</span>
                    <span class="identifier">V</span><span class="plain"> = </span><span class="identifier">Wordings::up_to</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">pos</span><span class="plain">-1);</span>
                    <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Wordings::up_to</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">pos</span><span class="plain">-1);</span>
                    <span class="reserved">break</span><span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">) &gt; 1) &amp;&amp; (</span><span class="identifier">r</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) {</span>
                <span class="identifier">V</span><span class="plain"> = </span><span class="identifier">Wordings::first_word</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
                <span class="identifier">P</span><span class="plain"> = </span><span class="identifier">Wordings::trim_first_word</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">) &gt; </span><span class="identifier">MAX_WORDS_IN_PREPOSITION</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">SP</span><span class="plain">) &gt; </span><span class="identifier">MAX_WORDS_IN_PREPOSITION</span><span class="plain">)) {</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_PrepositionLong</span><span class="plain">),</span>
                    <span class="string">"prepositions can be very long indeed in today's Inform"</span><span class="plain">,</span>
                    <span class="string">"but not as long as this."</span><span class="plain">);</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="identifier">verb_identity</span><span class="plain"> *</span><span class="identifier">vi</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="identifier">preposition_identity</span><span class="plain"> *</span><span class="identifier">prep</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="identifier">preposition_identity</span><span class="plain"> *</span><span class="identifier">second_prep</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">)) </span>&lt;<span class="cwebmacro">Find or create a new verb</span> <span class="cwebmacronumber">14.5</span>&gt;<span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">))</span>
                <span class="identifier">prep</span><span class="plain"> = </span><span class="identifier">Prepositions::make</span><span class="plain">(</span><span class="identifier">WordAssemblages::from_wording</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">),</span>
                    <span class="identifier">unexpected_upper_casing_used</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">SP</span><span class="plain">))</span>
                <span class="identifier">second_prep</span><span class="plain"> = </span><span class="identifier">Prepositions::make</span><span class="plain">(</span><span class="identifier">WordAssemblages::from_wording</span><span class="plain">(</span><span class="identifier">SP</span><span class="plain">),</span>
                    <span class="identifier">unexpected_upper_casing_used</span><span class="plain">);</span>

            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">meaning_given</span><span class="plain">) {</span>
                <span class="identifier">verb_meaning</span><span class="plain"> *</span><span class="identifier">current</span><span class="plain"> = </span><span class="identifier">Verbs::regular_meaning</span><span class="plain">(</span><span class="identifier">vi</span><span class="plain">, </span><span class="identifier">prep</span><span class="plain">, </span><span class="identifier">second_prep</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">VerbMeanings::is_meaningless</span><span class="plain">(</span><span class="identifier">current</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) {</span>
                    <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Currently $w means $y\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">vi</span><span class="plain">, </span><span class="identifier">current</span><span class="plain">);</span>
                    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">where</span><span class="plain"> = </span><span class="identifier">VerbMeanings::get_where_assigned</span><span class="plain">(</span><span class="identifier">current</span><span class="plain">);</span>
                    &lt;<span class="cwebmacro">Issue the actual problem message</span> <span class="cwebmacronumber">14.6</span>&gt;<span class="plain">;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>

            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">structures</span><span class="plain"> = 0;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">imperative</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">divided</span><span class="plain">) </span><span class="identifier">structures</span><span class="plain"> = </span><span class="identifier">VOO_FS_BIT</span><span class="plain">;</span>
                <span class="identifier">structures</span><span class="plain"> = </span><span class="identifier">VO_FS_BIT</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">divided</span><span class="plain">) </span><span class="identifier">structures</span><span class="plain"> = </span><span class="identifier">SVOO_FS_BIT</span><span class="plain">;</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="identifier">structures</span><span class="plain"> = </span><span class="identifier">SVO_FS_BIT</span><span class="plain">;</span>
            <span class="plain">}</span>

            <span class="identifier">Verbs::add_form</span><span class="plain">(</span><span class="identifier">vi</span><span class="plain">, </span><span class="identifier">prep</span><span class="plain">, </span><span class="identifier">second_prep</span><span class="plain">, </span><span class="identifier">vm</span><span class="plain">, </span><span class="identifier">structures</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function NewVerbs::parse_new is used in <a href="#SP11">&#167;11</a>, <a href="#SP13">&#167;13</a>.</p>

<p class="inwebparagraph"><a id="SP14_1"></a><b>&#167;14.1. I: Semantics. </b></p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Find the underlying relation of the new verb or preposition</span> <span class="cwebmacronumber">14.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="plain">&lt;</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">implies</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">PN</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">));</span>
        <span class="reserved">switch</span><span class="plain"> (&lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">PROP_VERBM</span><span class="plain">: {</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">RW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">implies</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;, 1);</span>
                <span class="identifier">vm</span><span class="plain"> = </span><span class="identifier">VerbMeanings::new</span><span class="plain">(</span><span class="functiontext">Properties::SettingRelations::make_set_property_BP</span><span class="plain">(</span><span class="identifier">RW</span><span class="plain">), </span><span class="identifier">NULL</span><span class="plain">); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">REL_VERBM</span><span class="plain">:</span>
                <span class="identifier">vm</span><span class="plain"> = </span><span class="identifier">VerbMeanings::new</span><span class="plain">(&lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;, </span><span class="identifier">NULL</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">BUILTIN_VERBM</span><span class="plain">: {</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">MW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">verb</span><span class="plain">-</span><span class="identifier">implies</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;, 1);</span>
                <span class="identifier">vm</span><span class="plain"> = </span><span class="functiontext">NewVerbs::sm_by_name</span><span class="plain">(</span><span class="identifier">Lexer::word_text</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">MW</span><span class="plain">)), &amp;</span><span class="identifier">priority</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">MW</span><span class="plain">) != 1) || (</span><span class="identifier">VerbMeanings::is_meaningless</span><span class="plain">(&amp;</span><span class="identifier">vm</span><span class="plain">))) {</span>
                    <span class="plain">#</span><span class="identifier">ifndef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
                    <span class="identifier">source_file</span><span class="plain"> *</span><span class="identifier">pos</span><span class="plain"> = </span><span class="identifier">Lexer::file_of_origin</span><span class="plain">(</span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">MW</span><span class="plain">));</span>
                    <span class="reserved">extension_file</span><span class="plain"> *</span><span class="identifier">loc</span><span class="plain"> = </span><span class="functiontext">SourceFiles::get_extension_corresponding</span><span class="plain">(</span><span class="identifier">pos</span><span class="plain">);</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">loc</span><span class="plain"> == </span><span class="identifier">standard_rules_extension</span><span class="plain">) </span><span class="reserved">return</span><span class="plain">;</span>
                    <span class="plain">#</span><span class="identifier">endif</span>
                    <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_NoSuchBuiltInMeaning</span><span class="plain">),</span>
                        <span class="string">"that's not one of the built-in meanings I know"</span><span class="plain">,</span>
                        <span class="string">"and should be one of the ones used in the Preamble to the "</span>
                        <span class="string">"Standard Rules."</span><span class="plain">);</span>
                    <span class="identifier">vm</span><span class="plain"> = </span><span class="identifier">VerbMeanings::new</span><span class="plain">(</span><span class="identifier">R_equality</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">VM_VERBM</span><span class="plain">: </span><span class="identifier">vm</span><span class="plain"> = *((</span><span class="identifier">verb_meaning</span><span class="plain"> *) (&lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;)); </span><span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">default</span><span class="plain">: </span><span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">meaning_given</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP14">&#167;14</a>.</p>

<p class="inwebparagraph"><a id="SP14_2"></a><b>&#167;14.2. IIa: Syntax of a new verb usage. </b></p>

<p class="inwebparagraph"><a id="SP14_3"></a><b>&#167;14.3.  </b>The following can define both a verb and a preposition, coupling them
together, or can define either one alone.
</p>

<p class="inwebparagraph">We shouldn't really use the same sentence form to define prepositions as they
do to define verbs: but it's easy to remember, and convenient, and no
alternative seems better, so we go along with it, and allow
</p>

<blockquote>
    <p>The verb to be beneath implies ...</p>

</blockquote>

<p class="inwebparagraph">even though this is not the definition of a verb at all, and it is only
"beneath" which is being defined.
</p>

<p class="inwebparagraph"><a id="SP14_4"></a><b>&#167;14.4.  </b>Casing problems are acutely problematic with prepositions, because so many
locations have names which begin with them &mdash; "Under Milkwood", "Inside the
Machine", "On Top of Old Smoky". Our best way to avoid confusion is to read
prepositions as such only when they do not unexpectedly jump into upper case,
i.e., to distinguish between the meanings of
</p>

<blockquote>
    <p>X is in Bahrain. Y is In Bahrain.</p>

</blockquote>

<p class="inwebparagraph">according to the unexpected capital I in the second "In". But just occasionally
people do want to define prepositions which genuinely involve an unexpected
upper-case letter; and those we flag for special treatment, since otherwise
they could never be parsed successfully.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Determine if unexpected upper casing is used in wording</span> <span class="cwebmacronumber">14.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">LOOP_THROUGH_WORDING</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">W</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Word::unexpectedly_upper_case</span><span class="plain">(</span><span class="identifier">i</span><span class="plain">))</span>
                <span class="identifier">unexpected_upper_casing_used</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP14">&#167;14</a>.</p>

<p class="inwebparagraph"><a id="SP14_5"></a><b>&#167;14.5.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Find or create a new verb</span> <span class="cwebmacronumber">14.5</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">word_assemblage</span><span class="plain"> </span><span class="identifier">infinitive</span><span class="plain"> = </span><span class="identifier">WordAssemblages::from_wording</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">);</span>
        <span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        &lt;<span class="cwebmacro">Conjugate the new verb</span> <span class="cwebmacronumber">14.5.1</span>&gt;<span class="plain">;</span>

        <span class="identifier">vi</span><span class="plain"> = </span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">vc_conjugates</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vi</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span>&lt;<span class="cwebmacro">Register the new verb's usage</span> <span class="cwebmacronumber">14.5.2</span>&gt;<span class="character">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP14">&#167;14</a>.</p>

<p class="inwebparagraph"><a id="SP14_5_1"></a><b>&#167;14.5.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Conjugate the new verb</span> <span class="cwebmacronumber">14.5.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">word_assemblage</span><span class="plain"> </span><span class="identifier">present_singular</span><span class="plain"> = </span><span class="identifier">WordAssemblages::lit_0</span><span class="plain">();</span>
        <span class="identifier">word_assemblage</span><span class="plain"> </span><span class="identifier">present_plural</span><span class="plain"> = </span><span class="identifier">WordAssemblages::lit_0</span><span class="plain">();</span>
        <span class="identifier">word_assemblage</span><span class="plain"> </span><span class="identifier">past</span><span class="plain"> = </span><span class="identifier">WordAssemblages::lit_0</span><span class="plain">();</span>
        <span class="identifier">word_assemblage</span><span class="plain"> </span><span class="identifier">past_participle</span><span class="plain"> = </span><span class="identifier">WordAssemblages::lit_0</span><span class="plain">();</span>
        <span class="identifier">word_assemblage</span><span class="plain"> </span><span class="identifier">participle</span><span class="plain"> = </span><span class="identifier">WordAssemblages::lit_0</span><span class="plain">();</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">PW</span><span class="plain">)) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">improper_parts</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            &lt;<span class="cwebmacro">Parse the parts of speech supplied for the verb</span> <span class="cwebmacronumber">14.5.1.1</span>&gt;<span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">improper_parts</span><span class="plain">) </span>&lt;<span class="cwebmacro">Give up on verb definition as malformed</span> <span class="cwebmacronumber">14.5.1.2</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">word_assemblage</span><span class="plain"> </span><span class="identifier">overrides</span><span class="plain">[7];</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">no_overrides</span><span class="plain"> = 7;</span>
        <span class="identifier">overrides</span><span class="plain">[</span><span class="identifier">BASE_FORM_TYPE</span><span class="plain">] = </span><span class="identifier">WordAssemblages::lit_0</span><span class="plain">();</span>
        <span class="identifier">overrides</span><span class="plain">[</span><span class="identifier">INFINITIVE_FORM_TYPE</span><span class="plain">] = </span><span class="identifier">present_plural</span><span class="plain">;</span>
        <span class="identifier">overrides</span><span class="plain">[</span><span class="identifier">PAST_PARTICIPLE_FORM_TYPE</span><span class="plain">] = </span><span class="identifier">past_participle</span><span class="plain">;</span>
        <span class="identifier">overrides</span><span class="plain">[</span><span class="identifier">PRESENT_PARTICIPLE_FORM_TYPE</span><span class="plain">] = </span><span class="identifier">participle</span><span class="plain">;</span>
        <span class="identifier">overrides</span><span class="plain">[</span><span class="identifier">ADJOINT_INFINITIVE_FORM_TYPE</span><span class="plain">] = </span><span class="identifier">WordAssemblages::lit_0</span><span class="plain">();</span>
        <span class="identifier">overrides</span><span class="plain">[5] = </span><span class="identifier">present_singular</span><span class="plain">;</span>
        <span class="identifier">overrides</span><span class="plain">[6] = </span><span class="identifier">past</span><span class="plain">;</span>

        <span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">nvc</span><span class="plain"> = </span><span class="identifier">Conjugation::conjugate_with_overrides</span><span class="plain">(</span><span class="identifier">infinitive</span><span class="plain">, </span><span class="identifier">overrides</span><span class="plain">, </span><span class="identifier">no_overrides</span><span class="plain">, </span><span class="identifier">nl</span><span class="plain">);</span>

        <span class="identifier">vc</span><span class="plain"> = </span><span class="identifier">Conjugation::find_prior</span><span class="plain">(</span><span class="identifier">nvc</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vc</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">vc</span><span class="plain"> = </span><span class="identifier">nvc</span><span class="plain">;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">PW</span><span class="plain">)) {</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">vc</span><span class="plain">) &amp;&amp; (</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">vc_conjugates</span><span class="plain"> == </span><span class="identifier">copular_verb</span><span class="plain">))</span>
                &lt;<span class="cwebmacro">Reject with a problem message if preposition is conjugated</span> <span class="cwebmacronumber">14.5.1.3</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP14_5">&#167;14.5</a>.</p>

<p class="inwebparagraph"><a id="SP14_5_1_1"></a><b>&#167;14.5.1.1.  </b>We read the parts of speech as a comma-separated list of individual parts
(but we don't allow "and" or "or" to divide this list: only commas).
</p>

<p class="inwebparagraph">At the end, if no present plural is supplied, we may as well use the
infinitive for that &mdash; the two are the same in most regular English verbs
("to sleep", "they sleep") even if not irregular ones ("to be",
"they are").
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Parse the parts of speech supplied for the verb</span> <span class="cwebmacronumber">14.5.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">more_to_read</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">participle_count</span><span class="plain"> = 0;</span>
        <span class="reserved">while</span><span class="plain"> (</span><span class="identifier">more_to_read</span><span class="plain">) {</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">CW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
            <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">list</span><span class="plain">-</span><span class="identifier">comma</span><span class="plain">-</span><span class="identifier">division</span><span class="plain">&gt;(</span><span class="identifier">PW</span><span class="plain">)) {</span>
                <span class="identifier">CW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">list</span><span class="plain">-</span><span class="identifier">comma</span><span class="plain">-</span><span class="identifier">division</span><span class="plain">&gt;, 1);</span>
                <span class="identifier">PW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">list</span><span class="plain">-</span><span class="identifier">comma</span><span class="plain">-</span><span class="identifier">division</span><span class="plain">&gt;, 2);</span>
                <span class="identifier">more_to_read</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="identifier">CW</span><span class="plain"> = </span><span class="identifier">PW</span><span class="plain">;</span>
                <span class="identifier">more_to_read</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="plain">}</span>
            &lt;<span class="cwebmacro">Parse the part of speech in this clause</span> <span class="cwebmacronumber">14.5.1.1.1</span>&gt;<span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::nonempty</span><span class="plain">(</span><span class="identifier">present_plural</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">present_plural</span><span class="plain"> = </span><span class="identifier">infinitive</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP14_5_1">&#167;14.5.1</a>.</p>

<p class="inwebparagraph"><a id="SP14_5_1_1_1"></a><b>&#167;14.5.1.1.1.  </b>Note that the suffix "-ing" is used to distinguish the present participle
("he is grabbing") from the past ("he is grabbed").
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Parse the part of speech in this clause</span> <span class="cwebmacronumber">14.5.1.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((&lt;</span><span class="identifier">conjugation</span><span class="plain">&gt;(</span><span class="identifier">CW</span><span class="plain">)) == </span><span class="identifier">FALSE</span><span class="plain">)</span>
            &lt;<span class="cwebmacro">Give up on verb definition as malformed</span> <span class="cwebmacronumber">14.5.1.2</span>&gt;<span class="plain">;</span>
        <span class="identifier">CW</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">conjugation</span><span class="plain">&gt;, 1);</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">number</span><span class="plain"> = &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">is_a_participle</span><span class="plain"> = &lt;&lt;</span><span class="identifier">is</span><span class="plain">-</span><span class="identifier">participle</span><span class="plain">&gt;&gt;;</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">)) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">L</span><span class="plain"> = </span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">P</span><span class="plain">), </span><span class="identifier">C</span><span class="plain"> = </span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">CW</span><span class="plain">);</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Looking at %W (%d) and %W (%d)\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">P</span><span class="plain">, </span><span class="identifier">L</span><span class="plain">, </span><span class="identifier">CW</span><span class="plain">, </span><span class="identifier">C</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">C</span><span class="plain"> &gt;= </span><span class="identifier">L</span><span class="plain">) {</span>
                <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">T</span><span class="plain"> = </span><span class="identifier">Wordings::from</span><span class="plain">(</span><span class="identifier">CW</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">CW</span><span class="plain">) + </span><span class="identifier">C</span><span class="plain">-</span><span class="identifier">L</span><span class="plain">);</span>
                <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Tail %W\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">T</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::match</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">, </span><span class="identifier">P</span><span class="plain">)) {</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">C</span><span class="plain"> &gt; </span><span class="identifier">L</span><span class="plain">) </span><span class="identifier">CW</span><span class="plain"> = </span><span class="identifier">Wordings::truncate</span><span class="plain">(</span><span class="identifier">CW</span><span class="plain">, </span><span class="identifier">C</span><span class="plain">-</span><span class="identifier">L</span><span class="plain">);</span>
                    <span class="reserved">else</span><span class="plain"> </span><span class="identifier">CW</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">improper_parts</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">improper_parts</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Improper: %d\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">improper_parts</span><span class="plain">);</span>
        <span class="plain">}</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">CW</span><span class="plain">) &gt; 0) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::length</span><span class="plain">(</span><span class="identifier">CW</span><span class="plain">) &gt; </span><span class="constant">MAX_WORDS_IN_VERB</span><span class="plain">) </span>&lt;<span class="cwebmacro">Give up on verb definition as malformed</span> <span class="cwebmacronumber">14.5.1.2</span>&gt;<span class="plain">;</span>

            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">is_a_participle</span><span class="plain">) {</span>
                <span class="identifier">participle_count</span><span class="plain">++;</span>
                <span class="reserved">if</span><span class="plain"> ((&lt;</span><span class="identifier">participle</span><span class="plain">-</span><span class="identifier">like</span><span class="plain">&gt;(</span><span class="identifier">CW</span><span class="plain">)) ||</span>
                    <span class="plain">(</span><span class="identifier">WordAssemblages::nonempty</span><span class="plain">(</span><span class="identifier">past_participle</span><span class="plain">)))</span>
                    <span class="identifier">participle</span><span class="plain"> = </span><span class="identifier">WordAssemblages::from_wording</span><span class="plain">(</span><span class="identifier">CW</span><span class="plain">);</span>
                <span class="reserved">else</span>
                    <span class="identifier">past_participle</span><span class="plain"> = </span><span class="identifier">WordAssemblages::from_wording</span><span class="plain">(</span><span class="identifier">CW</span><span class="plain">);</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">number</span><span class="plain"> == 2) {</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::nonempty</span><span class="plain">(</span><span class="identifier">present_plural</span><span class="plain">)) {</span>
                        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_PresentPluralTwice</span><span class="plain">),</span>
                            <span class="string">"the present plural has been given twice"</span><span class="plain">,</span>
                            <span class="string">"since two of the principal parts of this verb begin "</span>
                            <span class="string">"with 'they'."</span><span class="plain">);</span>
                    <span class="plain">}</span>
                    <span class="identifier">present_plural</span><span class="plain"> = </span><span class="identifier">WordAssemblages::from_wording</span><span class="plain">(</span><span class="identifier">CW</span><span class="plain">);</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::nonempty</span><span class="plain">(</span><span class="identifier">present_singular</span><span class="plain">))</span>
                        <span class="identifier">past</span><span class="plain"> = </span><span class="identifier">WordAssemblages::from_wording</span><span class="plain">(</span><span class="identifier">CW</span><span class="plain">);</span>
                    <span class="reserved">else</span>
                        <span class="identifier">present_singular</span><span class="plain"> = </span><span class="identifier">WordAssemblages::from_wording</span><span class="plain">(</span><span class="identifier">CW</span><span class="plain">);</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP14_5_1_1">&#167;14.5.1.1</a>.</p>

<p class="inwebparagraph"><a id="SP14_5_1_2"></a><b>&#167;14.5.1.2.  </b>A catch-all problem message:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Give up on verb definition as malformed</span> <span class="cwebmacronumber">14.5.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_VerbMalformed</span><span class="plain">),</span>
            <span class="string">"this verb's definition is malformed"</span><span class="plain">,</span>
            <span class="string">"and should have its principal parts supplied like so: 'The verb "</span>
            <span class="string">"to sport (he sports, they sport, he sported, it is sported, "</span>
            <span class="string">"he is sporting) ...'."</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP14_5_1">&#167;14.5.1</a>, <a href="#SP14_5_1_1_1">&#167;14.5.1.1.1</a> (twice).</p>

<p class="inwebparagraph"><a id="SP14_5_1_3"></a><b>&#167;14.5.1.3.  </b>This funny little problem message is the price we pay for blurring grammar
in the syntax provided for users. Prepositions do not inflect in English
when used in different tenses or when negated, so there's no conjugation
involved, and we need to reject any attempt &mdash; even though it would be
perfectly valid if a verb were being defined.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Reject with a problem message if preposition is conjugated</span> <span class="cwebmacronumber">14.5.1.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">PW</span><span class="plain">)) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_PrepositionConjugated</span><span class="plain">),</span>
                <span class="string">"the principal parts of 'to be' are known already"</span><span class="plain">,</span>
                <span class="string">"so should not be spelled out again as part of the instructions "</span>
                <span class="string">"for this new preposition."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP14_5_1">&#167;14.5.1</a>.</p>

<p class="inwebparagraph"><a id="SP14_6"></a><b>&#167;14.6.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue the actual problem message</span> <span class="cwebmacronumber">14.6</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">where</span><span class="plain">)</span>
            <span class="functiontext">Problems::Issue::two_sentences_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_DuplicateVerbs1</span><span class="plain">),</span>
                <span class="identifier">where</span><span class="plain">,</span>
                <span class="string">"this gives us two definitions of what appears to be the same verb"</span><span class="plain">,</span>
                <span class="string">"or at least has the same infinitive form."</span><span class="plain">);</span>
        <span class="reserved">else</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">),</span>
                <span class="string">"this verb definition appears to clash with a built-in verb"</span><span class="plain">,</span>
                <span class="string">"a table of which can be seen on the Phrasebook index."</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP14">&#167;14</a>.</p>

<p class="inwebparagraph"><a id="SP14_5_2"></a><b>&#167;14.5.2.  </b>The "priority" of a verb in an assertion affects which reading is chosen
in the case of ambiguity, with lower numbers preferred. We rank our verbs
as "to have" (priority 1), "to be" (2), general English verbs (3) and then
foreign verbs (4).
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Register the new verb's usage</span> <span class="cwebmacronumber">14.5.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">p</span><span class="plain"> = 4;</span>
        <span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain"> = </span><span class="identifier">VerbMeanings::get_relational_meaning</span><span class="plain">(&amp;</span><span class="identifier">vm</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">a_has_b_predicate</span><span class="plain">) </span><span class="identifier">p</span><span class="plain"> = 1;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">R_equality</span><span class="plain">) </span><span class="identifier">p</span><span class="plain"> = 2;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">nl</span><span class="plain">) &amp;&amp; (</span><span class="identifier">nl</span><span class="plain"> != </span><span class="identifier">English_language</span><span class="plain">)) </span><span class="identifier">p</span><span class="plain"> = 5;</span>
        <span class="plain">++</span><span class="identifier">new_verb_sequence_count</span><span class="plain">;</span>
        <span class="identifier">vi</span><span class="plain"> = </span><span class="identifier">Verbs::new_verb</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">vc_conjugates</span><span class="plain"> = </span><span class="identifier">vi</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">priority</span><span class="plain"> &gt;= 1) </span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">priority</span><span class="plain">;</span>
        <span class="identifier">VerbUsages::register_all_usages_of_verb</span><span class="plain">(</span><span class="identifier">vi</span><span class="plain">, </span><span class="identifier">unexpected_upper_casing_used</span><span class="plain">, </span><span class="identifier">p</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP14_5">&#167;14.5</a>.</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15. Bootstrapping. </b></p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">bootstrap</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt; ::=</span>
        <span class="identifier">be</span><span class="plain"> |</span>
        <span class="identifier">mean</span><span class="plain"> |</span>
        <span class="identifier">imply</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> (*</span><span class="identifier">func</span><span class="plain">)(</span><span class="reserved">int</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *, </span><span class="identifier">wording</span><span class="plain"> *), </span><span class="identifier">text_stream</span><span class="plain"> *</span><span class="identifier">name</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">p</span><span class="plain">) {</span>
        <span class="reserved">special_meaning_holder</span><span class="plain"> *</span><span class="identifier">smh</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">special_meaning_holder</span><span class="plain">);</span>
        <span class="identifier">smh</span><span class="plain">-</span><span class="element">&gt;sm_func</span><span class="plain"> = </span><span class="identifier">func</span><span class="plain">;</span>
        <span class="identifier">smh</span><span class="plain">-</span><span class="element">&gt;sm_name</span><span class="plain"> = </span><span class="identifier">Str::duplicate</span><span class="plain">(</span><span class="identifier">name</span><span class="plain">);</span>
        <span class="identifier">smh</span><span class="plain">-</span><span class="element">&gt;verb_priority</span><span class="plain"> = </span><span class="identifier">p</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="identifier">verb_meaning</span><span class="plain"> </span><span class="functiontext">NewVerbs::sm_by_name</span><span class="plain">(</span><span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">name</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">) {</span>
        <span class="reserved">special_meaning_holder</span><span class="plain"> *</span><span class="identifier">smh</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">smh</span><span class="plain">, </span><span class="reserved">special_meaning_holder</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Str::eq_wide_string</span><span class="plain">(</span><span class="identifier">smh</span><span class="plain">-</span><span class="element">&gt;sm_name</span><span class="plain">, </span><span class="identifier">name</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">) *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">smh</span><span class="plain">-</span><span class="element">&gt;verb_priority</span><span class="plain">;</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">VerbMeanings::special</span><span class="plain">(</span><span class="identifier">smh</span><span class="plain">-</span><span class="element">&gt;sm_func</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">VerbMeanings::meaninglessness</span><span class="plain">();</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">NewVerbs::bootstrap</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">NewVerbs::verb_means_SMF</span><span class="plain">, 							</span><span class="identifier">I</span><span class="string">"verb-means"</span><span class="plain">, 3);</span>

        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">NewVerbs::new_verb_SMF</span><span class="plain">, 							</span><span class="identifier">I</span><span class="string">"new-verb"</span><span class="plain">, 2);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">Plurals::plural_SMF</span><span class="plain">, 								</span><span class="identifier">I</span><span class="string">"new-plural"</span><span class="plain">, 2);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">Activities::new_activity_SMF</span><span class="plain">, 						</span><span class="identifier">I</span><span class="string">"new-activity"</span><span class="plain">, 2);</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="identifier">PL::Actions::new_action_SMF</span><span class="plain">, 						</span><span class="identifier">I</span><span class="string">"new-action"</span><span class="plain">, 2);</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">NewVerbs::new_adjective_SMF</span><span class="plain">,						</span><span class="identifier">I</span><span class="string">"new-adjective"</span><span class="plain">, 2);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">Assertions::Property::either_SMF</span><span class="plain">,					</span><span class="identifier">I</span><span class="string">"new-either-or"</span><span class="plain">, 2);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">Tables::Defining::defined_by_SMF</span><span class="plain">,					</span><span class="identifier">I</span><span class="string">"defined-by-table"</span><span class="plain">, 2);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">Rules::Placement::listed_in_SMF</span><span class="plain">,					</span><span class="identifier">I</span><span class="string">"rule-listed-in"</span><span class="plain">, 2);</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">MULTIMEDIA_MODULE</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="identifier">PL::Figures::new_figure_SMF</span><span class="plain">,						</span><span class="identifier">I</span><span class="string">"new-figure"</span><span class="plain">, 2);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="identifier">PL::Sounds::new_sound_SMF</span><span class="plain">,							</span><span class="identifier">I</span><span class="string">"new-sound"</span><span class="plain">, 2);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="identifier">PL::Files::new_file_SMF</span><span class="plain">,							</span><span class="identifier">I</span><span class="string">"new-file"</span><span class="plain">, 2);</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="identifier">PL::Bibliographic::episode_SMF</span><span class="plain">,					</span><span class="identifier">I</span><span class="string">"episode"</span><span class="plain">, 2);</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">Relations::new_relation_SMF</span><span class="plain">,						</span><span class="identifier">I</span><span class="string">"new-relation"</span><span class="plain">, 1);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">Assertions::Property::optional_either_SMF</span><span class="plain">,			</span><span class="identifier">I</span><span class="string">"can-be"</span><span class="plain">, 2);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">LiteralPatterns::specifies_SMF</span><span class="plain">, 					</span><span class="identifier">I</span><span class="string">"specifies-notation"</span><span class="plain">, 4);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">Rules::Placement::substitutes_for_SMF</span><span class="plain">,				</span><span class="identifier">I</span><span class="string">"rule-substitutes-for"</span><span class="plain">, 1);</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="identifier">PL::Scenes::begins_when_SMF</span><span class="plain">,						</span><span class="identifier">I</span><span class="string">"scene-begins-when"</span><span class="plain">, 1);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="identifier">PL::Scenes::ends_when_SMF</span><span class="plain">,							</span><span class="identifier">I</span><span class="string">"scene-ends-when"</span><span class="plain">, 1);</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">Rules::Placement::does_nothing_SMF</span><span class="plain">,				</span><span class="identifier">I</span><span class="string">"rule-does-nothing"</span><span class="plain">, 1);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">Rules::Placement::does_nothing_if_SMF</span><span class="plain">,				</span><span class="identifier">I</span><span class="string">"rule-does-nothing-if"</span><span class="plain">, 1);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">Rules::Placement::does_nothing_unless_SMF</span><span class="plain">,			</span><span class="identifier">I</span><span class="string">"rule-does-nothing-unless"</span><span class="plain">, 1);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">Sentences::VPs::translates_into_unicode_as_SMF</span><span class="plain">,	</span><span class="identifier">I</span><span class="string">"translates-into-unicode"</span><span class="plain">, 1);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">Sentences::VPs::translates_into_I6_as_SMF</span><span class="plain">,			</span><span class="identifier">I</span><span class="string">"translates-into-i6"</span><span class="plain">, 1);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">Sentences::VPs::translates_into_language_as_SMF</span><span class="plain">,	</span><span class="identifier">I</span><span class="string">"translates-into-language"</span><span class="plain">, 1);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">UseOptions::use_translates_as_SMF</span><span class="plain">,					</span><span class="identifier">I</span><span class="string">"use-translates"</span><span class="plain">, 4);</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">PL::Parsing::TestScripts::test_with_SMF</span><span class="plain">,			</span><span class="identifier">I</span><span class="string">"test-with"</span><span class="plain">, 1);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="identifier">PL::Parsing::understand_as_SMF</span><span class="plain">,					</span><span class="identifier">I</span><span class="string">"understand-as"</span><span class="plain">, 1);</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">UseOptions::use_SMF</span><span class="plain">,								</span><span class="identifier">I</span><span class="string">"use"</span><span class="plain">, 4);</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="identifier">PL::Bibliographic::Release::release_along_with_SMF</span><span class="plain">,</span><span class="identifier">I</span><span class="string">"release-along-with"</span><span class="plain">, 4);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="identifier">PL::EPSMap::index_map_with_SMF</span><span class="plain">,					</span><span class="identifier">I</span><span class="string">"index-map-with"</span><span class="plain">, 4);</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">Sentences::VPs::include_in_SMF</span><span class="plain">,					</span><span class="identifier">I</span><span class="string">"include-in"</span><span class="plain">, 4);</span>
        <span class="functiontext">NewVerbs::declare_sm</span><span class="plain">(</span><span class="functiontext">Sentences::VPs::omit_from_SMF</span><span class="plain">,						</span><span class="identifier">I</span><span class="string">"omit-from"</span><span class="plain">, 4);</span>

        <span class="identifier">word_assemblage</span><span class="plain"> </span><span class="identifier">infinitive</span><span class="plain"> = </span><span class="identifier">Preform::Nonparsing::wording</span><span class="plain">(&lt;</span><span class="identifier">bootstrap</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt;, 0);</span>
        <span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain"> = </span><span class="identifier">Conjugation::conjugate</span><span class="plain">(</span><span class="identifier">infinitive</span><span class="plain">, </span><span class="identifier">English_language</span><span class="plain">);</span>
        <span class="identifier">verb_identity</span><span class="plain"> *</span><span class="identifier">vi</span><span class="plain"> = </span><span class="identifier">Verbs::new_verb</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">);</span>
        <span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">vc_conjugates</span><span class="plain"> = </span><span class="identifier">vi</span><span class="plain">;</span>
        <span class="identifier">VerbUsages::register_all_usages_of_verb</span><span class="plain">(</span><span class="identifier">vi</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, 2);</span>

        <span class="identifier">infinitive</span><span class="plain"> = </span><span class="identifier">Preform::Nonparsing::wording</span><span class="plain">(&lt;</span><span class="identifier">bootstrap</span><span class="plain">-</span><span class="identifier">verb</span><span class="plain">&gt;, 1);</span>
        <span class="identifier">vc</span><span class="plain"> = </span><span class="identifier">Conjugation::conjugate</span><span class="plain">(</span><span class="identifier">infinitive</span><span class="plain">, </span><span class="identifier">English_language</span><span class="plain">);</span>
        <span class="identifier">vi</span><span class="plain"> = </span><span class="identifier">Verbs::new_verb</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">vc_conjugates</span><span class="plain"> = </span><span class="identifier">vi</span><span class="plain">;</span>
        <span class="identifier">VerbUsages::register_all_usages_of_verb</span><span class="plain">(</span><span class="identifier">vi</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, 3);</span>

        <span class="identifier">Verbs::add_form</span><span class="plain">(</span><span class="identifier">vi</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="functiontext">NewVerbs::sm_by_name</span><span class="plain">(</span><span class="identifier">L</span><span class="string">"verb-means"</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">), </span><span class="identifier">SVO_FS_BIT</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function NewVerbs::declare_sm appears nowhere else.</p>

<p class="endnote">The function NewVerbs::sm_by_name is used in <a href="#SP14_1">&#167;14.1</a>.</p>

<p class="endnote">The function NewVerbs::bootstrap is used in 7/ns (<a href="7-ns.html#SP9">&#167;9</a>).</p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17. Runtime conjugation. </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">NewVerbs::ConjugateVerb_invoke_emit</span><span class="plain">(</span><span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain">,</span>
        <span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">modal</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">negated</span><span class="plain">) {</span>
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">cv_pos</span><span class="plain"> = </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">CV_POS_HL</span><span class="plain">);</span>
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">cv_neg</span><span class="plain"> = </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">CV_NEG_HL</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">modal</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">negated</span><span class="plain">) {</span>
                <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">Conjugation::conj_iname</span><span class="plain">(</span><span class="identifier">modal</span><span class="plain">));</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">cv_neg</span><span class="plain">);</span>
                    <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">PNTOVP_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">STORY_TENSE_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Conjugation::conj_iname</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">Conjugation::conj_iname</span><span class="plain">(</span><span class="identifier">modal</span><span class="plain">));</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">cv_pos</span><span class="plain">);</span>
                    <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">PNTOVP_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">STORY_TENSE_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">Conjugation::conj_iname</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="plain">}</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">negated</span><span class="plain">) {</span>
                <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">Conjugation::conj_iname</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">));</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">cv_neg</span><span class="plain">);</span>
                    <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">PNTOVP_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">STORY_TENSE_HL</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">Conjugation::conj_iname</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">));</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">cv_pos</span><span class="plain">);</span>
                    <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">PNTOVP_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">STORY_TENSE_HL</span><span class="plain">));</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::ref_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">SAY__P_HL</span><span class="plain">));</span>
            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function NewVerbs::ConjugateVerb_invoke_emit is used in 25/ci (<a href="25-ci.html#SP3_1">&#167;3.1</a>, <a href="25-ci.html#SP3_2_3_3_1">&#167;3.2.3.3.1</a>, <a href="25-ci.html#SP3_2_3_4_1">&#167;3.2.3.4.1</a>).</p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18.  </b>Each VC is represented by a routine at run-time:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">NewVerbs::verb_form_is_instance</span><span class="plain">(</span><span class="identifier">verb_form</span><span class="plain"> *</span><span class="identifier">vf</span><span class="plain">) {</span>
        <span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain"> = </span><span class="identifier">vf</span><span class="plain">-&gt;</span><span class="identifier">underlying_verb</span><span class="plain">-&gt;</span><span class="identifier">conjugation</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">vc</span><span class="plain">) &amp;&amp; (</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">auxiliary_only</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">instance_of_verb</span><span class="plain">) &amp;&amp;</span>
            <span class="plain">((</span><span class="identifier">vf</span><span class="plain">-&gt;</span><span class="identifier">preposition</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">vf</span><span class="plain">-&gt;</span><span class="identifier">underlying_verb</span><span class="plain"> != </span><span class="identifier">copular_verb</span><span class="plain">)))</span>
            <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">NewVerbs::ConjugateVerbDefinitions</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">CV_POS_iname</span><span class="plain"> = </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">CV_POS_HL</span><span class="plain">);</span>
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">CV_NEG_iname</span><span class="plain"> = </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">CV_NEG_HL</span><span class="plain">);</span>
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">CV_MODAL_INAME_iname</span><span class="plain"> = </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">CV_MODAL_HL</span><span class="plain">);</span>
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">CV_MEANING_iname</span><span class="plain"> = </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">CV_MEANING_HL</span><span class="plain">);</span>

        <span class="functiontext">Emit::named_numeric_constant_signed</span><span class="plain">(</span><span class="identifier">CV_POS_iname</span><span class="plain">, -1);</span>
        <span class="functiontext">Emit::named_numeric_constant_signed</span><span class="plain">(</span><span class="identifier">CV_NEG_iname</span><span class="plain">, -2);</span>
        <span class="functiontext">Emit::named_numeric_constant_signed</span><span class="plain">(</span><span class="identifier">CV_MODAL_INAME_iname</span><span class="plain">, -3);</span>
        <span class="functiontext">Emit::named_numeric_constant_signed</span><span class="plain">(</span><span class="identifier">CV_MEANING_iname</span><span class="plain">, -4);</span>

        <span class="functiontext">Hierarchy::make_available</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">CV_POS_iname</span><span class="plain">);</span>
        <span class="functiontext">Hierarchy::make_available</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">CV_NEG_iname</span><span class="plain">);</span>
        <span class="functiontext">Hierarchy::make_available</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">CV_MODAL_INAME_iname</span><span class="plain">);</span>
        <span class="functiontext">Hierarchy::make_available</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">CV_MEANING_iname</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">NewVerbs::ConjugateVerb</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">verb_conjugation</span><span class="plain">)</span>
            &lt;<span class="cwebmacro">Compile ConjugateVerb routine</span> <span class="cwebmacronumber">18.1</span>&gt;<span class="plain">;</span>
        <span class="identifier">verb_form</span><span class="plain"> *</span><span class="identifier">vf</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">vf</span><span class="plain">, </span><span class="identifier">verb_form</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">NewVerbs::verb_form_is_instance</span><span class="plain">(</span><span class="identifier">vf</span><span class="plain">))</span>
                &lt;<span class="cwebmacro">Compile ConjugateVerbForm routine</span> <span class="cwebmacronumber">18.2</span>&gt;<span class="plain">;</span>
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">iname</span><span class="plain"> = </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">TABLEOFVERBS_HL</span><span class="plain">);</span>
        <span class="identifier">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="functiontext">Emit::named_array_begin</span><span class="plain">(</span><span class="identifier">iname</span><span class="plain">, </span><span class="identifier">K_value</span><span class="plain">);</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">vf</span><span class="plain">, </span><span class="identifier">verb_form</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">NewVerbs::verb_form_is_instance</span><span class="plain">(</span><span class="identifier">vf</span><span class="plain">))</span>
                <span class="functiontext">Emit::array_iname_entry</span><span class="plain">(</span><span class="identifier">Verbs::form_iname</span><span class="plain">(</span><span class="identifier">vf</span><span class="plain">));</span>
        <span class="functiontext">Emit::array_numeric_entry</span><span class="plain">(0);</span>
        <span class="functiontext">Emit::array_end</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function NewVerbs::verb_form_is_instance appears nowhere else.</p>

<p class="endnote">The function NewVerbs::ConjugateVerbDefinitions is used in 27/ei (<a href="27-ei.html#SP2">&#167;2</a>).</p>

<p class="endnote">The function NewVerbs::ConjugateVerb is used in 1/mr (<a href="1-mr.html#SP4_14">&#167;4.14</a>).</p>

<p class="inwebparagraph"><a id="SP18_1"></a><b>&#167;18.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile ConjugateVerb routine</span> <span class="cwebmacronumber">18.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="functiontext">Routines::begin</span><span class="plain">(</span><span class="identifier">Conjugation::conj_iname</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">));</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">fn_s</span><span class="plain"> = </span><span class="functiontext">LocalVariables::add_named_call_as_symbol</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"fn"</span><span class="plain">);</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">vp_s</span><span class="plain"> = </span><span class="functiontext">LocalVariables::add_named_call_as_symbol</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"vp"</span><span class="plain">);</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">t_s</span><span class="plain"> = </span><span class="functiontext">LocalVariables::add_named_call_as_symbol</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"t"</span><span class="plain">);</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">modal_to_s</span><span class="plain"> = </span><span class="functiontext">LocalVariables::add_named_call_as_symbol</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"modal_to"</span><span class="plain">);</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">SWITCH_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">fn_s</span><span class="plain">);</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">CASE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 1);</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="functiontext">NewVerbs::conj_from_wa</span><span class="plain">(&amp;(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">infinitive</span><span class="plain">), </span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">modal_to_s</span><span class="plain">, 0);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">CASE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 2);</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="functiontext">NewVerbs::conj_from_wa</span><span class="plain">(&amp;(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">past_participle</span><span class="plain">), </span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">modal_to_s</span><span class="plain">, 0);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">CASE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 3);</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="functiontext">NewVerbs::conj_from_wa</span><span class="plain">(&amp;(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">present_participle</span><span class="plain">), </span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">modal_to_s</span><span class="plain">, 0);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">modal_verb</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        &lt;<span class="cwebmacro">Check for modality</span> <span class="cwebmacronumber">18.1.1</span>&gt;<span class="plain">;</span>

        <span class="identifier">verb_identity</span><span class="plain"> *</span><span class="identifier">vi</span><span class="plain"> = </span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">vc_conjugates</span><span class="plain">;</span>
        <span class="identifier">verb_meaning</span><span class="plain"> *</span><span class="identifier">vm</span><span class="plain"> = (</span><span class="identifier">vi</span><span class="plain">)?</span><span class="identifier">Verbs::regular_meaning</span><span class="plain">(</span><span class="identifier">vi</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">):</span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="identifier">meaning</span><span class="plain"> = </span><span class="identifier">VerbMeanings::get_relational_meaning</span><span class="plain">(</span><span class="identifier">vm</span><span class="plain">);</span>
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">rel_iname</span><span class="plain"> = </span><span class="identifier">default_rr</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">meaning</span><span class="plain">) {</span>
            <span class="functiontext">BinaryPredicates::mark_as_needed</span><span class="plain">(</span><span class="identifier">meaning</span><span class="plain">);</span>
            <span class="identifier">rel_iname</span><span class="plain"> = </span><span class="identifier">meaning</span><span class="plain">-</span><span class="element">&gt;bp_iname</span><span class="plain">;</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Meaningful! %n\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">rel_iname</span><span class="plain">);</span>
        <span class="plain">}</span>

                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">CASE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">CV_MODAL_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">modal_verb</span><span class="plain">) </span><span class="identifier">Produce::rtrue</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">Produce::rfalse</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">CASE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">CV_MEANING_HL</span><span class="plain">));</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">RETURN_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">rel_iname</span><span class="plain">);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">sense</span><span class="plain"> = 0; </span><span class="identifier">sense</span><span class="plain"> &lt; 2; </span><span class="identifier">sense</span><span class="plain">++) {</span>
            <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">sense_iname</span><span class="plain"> = </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">CV_POS_HL</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">sense</span><span class="plain"> == 1) </span><span class="identifier">sense_iname</span><span class="plain"> = </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">CV_NEG_HL</span><span class="plain">);</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">CASE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">sense_iname</span><span class="plain">);</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">SWITCH_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">t_s</span><span class="plain">);</span>
                            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                &lt;<span class="cwebmacro">Compile conjugation in this sense</span> <span class="cwebmacronumber">18.1.2</span>&gt;<span class="plain">;</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="plain">}</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="functiontext">Routines::end</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18">&#167;18</a>.</p>

<p class="inwebparagraph"><a id="SP18_2"></a><b>&#167;18.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile ConjugateVerbForm routine</span> <span class="cwebmacronumber">18.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain"> = </span><span class="identifier">vf</span><span class="plain">-&gt;</span><span class="identifier">underlying_verb</span><span class="plain">-&gt;</span><span class="identifier">conjugation</span><span class="plain">;</span>
        <span class="identifier">packaging_state</span><span class="plain"> </span><span class="identifier">save</span><span class="plain"> = </span><span class="functiontext">Routines::begin</span><span class="plain">(</span><span class="identifier">Verbs::form_iname</span><span class="plain">(</span><span class="identifier">vf</span><span class="plain">));</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">fn_s</span><span class="plain"> = </span><span class="functiontext">LocalVariables::add_named_call_as_symbol</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"fn"</span><span class="plain">);</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">vp_s</span><span class="plain"> = </span><span class="functiontext">LocalVariables::add_named_call_as_symbol</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"vp"</span><span class="plain">);</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">t_s</span><span class="plain"> = </span><span class="functiontext">LocalVariables::add_named_call_as_symbol</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"t"</span><span class="plain">);</span>
        <span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">modal_to_s</span><span class="plain"> = </span><span class="functiontext">LocalVariables::add_named_call_as_symbol</span><span class="plain">(</span><span class="identifier">I</span><span class="string">"modal_to"</span><span class="plain">);</span>

        <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">);</span>
        <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">, </span><span class="string">"%A"</span><span class="plain">, &amp;(</span><span class="identifier">vf</span><span class="plain">-&gt;</span><span class="identifier">infinitive_reference_text</span><span class="plain">));</span>
        <span class="functiontext">Emit::code_comment</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">);</span>
        <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">C</span><span class="plain">);</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">STORE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::ref_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">t_s</span><span class="plain">);</span>
            <span class="identifier">Produce::inv_call_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">Conjugation::conj_iname</span><span class="plain">(</span><span class="identifier">vc</span><span class="plain">));</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">fn_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">vp_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">t_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">modal_to_s</span><span class="plain">);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">fn_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">CV_MODAL_HL</span><span class="plain">));</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">RETURN_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">t_s</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="identifier">verb_meaning</span><span class="plain"> *</span><span class="identifier">vm</span><span class="plain"> = &amp;(</span><span class="identifier">vf</span><span class="plain">-&gt;</span><span class="identifier">list_of_senses</span><span class="plain">-&gt;</span><span class="identifier">vm</span><span class="plain">);</span>
        <span class="identifier">inter_name</span><span class="plain"> *</span><span class="identifier">rel_iname</span><span class="plain"> = </span><span class="identifier">default_rr</span><span class="plain">;</span>
        <span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="identifier">meaning</span><span class="plain"> = </span><span class="identifier">VerbMeanings::get_relational_meaning</span><span class="plain">(</span><span class="identifier">vm</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">meaning</span><span class="plain">) {</span>
            <span class="functiontext">BinaryPredicates::mark_as_needed</span><span class="plain">(</span><span class="identifier">meaning</span><span class="plain">);</span>
            <span class="identifier">rel_iname</span><span class="plain"> = </span><span class="identifier">meaning</span><span class="plain">-</span><span class="element">&gt;bp_iname</span><span class="plain">;</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Meaningful 2! %n\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">rel_iname</span><span class="plain">);</span>
        <span class="plain">}</span>


        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">fn_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="functiontext">Hierarchy::find</span><span class="plain">(</span><span class="constant">CV_MEANING_HL</span><span class="plain">));</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">RETURN_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val_iname</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">rel_iname</span><span class="plain">);</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>

        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vf</span><span class="plain">-&gt;</span><span class="identifier">preposition</span><span class="plain">) {</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">);</span>
            <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">, </span><span class="string">" %A"</span><span class="plain">, &amp;(</span><span class="identifier">vf</span><span class="plain">-&gt;</span><span class="identifier">preposition</span><span class="plain">-&gt;</span><span class="identifier">prep_text</span><span class="plain">));</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINT_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_text</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">T</span><span class="plain">);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">T</span><span class="plain">);</span>
        <span class="plain">}</span>

        <span class="functiontext">Routines::end</span><span class="plain">(</span><span class="identifier">save</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18">&#167;18</a>.</p>

<p class="inwebparagraph"><a id="SP18_1_1"></a><b>&#167;18.1.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Check for modality</span> <span class="cwebmacronumber">18.1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">sense</span><span class="plain"> = 0; </span><span class="identifier">sense</span><span class="plain"> &lt; 2; </span><span class="identifier">sense</span><span class="plain">++)</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">tense</span><span class="plain">=0; </span><span class="identifier">tense</span><span class="plain">&lt;</span><span class="identifier">NO_KNOWN_TENSES</span><span class="plain">; </span><span class="identifier">tense</span><span class="plain">++)</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">part</span><span class="plain">=1; </span><span class="identifier">part</span><span class="plain">&lt;=6; </span><span class="identifier">part</span><span class="plain">++)</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">tabulations</span><span class="plain">[</span><span class="identifier">ACTIVE_MOOD</span><span class="plain">].</span><span class="identifier">modal_auxiliary_usage</span><span class="plain">[</span><span class="identifier">tense</span><span class="plain">][</span><span class="identifier">sense</span><span class="plain">][</span><span class="identifier">part</span><span class="plain">-1] != 0)</span>
                        <span class="identifier">modal_verb</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18_1">&#167;18.1</a>.</p>

<p class="inwebparagraph"><a id="SP18_1_2"></a><b>&#167;18.1.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile conjugation in this sense</span> <span class="cwebmacronumber">18.1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">tense</span><span class="plain">=0; </span><span class="identifier">tense</span><span class="plain">&lt;</span><span class="identifier">NO_KNOWN_TENSES</span><span class="plain">; </span><span class="identifier">tense</span><span class="plain">++) {</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">some_exist</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">some_dont_exist</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">,</span>
                <span class="identifier">some_differ</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">some_except_3PS_differ</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">some_are_modal</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="identifier">word_assemblage</span><span class="plain"> *</span><span class="identifier">common</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">, *</span><span class="identifier">common_except_3PS</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">part</span><span class="plain">=1; </span><span class="identifier">part</span><span class="plain">&lt;=6; </span><span class="identifier">part</span><span class="plain">++) {</span>
                <span class="identifier">word_assemblage</span><span class="plain"> *</span><span class="identifier">wa</span><span class="plain"> = &amp;(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">tabulations</span><span class="plain">[</span><span class="identifier">ACTIVE_MOOD</span><span class="plain">].</span><span class="identifier">vc_text</span><span class="plain">[</span><span class="identifier">tense</span><span class="plain">][</span><span class="identifier">sense</span><span class="plain">][</span><span class="identifier">part</span><span class="plain">-1]);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::nonempty</span><span class="plain">(*</span><span class="identifier">wa</span><span class="plain">)) {</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">some_exist</span><span class="plain">) {</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::compare</span><span class="plain">(</span><span class="identifier">wa</span><span class="plain">, </span><span class="identifier">common</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)</span>
                            <span class="identifier">some_differ</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">part</span><span class="plain"> != 3) {</span>
                            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">common_except_3PS</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">common_except_3PS</span><span class="plain"> = </span><span class="identifier">wa</span><span class="plain">;</span>
                            <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::compare</span><span class="plain">(</span><span class="identifier">wa</span><span class="plain">, </span><span class="identifier">common_except_3PS</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)</span>
                                <span class="identifier">some_except_3PS_differ</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                        <span class="plain">}</span>
                    <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                        <span class="identifier">some_exist</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                        <span class="identifier">common</span><span class="plain"> = </span><span class="identifier">wa</span><span class="plain">;</span>
                        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">part</span><span class="plain"> != 3) </span><span class="identifier">common_except_3PS</span><span class="plain"> = </span><span class="identifier">wa</span><span class="plain">;</span>
                    <span class="plain">}</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">tabulations</span><span class="plain">[</span><span class="identifier">ACTIVE_MOOD</span><span class="plain">].</span><span class="identifier">modal_auxiliary_usage</span><span class="plain">[</span><span class="identifier">tense</span><span class="plain">][</span><span class="identifier">sense</span><span class="plain">][</span><span class="identifier">part</span><span class="plain">-1] != 0)</span>
                        <span class="identifier">some_are_modal</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="identifier">some_dont_exist</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
            <span class="plain">}</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">some_exist</span><span class="plain">) {</span>
                <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">CASE_BIP</span><span class="plain">);</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) (</span><span class="identifier">tense</span><span class="plain">+1));</span>
                    <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">some_differ</span><span class="plain">) || (</span><span class="identifier">some_are_modal</span><span class="plain">)) {</span>
                            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">some_except_3PS_differ</span><span class="plain">) || (</span><span class="identifier">some_dont_exist</span><span class="plain">) || (</span><span class="identifier">some_are_modal</span><span class="plain">))</span>
                                &lt;<span class="cwebmacro">Compile a full switch of all six parts</span> <span class="cwebmacronumber">18.1.2.1</span>&gt;
                            <span class="reserved">else</span>
                                &lt;<span class="cwebmacro">Compile a choice between 3PS and the rest</span> <span class="cwebmacronumber">18.1.2.2</span>&gt;<span class="plain">;</span>
                        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                            &lt;<span class="cwebmacro">Compile for the case where all six parts are the same</span> <span class="cwebmacronumber">18.1.2.3</span>&gt;<span class="plain">;</span>
                        <span class="plain">}</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18_1">&#167;18.1</a>.</p>

<p class="inwebparagraph"><a id="SP18_1_2_1"></a><b>&#167;18.1.2.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile a full switch of all six parts</span> <span class="cwebmacronumber">18.1.2.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">SWITCH_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">vp_s</span><span class="plain">);</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="reserved">for</span><span class="plain"> (</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">part</span><span class="plain">=1; </span><span class="identifier">part</span><span class="plain">&lt;=6; </span><span class="identifier">part</span><span class="plain">++) {</span>
                    <span class="identifier">word_assemblage</span><span class="plain"> *</span><span class="identifier">wa</span><span class="plain"> = &amp;(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">tabulations</span><span class="plain">[</span><span class="identifier">ACTIVE_MOOD</span><span class="plain">].</span><span class="identifier">vc_text</span><span class="plain">[</span><span class="identifier">tense</span><span class="plain">][</span><span class="identifier">sense</span><span class="plain">][</span><span class="identifier">part</span><span class="plain">-1]);</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">WordAssemblages::nonempty</span><span class="plain">(*</span><span class="identifier">wa</span><span class="plain">)) {</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">CASE_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="identifier">part</span><span class="plain">);</span>
                            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                                <span class="reserved">int</span><span class="plain"> </span><span class="identifier">mau</span><span class="plain"> = </span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">tabulations</span><span class="plain">[</span><span class="identifier">ACTIVE_MOOD</span><span class="plain">].</span><span class="identifier">modal_auxiliary_usage</span><span class="plain">[</span><span class="identifier">tense</span><span class="plain">][</span><span class="identifier">sense</span><span class="plain">][</span><span class="identifier">part</span><span class="plain">-1];</span>
                                <span class="functiontext">NewVerbs::conj_from_wa</span><span class="plain">(</span><span class="identifier">wa</span><span class="plain">, </span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">modal_to_s</span><span class="plain">, </span><span class="identifier">mau</span><span class="plain">);</span>
                            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18_1_2">&#167;18.1.2</a>.</p>

<p class="inwebparagraph"><a id="SP18_1_2_2"></a><b>&#167;18.1.2.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile a choice between 3PS and the rest</span> <span class="cwebmacronumber">18.1.2.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IFELSE_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">EQ_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">vp_s</span><span class="plain">);</span>
                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 3);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">word_assemblage</span><span class="plain"> *</span><span class="identifier">wa</span><span class="plain"> = &amp;(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">tabulations</span><span class="plain">[</span><span class="identifier">ACTIVE_MOOD</span><span class="plain">].</span><span class="identifier">vc_text</span><span class="plain">[</span><span class="identifier">tense</span><span class="plain">][</span><span class="identifier">sense</span><span class="plain">][2]);</span>
                <span class="functiontext">NewVerbs::conj_from_wa</span><span class="plain">(</span><span class="identifier">wa</span><span class="plain">, </span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">modal_to_s</span><span class="plain">, 0);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">wa</span><span class="plain"> = &amp;(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">tabulations</span><span class="plain">[</span><span class="identifier">ACTIVE_MOOD</span><span class="plain">].</span><span class="identifier">vc_text</span><span class="plain">[</span><span class="identifier">tense</span><span class="plain">][</span><span class="identifier">sense</span><span class="plain">][0]);</span>
                <span class="functiontext">NewVerbs::conj_from_wa</span><span class="plain">(</span><span class="identifier">wa</span><span class="plain">, </span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">modal_to_s</span><span class="plain">, 0);</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18_1_2">&#167;18.1.2</a>.</p>

<p class="inwebparagraph"><a id="SP18_1_2_3"></a><b>&#167;18.1.2.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Compile for the case where all six parts are the same</span> <span class="cwebmacronumber">18.1.2.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">word_assemblage</span><span class="plain"> *</span><span class="identifier">wa</span><span class="plain"> = &amp;(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">tabulations</span><span class="plain">[</span><span class="identifier">ACTIVE_MOOD</span><span class="plain">].</span><span class="identifier">vc_text</span><span class="plain">[</span><span class="identifier">tense</span><span class="plain">][</span><span class="identifier">sense</span><span class="plain">][0]);</span>
        <span class="functiontext">NewVerbs::conj_from_wa</span><span class="plain">(</span><span class="identifier">wa</span><span class="plain">, </span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">modal_to_s</span><span class="plain">, 0);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18_1_2">&#167;18.1.2</a>.</p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">NewVerbs::conj_from_wa</span><span class="plain">(</span><span class="identifier">word_assemblage</span><span class="plain"> *</span><span class="identifier">wa</span><span class="plain">, </span><span class="identifier">verb_conjugation</span><span class="plain"> *</span><span class="identifier">vc</span><span class="plain">, </span><span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">modal_to_s</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">mau</span><span class="plain">) {</span>
        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINT_BIP</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">NewVerbs::takes_contraction_form</span><span class="plain">(</span><span class="identifier">wa</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">) &amp;&amp; (</span><span class="functiontext">NewVerbs::takes_contraction_form</span><span class="plain">(&amp;(</span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">infinitive</span><span class="plain">))))</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" "</span><span class="plain">);</span>
            <span class="reserved">int</span><span class="plain"> </span><span class="identifier">i</span><span class="plain">, </span><span class="identifier">n</span><span class="plain">;</span>
            <span class="identifier">vocabulary_entry</span><span class="plain"> **</span><span class="identifier">words</span><span class="plain">;</span>
            <span class="identifier">WordAssemblages::as_array</span><span class="plain">(</span><span class="identifier">wa</span><span class="plain">, &amp;</span><span class="identifier">words</span><span class="plain">, &amp;</span><span class="identifier">n</span><span class="plain">);</span>
            <span class="reserved">for</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">=0; </span><span class="identifier">i</span><span class="plain">&lt;</span><span class="identifier">n</span><span class="plain">; </span><span class="identifier">i</span><span class="plain">++) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">i</span><span class="plain">&gt;0) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">" "</span><span class="plain">);</span>
                <span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">q</span><span class="plain"> = </span><span class="identifier">Vocabulary::get_exemplar</span><span class="plain">(</span><span class="identifier">words</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">], </span><span class="identifier">FALSE</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">q</span><span class="plain">[0]) &amp;&amp; (</span><span class="identifier">q</span><span class="plain">[</span><span class="identifier">Wide::len</span><span class="plain">(</span><span class="identifier">q</span><span class="plain">)-1] == </span><span class="character">'*'</span><span class="plain">)) {</span>
    <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"star alert!"</span><span class="plain">);</span>
                    <span class="identifier">TEMPORARY_TEXT</span><span class="plain">(</span><span class="identifier">unstarred</span><span class="plain">);</span>
                    <span class="identifier">WRITE_TO</span><span class="plain">(</span><span class="identifier">unstarred</span><span class="plain">, </span><span class="string">"%V"</span><span class="plain">, </span><span class="identifier">words</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]);</span>
                    <span class="identifier">Str::delete_last_character</span><span class="plain">(</span><span class="identifier">unstarred</span><span class="plain">);</span>
                    <span class="identifier">feed_t</span><span class="plain"> </span><span class="identifier">id</span><span class="plain"> = </span><span class="identifier">Feeds::begin</span><span class="plain">();</span>
                    <span class="identifier">Feeds::feed_text</span><span class="plain">(</span><span class="identifier">L</span><span class="string">" "</span><span class="plain">);</span>
                    <span class="identifier">Feeds::feed_stream</span><span class="plain">(</span><span class="identifier">unstarred</span><span class="plain">);</span>
                    <span class="identifier">Feeds::feed_text</span><span class="plain">(</span><span class="identifier">L</span><span class="string">" "</span><span class="plain">);</span>
                    <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">unstarred</span><span class="plain">);</span>
                    <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Feeds::end</span><span class="plain">(</span><span class="identifier">id</span><span class="plain">);</span>
                    <span class="identifier">adjectival_phrase</span><span class="plain"> *</span><span class="identifier">aph</span><span class="plain"> = </span><span class="identifier">Adjectives::declare</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">vc</span><span class="plain">-&gt;</span><span class="identifier">defined_in</span><span class="plain">);</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"\</span><span class="plain">"</span><span class="string">; %n(prior_named_noun, (prior_named_list &gt;= 2)); print \</span><span class="plain">"</span><span class="string">"</span><span class="plain">,</span>
                        <span class="identifier">aph</span><span class="plain">-&gt;</span><span class="identifier">aph_iname</span><span class="plain">);</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"%V"</span><span class="plain">, </span><span class="identifier">words</span><span class="plain">[</span><span class="identifier">i</span><span class="plain">]);</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="identifier">Produce::val_text</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">OUT</span><span class="plain">);</span>
            <span class="identifier">DISCARD_TEXT</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">);</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">mau</span><span class="plain"> != 0) {</span>
            <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">IF_BIP</span><span class="plain">);</span>
            <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">modal_to_s</span><span class="plain">);</span>
                <span class="identifier">Produce::code</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">PRINT_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val_text</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">I</span><span class="string">" "</span><span class="plain">);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">INDIRECT1V_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">modal_to_s</span><span class="plain">);</span>
                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="identifier">mau</span><span class="plain">);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
                <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
            <span class="identifier">Produce::up</span><span class="plain">(</span><span class="functiontext">Emit::tree</span><span class="plain">());</span>
        <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">NewVerbs::takes_contraction_form</span><span class="plain">(</span><span class="identifier">word_assemblage</span><span class="plain"> *</span><span class="identifier">wa</span><span class="plain">) {</span>
        <span class="identifier">vocabulary_entry</span><span class="plain"> *</span><span class="identifier">ve</span><span class="plain"> = </span><span class="identifier">WordAssemblages::first_word</span><span class="plain">(</span><span class="identifier">wa</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ve</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">wchar_t</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain"> = </span><span class="identifier">Vocabulary::get_exemplar</span><span class="plain">(</span><span class="identifier">ve</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">p</span><span class="plain">[0] == </span><span class="character">'\</span><span class="plain">'</span><span class="character">'</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function NewVerbs::conj_from_wa is used in <a href="#SP18_1">&#167;18.1</a>, <a href="#SP18_1_2_1">&#167;18.1.2.1</a>, <a href="#SP18_1_2_2">&#167;18.1.2.2</a>, <a href="#SP18_1_2_3">&#167;18.1.2.3</a>.</p>

<p class="endnote">The function NewVerbs::takes_contraction_form appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP20"></a><b>&#167;20.  </b>This handles the special meaning "X is an adjective...".
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">new</span><span class="plain">-</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt; ::=</span>
        <span class="plain">&lt;</span><span class="identifier">indefinite</span><span class="plain">-</span><span class="identifier">article</span><span class="plain">&gt; &lt;</span><span class="identifier">new</span><span class="plain">-</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">unarticled</span><span class="plain">&gt; |	==&gt; </span><span class="identifier">R</span><span class="plain">[2]; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[2]</span>
        <span class="plain">&lt;</span><span class="identifier">new</span><span class="plain">-</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">unarticled</span><span class="plain">&gt;							==&gt; </span><span class="identifier">R</span><span class="plain">[1]; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>

    <span class="plain">&lt;</span><span class="identifier">new</span><span class="plain">-</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">-</span><span class="identifier">unarticled</span><span class="plain">&gt; ::=</span>
        <span class="identifier">adjective</span><span class="plain"> |															==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">NULL</span>
        <span class="identifier">adjective</span><span class="plain"> </span><span class="identifier">implying</span><span class="plain">/</span><span class="identifier">meaning</span><span class="plain"> &lt;</span><span class="identifier">nounphrase</span><span class="plain">-</span><span class="identifier">definite</span><span class="plain">&gt;					==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1]</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP21"></a><b>&#167;21.  </b></p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">NewVerbs::new_adjective_SMF</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">task</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">V</span><span class="plain">, </span><span class="identifier">wording</span><span class="plain"> *</span><span class="identifier">NPs</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">SW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[0]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">OW</span><span class="plain"> = (</span><span class="identifier">NPs</span><span class="plain">)?(</span><span class="identifier">NPs</span><span class="plain">[1]):</span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">task</span><span class="plain">) { </span>    <span class="comment">"In French petit is an adjective meaning..."</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">ACCEPT_SMFT</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">new</span><span class="plain">-</span><span class="identifier">adjective</span><span class="plain">-</span><span class="identifier">sentence</span><span class="plain">-</span><span class="identifier">object</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">)) {</span>
                    <span class="identifier">ParseTree::annotate_int</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">, </span><span class="constant">verb_id_ANNOT</span><span class="plain">, </span><span class="constant">SPECIAL_MEANING_VB</span><span class="plain">);</span>
                    <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">O</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">O</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) { &lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt;(</span><span class="identifier">OW</span><span class="plain">); </span><span class="identifier">O</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;; }</span>
                    <span class="plain">&lt;</span><span class="identifier">nounphrase</span><span class="plain">&gt;(</span><span class="identifier">SW</span><span class="plain">);</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
                    <span class="identifier">V</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> = </span><span class="identifier">O</span><span class="plain">;</span>
                    <span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="constant">TRAVERSE1_SMFT</span><span class="plain">:</span>
                <span class="functiontext">NewVerbs::declare_meaningless_adjective</span><span class="plain">(</span><span class="identifier">V</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>


</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function NewVerbs::new_adjective_SMF is used in <a href="#SP16">&#167;16</a>.</p>

<p class="inwebparagraph"><a id="SP22"></a><b>&#167;22.  </b></p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="reserved">definition</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt; ::=</span>
        <span class="identifier">in</span><span class="plain"> &lt;</span><span class="identifier">natural</span><span class="plain">-</span><span class="identifier">language</span><span class="plain">&gt; ... |		==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">RP</span><span class="plain">[1];</span>
        <span class="plain">...								==&gt; </span><span class="identifier">TRUE</span><span class="plain">; *</span><span class="identifier">XP</span><span class="plain"> = </span><span class="identifier">language_of_play</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP23"></a><b>&#167;23.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">NewVerbs::declare_meaningless_adjective</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">) {</span>
        <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">);</span>
        <span class="plain">&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="reserved">definition</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="constant">PREFORM_LANGUAGE_TYPE</span><span class="plain"> *</span><span class="identifier">nl</span><span class="plain"> = &lt;&lt;</span><span class="identifier">rp</span><span class="plain">&gt;&gt;;</span>
        <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">adjective</span><span class="plain">-</span><span class="reserved">definition</span><span class="plain">-</span><span class="identifier">subject</span><span class="plain">&gt;, 1);</span>
        <span class="reserved">if</span><span class="plain"> (!(&lt;</span><span class="identifier">adaptive</span><span class="plain">-</span><span class="identifier">adjective</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)))</span>
            <span class="identifier">Adjectives::declare</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">nl</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function NewVerbs::declare_meaningless_adjective is used in <a href="#SP21">&#167;21</a>.</p>

<p class="inwebparagraph"><a id="SP24"></a><b>&#167;24. Debug log. </b>The following dumps the entire stock of registered verb and preposition
usages to the debugging log.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">NewVerbs::log</span><span class="plain">(</span><span class="identifier">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vu</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) { </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"(null verb usage)"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain">; }</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"VU: $f "</span><span class="plain">, &amp;(</span><span class="identifier">vu</span><span class="plain">-&gt;</span><span class="identifier">vu_text</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vu</span><span class="plain">-&gt;</span><span class="identifier">negated_form_of_verb</span><span class="plain">) </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"(negated) "</span><span class="plain">);</span>
        <span class="identifier">Linguistics::log_tense_number</span><span class="plain">(</span><span class="identifier">DL</span><span class="plain">, </span><span class="identifier">vu</span><span class="plain">-&gt;</span><span class="identifier">tensed</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">NewVerbs::log_all</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        <span class="identifier">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">;</span>
        <span class="identifier">preposition_identity</span><span class="plain"> *</span><span class="identifier">prep</span><span class="plain">;</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"The current S-grammar has the following verb and preposition usages:\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">, </span><span class="identifier">verb_usage</span><span class="plain">) {</span>
            <span class="functiontext">NewVerbs::log</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">);</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"\</span><span class="plain">n</span><span class="string">"</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">prep</span><span class="plain">, </span><span class="identifier">preposition_identity</span><span class="plain">) {</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"$p\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">prep</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function NewVerbs::log is used in 7/ptu (<a href="7-ptu.html#SP17_1">&#167;17.1</a>).</p>

<p class="endnote">The function NewVerbs::log_all is used in 1/mr (<a href="1-mr.html#SP4_17">&#167;4.17</a>).</p>

<p class="inwebparagraph"><a id="SP25"></a><b>&#167;25. Index tabulation. </b>The following produces the table of verbs in the Phrasebook Index page.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">NewVerbs::tabulate</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="identifier">lexicon_entry</span><span class="plain"> *</span><span class="identifier">lex</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">tense</span><span class="plain">, </span><span class="reserved">char</span><span class="plain"> *</span><span class="identifier">tensename</span><span class="plain">) {</span>
        <span class="identifier">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">; </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">f</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">, </span><span class="identifier">verb_usage</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">vu</span><span class="plain">-&gt;</span><span class="identifier">vu_lex_entry</span><span class="plain"> == </span><span class="identifier">lex</span><span class="plain">) &amp;&amp; (</span><span class="identifier">VerbUsages::is_used_negatively</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">) == </span><span class="identifier">FALSE</span><span class="plain">)</span>
                <span class="plain">&amp;&amp; (</span><span class="identifier">VerbUsages::get_tense_used</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">) == </span><span class="identifier">tense</span><span class="plain">)) {</span>
                <span class="identifier">vocabulary_entry</span><span class="plain"> *</span><span class="identifier">lastword</span><span class="plain"> = </span><span class="identifier">WordAssemblages::last_word</span><span class="plain">(&amp;(</span><span class="identifier">vu</span><span class="plain">-&gt;</span><span class="identifier">vu_text</span><span class="plain">));</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">f</span><span class="plain">) {</span>
                    <span class="identifier">HTMLFiles::open_para</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, 2, </span><span class="string">"tight"</span><span class="plain">);</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"&lt;i&gt;%s:&lt;/i&gt;&amp;nbsp;"</span><span class="plain">, </span><span class="identifier">tensename</span><span class="plain">);</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"; "</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wide::cmp</span><span class="plain">(</span><span class="identifier">Vocabulary::get_exemplar</span><span class="plain">(</span><span class="identifier">lastword</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">), </span><span class="identifier">L</span><span class="string">"by"</span><span class="plain">) == 0) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"B "</span><span class="plain">);</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"A "</span><span class="plain">);</span>
                <span class="identifier">WordAssemblages::index</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, &amp;(</span><span class="identifier">vu</span><span class="plain">-&gt;</span><span class="identifier">vu_text</span><span class="plain">));</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wide::cmp</span><span class="plain">(</span><span class="identifier">Vocabulary::get_exemplar</span><span class="plain">(</span><span class="identifier">lastword</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">), </span><span class="identifier">L</span><span class="string">"by"</span><span class="plain">) == 0) </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"A"</span><span class="plain">);</span>
                <span class="reserved">else</span><span class="plain"> </span><span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"B"</span><span class="plain">);</span>
                <span class="identifier">f</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">f</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">) </span><span class="identifier">HTML_CLOSE</span><span class="plain">(</span><span class="string">"p"</span><span class="plain">);</span>
    <span class="plain">}</span>

    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">NewVerbs::tabulate_meaning</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="identifier">lexicon_entry</span><span class="plain"> *</span><span class="identifier">lex</span><span class="plain">) {</span>
        <span class="identifier">verb_usage</span><span class="plain"> *</span><span class="identifier">vu</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">, </span><span class="identifier">verb_usage</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vu</span><span class="plain">-&gt;</span><span class="identifier">vu_lex_entry</span><span class="plain"> == </span><span class="identifier">lex</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vu</span><span class="plain">-&gt;</span><span class="identifier">where_vu_created</span><span class="plain">)</span>
                    <span class="identifier">Index::link</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">-&gt;</span><span class="identifier">where_vu_created</span><span class="plain">)));</span>
                <span class="identifier">verb_meaning</span><span class="plain"> *</span><span class="identifier">vm</span><span class="plain"> = </span><span class="identifier">Verbs::regular_meaning</span><span class="plain">(</span><span class="identifier">vu</span><span class="plain">-&gt;</span><span class="identifier">verb_used</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vm</span><span class="plain">) {</span>
                    <span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain"> = </span><span class="identifier">VerbMeanings::get_relational_meaning</span><span class="plain">(</span><span class="identifier">vm</span><span class="plain">);</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain">) </span><span class="functiontext">Relations::index_for_verbs</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">bp</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>
        <span class="identifier">preposition_identity</span><span class="plain"> *</span><span class="identifier">prep</span><span class="plain">;</span>
        <span class="identifier">LOOP_OVER</span><span class="plain">(</span><span class="identifier">prep</span><span class="plain">, </span><span class="identifier">preposition_identity</span><span class="plain">)</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prep</span><span class="plain">-&gt;</span><span class="identifier">prep_lex_entry</span><span class="plain"> == </span><span class="identifier">lex</span><span class="plain">) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">prep</span><span class="plain">-&gt;</span><span class="identifier">where_prep_created</span><span class="plain">)</span>
                    <span class="identifier">Index::link</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">ParseTree::get_text</span><span class="plain">(</span><span class="identifier">prep</span><span class="plain">-&gt;</span><span class="identifier">where_prep_created</span><span class="plain">)));</span>
                <span class="identifier">verb_meaning</span><span class="plain"> *</span><span class="identifier">vm</span><span class="plain"> = </span><span class="identifier">Verbs::regular_meaning</span><span class="plain">(</span><span class="identifier">copular_verb</span><span class="plain">, </span><span class="identifier">prep</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">vm</span><span class="plain">) {</span>
                    <span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain"> = </span><span class="identifier">VerbMeanings::get_relational_meaning</span><span class="plain">(</span><span class="identifier">vm</span><span class="plain">);</span>
                    <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain">) </span><span class="functiontext">Relations::index_for_verbs</span><span class="plain">(</span><span class="identifier">OUT</span><span class="plain">, </span><span class="identifier">bp</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="reserved">return</span><span class="plain">;</span>
            <span class="plain">}</span>
    <span class="plain">}</span>

</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function NewVerbs::tabulate appears nowhere else.</p>

<p class="endnote">The function NewVerbs::tabulate_meaning appears nowhere else.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="6-tur.html">Back to 'The Universal Relation'</a></li><li><i>(This section ends Chapter 6: Verbs.)</i></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

