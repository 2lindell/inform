<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>9/pk</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of '9/rk' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">core</a></li><li><a href="index.html#9">Chapter 9: The A-Parser</a></li><li><b>Relation Knowledge</b></li></ul><p class="purpose">This section draws inferences about the relationships between objects or values.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Relationship nodes</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Relationship nodes. </b>Here we have a relationship between subtrees T_X and T_Y, where T_X
must be a list of values or objects (joined into an <code class="display"><span class="extract">AND_NT</span></code> tree), and
T_Y must be a <code class="display"><span class="extract">RELATIONSHIP_NT</span></code> subtree &mdash; which is usually a node
annotated with the predicate meant, and beneath that another list of
objects or values, but there are two exceptional cases to take care of.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Assertions::Relational::assert_subtree_in_relationship</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">value</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">relationship_subtree</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">value</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">relationship_subtree</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">))</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"assert relation between null subtrees"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">relationship_subtree</span><span class="plain">) != </span><span class="identifier">RELATIONSHIP_NT</span><span class="plain">)</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"asserted malformed relationship subtree"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">value</span><span class="plain">) == </span><span class="identifier">AND_NT</span><span class="plain">) {</span>
            <span class="functiontext">Assertions::Relational::assert_subtree_in_relationship</span><span class="plain">(</span><span class="identifier">value</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">, </span><span class="identifier">relationship_subtree</span><span class="plain">);</span>
            <span class="functiontext">Assertions::Relational::assert_subtree_in_relationship</span><span class="plain">(</span><span class="identifier">value</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">, </span><span class="identifier">relationship_subtree</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>

        <span class="reserved">switch</span><span class="plain">(</span><span class="identifier">ParseTree::int_annotation</span><span class="plain">(</span><span class="identifier">relationship_subtree</span><span class="plain">, </span><span class="identifier">relationship_node_type_ANNOT</span><span class="plain">)) {</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">STANDARD_RELN</span><span class="plain">: </span>&lt;<span class="cwebmacro">Standard relationship nodes (the vast majority)</span> <span class="cwebmacronumber">1.1</span>&gt;<span class="plain">;</span>
            <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">IF_MODULE</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">PARENTAGE_HERE_RELN</span><span class="plain">: </span>&lt;<span class="cwebmacro">Exceptional relationship nodes for placing objects "here"</span> <span class="cwebmacronumber">1.2</span>&gt;<span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> </span><span class="identifier">DIRECTION_RELN</span><span class="plain">: </span>&lt;<span class="cwebmacro">Exceptional relationship nodes for map connections</span> <span class="cwebmacronumber">1.3</span>&gt;<span class="plain">;</span>
            <span class="plain">#</span><span class="identifier">endif</span>
            <span class="reserved">default</span><span class="plain">: </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"unknown RELATIONSHIP node type"</span><span class="plain">);</span>
        <span class="plain">}</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Assertions::Relational::assert_subtree_in_relationship is used in 9/ma (<a href="9-ma.html#SP3_3_34_3">&#167;3.3.34.3</a>, <a href="9-ma.html#SP3_3_36">&#167;3.3.36</a>, <a href="9-ma.html#SP3_3_37">&#167;3.3.37</a>).</p>

<p class="inwebparagraph"><a id="SP1_1"></a><b>&#167;1.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Standard relationship nodes (the vast majority)</span> <span class="cwebmacronumber">1.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain"> = </span><span class="functiontext">BinaryPredicates::get_reversal</span><span class="plain">(</span><span class="identifier">ParseTree::get_relationship</span><span class="plain">(</span><span class="identifier">relationship_subtree</span><span class="plain">));</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">bp</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"asserted bp-less relationship subtree"</span><span class="plain">);</span>
        <span class="functiontext">Properties::SettingRelations::fix_property_bp</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">);</span>
        <span class="functiontext">Assertions::Relational::assert_relation_between_subtrees</span><span class="plain">(</span><span class="identifier">value</span><span class="plain">, </span><span class="identifier">bp</span><span class="plain">, </span><span class="identifier">relationship_subtree</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">);</span>
        <span class="reserved">break</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1">&#167;1</a>.</p>

<p class="inwebparagraph"><a id="SP1_2"></a><b>&#167;1.2.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Exceptional relationship nodes for placing objects "here"</span> <span class="cwebmacronumber">1.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_subject</span><span class="plain">(</span><span class="identifier">value</span><span class="plain">) == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_HereFailedOnNothing</span><span class="plain">),</span>
                <span class="string">"that is an assertion which puts nothing 'here'"</span><span class="plain">,</span>
                <span class="string">"which looks as if it might be trying to give me negative rather "</span>
                <span class="string">"than positive information. There's no need to tell me something "</span>
                <span class="string">"like 'Here is nothing.': just don't put anything there."</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
            <span class="functiontext">Calculus::Propositions::Assert::assert_true_about</span><span class="plain">(</span>
                <span class="functiontext">Calculus::Propositions::Abstract::to_put_here</span><span class="plain">(),</span>
                <span class="identifier">ParseTree::get_subject</span><span class="plain">(</span><span class="identifier">value</span><span class="plain">), </span><span class="identifier">prevailing_mood</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">break</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1">&#167;1</a>.</p>

<p class="inwebparagraph"><a id="SP1_3"></a><b>&#167;1.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Exceptional relationship nodes for map connections</span> <span class="cwebmacronumber">1.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        &lt;<span class="cwebmacro">Make some paranoid checks that the map subtree is valid</span> <span class="cwebmacronumber">1.3.1</span>&gt;<span class="plain">;</span>
        <span class="functiontext">Assertions::Relational::substitute_at_node</span><span class="plain">(</span><span class="identifier">relationship_subtree</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">);</span>
        <span class="functiontext">Assertions::Relational::substitute_at_node</span><span class="plain">(</span><span class="identifier">relationship_subtree</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">);</span>
        <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">iy</span><span class="plain"> = </span><span class="identifier">ParseTree::get_subject</span><span class="plain">(</span><span class="identifier">relationship_subtree</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">);</span>
        <span class="reserved">inference_subject</span><span class="plain"> *</span><span class="identifier">id</span><span class="plain"> = </span><span class="identifier">ParseTree::get_subject</span><span class="plain">(</span><span class="identifier">relationship_subtree</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">iy</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Rvalues::is_nothing_object_constant</span><span class="plain">(</span>
                <span class="identifier">ParseTree::get_evaluation</span><span class="plain">(</span><span class="identifier">relationship_subtree</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">)))</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_MapFromNowhere</span><span class="plain">),</span>
                    <span class="string">"the source of a map connection can't be nowhere"</span><span class="plain">,</span>
                    <span class="string">"so sentences like 'The pink door is south of nowhere.' are not "</span>
                    <span class="string">"allowed."</span><span class="plain">);</span>
            <span class="reserved">else</span>
                <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_MapFromNonroom2</span><span class="plain">),</span>
                    <span class="string">"the source of a map connection has to be a room or door"</span><span class="plain">,</span>
                    <span class="string">"so sentences like 'The pink door is south of 0.' are not "</span>
                    <span class="string">"allowed."</span><span class="plain">);</span>
            <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">iy</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) || (</span><span class="identifier">id</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">))</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"malformed directional subtree"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Rvalues::is_nothing_object_constant</span><span class="plain">(</span><span class="identifier">value</span><span class="plain">))</span>
            <span class="identifier">PL::Map::connect</span><span class="plain">(</span><span class="identifier">iy</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">, </span><span class="identifier">id</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">Rvalues::is_object</span><span class="plain">(</span><span class="identifier">ParseTree::get_evaluation</span><span class="plain">(</span><span class="identifier">value</span><span class="plain">)))</span>
            <span class="identifier">PL::Map::connect</span><span class="plain">(</span><span class="identifier">iy</span><span class="plain">, </span><span class="identifier">ParseTree::get_subject</span><span class="plain">(</span><span class="identifier">value</span><span class="plain">), </span><span class="identifier">id</span><span class="plain">);</span>
        <span class="reserved">else</span><span class="plain"> {</span>
            <span class="identifier">LOG</span><span class="plain">(</span><span class="string">"Val is $P\</span><span class="plain">n</span><span class="string">"</span><span class="plain">, </span><span class="identifier">value</span><span class="plain">);</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_MapToNonobject</span><span class="plain">),</span>
                <span class="string">"the destination of a map connection has to be either a room, "</span>
                <span class="string">"a door or 'nowhere'"</span><span class="plain">,</span>
                <span class="string">"but here the destination doesn't even seem to be an object."</span><span class="plain">);</span>
        <span class="plain">}</span>
        <span class="reserved">break</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1">&#167;1</a>.</p>

<p class="inwebparagraph"><a id="SP1_3_1"></a><b>&#167;1.3.1.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Make some paranoid checks that the map subtree is valid</span> <span class="cwebmacronumber">1.3.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">relationship_subtree</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) ||</span>
            <span class="plain">(</span><span class="identifier">relationship_subtree</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) ||</span>
            <span class="plain">(</span><span class="identifier">relationship_subtree</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain"> != </span><span class="identifier">NULL</span><span class="plain">))</span>
            <span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"malformed DIRECTION"</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">relationship_subtree</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">) != </span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">),</span>
                <span class="string">"this is not straightforward in saying which room (or door) leads away from"</span><span class="plain">,</span>
                <span class="string">"and should just name the source."</span><span class="plain">);</span>
            <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">relationship_subtree</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">) != </span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">BelievedImpossible</span><span class="plain">),</span>
                <span class="string">"this is not straightforward in saying which direction the room (or door) lies in"</span><span class="plain">,</span>
                <span class="string">"and should just name the direction."</span><span class="plain">);</span>
            <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP1_3">&#167;1.3</a>.</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b></p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Assertions::Relational::substitute_at_node</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">p</span><span class="plain">) {</span>
        <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">spec</span><span class="plain"> = </span><span class="identifier">ParseTree::get_evaluation</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">);</span>
        <span class="identifier">spec</span><span class="plain"> = </span><span class="functiontext">NonlocalVariables::substitute_constants</span><span class="plain">(</span><span class="identifier">spec</span><span class="plain">);</span>
        <span class="functiontext">Assertions::Refiner::noun_from_value</span><span class="plain">(</span><span class="identifier">p</span><span class="plain">, </span><span class="identifier">spec</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Assertions::Relational::substitute_at_node is used in <a href="#SP1_3">&#167;1.3</a>.</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>So the majority case above calls <code class="display"><span class="extract">Assertions::Relational::assert_relation_between_subtrees</span></code> to say
that subtrees T_X and T_Y, where T_X is a single value or object and
T_Y is a list of values or objects (joined into an <code class="display"><span class="extract">AND_NT</span></code> tree).
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Assertions::Relational::assert_relation_between_subtrees</span><span class="plain">(</span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">px</span><span class="plain">, </span><span class="reserved">binary_predicate</span><span class="plain"> *</span><span class="identifier">bp</span><span class="plain">, </span><span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">py</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">py</span><span class="plain">) == </span><span class="identifier">AND_NT</span><span class="plain">) {</span>
            <span class="functiontext">Assertions::Relational::assert_relation_between_subtrees</span><span class="plain">(</span><span class="identifier">px</span><span class="plain">, </span><span class="identifier">bp</span><span class="plain">, </span><span class="identifier">py</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">);</span>
            <span class="functiontext">Assertions::Relational::assert_relation_between_subtrees</span><span class="plain">(</span><span class="identifier">px</span><span class="plain">, </span><span class="identifier">bp</span><span class="plain">, </span><span class="identifier">py</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">-</span><span class="element">&gt;next</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">py</span><span class="plain">) == </span><span class="identifier">WITH_NT</span><span class="plain">) {</span>
            <span class="functiontext">Assertions::Relational::assert_relation_between_subtrees</span><span class="plain">(</span><span class="identifier">px</span><span class="plain">, </span><span class="identifier">bp</span><span class="plain">, </span><span class="identifier">py</span><span class="plain">-</span><span class="element">&gt;down</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">py</span><span class="plain">) == </span><span class="constant">EVERY_NT</span><span class="plain">) </span>&lt;<span class="cwebmacro">Issue problem for "every" used on the right</span> <span class="cwebmacronumber">3.3</span>&gt;<span class="plain">;</span>

        <span class="comment">reverse the relation (and swap the terms) to ensure it's the right way round</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="functiontext">BinaryPredicates::is_the_wrong_way_round</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">)) {</span>
            <span class="identifier">parse_node</span><span class="plain"> *</span><span class="identifier">pz</span><span class="plain"> = </span><span class="identifier">px</span><span class="plain">; </span><span class="identifier">px</span><span class="plain"> = </span><span class="identifier">py</span><span class="plain">; </span><span class="identifier">py</span><span class="plain"> = </span><span class="identifier">pz</span><span class="plain">;</span>
            <span class="identifier">bp</span><span class="plain"> = </span><span class="functiontext">BinaryPredicates::get_reversal</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">);</span>
        <span class="plain">}</span>

        &lt;<span class="cwebmacro">Normalise the two noun leaves</span> <span class="cwebmacronumber">3.1</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Impose a tedious restriction on relations between objects and values</span> <span class="cwebmacronumber">3.2</span>&gt;<span class="plain">;</span>

        <span class="functiontext">Calculus::Propositions::Assert::assert_true</span><span class="plain">(</span>
            <span class="functiontext">Calculus::Propositions::Abstract::to_set_relation</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">, </span><span class="identifier">ParseTree::get_subject</span><span class="plain">(</span><span class="identifier">px</span><span class="plain">), </span><span class="identifier">ParseTree::get_evaluation</span><span class="plain">(</span><span class="identifier">px</span><span class="plain">), </span><span class="identifier">ParseTree::get_subject</span><span class="plain">(</span><span class="identifier">py</span><span class="plain">), </span><span class="identifier">ParseTree::get_evaluation</span><span class="plain">(</span><span class="identifier">py</span><span class="plain">)),</span>
            <span class="identifier">prevailing_mood</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Assertions::Relational::assert_relation_between_subtrees is used in <a href="#SP1_1">&#167;1.1</a>.</p>

<p class="inwebparagraph"><a id="SP3_1"></a><b>&#167;3.1.  </b>Both sides have to be nouns representing constant values:
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Normalise the two noun leaves</span> <span class="cwebmacronumber">3.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="functiontext">Assertions::Refiner::coerce_adjectival_usage_to_noun</span><span class="plain">(</span><span class="identifier">px</span><span class="plain">); </span><span class="functiontext">Assertions::Refiner::turn_player_to_yourself</span><span class="plain">(</span><span class="identifier">px</span><span class="plain">);</span>
        <span class="functiontext">Assertions::Refiner::coerce_adjectival_usage_to_noun</span><span class="plain">(</span><span class="identifier">py</span><span class="plain">); </span><span class="functiontext">Assertions::Refiner::turn_player_to_yourself</span><span class="plain">(</span><span class="identifier">py</span><span class="plain">);</span>

        <span class="reserved">if</span><span class="plain"> (((</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">px</span><span class="plain">) != </span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">) &amp;&amp; (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">px</span><span class="plain">) != </span><span class="constant">COMMON_NOUN_NT</span><span class="plain">)) ||</span>
            <span class="plain">((</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">py</span><span class="plain">) != </span><span class="identifier">PROPER_NOUN_NT</span><span class="plain">) &amp;&amp; (</span><span class="identifier">ParseTree::get_type</span><span class="plain">(</span><span class="identifier">py</span><span class="plain">) != </span><span class="constant">COMMON_NOUN_NT</span><span class="plain">))) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_BadRelation</span><span class="plain">),</span>
                <span class="string">"this description of a relationship makes no sense to me"</span><span class="plain">,</span>
                <span class="string">"and should be something like 'X is in Y' (or 'on' or 'part of Y'); "</span>
                <span class="string">"or else 'X is here' or 'X is east of Y'."</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP3">&#167;3</a>.</p>

<p class="inwebparagraph"><a id="SP3_2"></a><b>&#167;3.2.  </b>At some point we should probably revisit this.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Impose a tedious restriction on relations between objects and values</span> <span class="cwebmacronumber">3.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="reserved">if</span><span class="plain"> ((</span><span class="functiontext">BinaryPredicates::relates_values_not_objects</span><span class="plain">(</span><span class="identifier">bp</span><span class="plain">)) &amp;&amp;</span>
            <span class="plain">(((</span><span class="identifier">ParseTree::get_subject</span><span class="plain">(</span><span class="identifier">px</span><span class="plain">)) &amp;&amp; (</span><span class="functiontext">InferenceSubjects::domain</span><span class="plain">(</span><span class="identifier">ParseTree::get_subject</span><span class="plain">(</span><span class="identifier">px</span><span class="plain">)))) ||</span>
            <span class="plain">((</span><span class="identifier">ParseTree::get_subject</span><span class="plain">(</span><span class="identifier">py</span><span class="plain">)) &amp;&amp; (</span><span class="functiontext">InferenceSubjects::domain</span><span class="plain">(</span><span class="identifier">ParseTree::get_subject</span><span class="plain">(</span><span class="identifier">py</span><span class="plain">)))))) {</span>
            <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_KindRelatedToValue</span><span class="plain">),</span>
                <span class="string">"relations between objects and values have to be made one "</span>
                <span class="string">"object at a time"</span><span class="plain">,</span>
                <span class="string">"not using kinds of object to make multiple relationships in "</span>
                <span class="string">"a single sentence. (Sorry for this restriction. It's sometimes "</span>
                <span class="string">"possible to get around it using words like 'every': for example, "</span>
                <span class="string">"'Every person is in the Ballroom.' is allowed.)"</span><span class="plain">);</span>
            <span class="reserved">return</span><span class="plain">;</span>
        <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP3">&#167;3</a>.</p>

<p class="inwebparagraph"><a id="SP3_3"></a><b>&#167;3.3.  </b><code class="display">
&lt;<span class="cwebmacrodefn">Issue problem for "every" used on the right</span> <span class="cwebmacronumber">3.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">Problems::Issue::sentence_problem</span><span class="plain">(</span><span class="identifier">_p_</span><span class="plain">(</span><span class="identifier">PM_EveryWrongSide</span><span class="plain">),</span>
            <span class="string">"'every' can only be used on the other side of the verb"</span><span class="plain">,</span>
            <span class="string">"because of limitations in Inform (but also to avoid certain possible "</span>
            <span class="string">"ambiguities). In general, 'every' should be applied to the subject of an "</span>
            <span class="string">"assertion sentence and not the object. Thus 'Sir Francis prefers every "</span>
            <span class="string">"blonde' is not allowed, but 'Every blonde is preferred by Sir Francis' is. "</span>
            <span class="string">"(It would be different if, instead of Sir Francis who's just one man, "</span>
            <span class="string">"the name of a kind appeared: 'A vehicle is in every room' is fine, for "</span>
            <span class="string">"example, because 'vehicle' is a kind.)"</span><span class="plain">);</span>
        <span class="reserved">return</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP3">&#167;3</a>.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="9-pk.html">Back to 'Property Knowledge'</a></li><li><a href="9-ass.html">Continue with 'Assemblies'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

