<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Booklet Title</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of 'P/ui' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">inter 1</a></li><li><a href="index.html#P">Preliminaries</a></li><li><b>Using Inter</b></li></ul><p class="purpose">Using Inter at the command line.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. What Inter does</a></li><li><a href="#SP2">&#167;2. Command-line usage</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. What Inter does. </b>The command-line executable Inter packages up the back end of the Inform 7
compiler into a stand-alone tool, and enables that back end to be used more
flexibly. For example, it can read or write either textual or binary inter
code, and can convert between them. It can also perform any of the numerous
code-generation stages on the code it reads, in any sequence. In short, it
aims to be a Swiss Army knife for inter code.
</p>

<p class="inwebparagraph">Because of that, it's possible to test code-generation stages individually:
we can read in some inter code from a text file, perform a single stage on
it, and write it out as text again. This gives us a very helpful window into
what Inform is doing; it also provides a test-bed for future optimisation,
or for future applications of inter code.
</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Command-line usage. </b>If you have compiled the standard distribution of the command-line tools
for Inform then the Inter executable will be at <code class="display"><span class="extract">inter/Tangled/inter</span></code>.
</p>

<p class="inwebparagraph">Inter has three basic modes. In the first, the command line specifies only
a single file:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inter/Tangled/inter INTERFILE</span>
</pre>

<p class="inwebparagraph">Inter simply verifies this file for correctness: that is, to see if the inter
code supplied conforms to the inter specification. It returns the exit code 0
if all is well, and issues error messages and returns 1 if not.
</p>

<p class="inwebparagraph">Such files can be in either textual or binary form, and Inter automatically
detects which by looking at their contents. (Conventionally, such files
have the filename extension <code class="display"><span class="extract">.intert</span></code> or <code class="display"><span class="extract">.interb</span></code> respectively, but that's
not how Inter decides.)
</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>In the second mode, Inter converts from textual to binary form or vice
versa. The option <code class="display"><span class="extract">-binary X</span></code> writes a binary form of the inter to file <code class="display"><span class="extract">X</span></code>,
and <code class="display"><span class="extract">-textual X</span></code> writes a text form. So, for example,
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inter/Tangled/inter my.intert -binary my.interb</span>
</pre>

<p class="inwebparagraph">converts <code class="display"><span class="extract">my.intert</span></code> (a textual inter file) to its binary equivalent
<code class="display"><span class="extract">my.interb</span></code>, and conversely:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inter/Tangled/inter my.interb -textual my.intert</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>In the third and most flexible mode, Inter runs the supplied code through
a pipeline of processing stages. The pipeline, which must contain at least
one stage, can be quite elaborate (see later), but for example:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">read &lt;- myfile.inter, resolve-conditional-compilation, generate inform6 -&gt; myfile.i6</span>
</pre>

<p class="inwebparagraph">is a valid three-stage pipeline. The command to do this is then:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inter/Tangled/inter -pipeline 'PIPELINE'</span>
</pre>

<p class="inwebparagraph">where <code class="display"><span class="extract">PIPELINE</span></code> is a textual description like the one above. In practice,
it may not be convenient to spell the pipeline out on the command line, so
one can also put it into a text file:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inter/Tangled/inter -pipeline-file mypl.interpipeline</span>
</pre>

<p class="inwebparagraph">Pipelines can contain variables, and their values can be set at the command
line with e.g.:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">-variable '*out=myfile.i6'</span>
</pre>

<p class="inwebparagraph">It is also possible to set the default directory for reading and writing files:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">-domain D</span>
</pre>

<p class="inwebparagraph">Finally, we can tell Inter where to find I6T template files:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">-template T</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><i>(This section begins Preliminaries.)</i></li><li><a href="P-ti.html">Continue with 'Textual Inter'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

