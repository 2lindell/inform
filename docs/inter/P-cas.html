<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>P/ia</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of 'P/cas' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">inter 1</a></li><li><a href="index.html#P">Preliminaries</a></li><li><b>Chains and Stages</b></li></ul><p class="purpose">Sequences of named code-generation stages are called chains.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Stages and descriptions</a></li><li><a href="#SP3">&#167;3. The code-generation stages</a></li><li><a href="#SP13">&#167;13. Diagnostic or non-working stages</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Stages and descriptions. </b>A processing stage is a step in code generation which acts on a repository
of inter in memory. Some stages change, add to or edit down that code, while
others leave it untouched but output a file based on it.
</p>

<p class="inwebparagraph">Each stage can see an entire repository of inter code at a time, and is
not restricted to working through it in sequence. Those which read in or write
out a file also have a filename supplied to them as a parameter, but there
are otherwise no configuration options. It's not possible to tell a stage
to work on one specific function alone, for example.
</p>

<p class="inwebparagraph">Stages are named, which are written without spaces, and conventionally use
hyphens: for example, <code class="display"><span class="extract">resolve-conditional-compilation</span></code>. Where a filename has
to be supplied, it appears after a colon. Thus <code class="display"><span class="extract">generate-inter:my.intert</span></code>
is a valid stage description.
</p>

<p class="inwebparagraph">A "chain" is a comma-separated list of stage descriptions, and represents a
sort of program to follow: memory inter is passed through each stage in turn.
The special stage <code class="display"><span class="extract">stop</span></code> halts processing of the chain midway. At present
this is only useful for making experimental edits to chain descriptions
to see what just the first half does, without deleting the second half of
the description.
</p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>There are three ways to use chains. One is from the command line of Inter:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inter/Tangled/inter FILE -inter 'CHAIN'</span>
</pre>

<p class="inwebparagraph">The other is to use two experimental features of Inform. This sentence:
</p>

<blockquote>
    <p>Use inter chain "STAGES".</p>

</blockquote>

<p class="inwebparagraph">replaces the chain normally used for code generation with the one supplied.
(This may very well cause the compiler not to produce viable code, of course.)
Equivalently, a replacement chain can be specified at the Inform 7 command line:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">$ inform7/Tangled/inform7 ... -inter 'CHAIN'</span>
</pre>

<p class="inwebparagraph">When using a chain within Inform, one further description syntax is allowed:
the filename <code class="display"><span class="extract">*</span></code> means "the filename Inform wants to use for the final
Inform 6 file". This tends to be used for the final stage in the chain, which
is normally <code class="display"><span class="extract">generate-i6:*</span></code>.
</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. The code-generation stages. </b>The following are all experimental, and have probably not yet reached their
final form or names. But this briefly describes the stages which currently
exist in the code generator. In the description below, the "repository" is
the reservoir of memory inter code being worked on.
</p>

<p class="inwebparagraph">Although one thinks of code generation as a process of turning inter into
Inform 6, in fact it goes both ways, because we also have to read in
the "template" of standing Inform 6 code. The early code generation stages
convert the template from Inform 6 into inter, merging it with the inter
already produced by the front end of the compiler. The later stages then
turn this merged repository into Inform 6 code. (Routines in the template,
therefore, are converted out of Inform 6 and then back into it again. This
sounds inefficient but is surprisingly fast, and enables many optimisations.)
</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b><code class="display"><span class="extract">link:T</span></code> reads in the I6T template file T, converts it to inter in a very
basic way (creating many splats), and merges it with the repository. Splats
are the unhappiest of inter statements, simply including verbatim snippets
of Inform 6 code.
</p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b><code class="display"><span class="extract">parse-linked-matter</span></code> examines the splats produced by linking and annotates
them by what they seem to want to do. For example,
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">splat &amp;"Global nitwit = 2;\n"</span>
</pre>

<p class="inwebparagraph">is recognised as an Inform 6 variable declaration, and annotated thus:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">splat GLOBAL &amp;"Global nitwit = 2;\n"</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6.  </b><code class="display"><span class="extract">resolve-conditional-compilation</span></code> looks for splats arising from Inform 6
conditional compilation directives such as <code class="display"><span class="extract">#ifdef</span></code>, <code class="display"><span class="extract">#ifndef</span></code>, <code class="display"><span class="extract">#endif</span></code>;
it then detects whether the relevant symbols are defined, or looks at their
values, and deletes sections of code not to be compiled. At the end of this
stage, there are no conditional compilation splats left in the repository.
For example:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">constant MAGIC K_number = 16339</span>
        <span class="plain">splat IFTRUE &amp;"#iftrue MAGIC == 16339;\n"</span>
        <span class="plain">constant WIZARD K_number = 5</span>
        <span class="plain">splat IFNOT &amp;"#ifnot;\n"</span>
        <span class="plain">constant MUGGLE K_number = 0</span>
        <span class="plain">splat ENDIF &amp;"#endif;\n"</span>
</pre>

<p class="inwebparagraph">is resolved to:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">constant MAGIC K_number = 16339</span>
        <span class="plain">constant WIZARD K_number = 5</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b><code class="display"><span class="extract">assimilate</span></code> aims to convert all remaining splats in the repository into
higher-level inter statements. For example,
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">splat STUB &amp;"#Stub Peach 0;\n"</span>
        <span class="plain">splat ATTRIBUTE &amp;"Attribute marmorial;\n"</span>
</pre>

<p class="inwebparagraph">becomes:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">constant Peach K_unchecked_function = Peach_B __assimilated=1</span>
        <span class="plain">property marmorial K_truth_state __assimilated=1 __attribute=1 __either_or=1</span>
</pre>

<p class="inwebparagraph">At the end of this stage, there should be no splats left in the repository,
and the linking process is complete.
</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b><code class="display"><span class="extract">make-identifiers-unique</span></code> looks for symbols marked with the <code class="display"><span class="extract">MAKE_NAME_UNIQUE</span></code>
flag (represented in textual form by an asterisk after its name), This flag
means that Inform wants the symbol name to be globally unique in the repository.
For example, if Inform generates the symbol name <code class="display"><span class="extract">fruit*</span></code>, it's really telling
the code generator that it eventually wants this to have a name which won't
collide with anything else.
</p>

<p class="inwebparagraph">What <code class="display"><span class="extract">make-identifiers-unique</span></code> does is to append <code class="display"><span class="extract">_U1</span></code>, <code class="display"><span class="extract">_U2</span></code>, ... to such
names across the repository. Thus <code class="display"><span class="extract">fruit*</span></code> might become <code class="display"><span class="extract">fruit_U176</span></code>, and it
is guaranteed that no other symbol has the same name.
</p>

<p class="inwebparagraph">This stage is needed because whereas the inter language has namespces, so
that the same name can mean different things in different parts of the
program, Inform 6 (mostly) does not. There cannot be two functions with the
same name in any I6 program, for example.
</p>

<p class="inwebparagraph">At the end of this stage, no symbol still has the <code class="display"><span class="extract">MAKE_NAME_UNIQUE</span></code> flag.
</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9.  </b><code class="display"><span class="extract">reconcile-verbs</span></code> is a short stage looking for clashes between any verbs (in
the parser interactive fiction sense) which have been assimilated from the
template, and verbs which have been defined in the main source text. For
example, suppose the source creates the command verb "abstract": this would
collide with the command meta-verb "abstract", intended for debugging, which
appears in the template. What this stage does is to detect such problems,
and if it finds one, to prefix the template verb with <code class="display"><span class="extract">!</span></code>. Thus we would end
up with two command verbs: <code class="display"><span class="extract">abstract</span></code>, with its source text meaning, and
<code class="display"><span class="extract">!abstract</span></code>, with its template meaning.
</p>

<p class="inwebparagraph">At the end of this stage, all parser verbs have distinct textual forms.
</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b><code class="display"><span class="extract">generate-inter:F</span></code> writes out the repository as a textual inter file <code class="display"><span class="extract">F</span></code>.
(By default, Inform doesn't do this: the inter ordinarily stays in memory
throughout.)
</p>

<p class="inwebparagraph">This stage leaves the repository unchanged.
</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b><code class="display"><span class="extract">generate-inter-binary:F</span></code> writes out the repository as a binary inter
file <code class="display"><span class="extract">F</span></code>. (By default, Inform doesn't do this: the inter ordinarily stays in
memory throughout.)
</p>

<p class="inwebparagraph">This stage leaves the repository unchanged.
</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12.  </b><code class="display"><span class="extract">generate-i6:F</span></code> translates the repository to an Inform 6 program. This is
normally the final stage in the Inform code generation chain.
</p>

<p class="inwebparagraph">This stage leaves the repository unchanged.
</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. Diagnostic or non-working stages. </b></p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14.  </b><code class="display"><span class="extract">show-dependencies:F</span></code> and <code class="display"><span class="extract">log-dependencies</span></code> output a dependency graph of
the symbols in the current repository, one to a file, the other to the
debugging log. A dependency means that one can't be compiled without the
other: for example, if a function has a local variable of a given kind, then
the function depends on that kind.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">eliminate-redundant-code</span></code> is a stage which removes all material from
the repository which the main routine is not dependent on. This can result
in many template routines being kicked out, and substantially reduces
story file sizes. The stage mostly works, but needs more refinement before
we could safely enable it by default with Inform.
</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b><code class="display"><span class="extract">summarise:F</span></code> is a very slow diagnostic stage showing the breakdown of the
current repository into packages, writing the output to file <code class="display"><span class="extract">F</span></code>. (Slow in
this sense means that it roughly triples compilation time.)
</p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16.  </b><code class="display"><span class="extract">export:F</span></code> and <code class="display"><span class="extract">import:F</span></code> were part of an experiment to do with caching the
inter generated by the Standard Rules. This eventually worked, but was put on
ice while a better and more systematic solution was found.
</p>

<hr class="tocbar">
<ul class="toc"><li><a href="P-ia.html">Back to 'Inform Annotations'</a></li><li><i>(This section ends Preliminaries.)</i></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

