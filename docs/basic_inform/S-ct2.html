<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>S/ct</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of 'S/ct2' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">basic_inform Template Library</a></li><li><b>Combinations Template</b></li></ul><p class="purpose">Code to support the combination kind of value constructor.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Block Format</a></li><li><a href="#SP2">&#167;2. KOV Support</a></li><li><a href="#SP3">&#167;3. Creation</a></li><li><a href="#SP4">&#167;4. Destruction</a></li><li><a href="#SP5">&#167;5. Copying</a></li><li><a href="#SP6">&#167;6. Comparison</a></li><li><a href="#SP7">&#167;7. Hashing</a></li><li><a href="#SP8">&#167;8. Printing</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Block Format. </b>A combination is like a list, but simpler; it has a fixed, usually short,
size. On the other hand, its entries are not all of the same kind as each
other.
</p>

<p class="inwebparagraph">The short block for a combination is simply a pointer to the long block.
This consists of one word to hold the strong kind ID, and then one word
for each entry in the combination. Thus, a triple combination uses 4 words.
</p>


<pre class="display">
    <span class="plain">Constant COMBINATION_KIND_F = 0;    ! Strong kind ID</span>
    <span class="plain">Constant COMBINATION_ITEM_BASE = 1; ! List items begin at this entry</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. KOV Support. </b>See the "BlockValues.i6t" segment for the specification of the following
routines.
</p>


<pre class="display">
    <span class="plain">[ COMBINATION_TY_Support task arg1 arg2 arg3;</span>
        <span class="plain">switch(task) {</span>
            <span class="plain">CREATE_KOVS:      return COMBINATION_TY_Create(arg1, arg2);</span>
            <span class="plain">DESTROY_KOVS:     COMBINATION_TY_Destroy(arg1);</span>
            <span class="plain">MAKEMUTABLE_KOVS: return 1;</span>
            <span class="plain">COPYKIND_KOVS:    return COMBINATION_TY_CopyKind(arg1, arg2);</span>
            <span class="plain">COPYQUICK_KOVS:   rtrue;</span>
            <span class="plain">COPYSB_KOVS:	  BlkValueCopySB1(arg1, arg2);</span>
            <span class="plain">KINDDATA_KOVS:    return COMBINATION_TY_KindData(arg1);</span>
            <span class="plain">EXTENT_KOVS:      return -1;</span>
            <span class="plain">COPY_KOVS:        COMBINATION_TY_Copy(arg1, arg2, arg3);</span>
            <span class="plain">COMPARE_KOVS:     return COMBINATION_TY_Compare(arg1, arg2);</span>
            <span class="plain">HASH_KOVS:        return COMBINATION_TY_Hash(arg1);</span>
            <span class="plain">DEBUG_KOVS:       print " = ", (COMBINATION_TY_Say) arg1;</span>
        <span class="plain">}</span>
        <span class="plain">! We choose not to respond to: CAST_KOVS, READ_FILE_KOVS, WRITE_FILE_KOVS</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Creation. </b>A combination is like a list, but simpler; it has a fixed, usually short,
size. On the other hand, its entries are not all of the same kind as each
other.
</p>

<p class="inwebparagraph">Combinations are stored as a fixed-sized block of word entries. The first
block is the only header information: a pointer to a further structure in
memory, describing the kind. The subsequent blocks are the actual records.
Thus, a triple (x, y, z) uses 4 words.
</p>


<pre class="display">
    <span class="plain">[ COMBINATION_TY_Create kind sb long_block N i bk v;</span>
        <span class="plain">N = KindBaseArity(kind);</span>
        <span class="plain">long_block = FlexAllocate(</span>
            <span class="plain">(COMBINATION_ITEM_BASE+N)*WORDSIZE, COMBINATION_TY, BLK_FLAG_WORD);</span>
        <span class="plain">BlkValueWrite(long_block, COMBINATION_KIND_F, kind, true);</span>
        <span class="plain">for (i=0: i&lt;N: i++) {</span>
            <span class="plain">bk = KindBaseTerm(kind, i);</span>
            <span class="plain">if (KOVIsBlockValue(bk)) v = BlkValueCreate(bk);</span>
            <span class="plain">else v = DefaultValueOfKOV(bk);</span>
            <span class="plain">BlkValueWrite(long_block, COMBINATION_ITEM_BASE+i, v, true);</span>
        <span class="plain">}</span>
        <span class="plain">return BlkValueCreateSB1(sb, long_block);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Destruction. </b>If the comb items are themselves block-values, they must all be freed before
the comb itself can be freed.
</p>


<pre class="display">
    <span class="plain">[ COMBINATION_TY_Destroy comb kind no_items i bk;</span>
        <span class="plain">kind = BlkValueRead(comb, COMBINATION_KIND_F);</span>
        <span class="plain">no_items = KindBaseArity(kind);</span>
        <span class="plain">for (i=0: i&lt;no_items: i++) {</span>
            <span class="plain">bk = KindBaseTerm(kind, i);</span>
            <span class="plain">if (KOVIsBlockValue(bk))</span>
                <span class="plain">BlkValueFree(BlkValueRead(comb, i+COMBINATION_ITEM_BASE));</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Copying. </b>Again, if the comb contains block-values then they must be duplicated rather
than bitwise copied as pointers.
</p>


<pre class="display">
    <span class="plain">[ COMBINATION_TY_CopyKind to from;</span>
        <span class="plain">BlkValueWrite(to, COMBINATION_KIND_F, BlkValueRead(from, COMBINATION_KIND_F));</span>
    <span class="plain">];</span>

    <span class="plain">[ COMBINATION_TY_CopySB to from;</span>
        <span class="plain">BlkValueCopySB1(to, from);</span>
    <span class="plain">];</span>

    <span class="plain">[ COMBINATION_TY_KindData comb;</span>
        <span class="plain">return BlkValueRead(comb, COMBINATION_KIND_F);</span>
    <span class="plain">];</span>

    <span class="plain">[ COMBINATION_TY_Copy to_comb from_comb precopied_comb_kov  no_items i nv kind bk;</span>
        <span class="plain">! kind = BlkValueRead(to_comb, COMBINATION_KIND_F);</span>
        <span class="plain">no_items = KindBaseArity(precopied_comb_kov);</span>
        <span class="plain">BlkValueWrite(to_comb, COMBINATION_KIND_F, precopied_comb_kov);</span>
        <span class="plain">for (i=0: i&lt;no_items: i++) {</span>
            <span class="plain">bk = KindBaseTerm(kind, i);</span>
            <span class="plain">if (KOVIsBlockValue(bk)) {</span>
                <span class="plain">nv = BlkValueCreate(bk);</span>
                <span class="plain">BlkValueCopy(nv, BlkValueRead(from_comb, i+COMBINATION_ITEM_BASE));</span>
                <span class="plain">BlkValueWrite(to_comb, i+COMBINATION_ITEM_BASE, nv);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Comparison. </b>This is a lexicographic comparison and assumes both combinations have the
same kind.
</p>


<pre class="display">
    <span class="plain">[ COMBINATION_TY_Compare left_comb right_comb delta no_items i cf kind bk;</span>
        <span class="plain">kind = BlkValueRead(left_comb, COMBINATION_KIND_F);</span>
        <span class="plain">no_items = KindBaseArity(kind);</span>
        <span class="plain">for (i=0: i&lt;no_items: i++) {</span>
            <span class="plain">bk = KindBaseTerm(kind, i);</span>
            <span class="plain">cf = KOVComparisonFunction(bk);</span>
            <span class="plain">if (cf == 0 or UnsignedCompare) {</span>
                <span class="plain">delta = BlkValueRead(left_comb, i+COMBINATION_ITEM_BASE) -</span>
                    <span class="plain">BlkValueRead(right_comb, i+COMBINATION_ITEM_BASE);</span>
                <span class="plain">if (delta) return delta;</span>
            <span class="plain">} else {</span>
                <span class="plain">delta = cf(BlkValueRead(left_comb, i+COMBINATION_ITEM_BASE),</span>
                    <span class="plain">BlkValueRead(right_comb, i+COMBINATION_ITEM_BASE));</span>
                <span class="plain">if (delta) return delta;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">return 0;</span>
    <span class="plain">];</span>

    <span class="plain">[ COMBINATION_TY_Distinguish left_comb right_comb;</span>
        <span class="plain">if (COMBINATION_TY_Compare(left_comb, right_comb) == 0) rfalse;</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Hashing. </b></p>


<pre class="display">
    <span class="plain">[ COMBINATION_TY_Hash comb  kind rv no_items i bk;</span>
        <span class="plain">rv = 0;</span>
        <span class="plain">kind = BlkValueRead(comb, COMBINATION_KIND_F);</span>
        <span class="plain">no_items = KindBaseArity(kind);</span>
        <span class="plain">for (i=0: i&lt;no_items: i++) {</span>
            <span class="plain">bk = KindBaseTerm(kind, i);</span>
            <span class="plain">rv = rv * 33 + GetHashValue(bk, BlkValueRead(comb, i+COMBINATION_ITEM_BASE));</span>
        <span class="plain">}</span>
        <span class="plain">return rv;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Printing. </b></p>


<pre class="display">
    <span class="plain">[ COMBINATION_TY_Say comb format no_items v i kind bk;</span>
        <span class="plain">if ((comb==0) || (BlkValueWeakKind(comb) ~= COMBINATION_TY)) return;</span>
        <span class="plain">kind = BlkValueRead(comb, COMBINATION_KIND_F);</span>
        <span class="plain">no_items = KindBaseArity(kind);</span>
        <span class="plain">print "(";</span>
        <span class="plain">for (i=0: i&lt;no_items: i++) {</span>
            <span class="plain">if (i&gt;0) print ", ";</span>
            <span class="plain">bk = KindBaseTerm(kind, i);</span>
            <span class="plain">v = BlkValueRead(comb, i+COMBINATION_ITEM_BASE);</span>
            <span class="plain">if (bk == LIST_OF_TY) LIST_OF_TY_Say(v, 1);</span>
            <span class="plain">else PrintKindValuePair(bk, v);</span>
        <span class="plain">}</span>
        <span class="plain">print ")";</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="S-ct.html">Back to 'Char Template'</a></li><li><a href="S-dt.html">Continue with 'Definitions Template'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

