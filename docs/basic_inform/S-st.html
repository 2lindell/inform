<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>S/rt4</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of 'S/st' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">basic_inform Template Library</a></li><li><b>Sort Template</b></li></ul><p class="purpose">To sort arrays.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Storage</a></li><li><a href="#SP2">&#167;2. Front End</a></li><li><a href="#SP3">&#167;3. Sort Range</a></li><li><a href="#SP4">&#167;4. Comparison and Exchange</a></li><li><a href="#SP5">&#167;5. 4W37 Sort</a></li><li><a href="#SP6">&#167;6. Insertion Sort</a></li><li><a href="#SP7">&#167;7. In-Place Mergesort</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Storage. </b>We are required to use a stable sorting algorithm with very low, ideally zero,
auxiliary storage requirement. Exchanges are generally slower than comparisons
for the typical application (sorting tables, where entire rows must be
exchanged whereas only entries in a single column need be compared).
</p>

<p class="inwebparagraph">In fact, we store some details in global variables for convenience and to
avoid filling the stack with copies, but otherwise we will hardly need any
auxiliary storage.
</p>


<pre class="display">
    <span class="plain">Global I7S_Tab; ! The array to be sorted, which can have almost any format</span>
    <span class="plain">Global I7S_Col; ! The "column number" in the array, if any</span>
    <span class="plain">Global I7S_Dir; ! The direction of sorting: ascending (1) or descending (-1)</span>
    <span class="plain">Global I7S_Swap; ! The current routine for swapping two fields</span>
    <span class="plain">Global I7S_Comp; ! The current routine for comparing two fields</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Front End. </b>To perform a sort, we first call <code class="display"><span class="extract">SetSortDomain</span></code> to declare the swap and
compare functions to be used, and then call <code class="display"><span class="extract">SortArray</span></code> actually to sort. (It
would be nice to combine these in a single call, but I6 allows a maximum of
7 call arguments for a routine, and that would make 8.) These are the only
two routines which should ever be called from outside of this template
segment.
</p>

<p class="inwebparagraph">The swap and compare functions are expected to take two arguments, which
are the field numbers of the fields being swapped or compared, where fields
are numbered from 1. Comparison is like <code class="display"><span class="extract">strcmp</span></code>: it returns 0 on equality,
and then is positive or negative according to which of the fields is
greater in value.
</p>


<pre class="display">
    <span class="plain">[ SetSortDomain swapf compf;</span>
        <span class="plain">I7S_Swap = swapf;</span>
        <span class="plain">I7S_Comp = compf;</span>
    <span class="plain">];</span>

    <span class="plain">[ SortArray tab col dir size test_flag algorithm;</span>
        <span class="plain">I7S_Tab = tab;</span>
        <span class="plain">I7S_Col = col;</span>
        <span class="plain">I7S_Dir = dir;</span>
        <span class="plain">SortRange(0, size, algorithm);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Sort Range. </b>This routine sorts a range of fields x&lt;= i &lt; y within the array. Fields
are numbered from 0. The supplied <code class="display"><span class="extract">algorithm</span></code> is an I6 routine to implement
a particular sorting algorithm; if it is not supplied, then in-place merge
sort is used by default.
</p>


<pre class="display">
    <span class="plain">[ SortRange x y algorithm;</span>
        <span class="plain">if (y - x &lt; 2) return;</span>
        <span class="plain">if (algorithm) {</span>
            <span class="plain">(algorithm)(x, y);</span>
        <span class="plain">} else {</span>
            <span class="plain">InPlaceMergeSortAlgorithm(x, y);</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Comparison and Exchange. </b>These are instrumented versions of how to swap and compare fields; note that
the swap and compare functions are expected to number the fields from 1, not
from 0. (This is convenient both for tables and lists, where rows and entries
respectively are both numbered from 1.) The only access which the sorting
algorithms have to the actual data being sorted is through these routines.
</p>


<pre class="display">
    <span class="plain">[ CompareFields x y;</span>
        <span class="plain">return I7S_Dir*I7S_Comp(I7S_Tab, I7S_Col, x+1, y+1, I7S_Dir);</span>
    <span class="plain">];</span>

    <span class="plain">[ ExchangeFields x y r;</span>
        <span class="plain">r = I7S_Swap(I7S_Tab, x+1, y+1);</span>
        <span class="plain">return r;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. 4W37 Sort. </b>We now present three alternative sorting algorithms.
</p>

<p class="inwebparagraph">The first is the one used in builds up to and including 4W37: note that this is
not quite bubble sort, and that it is unstable. It is now no longer used, but
is so short that we might as well keep it in the code base in case anyone needs
to resurrect a very early I7 project.
</p>


<pre class="display">
    <span class="plain">[ OldSortAlgorithm x y</span>
        <span class="plain">f i j;</span>
        <span class="plain">if (y - x &lt; 2) return;</span>
        <span class="plain">f = true;</span>
        <span class="plain">while (f) {</span>
            <span class="plain">f = false;</span>
            <span class="plain">for (i=x:i&lt;y:i++)</span>
                <span class="plain">for (j=i+1:j&lt;y:j++)</span>
                    <span class="plain">if (CompareFields(i, j) &gt; 0) {</span>
                        <span class="plain">ExchangeFields(i, j); f = true; break;</span>
                    <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Insertion Sort. </b>A stable algorithm which has O(n^2) running time and therefore cannot be
used with large arrays, but which has good performance on nearly sorted tables,
and which has very low overhead.
</p>


<pre class="display">
    <span class="plain">[ InsertionSortAlgorithm from to</span>
        <span class="plain">i j;</span>
        <span class="plain">if (to &gt; from+1) {</span>
            <span class="plain">for (i = from+1: i &lt; to: i++) {</span>
                <span class="plain">for (j = i: j &gt; from: j--) {</span>
                    <span class="plain">if (CompareFields(j, j-1) &lt; 0)</span>
                        <span class="plain">ExchangeFields(j, j-1);</span>
                    <span class="plain">else break;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. In-Place Mergesort. </b>A stable algorithm with O(nlog n) running time, at some stack cost, and
which is generally good for nearly sorted tables, but which is also complex
and has some overhead. The code here mostly follows Thomas Baudel's
implementation, which in turn follows the <code class="display"><span class="extract">C++</span></code> STL library.
</p>


<pre class="display">
    <span class="plain">[ InPlaceMergeSortAlgorithm from to</span>
        <span class="plain">middle;</span>
        <span class="plain">if (to - from &lt; 12) {</span>
            <span class="plain">if (to - from &lt; 2) return;</span>
            <span class="plain">InsertionSortAlgorithm(from, to);</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">middle = (from + to)/2;</span>
        <span class="plain">InPlaceMergeSortAlgorithm(from, middle);</span>
        <span class="plain">InPlaceMergeSortAlgorithm(middle, to);</span>
        <span class="plain">IPMS_Merge(from, middle, to, middle-from, to - middle);</span>
    <span class="plain">];</span>

    <span class="plain">[ IPMS_Lower from to val</span>
        <span class="plain">len half mid;</span>
        <span class="plain">len = to - from;</span>
        <span class="plain">while (len &gt; 0) {</span>
            <span class="plain">half = len/2;</span>
            <span class="plain">mid = from + half;</span>
            <span class="plain">if (CompareFields(mid, val) &lt; 0) {</span>
                <span class="plain">from = mid + 1;</span>
                <span class="plain">len = len - half -1;</span>
            <span class="plain">} else len = half;</span>
        <span class="plain">}</span>
        <span class="plain">return from;</span>
    <span class="plain">];</span>

    <span class="plain">[ IPMS_Upper from to val</span>
        <span class="plain">len half mid;</span>
        <span class="plain">len = to - from;</span>
        <span class="plain">while (len &gt; 0) {</span>
            <span class="plain">half = len/2;</span>
            <span class="plain">mid = from + half;</span>
            <span class="plain">if (CompareFields(val, mid) &lt; 0)</span>
                <span class="plain">len = half;</span>
            <span class="plain">else {</span>
                <span class="plain">from = mid + 1;</span>
                <span class="plain">len = len - half -1;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">return from;</span>
    <span class="plain">];</span>

    <span class="plain">[ IPMS_Reverse from to;</span>
        <span class="plain">while (from &lt; to) {</span>
            <span class="plain">ExchangeFields(from++, to--);</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ IPMS_Rotate from mid to</span>
        <span class="plain">n val shift p1 p2;</span>
        <span class="plain">if ((from==mid) || (mid==to)) return;</span>
        <span class="plain">IPMS_Reverse(from, mid-1);</span>
        <span class="plain">IPMS_Reverse(mid, to-1);</span>
        <span class="plain">IPMS_Reverse(from, to-1);</span>
    <span class="plain">];</span>

    <span class="plain">[ IPMS_Merge from pivot to len1 len2</span>
        <span class="plain">first_cut second_cut len11 len22 new_mid;</span>
        <span class="plain">if ((len1 == 0) || (len2 == 0)) return;</span>
        <span class="plain">if (len1+len2 == 2) {</span>
            <span class="plain">if (CompareFields(pivot, from) &lt; 0)</span>
            <span class="plain">ExchangeFields(pivot, from);</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">if (len1 &gt; len2) {</span>
            <span class="plain">len11 = len1/2;</span>
            <span class="plain">first_cut = from + len11;</span>
            <span class="plain">second_cut = IPMS_Lower(pivot, to, first_cut);</span>
            <span class="plain">len22 = second_cut - pivot;</span>
        <span class="plain">} else {</span>
            <span class="plain">len22 = len2/2;</span>
            <span class="plain">second_cut = pivot + len22;</span>
            <span class="plain">first_cut = IPMS_Upper(from, pivot, second_cut);</span>
            <span class="plain">len11 = first_cut - from;</span>
        <span class="plain">}</span>
        <span class="plain">IPMS_Rotate(first_cut, pivot, second_cut);</span>
        <span class="plain">new_mid = first_cut + len22;</span>
        <span class="plain">IPMS_Merge(from, first_cut, new_mid, len11, len22);</span>
        <span class="plain">IPMS_Merge(new_mid, second_cut, to, len1 - len11, len2 - len22);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="S-rt4.html">Back to 'Rulebooks Template'</a></li><li><a href="S-tt.html">Continue with 'Tables Template'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

