<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>S/mt</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of 'S/mt2' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">basic_inform Template Library</a></li><li><b>MStack Template</b></li></ul><p class="purpose">To allocate space on the memory stack for frames of variables to be used by rulebooks, activities and actions.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. The Memory Stack</a></li><li><a href="#SP2">&#167;2. Create Frame</a></li><li><a href="#SP3">&#167;3. Destroy Frame</a></li><li><a href="#SP4">&#167;4. Seek Frame</a></li><li><a href="#SP5">&#167;5. Backtrace</a></li><li><a href="#SP6">&#167;6. Access to Variables</a></li><li><a href="#SP7">&#167;7. Access to Nonexistent Variables</a></li><li><a href="#SP8">&#167;8. Rulebook Variables</a></li><li><a href="#SP9">&#167;9. Activity Variables</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. The Memory Stack. </b>The M-Stack, or memory stack, is a sequence of frames, piled upwards.
If we had an accessible stack in memory, we could use that, but neither
the Z-machine nor Glulx has such a stack, alas, alas, alas. The following
is not a very good solution, but it just about works.
</p>


<pre class="display">
    <span class="plain">Constant MAX_MSTACK_FRAME = 2 + MAX_FRAME_SIZE_NEEDED;</span>
    <span class="plain">Constant MSTACK_CAPACITY = 20;</span>
    <span class="plain">Constant MSTACK_SIZE = MSTACK_CAPACITY*MAX_MSTACK_FRAME;</span>

    <span class="plain">Array MStack --&gt; MSTACK_SIZE;</span>
    <span class="plain">Global MStack_Top = 0; ! Topmost word currently used</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Create Frame. </b>A frame is created by calling the following function with two arguments:
<code class="display"><span class="extract">creator</span></code>, a function which initialises a block of variables, and an
ID number identifying the owner.
</p>

<p class="inwebparagraph">The <code class="display"><span class="extract">creator</span></code> function is called with the address at which to initialise
the variables as its first argument, and the value 1 as the second
argument. (The idea is that the same function can be used later to
deallocate the variables, and then the second argument will be -1.)
The <code class="display"><span class="extract">creator</span></code> function returns the extent of the block of memory it has
used, in words. Thus is required to be strictly less than <code class="display"><span class="extract">MAX_MSTACK_FRAME</span></code>
minus 1.
</p>


<pre class="display">
    <span class="plain">[ Mstack_Create_Frame creator id extent;</span>
        <span class="plain">if (creator == 0) rfalse;</span>
        <span class="plain">extent = creator.call(MStack_Top+2, 1);</span>
        <span class="plain">if (extent == 0) rfalse;</span>
        <span class="plain">if (MStack_Top + MAX_MSTACK_FRAME &gt;= MSTACK_SIZE + 2) {</span>
            <span class="plain">RunTimeProblem(RTP_MSTACKMEMORY, MSTACK_SIZE);</span>
            <span class="plain">Mstack_Backtrace();</span>
            <span class="plain">rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">MStack_Top++;</span>
        <span class="plain">MStack--&gt;MStack_Top = id;</span>
        <span class="plain">MStack_Top++;</span>
        <span class="plain">MStack_Top = MStack_Top + extent;</span>
        <span class="plain">MStack--&gt;MStack_Top = -(extent+2);</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Destroy Frame. </b>As sketched above, the same creator function and ID number are passed to
the following routine to destroy the frame again. It takes the stack down
to the level of the most recently created frame with this ID number: note
that each action, for instance, has its own ID number for this purpose,
but can be taking place several times in a nested fashion &mdash; one taking
action might have caused another taking action which caused a third,
for instance, so that there are three incomplete taking actions at once.
In that case, there will be three independent sets of taking action
variables on the M-stack, all with the same ID number. We remove the
topmost one: the implication of that is that frames must always be
destroyed in reverse order of creation.
</p>

<p class="inwebparagraph">In practice, I7 uses frames such that the frame sought should always be
the topmost one in any case, and so that frames are always explicitly
destroyed, not wiped by being undercut when an earlier-created frame
is destroyed.
</p>


<pre class="display">
    <span class="plain">[ Mstack_Destroy_Frame creator id pos;</span>
        <span class="plain">pos = Mstack_Seek_Frame(id);</span>
        <span class="plain">if (pos == 0) rfalse; ! Not found: do nothing</span>
        <span class="plain">MStack_Top = pos - 2; ! Clear mstack down to just below this frame</span>
        <span class="plain">if (creator) creator.call(pos, -1);</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Seek Frame. </b>We return the position on the M-stack of the most recently created frame
with the given ID number (see above), or 0 if no such frame exists; the
size is stored in the global variable <code class="display"><span class="extract">MStack_Frame_Extent</span></code>. (Because word 0
on the stack is used as a sentinel &mdash; all frames are placed above it &mdash; no frame
can actually begin at word 0 on the stack, so 0 is safe to use as an exception.)
</p>


<pre class="display">
    <span class="plain">Global MStack_Frame_Extent = 0;</span>

    <span class="plain">[ Mstack_Seek_Frame id pos;</span>
        <span class="plain">pos = MStack_Top;</span>
        <span class="plain">while ((pos &gt; 0) &amp;&amp; (MStack--&gt;pos ~= 0)) {</span>
            <span class="plain">MStack_Frame_Extent = MStack--&gt;pos;</span>
            <span class="plain">pos = pos + MStack_Frame_Extent;</span>
            <span class="plain">MStack_Frame_Extent = (-2) - MStack_Frame_Extent;</span>
            <span class="plain">if (MStack--&gt;(pos+1) == id) return pos+2;</span>
        <span class="plain">}</span>
        <span class="plain">MStack_Frame_Extent = 0;</span>
        <span class="plain">return 0; ! Not found</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Backtrace. </b>Purely for debugging purposes, and giving feedback if the stack runs out of
memory:
</p>


<pre class="display">
    <span class="plain">[ Mstack_Backtrace pos k;</span>
        <span class="plain">print "Mstack backtrace: size ", MStack_Top+1, " words^";</span>
        <span class="plain">pos = MStack_Top;</span>
        <span class="plain">while (MStack--&gt;pos ~= 0) {</span>
            <span class="plain">MStack_Frame_Extent = MStack--&gt;pos;</span>
            <span class="plain">pos = pos + MStack_Frame_Extent;</span>
            <span class="plain">MStack_Frame_Extent = (-2) - MStack_Frame_Extent;</span>
            <span class="plain">print "Block at ", pos+2,</span>
                <span class="plain">" owner ID ", MStack--&gt;(pos+1), " size ", MStack_Frame_Extent, "^";</span>
            <span class="plain">for (k=0: k&lt;MStack_Frame_Extent: k++) print MStack--&gt;(pos+2+k), " ";</span>
            <span class="plain">print "^";</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Access to Variables. </b>An M-stack variable is identified by a combination of ID number and offset:
for instance ID 20007, offset 1, is the variable "room gone to" belonging
to the going action. The following routine converts that into an address on
the M-stack, in the topmost block with the given ID number (since "room gone
to", for instance, always means its value in the most current going action
of those now under way). Typechecking in the compiler should mean that it is
impossible to produce either error message below: NI will only compile valid
uses of <code class="display"><span class="extract">MstVO</span></code> ("M-stack variable offset") where the seek succeeds and
the offset is within range.
</p>


<pre class="display">
    <span class="plain">[ MstVO id off pos;</span>
        <span class="plain">pos = Mstack_Seek_Frame(id);</span>
        <span class="plain">if (pos == 0) {</span>
            <span class="plain">print "Variable unavailable for this action, activity or rulebook: ",</span>
                <span class="plain">"internal ID number ",</span>
                <span class="plain">id, "/", off, "^";</span>
            <span class="plain">rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">if ((off&lt;0) || (off &gt;= MStack_Frame_Extent)) {</span>
            <span class="plain">print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";</span>
            <span class="plain">rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">return pos+off;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Access to Nonexistent Variables. </b>A long-standing point where I7 is not as strict in type-checking as it might
be occurs when checking rule preambles like "Before going to a dead end...".
Such a preamble must be checked whatever the current action is &mdash; in many
cases, it will not be a going action at all; which means that "room gone to",
a value implied by the "to" clause, will not exist. If the type-checking
were stricter, it would be a nuisance for authors, and instead we relax a
little by accessing such variables using a more forgiving routine. Here,
if a variable does not exist, we return 0 to mean that it can be read at
M-stack position 0: this is the sentinel word, which is not part of any
frame, and which contains 0. Thus the variable reads as if it is 0, the
default for the kind of value "object", which is the KOV for action
variables such as "room gone to".
</p>

<p class="inwebparagraph">The routine may only be used where the variable is being read, and never
where it is to be written, of course: that would corrupt the sentinel.
</p>


<pre class="display">
    <span class="plain">[ MstVON id off pos;</span>
        <span class="plain">pos = Mstack_Seek_Frame(id);</span>
        <span class="plain">if (pos == 0) {</span>
            <span class="plain">return 0; ! word position 0 on the M-stack</span>
        <span class="plain">}</span>
        <span class="plain">if ((off&lt;0) || (off &gt;= MStack_Frame_Extent)) {</span>
            <span class="plain">print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";</span>
            <span class="plain">rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">return pos+off;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Rulebook Variables. </b>Each rulebook has a slate of variables, usually empty, with ID number the
same as the rulebook's own ID number. (Rulebook IDs number upwards from 0
in order of creation in the source text.) The associated creator functions,
usually null, are stored in an array if there is no problem about memory
usage, but with a switch statement if <code class="display"><span class="extract">MEMORY_ECONOMY</span></code> is in force; this
costs a very small amount of time, but saves 1K of readable memory.
</p>


<pre class="display">
    <span class="plain">[ MStack_CreateRBVars rb cr;</span>
        <span class="plain">#ifdef MEMORY_ECONOMY;</span>
        <span class="plain">cr = MStack_GetRBVarCreator(rb);</span>
        <span class="plain">#ifnot;</span>
        <span class="plain">cr = rulebook_var_creators--&gt;rb;</span>
        <span class="plain">#endif;</span>
        <span class="plain">if (cr) Mstack_Create_Frame(cr, rb);</span>
    <span class="plain">];</span>

    <span class="plain">[ MStack_DestroyRBVars rb cr;</span>
        <span class="plain">#ifdef MEMORY_ECONOMY;</span>
        <span class="plain">cr = MStack_GetRBVarCreator(rb);</span>
        <span class="plain">#ifnot;</span>
        <span class="plain">cr = rulebook_var_creators--&gt;rb;</span>
        <span class="plain">#endif;</span>
        <span class="plain">if (cr) Mstack_Destroy_Frame(cr, rb);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Activity Variables. </b>Exactly the same goes for activity variables except that here the ID number
is 10000+N, where N is the allocation ID of the activity. (This would
fail if there were more than 10,000 rulebooks, but this is very difficult
to see happening.)
</p>


<pre class="display">
    <span class="plain">[ MStack_CreateAVVars av cr;</span>
        <span class="plain">cr = activity_var_creators--&gt;av;</span>
        <span class="plain">if (cr == 0) return;</span>
        <span class="plain">Mstack_Create_Frame(cr, av + 10000);</span>
    <span class="plain">];</span>

    <span class="plain">[ MStack_DestroyAVVars av cr;</span>
        <span class="plain">cr = activity_var_creators--&gt;av;</span>
        <span class="plain">if (cr == 0) return;</span>
        <span class="plain">Mstack_Destroy_Frame(cr, av + 10000);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="S-mt.html">Back to 'Mathematics Template'</a></li><li><a href="S-prg.html">Continue with 'Paragraphing'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

