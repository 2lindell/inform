<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>S/gt</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of 'S/lt' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">basic_inform Template Library</a></li><li><b>Lists Template</b></li></ul><p class="purpose">Code to support the list of... kind of value constructor.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Block Format</a></li><li><a href="#SP2">&#167;2. KOV Support</a></li><li><a href="#SP3">&#167;3. Creation</a></li><li><a href="#SP4">&#167;4. Destruction</a></li><li><a href="#SP5">&#167;5. Copying</a></li><li><a href="#SP6">&#167;6. Comparison</a></li><li><a href="#SP7">&#167;7. Hashing</a></li><li><a href="#SP8">&#167;8. Printing</a></li><li><a href="#SP9">&#167;9. List From Description</a></li><li><a href="#SP10">&#167;10. Find Item</a></li><li><a href="#SP11">&#167;11. Insert Item</a></li><li><a href="#SP12">&#167;12. Append List</a></li><li><a href="#SP13">&#167;13. Remove Value</a></li><li><a href="#SP14">&#167;14. Remove Item Range</a></li><li><a href="#SP15">&#167;15. Remove List</a></li><li><a href="#SP16">&#167;16. Get Length</a></li><li><a href="#SP17">&#167;17. Set Length</a></li><li><a href="#SP18">&#167;18. Get Item</a></li><li><a href="#SP19">&#167;19. Write Item</a></li><li><a href="#SP20">&#167;20. Put Item</a></li><li><a href="#SP21">&#167;21. Reversing</a></li><li><a href="#SP22">&#167;22. Rotation</a></li><li><a href="#SP23">&#167;23. Sorting</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Block Format. </b>A list is a variable-length array of values all of which have the same kind.
(Compare a combination, a fixed-length array of values with possibly
different kinds.) The short block for a list is a pointer to the long
block. The long block consists of the strong kind ID of the items
(not of the list itself!), followed by the number of items, followed
by one word for each item.
</p>


<pre class="display">
    <span class="plain">Constant LIST_ITEM_KOV_F = 0; ! The kind of the items</span>
    <span class="plain">Constant LIST_LENGTH_F = 1;   ! The number of items</span>
    <span class="plain">Constant LIST_ITEM_BASE = 2;  ! List items begin at this entry</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. KOV Support. </b>See the "BlockValues.i6t" segment for the specification of the following
routines.
</p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_Support task arg1 arg2 arg3;</span>
        <span class="plain">switch(task) {</span>
            <span class="plain">CREATE_KOVS:      return LIST_OF_TY_Create(arg1, arg2);</span>
            <span class="plain">DESTROY_KOVS:     LIST_OF_TY_Destroy(arg1);</span>
            <span class="plain">MAKEMUTABLE_KOVS: return 1;</span>
            <span class="plain">COPYKIND_KOVS:    return LIST_OF_TY_CopyKind(arg1, arg2);</span>
            <span class="plain">COPYQUICK_KOVS:   return LIST_OF_TY_QuickCopy(arg1, arg2);</span>
            <span class="plain">COPYSB_KOVS:	  BlkValueCopySB1(arg1, arg2);</span>
            <span class="plain">KINDDATA_KOVS:    return LIST_OF_TY_KindData(arg1, arg2);</span>
            <span class="plain">EXTENT_KOVS:      return BlkValueRead(arg1, LIST_LENGTH_F) + LIST_ITEM_BASE;</span>
            <span class="plain">COPY_KOVS:        LIST_OF_TY_Copy(arg1, arg2, arg3);</span>
            <span class="plain">COMPARE_KOVS:     return LIST_OF_TY_Compare(arg1, arg2);</span>
            <span class="plain">HASH_KOVS:        return LIST_OF_TY_Hash(arg1);</span>
            <span class="plain">DEBUG_KOVS:       print " = {", (LIST_OF_TY_Say) arg1, "} of kind ",</span>
                                <span class="plain">BlkValueRead(arg1, LIST_ITEM_KOV_F);</span>
        <span class="plain">}</span>
        <span class="plain">! We choose not to respond to: CAST_KOVS, READ_FILE_KOVS, WRITE_FILE_KOVS</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Creation. </b>Lists are by default created empty but in a block-value with enough capacity
to hold 25 items, this being what's left in a 32-word block once all overheads
are taken care of: 4 words are consumed by the header, then 2 more by the
list metadata entries below.
</p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_Create skov sb list;</span>
        <span class="plain">skov = KindBaseTerm(skov, 0);</span>
        <span class="plain">list = FlexAllocate(27*WORDSIZE, LIST_OF_TY, BLK_FLAG_MULTIPLE + BLK_FLAG_WORD);</span>
        <span class="plain">BlkValueWrite(list, LIST_ITEM_KOV_F, skov, true);</span>
        <span class="plain">BlkValueWrite(list, LIST_LENGTH_F, 0, true);</span>
        <span class="plain">sb = BlkValueCreateSB1(sb, list);</span>
        <span class="plain">return sb;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Destruction. </b>If the list items are themselves block-values, they must all be freed before
the list itself can be freed.
</p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_Destroy list no_items i k;</span>
        <span class="plain">k = BlkValueRead(list, LIST_ITEM_KOV_F);</span>
        <span class="plain">if (KOVIsBlockValue(k)) {</span>
            <span class="plain">no_items = BlkValueRead(list, LIST_LENGTH_F);</span>
            <span class="plain">for (i=0: i&lt;no_items: i++) BlkValueFree(BlkValueRead(list, i+LIST_ITEM_BASE));</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Copying. </b>Again, if the list contains block-values then they must be duplicated rather
than bitwise copied as pointers.
</p>

<p class="inwebparagraph">Note that we use the pre-copy stage to remember the kind of value stored
in the list. Type-checking will make sure this isn't abused: cases where
it's important include copying the empty list into a list of rooms (it
should not as a result acquire the kind "list of values"), or copying
a list of people into a list of things (which should remain a list of
things.)
</p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_CopyKind to from;</span>
        <span class="plain">BlkValueWrite(to, LIST_ITEM_KOV_F, BlkValueRead(from, LIST_ITEM_KOV_F));</span>
    <span class="plain">];</span>

    <span class="plain">[ LIST_OF_TY_QuickCopy to from;</span>
        <span class="plain">if (BlkValueRead(to, LIST_ITEM_KOV_F) ~= BlkValueRead(from, LIST_ITEM_KOV_F))</span>
            <span class="plain">rfalse;</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>

    <span class="plain">[ LIST_OF_TY_KindData list;</span>
        <span class="plain">return BlkValueRead(list, LIST_ITEM_KOV_F);</span>
    <span class="plain">];</span>

    <span class="plain">[ LIST_OF_TY_Copy lto lfrom  precopied_list_kov no_items i nv bk val splk;</span>
        <span class="plain">no_items = BlkValueRead(lfrom, LIST_LENGTH_F);</span>
        <span class="plain">bk = BlkValueRead(lfrom, LIST_ITEM_KOV_F);</span>
        <span class="plain">if (precopied_list_kov ~= 0 or UNKNOWN_TY)</span>
            <span class="plain">BlkValueWrite(lto, LIST_ITEM_KOV_F, precopied_list_kov);</span>
        <span class="plain">else BlkValueWrite(lto, LIST_ITEM_KOV_F, bk);</span>
        <span class="plain">if (KOVIsBlockValue(bk)) {</span>
            <span class="plain">for (i=0: i&lt;no_items: i++) {</span>
                <span class="plain">val = BlkValueRead(lfrom, i+LIST_ITEM_BASE);</span>
                <span class="plain">if (precopied_list_kov ~= 0 or UNKNOWN_TY)</span>
                    <span class="plain">nv = BlkValueCreate(precopied_list_kov);</span>
                <span class="plain">else</span>
                    <span class="plain">nv = BlkValueCreate(bk);</span>
                <span class="plain">BlkValueCopy(nv, val);</span>
                <span class="plain">BlkValueWrite(lto, i+LIST_ITEM_BASE, nv);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Comparison. </b>Lists of a given kind of value are always grouped together, in this comparison:
but the effect of that is unlikely to be noticed since NI's type-checker will
probably prevent comparisons of lists of differing items in any case. The
next criterion is length: a short list precedes a long one. Beyond that, we
use the list's own preferred comparison function to judge the items in turn,
stopping as soon as a pair of corresponding items differs: thus we sort
lists of equal size in lexicographic order.
</p>

<p class="inwebparagraph">Since the comparison function depends only on the KOV, it may seem wasteful
of a word of memory to store it in the list, given that we are already storing
the KOV in any case. But we do this because comparisons have to be fast: we
don't want to incur the overhead of translating KOV to comparison function.
</p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_Compare listleft listright delta no_items i cf;</span>
        <span class="plain">delta = BlkValueRead(listleft, LIST_LENGTH_F) - BlkValueRead(listright, LIST_LENGTH_F);</span>
        <span class="plain">if (delta) return delta;</span>
        <span class="plain">no_items = BlkValueRead(listleft, LIST_LENGTH_F);</span>
        <span class="plain">if (no_items == 0) return 0;</span>
        <span class="plain">delta = BlkValueRead(listleft, LIST_ITEM_KOV_F) - BlkValueRead(listright, LIST_ITEM_KOV_F);</span>
        <span class="plain">if (delta) return delta;</span>
        <span class="plain">cf = LIST_OF_TY_ComparisonFn(listleft);</span>
        <span class="plain">if (cf == 0 or UnsignedCompare) {</span>
            <span class="plain">for (i=0: i&lt;no_items: i++) {</span>
                <span class="plain">delta = BlkValueRead(listleft, i+LIST_ITEM_BASE) -</span>
                    <span class="plain">BlkValueRead(listright, i+LIST_ITEM_BASE);</span>
                <span class="plain">if (delta) return delta;</span>
            <span class="plain">}</span>
        <span class="plain">} else {</span>
            <span class="plain">for (i=0: i&lt;no_items: i++) {</span>
                <span class="plain">delta = cf(BlkValueRead(listleft, i+LIST_ITEM_BASE),</span>
                    <span class="plain">BlkValueRead(listright, i+LIST_ITEM_BASE));</span>
                <span class="plain">if (delta) return delta;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">return 0;</span>
    <span class="plain">];</span>

    <span class="plain">[ LIST_OF_TY_ComparisonFn list;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;</span>
        <span class="plain">return KOVComparisonFunction(BlkValueRead(list, LIST_ITEM_KOV_F));</span>
    <span class="plain">];</span>

    <span class="plain">[ LIST_OF_TY_Distinguish txb1 txb2;</span>
        <span class="plain">if (LIST_OF_TY_Compare(txb1, txb2) == 0) rfalse;</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Hashing. </b></p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_Hash list  len kov rv i;</span>
        <span class="plain">rv = 0;</span>
        <span class="plain">len = BlkValueRead(list, LIST_LENGTH_F);</span>
        <span class="plain">kov = BlkValueRead(list, LIST_ITEM_KOV_F);</span>
        <span class="plain">for (i=0: i&lt;len: i++)</span>
            <span class="plain">rv = rv * 33 + GetHashValue(kov, BlkValueRead(list, i+LIST_ITEM_BASE));</span>
        <span class="plain">return rv;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Printing. </b>Unusually, this function can print the value in one of several formats:
0 for a comma-separated list; 1 for a braced, set-notation list; 2 for
a comma-separated list with definite articles, which only makes sense if
the list contains objects; 3 for a comma-separated list with indefinite
articles. Note that a list in this sense is not printed using the
"ListWriter.i6t" code for elaborate lists of objects, and it doesn't
use the "listing contents of..." activity in any circumstances.
</p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_Say list format no_items v i bk;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return;</span>
        <span class="plain">no_items = BlkValueRead(list, LIST_LENGTH_F);</span>
        <span class="plain">bk = KindAtomic(BlkValueRead(list, LIST_ITEM_KOV_F));</span>
        <span class="plain">! print no_items, " of kov=", BlkValueRead(list, LIST_ITEM_KOV_F), ":";</span>
        <span class="plain">if (format == 1) print "{";</span>
        <span class="plain">for (i=0:i&lt;no_items:i++) {</span>
            <span class="plain">v = BlkValueRead(list, i+LIST_ITEM_BASE);</span>
            <span class="plain">switch (format) {</span>
                <span class="plain">2: print (the) v;</span>
                <span class="plain">3: print (a) v;</span>
                <span class="plain">default:</span>
                    <span class="plain">if (bk == LIST_OF_TY) LIST_OF_TY_Say(v, 1);</span>
                    <span class="plain">else if ((bk == TEXT_TY) &amp;&amp; (format == 1)) {</span>
                        <span class="plain">print "~"; PrintKindValuePair(bk, v); print "~";</span>
                    <span class="plain">}</span>
                    <span class="plain">else PrintKindValuePair(bk, v);</span>
            <span class="plain">}</span>
            <span class="plain">if (i&lt;no_items-2) print ", ";</span>
            <span class="plain">if (i==no_items-2) {</span>
                <span class="plain">if (format == 1) print ", "; else {</span>
                    <span class="plain">if (TEMPLATE_CONFIGURATION_BITMAP &amp; SERIAL_COMMA_TCBIT) {</span>
                        <span class="plain">if (no_items ~= 2) print ",";</span>
                    <span class="plain">}</span>
                    <span class="plain">LIST_WRITER_INTERNAL_RM('C');</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">if (format == 1) print "}";</span>
        <span class="plain">prior_named_list = no_items; prior_named_list_gender = -1;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. List From Description. </b>That completes the compulsory services required for this KOV to function:
from here on, the remaining routines provide definitions of stored action-related
phrases in the Standard Rules.
</p>

<p class="inwebparagraph">Given a description <code class="display"><span class="extract">D</span></code> which applies to some objects and not others &mdash;
say, "lighted rooms adjacent to the Transport Hub" &mdash; we can cast this
into a list of all objects satisfying <code class="display"><span class="extract">D</span></code> with the following routine.
Slightly wastefully of time, we have to iterate through the objects
twice in order first to work out the length of list we will need, and
then to transcribe them.
</p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_Desc list desc kov obj no_items ex len i;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;</span>
        <span class="plain">ex = BlkValueLBCapacity(list);</span>
        <span class="plain">len = desc(-3);</span>
        <span class="plain">if (len+LIST_ITEM_BASE &gt; ex) {</span>
            <span class="plain">if (BlkValueSetLBCapacity(list, len+LIST_ITEM_BASE) == false)</span>
                <span class="plain">return 0;</span>
        <span class="plain">}</span>
        <span class="plain">if (kov) BlkValueWrite(list, LIST_ITEM_KOV_F, kov);</span>
        <span class="plain">else BlkValueWrite(list, LIST_ITEM_KOV_F, OBJECT_TY);</span>
        <span class="plain">BlkValueWrite(list, LIST_LENGTH_F, len);</span>
        <span class="plain">obj = 0;</span>
        <span class="plain">for (i=0: i&lt;len: i++) {</span>
            <span class="plain">obj = desc(-2, obj, i);</span>
            <span class="plain">! print "i = ", i, " and obj = ", obj, "^";</span>
            <span class="plain">BlkValueWrite(list, i+LIST_ITEM_BASE, obj);</span>
        <span class="plain">}</span>
        <span class="plain">return list;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Find Item. </b>We test whether a list <code class="display"><span class="extract">list</span></code> includes a value equal to <code class="display"><span class="extract">v</span></code> or not. Equality
here is in the sense of the list's comparison function: thus for texts or
other lists, say, deep comparisons rather than simple pointer comparisons are
performed. In other words, one copy of "Alert" is equal to another.
</p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_FindItem list v i no_items cf;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;</span>
        <span class="plain">cf = LIST_OF_TY_ComparisonFn(list);</span>
        <span class="plain">no_items = BlkValueRead(list, LIST_LENGTH_F);</span>
        <span class="plain">if (cf == 0 or UnsignedCompare) {</span>
            <span class="plain">for (i=0: i&lt;no_items: i++)</span>
                <span class="plain">if (v == BlkValueRead(list, i+LIST_ITEM_BASE)) rtrue;</span>
        <span class="plain">} else {</span>
            <span class="plain">for (i=0: i&lt;no_items: i++)</span>
                <span class="plain">if (cf(v, BlkValueRead(list, i+LIST_ITEM_BASE)) == 0) rtrue;</span>
        <span class="plain">}</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Insert Item. </b>The following routine inserts an item into the list. If this would break
the size of the current block-value, then we extend by at least enough room
to hold at least another 16 entries.
</p>

<p class="inwebparagraph">In the call <code class="display"><span class="extract">LIST_OF_TY_InsertItem(list, v, posnflag, posn, nodups)</span></code>, only
the first two arguments are compulsory.
</p>

<ul class="items"><li>(a) If <code class="display"><span class="extract">nodups</span></code> is set, and an item equal to <code class="display"><span class="extract">v</span></code> is already present in the
list, we return and do nothing. (<code class="display"><span class="extract">nodups</span></code> means "no duplicates".)
</li><li>(b) Otherwise, if <code class="display"><span class="extract">posnflag</span></code> is <code class="display"><span class="extract">false</span></code>, we append a new entry <code class="display"><span class="extract">v</span></code> at the
back of the given <code class="display"><span class="extract">list</span></code>.
</li><li>(c) Otherwise, when <code class="display"><span class="extract">posnflag</span></code> is <code class="display"><span class="extract">true</span></code>, <code class="display"><span class="extract">posn</span></code> indicates the insertion
position, from 1 (before the current first item) to N+1 (after the last),
where N is the number of items in the list at present.
</li></ul>

<pre class="display">
    <span class="plain">[ LIST_OF_TY_InsertItem list v posnflag posn nodups i no_items ex nv contents_kind;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;</span>
        <span class="plain">if (nodups &amp;&amp; (LIST_OF_TY_FindItem(list, v))) return list;</span>
        <span class="plain">no_items = BlkValueRead(list, LIST_LENGTH_F);</span>
        <span class="plain">BlkValueWrite(list, LIST_LENGTH_F, no_items); ! Forces the list to be mutable</span>
        <span class="plain">contents_kind = BlkValueRead(list, LIST_ITEM_KOV_F);</span>
        <span class="plain">if ((posnflag) &amp;&amp; ((posn&lt;1) || (posn &gt; no_items+1))) {</span>
            <span class="plain">print "*** Couldn't add at entry ", posn, " in the list ";</span>
            <span class="plain">LIST_OF_TY_Say(list, true);</span>
            <span class="plain">print ", which has entries in the range 1 to ", no_items, " ***^";</span>
            <span class="plain">RunTimeProblem(RTP_LISTRANGEERROR);</span>
            <span class="plain">rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">ex = BlkValueLBCapacity(list);</span>
        <span class="plain">if (no_items+LIST_ITEM_BASE+1 &gt; ex) {</span>
            <span class="plain">if (BlkValueSetLBCapacity(list, ex+16) == false) return 0;</span>
        <span class="plain">}</span>
        <span class="plain">if (KOVIsBlockValue(contents_kind)) {</span>
            <span class="plain">nv = BlkValueCreate(contents_kind);</span>
            <span class="plain">BlkValueCopy(nv, v);</span>
            <span class="plain">v = nv;</span>
        <span class="plain">}</span>
        <span class="plain">if (posnflag) {</span>
            <span class="plain">posn--;</span>
            <span class="plain">for (i=no_items:i&gt;posn:i--) {</span>
                <span class="plain">BlkValueWrite(list, i+LIST_ITEM_BASE,</span>
                    <span class="plain">BlkValueRead(list, i-1+LIST_ITEM_BASE));</span>
            <span class="plain">}</span>
            <span class="plain">BlkValueWrite(list, posn+LIST_ITEM_BASE, v);</span>
        <span class="plain">} else {</span>
            <span class="plain">BlkValueWrite(list, no_items+LIST_ITEM_BASE, v);</span>
        <span class="plain">}</span>
        <span class="plain">BlkValueWrite(list, LIST_LENGTH_F, no_items+1);</span>
        <span class="plain">return list;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Append List. </b>Instead of adjoining a single value, we adjoin an entire second list, which
must be of a compatible kind of value (something which NI's type-checking
machinery polices for us). Except that we have a list <code class="display"><span class="extract">more</span></code> rather than a
value <code class="display"><span class="extract">v</span></code> to insert, the specification is the same as for
<code class="display"><span class="extract">LIST_OF_TY_InsertItem</span></code>.
</p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_AppendList list more posnflag posn nodups v i j no_items msize ex nv;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;</span>
        <span class="plain">if ((more==0) || (BlkValueWeakKind(more) ~= LIST_OF_TY)) return list;</span>
        <span class="plain">no_items = BlkValueRead(list, LIST_LENGTH_F);</span>
        <span class="plain">BlkValueWrite(list, LIST_LENGTH_F, no_items); ! Forces the list to be mutable</span>
        <span class="plain">if ((posnflag) &amp;&amp; ((posn&lt;1) || (posn &gt; no_items+1))) {</span>
            <span class="plain">print "*** Couldn't add at entry ", posn, " in the list ";</span>
            <span class="plain">LIST_OF_TY_Say(list, true);</span>
            <span class="plain">print ", which has entries in the range 1 to ", no_items, " ***^";</span>
            <span class="plain">RunTimeProblem(RTP_LISTRANGEERROR);</span>
            <span class="plain">rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">msize = BlkValueRead(more, LIST_LENGTH_F);</span>
        <span class="plain">ex = BlkValueLBCapacity(list);</span>
        <span class="plain">if (no_items+msize+LIST_ITEM_BASE &gt; ex) {</span>
            <span class="plain">if (BlkValueSetLBCapacity(list, no_items+msize+LIST_ITEM_BASE+8) == false)</span>
                <span class="plain">return 0;</span>
        <span class="plain">}</span>
        <span class="plain">if (posnflag) {</span>
            <span class="plain">posn--;</span>
            <span class="plain">for (i=no_items+msize:i&gt;=posn+msize:i--) {</span>
                <span class="plain">BlkValueWrite(list, i+LIST_ITEM_BASE,</span>
                    <span class="plain">BlkValueRead(list, i-msize+LIST_ITEM_BASE));</span>
            <span class="plain">}</span>
            <span class="plain">! BlkValueWrite(list, posn, v);</span>
            <span class="plain">for (j=0: j&lt;msize: j++) {</span>
                <span class="plain">v = BlkValueRead(more, j+LIST_ITEM_BASE);</span>
                <span class="plain">if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {</span>
                    <span class="plain">nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));</span>
                    <span class="plain">BlkValueCopy(nv, v);</span>
                    <span class="plain">v = nv;</span>
                <span class="plain">}</span>
                <span class="plain">BlkValueWrite(list, posn+j+LIST_ITEM_BASE, v);</span>
            <span class="plain">}</span>
        <span class="plain">} else {</span>
            <span class="plain">for (i=0, j=0: i&lt;msize: i++) {</span>
                <span class="plain">v = BlkValueRead(more, i+LIST_ITEM_BASE);</span>
                <span class="plain">if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {</span>
                    <span class="plain">nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));</span>
                    <span class="plain">BlkValueCopy(nv, v);</span>
                    <span class="plain">v = nv;</span>
                <span class="plain">}</span>
                <span class="plain">if ((nodups == 0) || (LIST_OF_TY_FindItem(list, v) == false)) {</span>
                    <span class="plain">BlkValueWrite(list, no_items+j+LIST_ITEM_BASE, v);</span>
                    <span class="plain">j++;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">BlkValueWrite(list, LIST_LENGTH_F, no_items+j);</span>
        <span class="plain">return list;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. Remove Value. </b>We remove every instance of the value <code class="display"><span class="extract">v</span></code> from the given <code class="display"><span class="extract">list</span></code>. If the
optional flag <code class="display"><span class="extract">forgive</span></code> is set, then we make no complaint if no value of
<code class="display"><span class="extract">v</span></code> was present in the first place: otherwise, we issue a run-time problem.
</p>

<p class="inwebparagraph">Note that if the list contains block-values then the value must be properly
destroyed with <code class="display"><span class="extract">BlkValueFree</span></code> before being overwritten as the items shuffle down.
</p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_RemoveValue list v forgive i j no_items odsize f cf delendum;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;</span>
        <span class="plain">cf = LIST_OF_TY_ComparisonFn(list);</span>
        <span class="plain">no_items = BlkValueRead(list, LIST_LENGTH_F); odsize = no_items;</span>
        <span class="plain">BlkValueWrite(list, LIST_LENGTH_F, no_items); ! Forces the list to be mutable</span>
        <span class="plain">for (i=0: i&lt;no_items: i++) {</span>
            <span class="plain">delendum = BlkValueRead(list, i+LIST_ITEM_BASE);</span>
            <span class="plain">if (cf == 0 or UnsignedCompare)</span>
                <span class="plain">f = (v == delendum);</span>
            <span class="plain">else</span>
                <span class="plain">f = (cf(v, delendum) == 0);</span>
            <span class="plain">if (f) {</span>
                <span class="plain">if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))</span>
                    <span class="plain">BlkValueFree(delendum);</span>
                <span class="plain">for (j=i+1: j&lt;no_items: j++)</span>
                    <span class="plain">BlkValueWrite(list, j-1+LIST_ITEM_BASE,</span>
                        <span class="plain">BlkValueRead(list, j+LIST_ITEM_BASE));</span>
                <span class="plain">no_items--; i--;</span>
                <span class="plain">BlkValueWrite(list, LIST_LENGTH_F, no_items);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">if (odsize ~= no_items) rfalse;</span>
        <span class="plain">if (forgive) rfalse;</span>
        <span class="plain">print "*** Couldn't remove: the value ";</span>
        <span class="plain">PrintKindValuePair(BlkValueRead(list, LIST_ITEM_KOV_F), v);</span>
        <span class="plain">print " was not present in the list ";</span>
        <span class="plain">LIST_OF_TY_Say(list, true);</span>
        <span class="plain">print " ***^";</span>
        <span class="plain">RunTimeProblem(RTP_LISTRANGEERROR);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Remove Item Range. </b>We excise items <code class="display"><span class="extract">from</span></code> to <code class="display"><span class="extract">to</span></code> from the given <code class="display"><span class="extract">list</span></code>, which numbers its items
upwards from 1. If the optional flag <code class="display"><span class="extract">forgive</span></code> is set, then we truncate a range
overspilling the actual list, and we make no complaint if it turns out that
there is then nothing to be done: otherwise, in either event, we issue a
run-time problem.
</p>

<p class="inwebparagraph">Once again, we destroy any block-values whose pointers will be overwritten
as the list shuffles down to fill the void.
</p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_RemoveItemRange list from to forgive i d no_items;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;</span>
        <span class="plain">no_items = BlkValueRead(list, LIST_LENGTH_F);</span>
        <span class="plain">if ((from &gt; to) || (from &lt;= 0) || (to &gt; no_items)) {</span>
            <span class="plain">if (forgive) {</span>
                <span class="plain">if (from &lt;= 0) from = 1;</span>
                <span class="plain">if (to &gt;= no_items) to = no_items;</span>
                <span class="plain">if (from &gt; to) return list;</span>
            <span class="plain">} else {</span>
                <span class="plain">print "*** Couldn't remove entries ", from, " to ", to, " from the list ";</span>
                <span class="plain">LIST_OF_TY_Say(list, true);</span>
                <span class="plain">print ", which has entries in the range 1 to ", no_items, " ***^";</span>
                <span class="plain">RunTimeProblem(RTP_LISTRANGEERROR);</span>
                <span class="plain">rfalse;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">to--; from--;</span>
        <span class="plain">d = to-from+1;</span>
        <span class="plain">if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))</span>
            <span class="plain">for (i=0: i&lt;d: i++)</span>
                <span class="plain">BlkValueFree(BlkValueRead(list, from+i+LIST_ITEM_BASE));</span>
        <span class="plain">for (i=from: i&lt;no_items-d: i++)</span>
            <span class="plain">BlkValueWrite(list, i+LIST_ITEM_BASE,</span>
                <span class="plain">BlkValueRead(list, i+d+LIST_ITEM_BASE));</span>
        <span class="plain">BlkValueWrite(list, LIST_LENGTH_F, no_items-d);</span>
        <span class="plain">return list;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15. Remove List. </b>We excise all values from the removal list <code class="display"><span class="extract">rlist</span></code>, wherever they occur in
<code class="display"><span class="extract">list</span></code>. Inevitably, given that we haven't sorted these lists and can spare
neither time nor storage to do so, this is an expensive process with a
running time proportional to the product of the two list sizes: we accept
that as an overhead because in practice the <code class="display"><span class="extract">rlist</span></code> is almost always small
in real-world use.
</p>

<p class="inwebparagraph">If the initial lists were disjoint, so that no removals occur, we always
forgive the user: the request was not necessarily a foolish one, it only
happened in this situation to be unhelpful.
</p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_Remove_List list rlist i j k v w no_items odsize rsize cf f;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;</span>
        <span class="plain">no_items = BlkValueRead(list, LIST_LENGTH_F); odsize = no_items;</span>
        <span class="plain">rsize = BlkValueRead(rlist, LIST_LENGTH_F);</span>
        <span class="plain">cf = LIST_OF_TY_ComparisonFn(list);</span>
        <span class="plain">for (i=0: i&lt;no_items: i++) {</span>
            <span class="plain">v = BlkValueRead(list, i+LIST_ITEM_BASE);</span>
            <span class="plain">for (k=0: k&lt;rsize: k++) {</span>
                <span class="plain">w = BlkValueRead(rlist, k+LIST_ITEM_BASE);</span>
                <span class="plain">if (cf == 0 or UnsignedCompare)</span>
                    <span class="plain">f = (v == w);</span>
                <span class="plain">else</span>
                    <span class="plain">f = (cf(v, w) == 0);</span>
                <span class="plain">if (f) {</span>
                    <span class="plain">if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))</span>
                        <span class="plain">BlkValueFree(v);</span>
                    <span class="plain">for (j=i+1: j&lt;no_items: j++)</span>
                        <span class="plain">BlkValueWrite(list, j+LIST_ITEM_BASE-1,</span>
                            <span class="plain">BlkValueRead(list, j+LIST_ITEM_BASE));</span>
                    <span class="plain">no_items--; i--;</span>
                    <span class="plain">BlkValueWrite(list, LIST_LENGTH_F, no_items);</span>
                    <span class="plain">break;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16. Get Length. </b></p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_GetLength list;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;</span>
        <span class="plain">return BlkValueRead(list, LIST_LENGTH_F);</span>
    <span class="plain">];</span>

    <span class="plain">[ LIST_OF_TY_Empty list;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) rfalse;</span>
        <span class="plain">if (BlkValueRead(list, LIST_LENGTH_F) == 0) rtrue;</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17. Set Length. </b>This is rather harder: it might lengthen the list, in which case we
have to pad out with the default value for the kind of value stored &mdash;
padding a list of numbers with 0s, a list of texts with copies of the
empty text, and so on &mdash; creating such block-values as might be needed;
or else it might shorten the list, in which case we must cut items,
destroying them properly if they were block-values.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">LIST_OF_TY_SetLength(list, newsize, this_way_only, truncation_end)</span></code>
alters the length of the given <code class="display"><span class="extract">list</span></code> to <code class="display"><span class="extract">newsize</span></code>. If <code class="display"><span class="extract">this_way_only</span></code> is 1,
the list is only allowed to grow, and nothing happens if we have asked to
shrink it; if it is -1, the list is only allowed to shrink; if it is 0,
the list is allowed either to grow or shrink. In the event that the list
does have to shrink, entries must be removed, and we remove from the end
if <code class="display"><span class="extract">truncation_end</span></code> is 1, or from the start if it is -1.
</p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_SetLength list newsize this_way_only truncation_end no_items ex i dv;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;</span>
        <span class="plain">if (newsize &lt; 0) return RunTimeProblem(RTP_LISTSIZENEGATIVE, newsize);</span>
        <span class="plain">BlkMakeMutable(list);</span>
        <span class="plain">no_items = BlkValueRead(list, LIST_LENGTH_F);</span>
        <span class="plain">if (no_items &lt; newsize) {</span>
            <span class="plain">if (this_way_only == -1) return list;</span>
            <span class="plain">ex = BlkValueLBCapacity(list);</span>
            <span class="plain">if (newsize+LIST_ITEM_BASE &gt; ex) {</span>
                <span class="plain">if (BlkValueSetLBCapacity(list, newsize+LIST_ITEM_BASE) == false)</span>
                    <span class="plain">return 0;</span>
            <span class="plain">}</span>
            <span class="plain">dv = DefaultValueOfKOV(BlkValueRead(list, LIST_ITEM_KOV_F));</span>
            <span class="plain">for (i=no_items: i&lt;newsize: i++)</span>
                <span class="plain">BlkValueWrite(list, LIST_ITEM_BASE+i, dv);</span>
            <span class="plain">BlkValueWrite(list, LIST_LENGTH_F, newsize);</span>
        <span class="plain">}</span>
        <span class="plain">if (no_items &gt; newsize) {</span>
            <span class="plain">if (this_way_only == 1) return list;</span>
            <span class="plain">if (truncation_end == -1) {</span>
                <span class="plain">if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))</span>
                    <span class="plain">for (i=0: i&lt;no_items-newsize: i++)</span>
                        <span class="plain">BlkValueFree(BlkValueRead(list, LIST_ITEM_BASE+i));</span>
                <span class="plain">for (i=0: i&lt;newsize: i++)</span>
                    <span class="plain">BlkValueWrite(list, LIST_ITEM_BASE+i,</span>
                        <span class="plain">BlkValueRead(list, LIST_ITEM_BASE+no_items-newsize+i));</span>
            <span class="plain">} else {</span>
                <span class="plain">if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F)))</span>
                    <span class="plain">for (i=newsize: i&lt;no_items: i++)</span>
                        <span class="plain">BlkValueFree(BlkValueRead(list, LIST_ITEM_BASE+i));</span>
            <span class="plain">}</span>
            <span class="plain">BlkValueWrite(list, LIST_LENGTH_F, newsize);</span>
        <span class="plain">}</span>
        <span class="plain">return list;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18. Get Item. </b></p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_GetItem list i forgive no_items;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;</span>
        <span class="plain">no_items = BlkValueRead(list, LIST_LENGTH_F);</span>
        <span class="plain">if ((i&lt;=0) || (i&gt;no_items)) {</span>
            <span class="plain">if (forgive) return false;</span>
            <span class="plain">print "*** Couldn't read from entry ", i, " of a list which";</span>
            <span class="plain">switch (no_items) {</span>
                <span class="plain">0: print " is empty ***^";</span>
                <span class="plain">1: print " has only one entry, numbered 1 ***^";</span>
                <span class="plain">default: print " has entries numbered from 1 to ", no_items, " ***^";</span>
            <span class="plain">}</span>
            <span class="plain">RunTimeProblem(RTP_LISTRANGEERROR);</span>
            <span class="plain">if (no_items &gt;= 1) i = 1;</span>
            <span class="plain">else return false;</span>
        <span class="plain">}</span>
        <span class="plain">return BlkValueRead(list, LIST_ITEM_BASE+i-1);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19. Write Item. </b>The slightly odd name for this function comes about because our usual way
to convert an rvalue such as <code class="display"><span class="extract">LIST_OF_TY_GetItem(L, 4)</span></code> is to prefix
<code class="display"><span class="extract">Write</span></code>, so that it becomes <code class="display"><span class="extract">WriteLIST_OF_TY_GetItem(L, 4)</span></code>.
</p>


<pre class="display">
    <span class="plain">[ WriteLIST_OF_TY_GetItem list i val no_items;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;</span>
        <span class="plain">no_items = BlkValueRead(list, LIST_LENGTH_F);</span>
        <span class="plain">if ((i&lt;=0) || (i&gt;no_items)) {</span>
            <span class="plain">print "*** Couldn't write to list entry ", i, " of a list which";</span>
            <span class="plain">switch (no_items) {</span>
                <span class="plain">0: print " is empty ***^";</span>
                <span class="plain">1: print " has only one entry, numbered 1 ***^";</span>
                <span class="plain">default: print " has entries numbered from 1 to ", no_items, " ***^";</span>
            <span class="plain">}</span>
            <span class="plain">return RunTimeProblem(RTP_LISTRANGEERROR);</span>
        <span class="plain">}</span>
        <span class="plain">BlkValueWrite(list, LIST_ITEM_BASE+i-1, val);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP20"></a><b>&#167;20. Put Item. </b>Higher-level code should not use <code class="display"><span class="extract">Write_LIST_OF_TY_GetItem</span></code>, because it does
not properly keep track of block-value copying: the following should be
used instead.
</p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_PutItem list i v  no_items nv;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return false;</span>
        <span class="plain">no_items = BlkValueRead(list, LIST_LENGTH_F);</span>
        <span class="plain">if (KOVIsBlockValue(BlkValueRead(list, LIST_ITEM_KOV_F))) {</span>
            <span class="plain">nv = BlkValueCreate(BlkValueRead(list, LIST_ITEM_KOV_F));</span>
            <span class="plain">BlkValueCopy(nv, v);</span>
            <span class="plain">v = nv;</span>
        <span class="plain">}</span>
        <span class="plain">if ((i&lt;=0) || (i&gt;no_items)) return false;</span>
        <span class="plain">BlkValueWrite(list, LIST_ITEM_BASE+i-1, v);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP21"></a><b>&#167;21. Reversing. </b>Reversing a list is, happily, a very efficient operation when the list contains
block-values: because the pointers are rearranged but none is duplicated or
destroyed, we can for once ignore the fact that they are pointers to
block-values and simply move them around like any other data.
</p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_Reverse list no_items i v;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;</span>
        <span class="plain">no_items = BlkValueRead(list, LIST_LENGTH_F);</span>
        <span class="plain">if (no_items &lt; 2) return list;</span>
        <span class="plain">for (i=0:i*2&lt;no_items:i++) {</span>
            <span class="plain">v = BlkValueRead(list, LIST_ITEM_BASE+i);</span>
            <span class="plain">BlkValueWrite(list, LIST_ITEM_BASE+i,</span>
                <span class="plain">BlkValueRead(list, LIST_ITEM_BASE+no_items-1-i));</span>
            <span class="plain">BlkValueWrite(list, LIST_ITEM_BASE+no_items-1-i, v);</span>
        <span class="plain">}</span>
        <span class="plain">return list;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP22"></a><b>&#167;22. Rotation. </b>The same is true of rotation. Here, "forwards" rotation means towards the
end of the list, "backwards" means towards the start.
</p>


<pre class="display">
    <span class="plain">[ LIST_OF_TY_Rotate list backwards  no_items i v;</span>
        <span class="plain">if ((list==0) || (BlkValueWeakKind(list) ~= LIST_OF_TY)) return 0;</span>
        <span class="plain">no_items = BlkValueRead(list, LIST_LENGTH_F);</span>
        <span class="plain">if (no_items &lt; 2) return list;</span>
        <span class="plain">if (backwards) {</span>
            <span class="plain">v = BlkValueRead(list, LIST_ITEM_BASE);</span>
            <span class="plain">for (i=0:i&lt;no_items-1:i++)</span>
                <span class="plain">BlkValueWrite(list, LIST_ITEM_BASE+i,</span>
                    <span class="plain">BlkValueRead(list, LIST_ITEM_BASE+i+1));</span>
            <span class="plain">BlkValueWrite(list, no_items-1+LIST_ITEM_BASE, v);</span>
        <span class="plain">} else {</span>
            <span class="plain">v = BlkValueRead(list, no_items-1+LIST_ITEM_BASE);</span>
            <span class="plain">for (i=no_items-1:i&gt;0:i--)</span>
                <span class="plain">BlkValueWrite(list, LIST_ITEM_BASE+i,</span>
                    <span class="plain">BlkValueRead(list, LIST_ITEM_BASE+i-1));</span>
            <span class="plain">BlkValueWrite(list, LIST_ITEM_BASE, v);</span>
        <span class="plain">}</span>
        <span class="plain">return list;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP23"></a><b>&#167;23. Sorting. </b>And the same, again, is true of sorting: but we do have to take note of block
values when it comes to performing comparisons, because we can only compare
items in the list by looking at their contents, not the pointers to their
contents.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">LIST_OF_TY_Sort(list, dir, prop)</span></code> sorts the given <code class="display"><span class="extract">list</span></code> in ascending order
if <code class="display"><span class="extract">dir</span></code> is 1, in descending order if <code class="display"><span class="extract">dir</span></code> is -1, or in random order if
<code class="display"><span class="extract">dir</span></code> is 2. The comparison used is the one for the kind of value stored in
the list, unless the optional argument <code class="display"><span class="extract">prop</span></code> is supplied, in which case
we sort based not on the item values but on their values for the property
<code class="display"><span class="extract">prop</span></code>. (This only makes sense if the list contains objects.)
</p>


<pre class="display">
    <span class="plain">Global LIST_OF_TY_Sort_cf;</span>

    <span class="plain">[ LIST_OF_TY_Sort list dir prop cf  i j no_items v;</span>
        <span class="plain">BlkMakeMutable(list);</span>
        <span class="plain">no_items = BlkValueRead(list, LIST_LENGTH_F);</span>
        <span class="plain">if (dir == 2) {</span>
            <span class="plain">if (no_items &lt; 2) return;</span>
            <span class="plain">for (i=1:i&lt;no_items:i++) {</span>
                <span class="plain">j = random(i+1) - 1;</span>
                <span class="plain">v = BlkValueRead(list, LIST_ITEM_BASE+i);</span>
                <span class="plain">BlkValueWrite(list, LIST_ITEM_BASE+i, BlkValueRead(list, LIST_ITEM_BASE+j));</span>
                <span class="plain">BlkValueWrite(list, LIST_ITEM_BASE+j, v);</span>
            <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">SetSortDomain(ListSwapEntries, ListCompareEntries);</span>
        <span class="plain">if (cf) LIST_OF_TY_Sort_cf = BlkValueCompare;</span>
        <span class="plain">else LIST_OF_TY_Sort_cf = 0;</span>
        <span class="plain">SortArray(list, prop, dir, no_items, false, 0);</span>
    <span class="plain">];</span>

    <span class="plain">[ ListSwapEntries list i j v;</span>
        <span class="plain">if (i==j) return;</span>
        <span class="plain">v = BlkValueRead(list, LIST_ITEM_BASE+i-1);</span>
        <span class="plain">BlkValueWrite(list, LIST_ITEM_BASE+i-1, BlkValueRead(list, LIST_ITEM_BASE+j-1));</span>
        <span class="plain">BlkValueWrite(list, LIST_ITEM_BASE+j-1, v);</span>
    <span class="plain">];</span>

    <span class="plain">[ ListCompareEntries list col i j d cf;</span>
        <span class="plain">if (i==j) return 0;</span>
        <span class="plain">i = BlkValueRead(list, LIST_ITEM_BASE+i-1);</span>
        <span class="plain">j = BlkValueRead(list, LIST_ITEM_BASE+j-1);</span>
        <span class="plain">if (I7S_Col) {</span>
            <span class="plain">if (i provides I7S_Col) i=i.I7S_Col; else i=0;</span>
            <span class="plain">if (j provides I7S_Col) j=j.I7S_Col; else j=0;</span>
            <span class="plain">cf = LIST_OF_TY_Sort_cf;</span>
        <span class="plain">} else {</span>
            <span class="plain">cf = LIST_OF_TY_ComparisonFn(list);</span>
        <span class="plain">}</span>
        <span class="plain">if (cf == 0) {</span>
            <span class="plain">if (i &gt; j) return 1;</span>
            <span class="plain">if (i &lt; j) return -1;</span>
            <span class="plain">return 0;</span>
        <span class="plain">} else</span>
            <span class="plain">return cf(i, j);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="S-gt.html">Back to 'Glulx Template'</a></li><li><a href="S-mt.html">Continue with 'Mathematics Template'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

