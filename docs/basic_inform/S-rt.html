<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>S/prg</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of 'S/rt' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">basic_inform Template Library</a></li><li><b>RegExp Template</b></li></ul><p class="purpose">Code to match and replace on regular expressions against indexed text strings.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Debugging</a></li><li><a href="#SP2">&#167;2. Algorithm</a></li><li><a href="#SP3">&#167;3. Class Codes</a></li><li><a href="#SP4">&#167;4. Packets</a></li><li><a href="#SP5">&#167;5. Nodes</a></li><li><a href="#SP6">&#167;6. Match Variables</a></li><li><a href="#SP7">&#167;7. Markers</a></li><li><a href="#SP8">&#167;8. Debugging</a></li><li><a href="#SP9">&#167;9. Compiling Tree For Substring Search</a></li><li><a href="#SP10">&#167;10. Compiling Tree For Regexp Search</a></li><li><a href="#SP11">&#167;11. Parser</a></li><li><a href="#SP12">&#167;12. Parse At Position</a></li><li><a href="#SP13">&#167;13. Backtracking</a></li><li><a href="#SP14">&#167;14. Fail Subexpressions</a></li><li><a href="#SP15">&#167;15. Erasing Constraints</a></li><li><a href="#SP16">&#167;16. Matching Literal Text</a></li><li><a href="#SP17">&#167;17. Matching Character Range</a></li><li><a href="#SP18">&#167;18. Search And Replace</a></li><li><a href="#SP19">&#167;19. Concatenation</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Debugging. </b>Set this to true at your peril.
</p>


<pre class="display">
    <span class="plain">Global TEXT_TY_RE_Trace = false; ! Change to true for (a lot of) debugging data in use</span>
    <span class="plain">[ TEXT_TY_RE_SetTrace F; TEXT_TY_RE_Trace = F; ];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Algorithm. </b>Once Inform 7 supported (indexed) text, regular-expression matching became an
obvious goal: regexp-based features offer more or less the gold standard in
text search and replace facilities, and I7 is so concerned with text that
we shouldn't make do with less. But the best and most portable
implementation of regular expression matching, PCRE by Philip Hazel, is
about a hundred times larger than the code in this section, and also had
unacceptable memory needs: there was no practicable way to make it small
enough to do useful work on the Z-machine. Nor could an I6 regexp-matcher
compile just-in-time code, or translate the expression into a suitable
deterministic finite state machine. One day, though, I read one of the
papers which Brian Kernighan writes every few years to the effect that
regular-expression matching is much easier than you think. Kernighan is
right: writing a regexp matcher is indeed easier than you think (one day's
worth of cheerful hacking), but debugging one until it passes the trickiest
hundred of Perl's 645 test cases is another matter (and it took a whole
week more). Still, the result seems to be robust. The main compromise made
is that backtracking is not always comprehensive with regexps like
<code class="display"><span class="extract">^(a\1?){4}$</span></code>, because we do not allocate individual storage to backtrack
individually through all possibilities of each of the four uses of the
bracketed subexpression &mdash; which means we miss some cases, since the
subexpression contains a reference to itself, so that its content can vary
in the four uses. PCRE's approach here is to expand the expression as if it
were a sequence of four bracketed expressions, thus removing the awkward
quantifier <code class="display"><span class="extract">{4}</span></code>, but that costs memory: indeed this is why PCRE cannot
solve all of Perl's test cases without its default memory allocation being
raised. In other respects, the algorithm below appears to be accurate if
not very fast.
</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Class Codes. </b>While in principle we could keep the match expression in textual form, in
practice the syntax of regular expressions is complex enough that this
would be tricky and rather slow: we would be parsing the same notations over
and over again. So we begin by compiling it to a simple tree structure. The
tree is made up of nodes, and each node has a "class code": these are
identified by the <code class="display"><span class="extract">*_RE_CC</span></code> constants below. Note that the class codes
below are all negative: this is so that they are distinct from all valid
ZSCII or Unicode characters. (ZSCII is used only on the Z-machine, which
has a 16-bit word but an 8-bit character set, so that all character values
are positive; similarly, Unicode is (for our purposes) a 16-bit character
set on a 32-bit virtual machine.)
</p>


<pre class="display">
    <span class="plain">! Character classes</span>

    <span class="plain">Constant NEWLINE_RE_CC = -1;</span>
    <span class="plain">Constant TAB_RE_CC = -2;</span>
    <span class="plain">Constant DIGIT_RE_CC = -3;</span>
    <span class="plain">Constant NONDIGIT_RE_CC = -4;</span>
    <span class="plain">Constant WHITESPACE_RE_CC = -5;</span>
    <span class="plain">Constant NONWHITESPACE_RE_CC = -6;</span>
    <span class="plain">Constant PUNCTUATION_RE_CC = -7;</span>
    <span class="plain">Constant NONPUNCTUATION_RE_CC = -8;</span>
    <span class="plain">Constant WORD_RE_CC = -9;</span>
    <span class="plain">Constant NONWORD_RE_CC = -10;</span>
    <span class="plain">Constant ANYTHING_RE_CC = -11;</span>
    <span class="plain">Constant NOTHING_RE_CC = -12;</span>
    <span class="plain">Constant RANGE_RE_CC = -13;</span>
    <span class="plain">Constant LCASE_RE_CC = -14;</span>
    <span class="plain">Constant NONLCASE_RE_CC = -15;</span>
    <span class="plain">Constant UCASE_RE_CC = -16;</span>
    <span class="plain">Constant NONUCASE_RE_CC = -17;</span>

    <span class="plain">! Control structures</span>

    <span class="plain">Constant SUBEXP_RE_CC = -20;</span>
    <span class="plain">Constant DISJUNCTION_RE_CC = -21;</span>
    <span class="plain">Constant CHOICE_RE_CC = -22;</span>
    <span class="plain">Constant QUANTIFIER_RE_CC = -23;</span>
    <span class="plain">Constant IF_RE_CC = -24;</span>
    <span class="plain">Constant CONDITION_RE_CC = -25;</span>
    <span class="plain">Constant THEN_RE_CC = -26;</span>
    <span class="plain">Constant ELSE_RE_CC = -27;</span>

    <span class="plain">! Substring matchers</span>

    <span class="plain">Constant VARIABLE_RE_CC = -30;</span>
    <span class="plain">Constant LITERAL_RE_CC = -31;</span>

    <span class="plain">! Positional matchers</span>

    <span class="plain">Constant START_RE_CC = -40;</span>
    <span class="plain">Constant END_RE_CC = -41;</span>
    <span class="plain">Constant BOUNDARY_RE_CC = -42;</span>
    <span class="plain">Constant NONBOUNDARY_RE_CC = -43;</span>
    <span class="plain">Constant ALWAYS_RE_CC = -44;</span>
    <span class="plain">Constant NEVER_RE_CC = -45;</span>

    <span class="plain">! Mode switches</span>

    <span class="plain">Constant SENSITIVITY_RE_CC = -50;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Packets. </b>The nodes of the compiled expression tree are stored in "packets", which
are segments of a fixed array. A regexp complicated enough that it cannot
be stored in <code class="display"><span class="extract">RE_MAX_PACKETS</span></code> packets will be rejected with an error: it
looks like a rather low limit, but in fact suffices to handle all of Perl's
test cases, some of which are works of diabolism.
</p>

<p class="inwebparagraph">A packet is then a record containing 14 fields, with offsets defined by the
constants defined below. These fields combine the compilation of the
corresponding fragment of the regexp with both the tree structure holding
these packets together and also the current state of the temporary variables
recording how far we have progressed in trying all of the possible ways to
match the packet.
</p>


<pre class="display">
    <span class="plain">Constant RE_MAX_PACKETS = 32;</span>

    <span class="plain">Constant RE_PACKET_SIZE = 14; ! Words of memory used per packet</span>
    <span class="plain">Constant RE_PACKET_SIZE_IN_BYTES = WORDSIZE*RE_PACKET_SIZE; ! Bytes used per packet</span>

    <span class="plain">Array RE_PACKET_space --&gt; RE_MAX_PACKETS*RE_PACKET_SIZE;</span>

    <span class="plain">Constant RE_CCLASS = 0;      ! One of the class codes defined above</span>
    <span class="plain">Constant RE_PAR1 = 1;        ! Three parameters whose meaning depends on class code</span>
    <span class="plain">Constant RE_PAR2 = 2;</span>
    <span class="plain">Constant RE_PAR3 = 3;</span>
    <span class="plain">Constant RE_NEXT = 4;        ! Younger sibling in the compiled tree</span>
    <span class="plain">Constant RE_PREVIOUS = 5;    ! Elder sibling</span>
    <span class="plain">Constant RE_DOWN = 6;        ! Child</span>
    <span class="plain">Constant RE_UP = 7;          ! Parent</span>
    <span class="plain">Constant RE_DATA1 = 8;       ! Backtracking data</span>
    <span class="plain">Constant RE_DATA2 = 9;</span>
    <span class="plain">Constant RE_CONSTRAINT = 10;</span>
    <span class="plain">Constant RE_CACHE1 = 11;</span>
    <span class="plain">Constant RE_CACHE2 = 12;</span>
    <span class="plain">Constant RE_MODES = 13;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Nodes. </b>The routine to create a node, something which happens only during the
compilation phase, and also the routine which returns the address of a given
node. Nodes are numbered from 0 up to M-1, where M is the constant
<code class="display"><span class="extract">RE_MAX_PACKETS</span></code>.
</p>


<pre class="display">
    <span class="plain">[ TEXT_TY_RE_Node n cc par1 par2 par3  offset;</span>
        <span class="plain">if ((n&lt;0) || (n &gt;= RE_MAX_PACKETS)) rfalse;</span>
        <span class="plain">offset = RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;</span>
        <span class="plain">offset--&gt;RE_CCLASS = cc;</span>
        <span class="plain">offset--&gt;RE_PAR1 = par1;</span>
        <span class="plain">offset--&gt;RE_PAR2 = par2;</span>
        <span class="plain">offset--&gt;RE_PAR3 = par3;</span>
        <span class="plain">offset--&gt;RE_NEXT = NULL;</span>
        <span class="plain">offset--&gt;RE_PREVIOUS = NULL;</span>
        <span class="plain">offset--&gt;RE_DOWN = NULL;</span>
        <span class="plain">offset--&gt;RE_UP = NULL;</span>
        <span class="plain">offset--&gt;RE_DATA1 = -1; ! Match start</span>
        <span class="plain">offset--&gt;RE_DATA2 = -1; ! Match end</span>
        <span class="plain">offset--&gt;RE_CONSTRAINT = -1; ! Rewind edge</span>
        <span class="plain">return offset;</span>
    <span class="plain">];</span>

    <span class="plain">[ TEXT_TY_RE_NodeAddress n;</span>
        <span class="plain">if ((n&lt;0) || (n &gt;= RE_MAX_PACKETS)) return -1;</span>
        <span class="plain">return RE_PACKET_space + n*RE_PACKET_SIZE_IN_BYTES;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Match Variables. </b>A bracketed subexpression can be used as a variable: we support <code class="display"><span class="extract">\1</span></code>, ..., <code class="display"><span class="extract">\9</span></code>
to mean "the value of subexpression 1 to 9", and <code class="display"><span class="extract">\0</span></code> to mean "the whole
text matched", as if the entire regexp were bracketed. (PCRE and Perl also
allow <code class="display"><span class="extract">\10</span></code>, <code class="display"><span class="extract">\11</span></code>, ..., but we don't, because it complicates parsing and
memory is too short.)
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">RE_Subexpressions--&gt;10</span></code> stores the number of subexpressions in use, not
counting <code class="display"><span class="extract">\0</span></code>. During the compiling stage, <code class="display"><span class="extract">RE_Subexpressions--&gt;N</span></code> is set
to point to the node representating <code class="display"><span class="extract">\N</span></code>, where <code class="display"><span class="extract">N</span></code> varies from 1 to 9.
When matching is complete, and assuming we care about the contents of
these variables &mdash; which we might not, and if not we certainly don't want
to waste time and memory &mdash; we call <code class="display"><span class="extract">TEXT_TY_RE_CreateMatchVars</span></code> to allocate
text variables and fill them in as appropriate, memory permitting.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">TEXT_TY_RE_EmptyMatchVars</span></code> empties any such variables which may survive from
a previous match, setting them to the empty text.
</p>


<pre class="display">
    <span class="plain">Array RE_Subexpressions --&gt; 11; ! Address of node for this subexpression</span>
    <span class="plain">Array Allocated_Match_Vars --&gt; 10; ! Indexed text to hold values of the variables</span>

    <span class="plain">[ TEXT_TY_RE_DebugMatchVars txt</span>
        <span class="plain">offset n i;</span>
        <span class="plain">print RE_Subexpressions--&gt;10, " collecting subexps^";</span>
        <span class="plain">for (n=0:(n&lt;RE_Subexpressions--&gt;10) &amp;&amp; (n&lt;10): n++) {</span>
            <span class="plain">offset = RE_Subexpressions--&gt;n;</span>
            <span class="plain">print "Subexp ", offset--&gt;RE_PAR1,</span>
                <span class="plain">" = [", offset--&gt;RE_DATA1, ",", offset--&gt;RE_DATA2, "] = ";</span>
            <span class="plain">for (i=offset--&gt;RE_DATA1:i&lt;offset--&gt;RE_DATA2:i++)</span>
                <span class="plain">print (char) BlkValueRead(txt, i);</span>
            <span class="plain">print "^";</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ TEXT_TY_RE_CreateMatchVars txt</span>
        <span class="plain">offset n i ch ctxt cl csize;</span>
        <span class="plain">for (n=0:(n&lt;RE_Subexpressions--&gt;10) &amp;&amp; (n&lt;10): n++) {</span>
            <span class="plain">offset = RE_Subexpressions--&gt;n;</span>
            <span class="plain">if (Allocated_Match_Vars--&gt;n) BlkValueFree(Allocated_Match_Vars--&gt;n);</span>
            <span class="plain">Allocated_Match_Vars--&gt;n = BlkValueCreate(TEXT_TY);</span>
            <span class="plain">TEXT_TY_Transmute(Allocated_Match_Vars--&gt;n);</span>
            <span class="plain">ctxt = Allocated_Match_Vars--&gt;n;</span>
            <span class="plain">csize = BlkValueLBCapacity(ctxt);</span>
            <span class="plain">cl = 0;</span>
            <span class="plain">for (i=offset--&gt;RE_DATA1:i&lt;offset--&gt;RE_DATA2:i++) {</span>
                <span class="plain">ch = BlkValueRead(txt, i);</span>
                <span class="plain">if (cl+1 &gt;= csize) {</span>
                    <span class="plain">if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;</span>
                    <span class="plain">csize = BlkValueLBCapacity(ctxt);</span>
                <span class="plain">}</span>
                <span class="plain">BlkValueWrite(ctxt, cl++, ch);</span>
            <span class="plain">}</span>
            <span class="plain">BlkValueWrite(ctxt, cl, 0);</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ TEXT_TY_RE_EmptyMatchVars txt</span>
        <span class="plain">n;</span>
        <span class="plain">for (n=0:((n&lt;RE_Subexpressions--&gt;10) &amp;&amp; (n&lt;10)): n++)</span>
            <span class="plain">if (Allocated_Match_Vars--&gt;n ~= 0)</span>
                <span class="plain">BlkValueWrite(Allocated_Match_Vars--&gt;n, 0, 0);</span>
    <span class="plain">];</span>

    <span class="plain">[ TEXT_TY_RE_GetMatchVar vn</span>
        <span class="plain">offset;</span>
        <span class="plain">if ((vn&lt;0) || (vn&gt;=10) || (vn &gt;= RE_Subexpressions--&gt;10)) return EMPTY_TEXT_VALUE;</span>
        <span class="plain">offset = RE_Subexpressions--&gt;vn;</span>
        <span class="plain">if (offset == 0) return EMPTY_TEXT_VALUE;</span>
        <span class="plain">if (offset--&gt;RE_DATA1 &lt; 0) return EMPTY_TEXT_VALUE;</span>
        <span class="plain">if (Allocated_Match_Vars--&gt;vn == 0) {</span>
            <span class="plain">print "*** ", vn, " unallocated! ***^";</span>
            <span class="plain">return EMPTY_TEXT_VALUE;</span>
        <span class="plain">}</span>
        <span class="plain">return Allocated_Match_Vars--&gt;vn;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Markers. </b>At each node, the <code class="display"><span class="extract">--&gt;RE_DATA1</span></code> and <code class="display"><span class="extract">--&gt;RE_DATA2</span></code> fields represent the
character positions of the start and end of the text matched by the node
and its subtree (if any). These are called markers.
</p>

<p class="inwebparagraph">Thus <code class="display"><span class="extract">TEXT_TY_MV_End(N, 0)</span></code> returns the start of <code class="display"><span class="extract">\N</span></code> and <code class="display"><span class="extract">TEXT_TY_MV_End(N, 1)</span></code>
the end of <code class="display"><span class="extract">\N</span></code>, according to the current match of subexpression <code class="display"><span class="extract">N</span></code>.
</p>


<pre class="display">
    <span class="plain">[ TEXT_TY_MV_End n end</span>
        <span class="plain">offset;</span>
        <span class="plain">offset = RE_Subexpressions--&gt;n;</span>
        <span class="plain">if (end==0) return offset--&gt;RE_DATA1;</span>
        <span class="plain">return offset--&gt;RE_DATA2;</span>
    <span class="plain">];</span>

    <span class="plain">[ TEXT_TY_RE_Clear_Markers token;</span>
        <span class="plain">for (: token ~= NULL: token = token--&gt;RE_NEXT) {</span>
            <span class="plain">if (token--&gt;RE_DOWN ~= NULL) TEXT_TY_RE_Clear_Markers(token--&gt;RE_DOWN);</span>
            <span class="plain">token--&gt;RE_DATA1 = -1;</span>
            <span class="plain">token--&gt;RE_DATA2 = -1;</span>
            <span class="plain">token--&gt;RE_CONSTRAINT = -1;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Debugging. </b>Code in this paragraph simply prints a convenient screen representation of
the compiled regexp, together with the current values of its markers. It is
invaluable for debugging purposes and, touch wood, may not be needed again,
but it is relatively compact and we keep it just in case.
</p>


<pre class="display">
    <span class="plain">[ TEXT_TY_RE_DebugTree ftxt detail;</span>
        <span class="plain">print "Pattern: ", (TEXT_TY_Say) ftxt, "^";</span>
        <span class="plain">TEXT_TY_RE_DebugSubtree(ftxt, 1, RE_PACKET_space, detail);</span>
    <span class="plain">];</span>

    <span class="plain">[ TEXT_TY_RE_DebugSubtree ftxt depth offset detail</span>
        <span class="plain">cup;</span>
        <span class="plain">if (offset ~= NULL) {</span>
            <span class="plain">cup = offset--&gt;RE_UP;</span>
            <span class="plain">if (offset--&gt;RE_PREVIOUS ~= NULL) print "*** broken initial previous ***^";</span>
        <span class="plain">}</span>
        <span class="plain">while (offset ~= NULL) {</span>
            <span class="plain">if (offset--&gt;RE_UP ~= cup) print "*** broken up matching ***^";</span>
            <span class="plain">spaces(depth*2);</span>
            <span class="plain">TEXT_TY_RE_DebugNode(offset, ftxt, detail);</span>
            <span class="plain">if (offset--&gt;RE_DOWN ~= NULL) {</span>
                <span class="plain">if ((offset--&gt;RE_DOWN)--&gt;RE_UP ~= offset)</span>
                    <span class="plain">print "*** broken down/up ***^";</span>
                <span class="plain">TEXT_TY_RE_DebugSubtree(ftxt, depth+1, offset--&gt;RE_DOWN, detail);</span>
            <span class="plain">}</span>
            <span class="plain">if (offset--&gt;RE_NEXT ~= NULL) {</span>
                <span class="plain">if ((offset--&gt;RE_NEXT)--&gt;RE_PREVIOUS ~= offset)</span>
                    <span class="plain">print "*** broken next/previous ***^";</span>
            <span class="plain">}</span>
            <span class="plain">offset = offset--&gt;RE_NEXT;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ TEXT_TY_RE_DebugNode offset ftxt detail</span>
        <span class="plain">i par1 par2 par3;</span>
        <span class="plain">if (offset == NULL) "[NULL]";</span>
        <span class="plain">print "[", (offset-RE_PACKET_space)/(RE_PACKET_SIZE_IN_BYTES), "] ";</span>
        <span class="plain">! for (i=0:i&lt;RE_PACKET_SIZE:i++) print offset--&gt;i, " ";</span>
        <span class="plain">par1 = offset--&gt;RE_PAR1;</span>
        <span class="plain">par2 = offset--&gt;RE_PAR2;</span>
        <span class="plain">par3 = offset--&gt;RE_PAR3;</span>
        <span class="plain">switch (offset--&gt;RE_CCLASS) {</span>
            <span class="plain">DIGIT_RE_CC: print "DIGIT";</span>
            <span class="plain">NONDIGIT_RE_CC: print "NONDIGIT";</span>
            <span class="plain">UCASE_RE_CC: print "UCASE";</span>
            <span class="plain">NONUCASE_RE_CC: print "NONUCASE";</span>
            <span class="plain">LCASE_RE_CC: print "LCASE";</span>
            <span class="plain">NONLCASE_RE_CC: print "NONLCASE";</span>
            <span class="plain">WHITESPACE_RE_CC: print "WHITESPACE";</span>
            <span class="plain">NONWHITESPACE_RE_CC: print "NONWHITESPACE";</span>
            <span class="plain">PUNCTUATION_RE_CC: print "PUNCTUATION";</span>
            <span class="plain">NONPUNCTUATION_RE_CC: print "NONPUNCTUATION";</span>
            <span class="plain">WORD_RE_CC: print "WORD";</span>
            <span class="plain">NONWORD_RE_CC: print "NONWORD";</span>
            <span class="plain">ALWAYS_RE_CC: print "ALWAYS";</span>
            <span class="plain">NEVER_RE_CC: print "NEVER";</span>
            <span class="plain">START_RE_CC: print "START";</span>
            <span class="plain">END_RE_CC: print "END";</span>
            <span class="plain">BOUNDARY_RE_CC: print "BOUNDARY";</span>
            <span class="plain">NONBOUNDARY_RE_CC: print "NONBOUNDARY";</span>
            <span class="plain">ANYTHING_RE_CC: print "ANYTHING";</span>
            <span class="plain">NOTHING_RE_CC: print "NOTHING";</span>
            <span class="plain">RANGE_RE_CC: print "RANGE"; if (par3 == true) print " (negated)";</span>
                <span class="plain">print " ";</span>
                <span class="plain">for (i=par1:i&lt;par2:i++) print (char) BlkValueRead(ftxt, i);</span>
            <span class="plain">VARIABLE_RE_CC: print "VARIABLE ", par1;</span>
            <span class="plain">SUBEXP_RE_CC:</span>
                <span class="plain">if (par1 == 0) print "EXP";</span>
                <span class="plain">else print "SUBEXP ";</span>
                <span class="plain">if (par1 &gt;= 0) print "= V", par1;</span>
                <span class="plain">if (par2 == 1) {</span>
                    <span class="plain">if (par3 == 0) print " (?=...) lookahead";</span>
                    <span class="plain">else print " (?&lt;=...) lookbehind of width ", par3;</span>
                <span class="plain">}</span>
                <span class="plain">if (par2 == 2) {</span>
                    <span class="plain">if (par3 == 0) print " (?!...) negated lookahead";</span>
                    <span class="plain">else print " (?&lt;!...) negated lookbehind of width ", par3;</span>
                <span class="plain">}</span>
                <span class="plain">if (par2 == 3) print " uncollecting";</span>
                <span class="plain">if (par2 == 0 or 3) {</span>
                    <span class="plain">if (par3 == 1) print " forcing case sensitivity";</span>
                    <span class="plain">if (par3 == 2) print " forcing case insensitivity";</span>
                <span class="plain">}</span>
                <span class="plain">if (par2 == 4) print " (?&gt;...) possessive";</span>
            <span class="plain">NEWLINE_RE_CC: print "NEWLINE";</span>
            <span class="plain">TAB_RE_CC: print "TAB";</span>
            <span class="plain">QUANTIFIER_RE_CC: print "QUANTIFIER min=", par1, " max=", par2;</span>
                <span class="plain">if (par3) print " (lazy)"; else print " (greedy)";</span>
            <span class="plain">LITERAL_RE_CC: print "LITERAL";</span>
                <span class="plain">print " ";</span>
                <span class="plain">for (i=par1:i&lt;par2:i++) print (char) BlkValueRead(ftxt, i);</span>
            <span class="plain">DISJUNCTION_RE_CC: print "DISJUNCTION of ", par1, " choices";</span>
            <span class="plain">CHOICE_RE_CC: print "CHOICE no ", par1;</span>
            <span class="plain">SENSITIVITY_RE_CC: print "SENSITIVITY";</span>
                <span class="plain">if (par1) print " off"; else print " on";</span>
            <span class="plain">IF_RE_CC: print "IF"; if (par1 &gt;= 1) print " = V", par1;</span>
            <span class="plain">CONDITION_RE_CC: print "CONDITION"; if (par1 &gt;= 1) print " = V", par1;</span>
            <span class="plain">THEN_RE_CC: print "THEN";</span>
            <span class="plain">ELSE_RE_CC: print "ELSE";</span>
        <span class="plain">}</span>
        <span class="plain">if (detail)</span>
            <span class="plain">print ": ", offset--&gt;RE_DATA1, ", ", offset--&gt;RE_DATA2, ", ", offset--&gt;RE_CONSTRAINT;</span>
        <span class="plain">print "^";</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Compiling Tree For Substring Search. </b>When we search for a literal substring, say looking for "per" in
"Supernumerary", we will in fact use the same apparatus as when searching
for a regular expression: we compile a very simple node tree in which <code class="display"><span class="extract">\0</span></code>
as the root contains just one child node, a <code class="display"><span class="extract">LITERAL_RE_CC</span></code> matching exactly
the text "per". We return 2 since that's the number of nodes in the tree.
</p>


<pre class="display">
    <span class="plain">[ TEXT_TY_CHR_CompileTree ftxt exactly</span>
        <span class="plain">root literal fto no_packets token attach_to;</span>

        <span class="plain">fto = TEXT_TY_CharacterLength(ftxt);</span>

        <span class="plain">root = TEXT_TY_RE_Node(0, SUBEXP_RE_CC, 0, 0, 0);</span>
        <span class="plain">literal = TEXT_TY_RE_Node(1, LITERAL_RE_CC, 0, fto, 0);</span>

        <span class="plain">root--&gt;RE_DOWN = literal;</span>
        <span class="plain">literal--&gt;RE_UP = root;</span>

        <span class="plain">if (exactly) {</span>
            <span class="plain">no_packets = 2;</span>
            <span class="plain">if (no_packets+3 &gt; RE_MAX_PACKETS) return "regexp too complex";</span>
            <span class="plain">exactly = RE_PACKET_space--&gt;RE_DOWN;</span>
            <span class="plain">token = TEXT_TY_RE_Node(no_packets++, START_RE_CC, 0, 0, 0);</span>
            <span class="plain">RE_PACKET_space--&gt;RE_DOWN = token; token--&gt;RE_UP = RE_PACKET_space;</span>
            <span class="plain">attach_to = TEXT_TY_RE_Node(no_packets++, SUBEXP_RE_CC, -1, 3, 0);</span>
            <span class="plain">token--&gt;RE_NEXT = attach_to; attach_to--&gt;RE_PREVIOUS = token;</span>
            <span class="plain">attach_to--&gt;RE_UP = RE_PACKET_space;</span>
            <span class="plain">attach_to--&gt;RE_NEXT = TEXT_TY_RE_Node(no_packets++, END_RE_CC, 0, 0, 0);</span>
            <span class="plain">(attach_to--&gt;RE_NEXT)--&gt;RE_PREVIOUS = attach_to;</span>
            <span class="plain">(attach_to--&gt;RE_NEXT)--&gt;RE_UP = RE_PACKET_space;</span>
            <span class="plain">attach_to--&gt;RE_DOWN = exactly;</span>
            <span class="plain">while (exactly ~= NULL) {</span>
                <span class="plain">exactly--&gt;RE_UP = attach_to; exactly = exactly--&gt;RE_NEXT;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>

        <span class="plain">no_packets = TEXT_TY_RE_ExpandChoices(RE_PACKET_space, no_packets);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Compiling Tree For Regexp Search. </b>But in general we need to compile a regular expression string into a tree
of the kind described above, and here is the routine which does that,
returning the number of nodes used to build the tree. The syntax it accepts
is very fully documented in Writing with Inform, so no details are
given here.
</p>


<pre class="display">
    <span class="plain">Array Subexp_Posns --&gt; 20;</span>
    <span class="plain">[ TEXT_TY_RE_CompileTree ftxt exactly</span>
        <span class="plain">no_packets ffrom fto cc par1 par2 par3</span>
        <span class="plain">quantifiable token attach_to no_subs blevel bits;</span>

        <span class="plain">fto = TEXT_TY_CharacterLength(ftxt);</span>
        <span class="plain">if (fto == 0) {</span>
            <span class="plain">TEXT_TY_RE_Node(no_packets++, NEVER_RE_CC, 0, 0, 0); ! Empty regexp never matches</span>
            <span class="plain">return 1;</span>
        <span class="plain">}</span>

        <span class="plain">attach_to = TEXT_TY_RE_Node(no_packets++, SUBEXP_RE_CC, 0, 0, 0);</span>
        <span class="plain">RE_Subexpressions--&gt;0 = attach_to; RE_Subexpressions--&gt;10 = 1; no_subs = 1;</span>

        <span class="plain">quantifiable = false; blevel = 0;</span>

        <span class="plain">for (ffrom = 0: ffrom &lt; fto: ) {</span>
            <span class="plain">cc = BlkValueRead(ftxt, ffrom++); par1 = 0; par2 = 0; par3 = 0;</span>
            <span class="plain">if (cc == '\') {</span>
                <span class="plain">if (ffrom == fto) return "Search pattern not terminated";</span>
                <span class="plain">cc = BlkValueRead(ftxt, ffrom++);</span>
                <span class="plain">switch (cc) {</span>
                    <span class="plain">'b': cc = BOUNDARY_RE_CC;</span>
                    <span class="plain">'B': cc = NONBOUNDARY_RE_CC;</span>
                    <span class="plain">'d': cc = DIGIT_RE_CC;</span>
                    <span class="plain">'D': cc = NONDIGIT_RE_CC;</span>
                    <span class="plain">'l': cc = LCASE_RE_CC;</span>
                    <span class="plain">'L': cc = NONLCASE_RE_CC;</span>
                    <span class="plain">'n': cc = NEWLINE_RE_CC;</span>
                    <span class="plain">'p': cc = PUNCTUATION_RE_CC;</span>
                    <span class="plain">'P': cc = NONPUNCTUATION_RE_CC;</span>
                    <span class="plain">'s': cc = WHITESPACE_RE_CC;</span>
                    <span class="plain">'S': cc = NONWHITESPACE_RE_CC;</span>
                    <span class="plain">'t': cc = TAB_RE_CC;</span>
                    <span class="plain">'u': cc = UCASE_RE_CC;</span>
                    <span class="plain">'U': cc = NONUCASE_RE_CC;</span>
                    <span class="plain">'w': cc = WORD_RE_CC;</span>
                    <span class="plain">'W': cc = NONWORD_RE_CC;</span>
                    <span class="plain">default:</span>
                        <span class="plain">if ((cc &gt;= '1') &amp;&amp; (cc &lt;= '9')) {</span>
                            <span class="plain">par1 = cc-'0';</span>
                            <span class="plain">cc = VARIABLE_RE_CC;</span>
                        <span class="plain">} else {</span>
                            <span class="plain">if (((cc &gt;= 'a') &amp;&amp; (cc &lt;= 'z')) ||</span>
                                <span class="plain">((cc &gt;= 'A') &amp;&amp; (cc &lt;= 'Z'))) return "unknown escape";</span>
                            <span class="plain">cc = LITERAL_RE_CC;</span>
                            <span class="plain">par1 = ffrom-1; par2 = ffrom;</span>
                        <span class="plain">}</span>
                <span class="plain">}</span>
                <span class="plain">quantifiable = true;</span>
            <span class="plain">} else {</span>
                <span class="plain">switch (cc) {</span>
                    <span class="plain">'(': par2 = 0;</span>
                        <span class="plain">!if (BlkValueRead(ftxt, ffrom) == ')') return "empty subexpression";</span>
                        <span class="plain">if (BlkValueRead(ftxt, ffrom) == '?') {</span>
                            <span class="plain">ffrom++;</span>
                            <span class="plain">bits = true;</span>
                            <span class="plain">if (BlkValueRead(ftxt, ffrom) == '-') { ffrom++; bits = false; }</span>
                            <span class="plain">else if (BlkValueRead(ftxt, ffrom) == '&lt;') { ffrom++; bits = false; }</span>
                            <span class="plain">switch (cc = BlkValueRead(ftxt, ffrom++)) {</span>
                                <span class="plain">'#': while (BlkValueRead(ftxt, ffrom++) ~= 0 or ')') ;</span>
                                    <span class="plain">if (BlkValueRead(ftxt, ffrom-1) == 0)</span>
                                        <span class="plain">return "comment never ends";</span>
                                    <span class="plain">continue;</span>
                                <span class="plain">'(': cc = BlkValueRead(ftxt, ffrom);</span>
                                    <span class="plain">if ((cc == '1' or '2' or '3' or '4' or</span>
                                        <span class="plain">'5' or '6' or '7' or '8' or '9') &amp;&amp;</span>
                                        <span class="plain">(BlkValueRead(ftxt, ffrom+1) ==')')) {</span>
                                        <span class="plain">ffrom = ffrom + 2;</span>
                                        <span class="plain">par1 = cc - '0';</span>
                                    <span class="plain">} else ffrom--;</span>
                                    <span class="plain">cc = IF_RE_CC; ! (?(...)...) conditional</span>
                                    <span class="plain">quantifiable = false;</span>
                                    <span class="plain">if (blevel == 20) return "subexpressions too deep";</span>
                                    <span class="plain">Subexp_Posns--&gt;(blevel++) = TEXT_TY_RE_NodeAddress(no_packets);</span>
                                    <span class="plain">jump CClassKnown;</span>
                                <span class="plain">'=': par2 = 1; ! (?=...) lookahead/behind</span>
                                    <span class="plain">par3 = 0; if (bits == false) par3 = -1;</span>
                                <span class="plain">'!': par2 = 2; ! (?!...) negated lookahead/behind</span>
                                    <span class="plain">par3 = 0; if (bits == false) par3 = -1;</span>
                                <span class="plain">':': par2 = 3; ! (?:...) uncollecting subexpression</span>
                                <span class="plain">'&gt;': par2 = 4; ! (?&gt;...) possessive</span>
                                <span class="plain">default:</span>
                                    <span class="plain">if (BlkValueRead(ftxt, ffrom) == ')') {</span>
                                        <span class="plain">if (cc == 'i') {</span>
                                            <span class="plain">cc = SENSITIVITY_RE_CC; par1 = bits; ffrom++;</span>
                                            <span class="plain">jump CClassKnown;</span>
                                        <span class="plain">}</span>
                                    <span class="plain">}</span>
                                    <span class="plain">if (BlkValueRead(ftxt, ffrom) == ':') {</span>
                                        <span class="plain">if (cc == 'i') {</span>
                                            <span class="plain">par1 = bits; par2 = 3; par3 = bits+1; ffrom++;</span>
                                            <span class="plain">jump AllowForm;</span>
                                        <span class="plain">}</span>
                                    <span class="plain">}</span>
                                    <span class="plain">return "unknown (?...) form";</span>
                            <span class="plain">}</span>
                        <span class="plain">}</span>
                        <span class="plain">.AllowForm;</span>
                        <span class="plain">if (par2 == 0) par1 = no_subs++; else par1 = -1;</span>
                        <span class="plain">cc = SUBEXP_RE_CC;</span>
                        <span class="plain">quantifiable = false;</span>
                        <span class="plain">if (blevel == 20) return "subexpressions too deep";</span>
                        <span class="plain">Subexp_Posns--&gt;(blevel++) = TEXT_TY_RE_NodeAddress(no_packets);</span>
                    <span class="plain">')': if (blevel == 0) return "subexpression bracket mismatch";</span>
                        <span class="plain">blevel--;</span>
                        <span class="plain">attach_to = Subexp_Posns--&gt;blevel;</span>
                        <span class="plain">if (attach_to--&gt;RE_DOWN == NULL) {</span>
                            <span class="plain">if (no_packets &gt;= RE_MAX_PACKETS) return "regexp too complex";</span>
                            <span class="plain">attach_to--&gt;RE_DOWN =</span>
                                <span class="plain">TEXT_TY_RE_Node(no_packets++, ALWAYS_RE_CC, 0, 0, 0);</span>
                            <span class="plain">(attach_to--&gt;RE_DOWN)--&gt;RE_UP = attach_to;</span>
                        <span class="plain">}</span>
                        <span class="plain">quantifiable = true;</span>
                        <span class="plain">continue;</span>
                    <span class="plain">'.': cc = ANYTHING_RE_CC; quantifiable = true;</span>
                    <span class="plain">'|': cc = CHOICE_RE_CC; quantifiable = false;</span>
                    <span class="plain">'^': cc = START_RE_CC; quantifiable = false;</span>
                    <span class="plain">'$': cc = END_RE_CC; quantifiable = false;</span>
                    <span class="plain">'{': if (quantifiable == false) return "quantifier misplaced";</span>
                        <span class="plain">par1 = 0; par2 = -1; bits = 1;</span>
                        <span class="plain">while ((cc=BlkValueRead(ftxt, ffrom++)) ~= 0 or '}') {</span>
                            <span class="plain">if (cc == ',') {</span>
                                <span class="plain">bits++;</span>
                                <span class="plain">if (bits &gt;= 3) return "too many colons in ?{...}";</span>
                                <span class="plain">continue;</span>
                            <span class="plain">}</span>
                            <span class="plain">if ((cc &gt;= '0') || (cc &lt;= '9')) {</span>
                                <span class="plain">if (bits == 1) {</span>
                                    <span class="plain">if (par1 &lt; 0) par1 = 0;</span>
                                    <span class="plain">par1 = par1*10 + (cc-'0');</span>
                                <span class="plain">} else {</span>
                                    <span class="plain">if (par2 &lt; 0) par2 = 0;</span>
                                    <span class="plain">par2 = par2*10 + (cc-'0');</span>
                                <span class="plain">}</span>
                            <span class="plain">} else return "non-digit in ?{...}";</span>
                        <span class="plain">}</span>
                        <span class="plain">if (cc ~= '}') return "{x,y} quantifier never ends";</span>
                        <span class="plain">cc = QUANTIFIER_RE_CC;</span>
                        <span class="plain">if (par2 == -1) {</span>
                            <span class="plain">if (bits == 2) par2 = 30000;</span>
                            <span class="plain">else par2 = par1;</span>
                        <span class="plain">}</span>
                        <span class="plain">if (par1 &gt; par2) return "{x,y} with x greater than y";</span>
                        <span class="plain">if (BlkValueRead(ftxt, ffrom) == '?') { ffrom++; par3 = true; }</span>
                        <span class="plain">quantifiable = false;</span>
                    <span class="plain">'&lt;', '[': par3 = false; if (cc == '&lt;') bits = '&gt;'; else bits = ']';</span>
                        <span class="plain">if (BlkValueRead(ftxt, ffrom) == '^') { ffrom++; par3 = true; }</span>
                        <span class="plain">par1 = ffrom;</span>
                        <span class="plain">if (BlkValueRead(ftxt, ffrom) == bits) { ffrom++; }</span>
                        <span class="plain">while (cc ~= bits or 0) {</span>
                            <span class="plain">cc = BlkValueRead(ftxt, ffrom++);</span>
                            <span class="plain">if (cc == '\') {</span>
                                <span class="plain">cc = BlkValueRead(ftxt, ffrom++);</span>
                                <span class="plain">if (cc ~= 0) cc = BlkValueRead(ftxt, ffrom++);</span>
                            <span class="plain">}</span>
                        <span class="plain">}</span>
                        <span class="plain">if (cc == 0) return "Character range never ends";</span>
                        <span class="plain">par2 = ffrom-1;</span>
                        <span class="plain">if ((par2 &gt; par1 + 1) &amp;&amp;</span>
                            <span class="plain">(BlkValueRead(ftxt, par1) == ':') &amp;&amp;</span>
                            <span class="plain">(BlkValueRead(ftxt, par2-1) == ':') &amp;&amp;</span>
                            <span class="plain">(BlkValueRead(ftxt, par2-2) ~= '\'))</span>
                            <span class="plain">return "POSIX named character classes unsupported";</span>
                        <span class="plain">bits = TEXT_TY_RE_RangeSyntaxCorrect(ftxt, par1, par2);</span>
                        <span class="plain">if (bits) return bits;</span>
                        <span class="plain">if (par1 &lt; par2) cc = RANGE_RE_CC;</span>
                        <span class="plain">else cc = NOTHING_RE_CC;</span>
                        <span class="plain">quantifiable = true;</span>
                    <span class="plain">'*': if (quantifiable == false) return "quantifier misplaced";</span>
                        <span class="plain">cc = QUANTIFIER_RE_CC;</span>
                        <span class="plain">par1 = 0; par2 = 30000;</span>
                        <span class="plain">if (BlkValueRead(ftxt, ffrom) == '?') { ffrom++; par3 = true; }</span>
                        <span class="plain">quantifiable = false;</span>
                    <span class="plain">'+': if (quantifiable == false) return "quantifier misplaced";</span>
                        <span class="plain">cc = QUANTIFIER_RE_CC;</span>
                        <span class="plain">par1 = 1; par2 = 30000;</span>
                        <span class="plain">if (BlkValueRead(ftxt, ffrom) == '?') { ffrom++; par3 = true; }</span>
                        <span class="plain">quantifiable = false;</span>
                    <span class="plain">'?': if (quantifiable == false) return "quantifier misplaced";</span>
                        <span class="plain">cc = QUANTIFIER_RE_CC;</span>
                        <span class="plain">par1 = 0; par2 = 1;</span>
                        <span class="plain">if (BlkValueRead(ftxt, ffrom) == '?') { ffrom++; par3 = true; }</span>
                        <span class="plain">quantifiable = false;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>

            <span class="plain">.CClassKnown;</span>

            <span class="plain">if (cc &gt;= 0) {</span>
                <span class="plain">quantifiable = true;</span>
                <span class="plain">if ((attach_to--&gt;RE_CCLASS == LITERAL_RE_CC) &amp;&amp;</span>
                    <span class="plain">(BlkValueRead(ftxt, ffrom) ~= '*' or '+' or '?' or '{')) {</span>
                    <span class="plain">(attach_to--&gt;RE_PAR2)++;</span>
                    <span class="plain">if (TEXT_TY_RE_Trace == 2) {</span>
                        <span class="plain">print "Extending literal by ", cc, "=", (char) cc, "^";</span>
                    <span class="plain">}</span>
                    <span class="plain">continue;</span>
                <span class="plain">}</span>
                <span class="plain">cc = LITERAL_RE_CC; par1 = ffrom-1; par2 = ffrom;</span>
            <span class="plain">}</span>

            <span class="plain">if (no_packets &gt;= RE_MAX_PACKETS) return "regexp too complex";</span>

            <span class="plain">if (TEXT_TY_RE_Trace == 2) {</span>
                <span class="plain">print "Attaching packet ", no_packets+1, " to ";</span>
                <span class="plain">TEXT_TY_RE_DebugNode(attach_to, ftxt);</span>
                <span class="plain">TEXT_TY_RE_DebugTree(ftxt);</span>
            <span class="plain">}</span>

            <span class="plain">token = TEXT_TY_RE_Node(no_packets++, cc, par1, par2, par3);</span>

            <span class="plain">if ((token--&gt;RE_CCLASS == SUBEXP_RE_CC) &amp;&amp; (token--&gt;RE_PAR2 == 0)) {</span>
                <span class="plain">RE_Subexpressions--&gt;(token--&gt;RE_PAR1) = token;</span>
                <span class="plain">(RE_Subexpressions--&gt;10)++;</span>
            <span class="plain">}</span>

            <span class="plain">if ((attach_to--&gt;RE_CCLASS == SUBEXP_RE_CC or CHOICE_RE_CC or IF_RE_CC) &amp;&amp;</span>
                <span class="plain">(attach_to--&gt;RE_DOWN == NULL)) {</span>
                <span class="plain">attach_to--&gt;RE_DOWN = token; token--&gt;RE_UP = attach_to;</span>
            <span class="plain">} else {</span>
                <span class="plain">if ((token--&gt;RE_CCLASS == CHOICE_RE_CC) &amp;&amp;</span>
                    <span class="plain">((attach_to--&gt;RE_UP)--&gt;RE_CCLASS == CHOICE_RE_CC)) {</span>
                    <span class="plain">no_packets--; token = attach_to--&gt;RE_UP;</span>
                <span class="plain">} else {</span>
                    <span class="plain">if (token--&gt;RE_CCLASS == CHOICE_RE_CC) {</span>
                        <span class="plain">while (attach_to--&gt;RE_PREVIOUS ~= NULL)</span>
                            <span class="plain">attach_to = attach_to--&gt;RE_PREVIOUS;</span>
                    <span class="plain">}</span>
                    <span class="plain">if (token--&gt;RE_CCLASS == QUANTIFIER_RE_CC or CHOICE_RE_CC) {</span>
                        <span class="plain">token--&gt;RE_PREVIOUS = attach_to--&gt;RE_PREVIOUS;</span>
                        <span class="plain">token--&gt;RE_UP = attach_to--&gt;RE_UP;</span>
                        <span class="plain">if ((attach_to--&gt;RE_UP ~= NULL) &amp;&amp; (attach_to--&gt;RE_PREVIOUS == NULL))</span>
                            <span class="plain">(attach_to--&gt;RE_UP)--&gt;RE_DOWN = token;</span>
                        <span class="plain">token--&gt;RE_DOWN = attach_to;</span>
                        <span class="plain">bits = attach_to;</span>
                        <span class="plain">while (bits ~= NULL) {</span>
                            <span class="plain">bits--&gt;RE_UP = token;</span>
                            <span class="plain">bits = bits--&gt;RE_NEXT;</span>
                        <span class="plain">}</span>
                        <span class="plain">attach_to--&gt;RE_PREVIOUS = NULL;</span>
                        <span class="plain">if (token--&gt;RE_PREVIOUS ~= NULL)</span>
                            <span class="plain">(token--&gt;RE_PREVIOUS)--&gt;RE_NEXT = token;</span>
                    <span class="plain">} else {</span>
                        <span class="plain">attach_to--&gt;RE_NEXT = token; token--&gt;RE_PREVIOUS = attach_to;</span>
                        <span class="plain">token--&gt;RE_UP = attach_to--&gt;RE_UP;</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">}</span>

            <span class="plain">if (token--&gt;RE_CCLASS == CHOICE_RE_CC) {</span>
                <span class="plain">if (no_packets &gt;= RE_MAX_PACKETS) return "regexp too complex";</span>
                <span class="plain">token--&gt;RE_NEXT = TEXT_TY_RE_Node(no_packets++, CHOICE_RE_CC, 0, 0, 0);</span>
                <span class="plain">(token--&gt;RE_NEXT)--&gt;RE_PREVIOUS = token;</span>
                <span class="plain">(token--&gt;RE_NEXT)--&gt;RE_UP = token--&gt;RE_UP;</span>
                <span class="plain">token = token--&gt;RE_NEXT;</span>
            <span class="plain">}</span>

            <span class="plain">attach_to = token;</span>

            <span class="plain">if (TEXT_TY_RE_Trace == 2) {</span>
                <span class="plain">print "Result:^";</span>
                <span class="plain">TEXT_TY_RE_DebugTree(ftxt);</span>
            <span class="plain">}</span>

        <span class="plain">}</span>

        <span class="plain">if (blevel ~= 0) return "subexpression bracket mismatch";</span>

        <span class="plain">if (exactly) {</span>
            <span class="plain">if (no_packets+3 &gt; RE_MAX_PACKETS) return "regexp too complex";</span>
            <span class="plain">exactly = RE_PACKET_space--&gt;RE_DOWN;</span>
            <span class="plain">token = TEXT_TY_RE_Node(no_packets++, START_RE_CC, 0, 0, 0);</span>
            <span class="plain">RE_PACKET_space--&gt;RE_DOWN = token; token--&gt;RE_UP = RE_PACKET_space;</span>
            <span class="plain">attach_to = TEXT_TY_RE_Node(no_packets++, SUBEXP_RE_CC, -1, 3, 0);</span>
            <span class="plain">token--&gt;RE_NEXT = attach_to; attach_to--&gt;RE_PREVIOUS = token;</span>
            <span class="plain">attach_to--&gt;RE_UP = RE_PACKET_space;</span>
            <span class="plain">attach_to--&gt;RE_NEXT = TEXT_TY_RE_Node(no_packets++, END_RE_CC, 0, 0, 0);</span>
            <span class="plain">(attach_to--&gt;RE_NEXT)--&gt;RE_PREVIOUS = attach_to;</span>
            <span class="plain">(attach_to--&gt;RE_NEXT)--&gt;RE_UP = RE_PACKET_space;</span>
            <span class="plain">attach_to--&gt;RE_DOWN = exactly;</span>
            <span class="plain">while (exactly ~= NULL) {</span>
                <span class="plain">exactly--&gt;RE_UP = attach_to; exactly = exactly--&gt;RE_NEXT;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>

        <span class="plain">no_packets = TEXT_TY_RE_ExpandChoices(RE_PACKET_space, no_packets);</span>

        <span class="plain">if (TEXT_TY_RE_Trace) {</span>
            <span class="plain">print "Compiled pattern:^";</span>
            <span class="plain">TEXT_TY_RE_DebugTree(ftxt);</span>
        <span class="plain">}</span>

        <span class="plain">bits = TEXT_TY_RE_CheckTree(RE_PACKET_space, no_subs); if (bits) return bits;</span>

        <span class="plain">return no_packets;</span>
    <span class="plain">];</span>

    <span class="plain">[ TEXT_TY_RE_RangeSyntaxCorrect ftxt rf rt</span>
        <span class="plain">i chm;</span>
        <span class="plain">for (i=rf: i&lt;rt: i++) {</span>
            <span class="plain">chm = BlkValueRead(ftxt, i);</span>
            <span class="plain">if ((chm == '\') &amp;&amp; (i+1&lt;rt)) {</span>
                <span class="plain">chm = BlkValueRead(ftxt, ++i);</span>
                <span class="plain">if (((chm &gt;= 'a') &amp;&amp; (chm &lt;= 'z')) ||</span>
                    <span class="plain">((chm &gt;= 'A') &amp;&amp; (chm &lt;= 'Z'))) {</span>
                    <span class="plain">if (chm ~= 's' or 'S' or 'p' or 'P' or 'w' or 'W' or 'd'</span>
                        <span class="plain">or 'D' or 'n' or 't' or 'l' or 'L' or 'u' or 'U')</span>
                        <span class="plain">return "Invalid escape in {} range";</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">if ((i+2&lt;rt) &amp;&amp; (BlkValueRead(ftxt, i+1) == '-')) {</span>
                <span class="plain">if (chm &gt; BlkValueRead(ftxt, i+2)) return "Invalid {} range";</span>
                <span class="plain">i=i+2;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>

    <span class="plain">[ TEXT_TY_RE_ExpandChoices token no_packets</span>
        <span class="plain">rv prev nex holder new ct n cond_node then_node else_node;</span>
        <span class="plain">while (token ~= NULL) {</span>
            <span class="plain">if (token--&gt;RE_CCLASS == IF_RE_CC) {</span>
                <span class="plain">if ((token--&gt;RE_DOWN)--&gt;RE_CCLASS == CHOICE_RE_CC) {</span>
                    <span class="plain">for (nex=token--&gt;RE_DOWN, n=0: nex~=NULL: nex=nex--&gt;RE_NEXT) n++;</span>
                    <span class="plain">if (n~=2) return "conditional has too many clauses";</span>
                    <span class="plain">if (no_packets &gt;= RE_MAX_PACKETS) return "regexp too complex";</span>
                    <span class="plain">cond_node = TEXT_TY_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);</span>
                    <span class="plain">if (token--&gt;RE_PAR1 &gt;= 1) {</span>
                        <span class="plain">cond_node--&gt;RE_PAR1 = token--&gt;RE_PAR1;</span>
                    <span class="plain">}</span>
                    <span class="plain">then_node = token--&gt;RE_DOWN;</span>
                    <span class="plain">then_node--&gt;RE_CCLASS = THEN_RE_CC;</span>
                    <span class="plain">else_node = then_node--&gt;RE_NEXT;</span>
                    <span class="plain">else_node--&gt;RE_CCLASS = ELSE_RE_CC;</span>
                    <span class="plain">if (cond_node--&gt;RE_PAR1 &lt; 1) {</span>
                        <span class="plain">cond_node--&gt;RE_DOWN = then_node--&gt;RE_DOWN;</span>
                        <span class="plain">then_node--&gt;RE_DOWN = (then_node--&gt;RE_DOWN)--&gt;RE_NEXT;</span>
                        <span class="plain">if (then_node--&gt;RE_DOWN ~= NULL)</span>
                            <span class="plain">(then_node--&gt;RE_DOWN)--&gt;RE_PREVIOUS = NULL;</span>
                        <span class="plain">(cond_node--&gt;RE_DOWN)--&gt;RE_NEXT = NULL;</span>
                        <span class="plain">(cond_node--&gt;RE_DOWN)--&gt;RE_UP = cond_node;</span>
                    <span class="plain">}</span>
                    <span class="plain">token--&gt;RE_DOWN = cond_node; cond_node--&gt;RE_UP = token;</span>
                    <span class="plain">cond_node--&gt;RE_NEXT = then_node; then_node--&gt;RE_PREVIOUS = cond_node;</span>
                <span class="plain">} else {</span>
                    <span class="plain">if (no_packets &gt;= RE_MAX_PACKETS) return "regexp too complex";</span>
                    <span class="plain">cond_node = TEXT_TY_RE_Node(no_packets++, CONDITION_RE_CC, 0, 0, 0);</span>
                    <span class="plain">if (no_packets &gt;= RE_MAX_PACKETS) return "regexp too complex";</span>
                    <span class="plain">then_node = TEXT_TY_RE_Node(no_packets++, THEN_RE_CC, 0, 0, 0);</span>
                    <span class="plain">if (token--&gt;RE_PAR1 &gt;= 1) {</span>
                        <span class="plain">cond_node--&gt;RE_PAR1 = token--&gt;RE_PAR1;</span>
                        <span class="plain">then_node--&gt;RE_DOWN = token--&gt;RE_DOWN;</span>
                    <span class="plain">} else {</span>
                        <span class="plain">cond_node--&gt;RE_DOWN = token--&gt;RE_DOWN;</span>
                        <span class="plain">then_node--&gt;RE_DOWN = (token--&gt;RE_DOWN)--&gt;RE_NEXT;</span>
                        <span class="plain">(cond_node--&gt;RE_DOWN)--&gt;RE_NEXT = NULL;</span>
                        <span class="plain">(cond_node--&gt;RE_DOWN)--&gt;RE_UP = cond_node;</span>
                    <span class="plain">}</span>
                    <span class="plain">token--&gt;RE_DOWN = cond_node;</span>
                    <span class="plain">cond_node--&gt;RE_UP = token; cond_node--&gt;RE_NEXT = then_node;</span>
                    <span class="plain">then_node--&gt;RE_PREVIOUS = cond_node; then_node--&gt;RE_UP = token;</span>
                    <span class="plain">then_node--&gt;RE_NEXT = NULL;</span>
                    <span class="plain">if (then_node--&gt;RE_DOWN ~= NULL)</span>
                        <span class="plain">(then_node--&gt;RE_DOWN)--&gt;RE_PREVIOUS = NULL;</span>
                    <span class="plain">for (nex = then_node--&gt;RE_DOWN: nex ~= NULL: nex = nex--&gt;RE_NEXT) {</span>
                        <span class="plain">nex--&gt;RE_UP = then_node;</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>

                <span class="plain">if (cond_node--&gt;RE_DOWN ~= NULL) {</span>
                    <span class="plain">nex = cond_node--&gt;RE_DOWN;</span>
                    <span class="plain">if ((nex--&gt;RE_CCLASS ~= SUBEXP_RE_CC) ||</span>
                        <span class="plain">(nex--&gt;RE_NEXT ~= NULL) ||</span>
                        <span class="plain">(nex--&gt;RE_PAR2 ~= 1 or 2)) {</span>
                        <span class="plain">!TEXT_TY_RE_DebugSubtree(0, 0, nex, true);</span>
                        <span class="plain">return "condition not lookahead/behind";</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">if ((token--&gt;RE_CCLASS == CHOICE_RE_CC) &amp;&amp; (token--&gt;RE_PAR1 &lt; 1)) {</span>
                <span class="plain">prev = token--&gt;RE_PREVIOUS;</span>
                <span class="plain">nex = token--&gt;RE_NEXT;</span>
                <span class="plain">while ((nex ~= NULL) &amp;&amp; (nex--&gt;RE_CCLASS == CHOICE_RE_CC))</span>
                    <span class="plain">nex = nex--&gt;RE_NEXT;</span>
                <span class="plain">holder = token--&gt;RE_UP; if (holder == NULL) return "bang";</span>
                <span class="plain">if (no_packets &gt;= RE_MAX_PACKETS) return "regexp too complex";</span>
                <span class="plain">new = TEXT_TY_RE_Node(no_packets++, DISJUNCTION_RE_CC, 0, 0, 0);</span>
                <span class="plain">holder--&gt;RE_DOWN = new; new--&gt;RE_UP = holder;</span>
                <span class="plain">if (prev ~= NULL) {</span>
                    <span class="plain">prev--&gt;RE_NEXT = new; new--&gt;RE_PREVIOUS = prev;</span>
                <span class="plain">}</span>
                <span class="plain">if (nex ~= NULL) {</span>
                    <span class="plain">nex--&gt;RE_PREVIOUS = new; new--&gt;RE_NEXT = nex;</span>
                <span class="plain">}</span>
                <span class="plain">new--&gt;RE_DOWN = token;</span>
                <span class="plain">token--&gt;RE_PREVIOUS = NULL;</span>
                <span class="plain">ct = 1;</span>
                <span class="plain">while (token ~= NULL) {</span>
                    <span class="plain">token--&gt;RE_PAR1 = ct++;</span>
                    <span class="plain">token--&gt;RE_UP = new;</span>
                    <span class="plain">if ((token--&gt;RE_NEXT ~= NULL) &amp;&amp;</span>
                        <span class="plain">((token--&gt;RE_NEXT)--&gt;RE_CCLASS ~= CHOICE_RE_CC))</span>
                        <span class="plain">token--&gt;RE_NEXT = NULL;</span>
                    <span class="plain">token = token--&gt;RE_NEXT;</span>
                <span class="plain">}</span>
                <span class="plain">new--&gt;RE_PAR1 = ct-1;</span>
                <span class="plain">if (token ~= NULL) token--&gt;RE_NEXT = NULL;</span>
                <span class="plain">token = new; continue;</span>
            <span class="plain">}</span>
            <span class="plain">if (token--&gt;RE_DOWN ~= NULL) {</span>
                <span class="plain">no_packets = TEXT_TY_RE_ExpandChoices(token--&gt;RE_DOWN, no_packets);</span>
                <span class="plain">if ((no_packets&lt;0) || (no_packets &gt;= RE_MAX_PACKETS)) break;</span>
            <span class="plain">}</span>
            <span class="plain">token = token--&gt;RE_NEXT;</span>
        <span class="plain">}</span>
        <span class="plain">return no_packets;</span>
    <span class="plain">];</span>

    <span class="plain">[ TEXT_TY_RE_CheckTree token no_subs</span>
        <span class="plain">rv;</span>
        <span class="plain">while (token ~= NULL) {</span>
            <span class="plain">if (token--&gt;RE_CCLASS == VARIABLE_RE_CC) {</span>
                <span class="plain">if (token--&gt;RE_PAR1 &gt;= no_subs) return "reference to nonexistent group";</span>
            <span class="plain">}</span>
            <span class="plain">if ((token--&gt;RE_CCLASS == SUBEXP_RE_CC) &amp;&amp;</span>
                <span class="plain">(token--&gt;RE_PAR2 == 1 or 2) &amp;&amp;</span>
                <span class="plain">(token--&gt;RE_PAR3 == -1)) {</span>
                <span class="plain">token--&gt;RE_PAR3 = TEXT_TY_RE_Width(token--&gt;RE_DOWN);</span>
                <span class="plain">if (token--&gt;RE_PAR3 == -1) return "variable length lookbehind not implemented";</span>
            <span class="plain">}</span>
            <span class="plain">if (token--&gt;RE_DOWN ~= NULL) {</span>
                <span class="plain">rv = TEXT_TY_RE_CheckTree(token--&gt;RE_DOWN, no_subs);</span>
                <span class="plain">if (rv) return rv;</span>
            <span class="plain">}</span>
            <span class="plain">token = token--&gt;RE_NEXT;</span>
        <span class="plain">}</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>

    <span class="plain">[ TEXT_TY_RE_Width token downwards</span>
        <span class="plain">w rv aw choice;</span>
        <span class="plain">while (token ~= NULL) {</span>
            <span class="plain">switch (token--&gt;RE_CCLASS) {</span>
                <span class="plain">DIGIT_RE_CC, NONDIGIT_RE_CC, WHITESPACE_RE_CC, NONWHITESPACE_RE_CC,</span>
                <span class="plain">PUNCTUATION_RE_CC, NONPUNCTUATION_RE_CC, WORD_RE_CC, NONWORD_RE_CC,</span>
                <span class="plain">ANYTHING_RE_CC, NOTHING_RE_CC, RANGE_RE_CC, NEWLINE_RE_CC, TAB_RE_CC,</span>
                <span class="plain">UCASE_RE_CC, NONUCASE_RE_CC, LCASE_RE_CC, NONLCASE_RE_CC:</span>
                    <span class="plain">w++;</span>
                <span class="plain">START_RE_CC, END_RE_CC, BOUNDARY_RE_CC, NONBOUNDARY_RE_CC, ALWAYS_RE_CC:</span>
                    <span class="plain">;</span>
                <span class="plain">LITERAL_RE_CC:</span>
                    <span class="plain">w = w + token--&gt;RE_PAR2 - token--&gt;RE_PAR1;</span>
                <span class="plain">VARIABLE_RE_CC:</span>
                    <span class="plain">return -1;</span>
                <span class="plain">IF_RE_CC:</span>
                    <span class="plain">rv = TEXT_TY_RE_Width((token--&gt;RE_DOWN)--&gt;RE_NEXT);</span>
                    <span class="plain">if (rv == -1) return -1;</span>
                    <span class="plain">if (rv ~= TEXT_TY_RE_Width(((token--&gt;RE_DOWN)--&gt;RE_NEXT)--&gt;RE_NEXT))</span>
                        <span class="plain">return -1;</span>
                    <span class="plain">w = w + rv;</span>
                <span class="plain">SUBEXP_RE_CC:</span>
                    <span class="plain">if (token--&gt;RE_PAR2 == 1 or 2) rv = 0;</span>
                    <span class="plain">else {</span>
                        <span class="plain">rv = TEXT_TY_RE_Width(token--&gt;RE_DOWN);</span>
                        <span class="plain">if (rv == -1) return -1;</span>
                    <span class="plain">}</span>
                    <span class="plain">w = w + rv;</span>
                <span class="plain">QUANTIFIER_RE_CC:</span>
                    <span class="plain">if (token--&gt;RE_PAR1 ~= token--&gt;RE_PAR2) return -1;</span>
                    <span class="plain">rv = TEXT_TY_RE_Width(token--&gt;RE_DOWN);</span>
                    <span class="plain">if (rv == -1) return -1;</span>
                    <span class="plain">w = w + rv*(token--&gt;RE_PAR1);</span>
                <span class="plain">DISJUNCTION_RE_CC:</span>
                    <span class="plain">aw = -1;</span>
                    <span class="plain">for (choice = token--&gt;RE_DOWN: choice ~= NULL: choice = choice--&gt;RE_NEXT) {</span>
                        <span class="plain">rv = TEXT_TY_RE_Width(choice--&gt;RE_DOWN);</span>
                        <span class="plain">!print "Option found ", rv, "^";</span>
                        <span class="plain">if (rv == -1) return -1;</span>
                        <span class="plain">if ((aw &gt;= 0) &amp;&amp; (aw ~= rv)) return -1;</span>
                        <span class="plain">aw = rv;</span>
                    <span class="plain">}</span>
                    <span class="plain">w = w + aw;</span>
                <span class="plain">SENSITIVITY_RE_CC:</span>
                    <span class="plain">;</span>
            <span class="plain">}</span>
            <span class="plain">if (downwards) return w;</span>
            <span class="plain">if (token ~= NULL) token = token--&gt;RE_NEXT;</span>
        <span class="plain">}</span>
        <span class="plain">return w;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Parser. </b>The virtue of all of that tree compilation is that the code which actually
does the work &mdash; which parses the source text to see if the regular expression
matches it &mdash; is much shorter and quicker: indeed, it takes up fewer lines
than the compiler part, which goes to show that decoding regular expression
syntax is a more complex task than acting upon it. This would have surprised
the pioneers of regexp, but the syntax has become much more complicated over
the decades because of a steady increase in the number of extended notations.
The process shows no sign of stopping, with Python and PCRE continuing to
push boundaries beyond Perl, which was once thought the superest, duperest
regexp syntax there could be. However: to work.
</p>

<p class="inwebparagraph">The main matcher simply starts a recursive subroutine to perform the match.
However, the subroutine tests for a match at a particular position in the
source text; so the main routine tries the subroutine everywhere convenient
in the source text, from left to right, until a match is made &mdash; unless the
regexp is constrained by a <code class="display"><span class="extract">^</span></code> glyph to begin matching at the start of the
source text, which will cause a <code class="display"><span class="extract">START_RE_CC</span></code> node to be the eldest child
of the <code class="display"><span class="extract">\0</span></code> root.
</p>


<pre class="display">
    <span class="plain">Global TEXT_TY_RE_RewindCount;</span>
    <span class="plain">[ TEXT_TY_RE_PrintNoRewinds; print TEXT_TY_RE_RewindCount; ];</span>

    <span class="plain">Constant CIS_MFLAG = 1;</span>
    <span class="plain">Constant ACCUM_MFLAG = 2;</span>

    <span class="plain">[ TEXT_TY_RE_Parse ftxt txt ipos insens</span>
        <span class="plain">ilen rv root i initial_mode;</span>

        <span class="plain">ilen = TEXT_TY_CharacterLength(txt);</span>
        <span class="plain">if ((ipos&lt;0) || (ipos&gt;ilen)) return -1;</span>

        <span class="plain">root = RE_PACKET_space;</span>

        <span class="plain">initial_mode = 0; if (insens) initial_mode = CIS_MFLAG;</span>

        <span class="plain">TEXT_TY_RE_Clear_Markers(RE_PACKET_space);</span>

        <span class="plain">for (:ipos&lt;=ilen:ipos++) {</span>
            <span class="plain">if ((RE_PACKET_space--&gt;RE_DOWN ~= NULL) &amp;&amp;</span>
                <span class="plain">((RE_PACKET_space--&gt;RE_DOWN)--&gt;RE_CCLASS == START_RE_CC) &amp;&amp;</span>
                <span class="plain">(ipos&gt;0)) { rv = -1; break; }</span>
            <span class="plain">if (ipos &gt; 0) TEXT_TY_RE_EraseConstraints(RE_PACKET_space, initial_mode);</span>
            <span class="plain">TEXT_TY_RE_RewindCount = 0;</span>
            <span class="plain">rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ilen, RE_PACKET_space, initial_mode);</span>
            <span class="plain">if (rv &gt;= 0) break;</span>
        <span class="plain">}</span>

        <span class="plain">if (rv == -1) {</span>
            <span class="plain">root--&gt;RE_DATA1 = -1;</span>
            <span class="plain">root--&gt;RE_DATA2 = -1;</span>
        <span class="plain">} else {</span>
            <span class="plain">root--&gt;RE_DATA1 = ipos;</span>
            <span class="plain">root--&gt;RE_DATA2 = ipos+rv;</span>
        <span class="plain">}</span>
        <span class="plain">return rv;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Parse At Position. </b><code class="display"><span class="extract">TEXT_TY_RE_ParseAtPosition(ftxt, txt, ifrom, ito)</span></code> attempts to match text
beginning at position <code class="display"><span class="extract">ifrom</span></code> in the text <code class="display"><span class="extract">txt</span></code> and extending for
any length up to position <code class="display"><span class="extract">ito</span></code>: it returns the number of characters which
were matched (which can legitimately be 0), or -1 if no match could be
made. <code class="display"><span class="extract">ftxt</span></code> is the original text of the regular expression in its
precompiled form, which we need partly to print good debugging information,
but mostly in order to match against a <code class="display"><span class="extract">LITERAL_RE_CC</span></code> node.
</p>


<pre class="display">
    <span class="plain">[ TEXT_TY_RE_ParseAtPosition ftxt txt ifrom ito token mode_flags</span>
        <span class="plain">outcome ipos npos rv i ch edge rewind_this;</span>

        <span class="plain">if (ifrom &gt; ito) return -1;</span>

        <span class="plain">ipos = ifrom;</span>

        <span class="plain">.Rewind;</span>
        <span class="plain">while (token ~= NULL) {</span>
            <span class="plain">outcome = false;</span>
            <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                <span class="plain">print "Matching at ", ipos, ": ";</span>
                <span class="plain">TEXT_TY_RE_DebugNode(token, ftxt, true);</span>
            <span class="plain">}</span>

            <span class="plain">if (ipos&lt;ito) ch = BlkValueRead(txt, ipos); else ch = 0;</span>

            <span class="plain">token--&gt;RE_MODES = mode_flags; ! Save in case of backtrack</span>

            <span class="plain">switch (token--&gt;RE_CCLASS) {</span>

                <span class="plain">! Should never happen</span>

                <span class="plain">CHOICE_RE_CC: return "internal error";</span>

                <span class="plain">! Mode switches</span>

                <span class="plain">SENSITIVITY_RE_CC:</span>
                    <span class="plain">if (token--&gt;RE_PAR1) mode_flags = mode_flags | CIS_MFLAG;</span>
                    <span class="plain">else mode_flags = mode_flags &amp; (~CIS_MFLAG);</span>
                    <span class="plain">outcome = true;</span>

                <span class="plain">! Zero-length positional markers</span>

                <span class="plain">ALWAYS_RE_CC:</span>
                    <span class="plain">outcome = true;</span>
                <span class="plain">NEVER_RE_CC:</span>
                    <span class="plain">;</span>
                <span class="plain">START_RE_CC:</span>
                    <span class="plain">if (ipos == 0) outcome = true;</span>
                <span class="plain">END_RE_CC:</span>
                    <span class="plain">if (BlkValueRead(txt, ipos) == 0) outcome = true;</span>
                <span class="plain">BOUNDARY_RE_CC:</span>
                    <span class="plain">rv = 0;</span>
                    <span class="plain">if (BlkValueRead(txt, ipos) == 0 or 10 or 13 or 32 or 9</span>
                        <span class="plain">or '.' or ',' or '!' or '?'</span>
                        <span class="plain">or '-' or '/' or '"' or ':' or ';'</span>
                        <span class="plain">or '(' or ')' or '[' or ']' or '{' or '}') rv++;</span>
                    <span class="plain">if (ipos == 0) ch = 0;</span>
                    <span class="plain">else ch = BlkValueRead(txt, ipos-1);</span>
                    <span class="plain">if (ch == 0 or 10 or 13 or 32 or 9</span>
                        <span class="plain">or '.' or ',' or '!' or '?'</span>
                        <span class="plain">or '-' or '/' or '"' or ':' or ';'</span>
                        <span class="plain">or '(' or ')' or '[' or ']' or '{' or '}') rv++;</span>
                    <span class="plain">if (rv == 1) outcome = true;</span>
                <span class="plain">NONBOUNDARY_RE_CC:</span>
                    <span class="plain">rv = 0;</span>
                    <span class="plain">if (BlkValueRead(txt, ipos) == 0 or 10 or 13 or 32 or 9</span>
                        <span class="plain">or '.' or ',' or '!' or '?'</span>
                        <span class="plain">or '-' or '/' or '"' or ':' or ';'</span>
                        <span class="plain">or '(' or ')' or '[' or ']' or '{' or '}') rv++;</span>
                    <span class="plain">if (ipos == 0) ch = 0;</span>
                    <span class="plain">else ch = BlkValueRead(txt, ipos-1);</span>
                    <span class="plain">if (ch == 0 or 10 or 13 or 32 or 9</span>
                        <span class="plain">or '.' or ',' or '!' or '?'</span>
                        <span class="plain">or '-' or '/' or '"' or ':' or ';'</span>
                        <span class="plain">or '(' or ')' or '[' or ']' or '{' or '}') rv++;</span>
                    <span class="plain">if (rv ~= 1) outcome = true;</span>

                <span class="plain">! Control constructs</span>

                <span class="plain">IF_RE_CC:</span>
                    <span class="plain">i = token--&gt;RE_PAR1; ch = false;</span>
                    <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                        <span class="plain">print "Trying conditional from ", ipos, ": ";</span>
                        <span class="plain">TEXT_TY_RE_DebugNode(token, ftxt, true);</span>
                    <span class="plain">}</span>
                    <span class="plain">if (i &gt;= 1) {</span>
                        <span class="plain">if ((i&lt;RE_Subexpressions--&gt;10) &amp;&amp;</span>
                            <span class="plain">((RE_Subexpressions--&gt;i)--&gt;RE_DATA1 &gt;= 0)) ch = true;</span>
                    <span class="plain">} else {</span>
                        <span class="plain">rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito,</span>
                            <span class="plain">(token--&gt;RE_DOWN)--&gt;RE_DOWN, mode_flags);</span>
                        <span class="plain">if (rv &gt;= 0) ch = true;</span>
                    <span class="plain">}</span>
                    <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                        <span class="plain">print "Condition found to be ", ch, "^";</span>
                    <span class="plain">}</span>
                    <span class="plain">if (ch) {</span>
                        <span class="plain">rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito,</span>
                            <span class="plain">((token--&gt;RE_DOWN)--&gt;RE_NEXT)--&gt;RE_DOWN, mode_flags);</span>
                        <span class="plain">!print "Then clause returned ", rv, "^";</span>
                    <span class="plain">} else {</span>
                        <span class="plain">if ((((token--&gt;RE_DOWN)--&gt;RE_NEXT)--&gt;RE_NEXT) == NULL)</span>
                            <span class="plain">rv = 0; ! The empty else clause matches</span>
                        <span class="plain">else rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito,</span>
                            <span class="plain">(((token--&gt;RE_DOWN)--&gt;RE_NEXT)--&gt;RE_NEXT)--&gt;RE_DOWN, mode_flags);</span>
                        <span class="plain">!print "Else clause returned ", rv, "^";</span>
                    <span class="plain">}</span>
                    <span class="plain">if (rv &gt;= 0) {</span>
                        <span class="plain">outcome = true;</span>
                        <span class="plain">ipos = ipos + rv;</span>
                    <span class="plain">}</span>
                <span class="plain">DISJUNCTION_RE_CC:</span>
                    <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                        <span class="plain">print "Trying disjunction from ", ipos, ": ";</span>
                        <span class="plain">TEXT_TY_RE_DebugNode(token, ftxt, true);</span>
                    <span class="plain">}</span>
                    <span class="plain">for (ch = token--&gt;RE_DOWN: ch ~= NULL: ch = ch--&gt;RE_NEXT) {</span>
                        <span class="plain">if (ch--&gt;RE_PAR1 &lt;= token--&gt;RE_CONSTRAINT) continue;</span>
                        <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                            <span class="plain">print "Trying choice at ", ipos, ": ";</span>
                            <span class="plain">TEXT_TY_RE_DebugNode(ch, ftxt, true);</span>
                        <span class="plain">}</span>
                        <span class="plain">rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito,</span>
                            <span class="plain">ch--&gt;RE_DOWN, mode_flags);</span>
                        <span class="plain">if (rv &gt;= 0) {</span>
                            <span class="plain">token--&gt;RE_DATA1 = ipos; ! Where match was made</span>
                            <span class="plain">token--&gt;RE_DATA2 = ch--&gt;RE_PAR1; ! Option taken</span>
                            <span class="plain">ipos = ipos + rv;</span>
                            <span class="plain">outcome = true;</span>
                            <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                                <span class="plain">print "Choice worked with width ", rv, ": ";</span>
                                <span class="plain">TEXT_TY_RE_DebugNode(ch, ftxt, true);</span>
                            <span class="plain">}</span>
                            <span class="plain">break;</span>
                        <span class="plain">} else {</span>
                            <span class="plain">if (mode_flags &amp; ACCUM_MFLAG == false)</span>
                                <span class="plain">TEXT_TY_RE_FailSubexpressions(ch--&gt;RE_DOWN);</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                    <span class="plain">if (outcome == false) {</span>
                        <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                            <span class="plain">print "Failed disjunction from ", ipos, ": ";</span>
                            <span class="plain">TEXT_TY_RE_DebugNode(token, ftxt, true);</span>
                        <span class="plain">}</span>
                        <span class="plain">token--&gt;RE_DATA1 = ipos; ! Where match was tried</span>
                        <span class="plain">token--&gt;RE_DATA2 = -1; ! No option was taken</span>
                    <span class="plain">}</span>
                <span class="plain">SUBEXP_RE_CC:</span>
                    <span class="plain">if (token--&gt;RE_PAR2 == 1 or 2) {</span>
                        <span class="plain">npos = ipos - token--&gt;RE_PAR3;</span>
                        <span class="plain">if (npos&lt;0) rv = -1; ! Lookbehind fails: nothing behind</span>
                        <span class="plain">else rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, token--&gt;RE_DOWN,</span>
                            <span class="plain">mode_flags);</span>
                    <span class="plain">} else {</span>
                        <span class="plain">switch (token--&gt;RE_PAR3) {</span>
                            <span class="plain">0: rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, token--&gt;RE_DOWN,</span>
                                <span class="plain">mode_flags);</span>
                            <span class="plain">1: rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, token--&gt;RE_DOWN,</span>
                                <span class="plain">mode_flags &amp; (~CIS_MFLAG));</span>
                            <span class="plain">2: rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, ipos, ito, token--&gt;RE_DOWN,</span>
                                <span class="plain">mode_flags | CIS_MFLAG);</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                    <span class="plain">npos = ipos;</span>
                    <span class="plain">if (rv &gt;= 0) npos = ipos + rv;</span>
                    <span class="plain">switch (token--&gt;RE_PAR2) {</span>
                        <span class="plain">1: if (rv &gt;= 0) rv = 0;</span>
                        <span class="plain">2: if (rv &gt;= 0) rv = -1; else rv = 0;</span>
                    <span class="plain">}</span>
                    <span class="plain">if (rv &gt;= 0) {</span>
                        <span class="plain">token--&gt;RE_DATA1 = ipos;</span>
                        <span class="plain">ipos = ipos + rv;</span>
                        <span class="plain">token--&gt;RE_DATA2 = npos;</span>
                        <span class="plain">outcome = true;</span>
                    <span class="plain">} else {</span>
                        <span class="plain">if (mode_flags &amp; ACCUM_MFLAG == false) {</span>
                            <span class="plain">token--&gt;RE_DATA1 = -1;</span>
                            <span class="plain">token--&gt;RE_DATA2 = -1;</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                    <span class="plain">if (token--&gt;RE_PAR2 == 2) TEXT_TY_RE_FailSubexpressions(token, true);</span>
                <span class="plain">QUANTIFIER_RE_CC:</span>
                    <span class="plain">token--&gt;RE_DATA1 = ipos;</span>
                    <span class="plain">if ((token--&gt;RE_DOWN)--&gt;RE_CCLASS == SUBEXP_RE_CC) {</span>
                        <span class="plain">(token--&gt;RE_DOWN)--&gt;RE_CACHE1 = -1;</span>
                        <span class="plain">(token--&gt;RE_DOWN)--&gt;RE_CACHE2 = -1;</span>
                    <span class="plain">}</span>
                    <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                        <span class="plain">print "Trying quantifier from ", ipos, ": ";</span>
                        <span class="plain">TEXT_TY_RE_DebugNode(token, ftxt, true);</span>
                    <span class="plain">}</span>
                    <span class="plain">if (token--&gt;RE_PAR3 == false) { ! Greedy quantifier</span>
                        <span class="plain">!edge = ito; if (token--&gt;RE_CONSTRAINT &gt;= 0) edge = token--&gt;RE_CONSTRAINT;</span>
                        <span class="plain">edge = token--&gt;RE_PAR2;</span>
                        <span class="plain">if (token--&gt;RE_CONSTRAINT &gt;= 0) edge = token--&gt;RE_CONSTRAINT;</span>
                        <span class="plain">rv = -1;</span>
                        <span class="plain">for (i=0, npos=ipos: i&lt;edge: i++) {</span>
                            <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                                <span class="plain">print "Trying quant rep ", i+1, " at ", npos, ": ";</span>
                                <span class="plain">TEXT_TY_RE_DebugNode(token, ftxt, true);</span>
                            <span class="plain">}</span>
                            <span class="plain">rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, token--&gt;RE_DOWN,</span>
                                <span class="plain">mode_flags | ACCUM_MFLAG);</span>
                            <span class="plain">if (rv &lt; 0) break;</span>
                            <span class="plain">if ((token--&gt;RE_DOWN)--&gt;RE_CCLASS == SUBEXP_RE_CC) {</span>
                                <span class="plain">(token--&gt;RE_DOWN)--&gt;RE_CACHE1 = (token--&gt;RE_DOWN)--&gt;RE_DATA1;</span>
                                <span class="plain">(token--&gt;RE_DOWN)--&gt;RE_CACHE2 = (token--&gt;RE_DOWN)--&gt;RE_DATA2;</span>
                            <span class="plain">}</span>
                            <span class="plain">if ((rv == 0) &amp;&amp; (token--&gt;RE_PAR2 == 30000) &amp;&amp; (i&gt;=1)) { i++; break; }</span>
                            <span class="plain">npos = npos + rv;</span>
                        <span class="plain">}</span>
                        <span class="plain">if ((i &gt;= token--&gt;RE_PAR1) &amp;&amp; (i &lt;= token--&gt;RE_PAR2))</span>
                            <span class="plain">outcome = true;</span>
                    <span class="plain">} else { ! Lazy quantifier</span>
                        <span class="plain">edge = token--&gt;RE_PAR1;</span>
                        <span class="plain">if (token--&gt;RE_CONSTRAINT &gt; edge) edge = token--&gt;RE_CONSTRAINT;</span>
                        <span class="plain">for (i=0, npos=ipos: (npos&lt;ito) &amp;&amp; (i &lt; token--&gt;RE_PAR2): i++) {</span>
                            <span class="plain">if (i &gt;= edge) break;</span>
                            <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                                <span class="plain">print "Trying quant rep ", i+1, " at ", npos, ": ";</span>
                                <span class="plain">TEXT_TY_RE_DebugNode(token, ftxt, true);</span>
                            <span class="plain">}</span>
                            <span class="plain">rv = TEXT_TY_RE_ParseAtPosition(ftxt, txt, npos, ito, token--&gt;RE_DOWN,</span>
                                <span class="plain">mode_flags | ACCUM_MFLAG);</span>
                            <span class="plain">if (rv &lt; 0) break;</span>
                            <span class="plain">if ((token--&gt;RE_DOWN)--&gt;RE_CCLASS == SUBEXP_RE_CC) {</span>
                                <span class="plain">(token--&gt;RE_DOWN)--&gt;RE_CACHE1 = (token--&gt;RE_DOWN)--&gt;RE_DATA1;</span>
                                <span class="plain">(token--&gt;RE_DOWN)--&gt;RE_CACHE2 = (token--&gt;RE_DOWN)--&gt;RE_DATA2;</span>
                            <span class="plain">}</span>
                            <span class="plain">if ((rv == 0) &amp;&amp; (token--&gt;RE_PAR2 == 30000) &amp;&amp; (i&gt;=1)) { i++; break; }</span>
                            <span class="plain">npos = npos + rv;</span>
                        <span class="plain">}</span>
                        <span class="plain">if ((i &gt;= edge) &amp;&amp; (i &lt;= token--&gt;RE_PAR2))</span>
                            <span class="plain">outcome = true;</span>
                    <span class="plain">}</span>
                    <span class="plain">if (outcome) {</span>
                        <span class="plain">if (token--&gt;RE_PAR3 == false) { ! Greedy quantifier</span>
                            <span class="plain">if (i &gt; token--&gt;RE_PAR1) { ! I.e., if we have been greedy</span>
                                <span class="plain">token--&gt;RE_DATA2 = i-1; ! And its edge limitation</span>
                            <span class="plain">} else {</span>
                                <span class="plain">token--&gt;RE_DATA2 = -1;</span>
                            <span class="plain">}</span>
                        <span class="plain">} else { ! Lazy quantifier</span>
                            <span class="plain">if (i &lt; token--&gt;RE_PAR2) { ! I.e., if we have been lazy</span>
                                <span class="plain">token--&gt;RE_DATA2 = i+1; ! And its edge limitation</span>
                            <span class="plain">} else {</span>
                                <span class="plain">token--&gt;RE_DATA2 = -1;</span>
                            <span class="plain">}</span>
                        <span class="plain">}</span>
                        <span class="plain">ipos = npos;</span>
                        <span class="plain">if ((i == 0) &amp;&amp; (mode_flags &amp; ACCUM_MFLAG == false))</span>
                            <span class="plain">TEXT_TY_RE_FailSubexpressions(token--&gt;RE_DOWN);</span>
                        <span class="plain">if ((token--&gt;RE_DOWN)--&gt;RE_CCLASS == SUBEXP_RE_CC) {</span>
                            <span class="plain">(token--&gt;RE_DOWN)--&gt;RE_DATA1 = (token--&gt;RE_DOWN)--&gt;RE_CACHE1;</span>
                            <span class="plain">(token--&gt;RE_DOWN)--&gt;RE_DATA2 = (token--&gt;RE_DOWN)--&gt;RE_CACHE2;</span>
                        <span class="plain">}</span>
                        <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                            <span class="plain">print "Successful quant reps ", i, ": ";</span>
                            <span class="plain">TEXT_TY_RE_DebugNode(token, ftxt, true);</span>
                        <span class="plain">}</span>
                    <span class="plain">} else {</span>
                        <span class="plain">!token--&gt;RE_DATA2 = -1;</span>
                        <span class="plain">if (mode_flags &amp; ACCUM_MFLAG == false)</span>
                            <span class="plain">TEXT_TY_RE_FailSubexpressions(token--&gt;RE_DOWN);</span>
                        <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                            <span class="plain">print "Failed quant reps ", i, ": ";</span>
                            <span class="plain">TEXT_TY_RE_DebugNode(token, ftxt, true);</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>

                <span class="plain">! Character classes</span>

                <span class="plain">NOTHING_RE_CC: ;</span>
                <span class="plain">ANYTHING_RE_CC: if (ch) outcome = true; ipos++;</span>
                <span class="plain">WHITESPACE_RE_CC:</span>
                    <span class="plain">if (ch == 10 or 13 or 32 or 9) { outcome = true; ipos++; }</span>
                <span class="plain">NONWHITESPACE_RE_CC:</span>
                    <span class="plain">if ((ch) &amp;&amp; (ch ~= 10 or 13 or 32 or 9)) { outcome = true; ipos++; }</span>
                <span class="plain">PUNCTUATION_RE_CC:</span>
                    <span class="plain">if (ch == '.' or ',' or '!' or '?'</span>
                        <span class="plain">or '-' or '/' or '"' or ':' or ';'</span>
                        <span class="plain">or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }</span>
                <span class="plain">NONPUNCTUATION_RE_CC:</span>
                    <span class="plain">if ((ch) &amp;&amp; (ch ~= '.' or ',' or '!' or '?'</span>
                        <span class="plain">or '-' or '/' or '"' or ':' or ';'</span>
                        <span class="plain">or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }</span>
                <span class="plain">WORD_RE_CC:</span>
                    <span class="plain">if ((ch) &amp;&amp; (ch ~= 10 or 13 or 32 or 9</span>
                        <span class="plain">or '.' or ',' or '!' or '?'</span>
                        <span class="plain">or '-' or '/' or '"' or ':' or ';'</span>
                        <span class="plain">or '(' or ')' or '[' or ']' or '{' or '}')) { outcome = true; ipos++; }</span>
                <span class="plain">NONWORD_RE_CC:</span>
                    <span class="plain">if (ch == 10 or 13 or 32 or 9</span>
                        <span class="plain">or '.' or ',' or '!' or '?'</span>
                        <span class="plain">or '-' or '/' or '"' or ':' or ';'</span>
                        <span class="plain">or '(' or ')' or '[' or ']' or '{' or '}') { outcome = true; ipos++; }</span>
                <span class="plain">DIGIT_RE_CC:</span>
                    <span class="plain">if (ch == '0' or '1' or '2' or '3' or '4'</span>
                        <span class="plain">or '5' or '6' or '7' or '8' or '9') { outcome = true; ipos++; }</span>
                <span class="plain">NONDIGIT_RE_CC:</span>
                    <span class="plain">if ((ch) &amp;&amp; (ch ~= '0' or '1' or '2' or '3' or '4'</span>
                        <span class="plain">or '5' or '6' or '7' or '8' or '9')) { outcome = true; ipos++; }</span>
                <span class="plain">LCASE_RE_CC:</span>
                    <span class="plain">if (CharIsOfCase(ch, 0)) { outcome = true; ipos++; }</span>
                <span class="plain">NONLCASE_RE_CC:</span>
                    <span class="plain">if ((ch) &amp;&amp; (CharIsOfCase(ch, 0) == false)) { outcome = true; ipos++; }</span>
                <span class="plain">UCASE_RE_CC:</span>
                    <span class="plain">if (CharIsOfCase(ch, 1)) { outcome = true; ipos++; }</span>
                <span class="plain">NONUCASE_RE_CC:</span>
                    <span class="plain">if ((ch) &amp;&amp; (CharIsOfCase(ch, 1) == false)) { outcome = true; ipos++; }</span>
                <span class="plain">NEWLINE_RE_CC: if (ch == 10) { outcome = true; ipos++; }</span>
                <span class="plain">TAB_RE_CC: if (ch == 9) { outcome = true; ipos++; }</span>
                <span class="plain">RANGE_RE_CC:</span>
                    <span class="plain">if (TEXT_TY_RE_Range(ch, ftxt,</span>
                        <span class="plain">token--&gt;RE_PAR1, token--&gt;RE_PAR2, token--&gt;RE_PAR3, mode_flags &amp; CIS_MFLAG))</span>
                        <span class="plain">{ outcome = true; ipos++; }</span>

                <span class="plain">! Substring matches</span>

                <span class="plain">LITERAL_RE_CC:</span>
                    <span class="plain">rv = TEXT_TY_RE_MatchSubstring(txt, ipos,</span>
                        <span class="plain">ftxt, token--&gt;RE_PAR1, token--&gt;RE_PAR2, mode_flags &amp; CIS_MFLAG);</span>
                    <span class="plain">if (rv &gt;= 0) { ipos = ipos + rv; outcome = true; }</span>
                <span class="plain">VARIABLE_RE_CC:</span>
                    <span class="plain">i = token--&gt;RE_PAR1;</span>
                    <span class="plain">if ((RE_Subexpressions--&gt;i)--&gt;RE_DATA1 &gt;= 0) {</span>
                        <span class="plain">rv = TEXT_TY_RE_MatchSubstring(txt, ipos,</span>
                            <span class="plain">txt, (RE_Subexpressions--&gt;i)--&gt;RE_DATA1,</span>
                            <span class="plain">(RE_Subexpressions--&gt;i)--&gt;RE_DATA2, mode_flags &amp; CIS_MFLAG);</span>
                        <span class="plain">if (rv &gt;= 0) { ipos = ipos + rv; outcome = true; }</span>
                    <span class="plain">}</span>
                    <span class="plain">.NeverMatchIncompleteVar;</span>
            <span class="plain">}</span>

            <span class="plain">if (outcome == false) {</span>
                <span class="plain">if (TEXT_TY_RE_RewindCount++ &gt;= 10000) {</span>
                    <span class="plain">if (TEXT_TY_RE_RewindCount == 10001) {</span>
                        <span class="plain">style bold; print "OVERFLOW^"; style roman;</span>
                    <span class="plain">}</span>
                    <span class="plain">return -1;</span>
                <span class="plain">}</span>
                <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                    <span class="plain">print "Rewind sought from failure at pos ", ipos, " with: ";</span>
                        <span class="plain">TEXT_TY_RE_DebugNode(token, ftxt, true);</span>
                <span class="plain">}</span>
                <span class="plain">if ((token--&gt;RE_CCLASS == QUANTIFIER_RE_CC) &amp;&amp;</span>
                    <span class="plain">(TEXT_TY_RE_SeekBacktrack(token--&gt;RE_DOWN, ftxt, false, ito, false)))</span>
                    <span class="plain">jump RewindFound;</span>
                <span class="plain">if (mode_flags &amp; ACCUM_MFLAG == false) TEXT_TY_RE_FailSubexpressions(token);</span>
                <span class="plain">token = token--&gt;RE_PREVIOUS;</span>
                <span class="plain">while (token ~= NULL) {</span>
                    <span class="plain">if (TEXT_TY_RE_SeekBacktrack(token, ftxt, true, ito, false)) {</span>
                        <span class="plain">.RewindFound;</span>
                        <span class="plain">ipos = token--&gt;RE_DATA1;</span>
                        <span class="plain">mode_flags = token--&gt;RE_MODES;</span>
                        <span class="plain">if (mode_flags &amp; ACCUM_MFLAG == false)</span>
                            <span class="plain">TEXT_TY_RE_FailSubexpressions(token, true);</span>
                        <span class="plain">if (ipos == -1)</span>
                            <span class="plain">TEXT_TY_RE_DebugTree(ftxt, true);</span>
                        <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                            <span class="plain">print "^[", ifrom, ",", ito, "] rewinding to ", ipos, " at ";</span>
                            <span class="plain">TEXT_TY_RE_DebugNode(token, ftxt, true);</span>
                        <span class="plain">}</span>
                        <span class="plain">jump Rewind;</span>
                    <span class="plain">}</span>
                    <span class="plain">token = token--&gt;RE_PREVIOUS;</span>
                <span class="plain">}</span>
                <span class="plain">if (TEXT_TY_RE_Trace)</span>
                    <span class="plain">print "^Rewind impossible^";</span>
                <span class="plain">return -1;</span>
            <span class="plain">}</span>

            <span class="plain">token = token--&gt;RE_NEXT;</span>
        <span class="plain">}</span>
        <span class="plain">return ipos - ifrom;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. Backtracking. </b>It would be very straightforward to match regular expressions with the
above recursive code if, for every node, there were a fixed number of
characters (depending on the node) such that there would either be a
match eating that many characters, or else no match at all. If that
were true, we could simply march through the text matching until we
could match no more, and although some nodes might have ambiguous readings,
we could always match the first possibility which worked. There would never
be any need to retreat.
</p>

<p class="inwebparagraph">Well, in fact that happy state does apply to a surprising number of nodes,
and some quite complicated regular expressions can be made which use only
them: <code class="display"><span class="extract">&lt;abc&gt;{2}\d\d\1</span></code>, for instance, matches a sequence of exactly 6
characters or else fails to match altogether, and there is never any need
to backtrack. One reason why backtracking is a fairly good algorithm in
practice is that these "good" cases occur fairly often, in subexpressions
if not in the entire expression, and the simple method above disposes of
them efficiently.
</p>

<p class="inwebparagraph">But in an expression like <code class="display"><span class="extract">ab+bb</span></code>, there is no alternative to backtracking
if we are going to try to match the nodes from left to right: we match the
"a", then we match as many "b"s as we can &mdash; but then we find that we
have to match "bb", and this is necessarily impossible because we have
just eaten all of the "b"s available. We therefore backtrack one node
to the <code class="display"><span class="extract">b+</span></code> and try again. We obviously can't literally try again because
that would give the same result: instead we impose a constraint. Suppose
it previously matched a row of 23 letter "b"s, so that the quantifier <code class="display"><span class="extract">+</span></code>
resulted in a multiplicity of 23. We then constrain the node and in effect
consider it to be <code class="display"><span class="extract">b{1,22}</span></code>, that is, to match at least 1 and at most 22
letter "b"s. That still won't work, as it happens, so we backtrack again
with a constraint tightened to make it <code class="display"><span class="extract">b{1,21}</span></code>, and now the match occurs
as we would hope. When the expression becomes more complex, backtracking
becomes a longer-distance, recursive procedure &mdash; we have to exhaust all
possibilities of a more recent node before tracking back to one from longer
ago. (This is why the worst test cases are those which entice us into a long,
long series of matches only to find that a guess made right back at the
start was ill-fated.)
</p>

<p class="inwebparagraph">Rather than describing <code class="display"><span class="extract">TEXT_TY_RE_SeekBacktrack</span></code> in detail here, it is probably
more useful to suggest that the reader observe it in action by setting
<code class="display"><span class="extract">TEXT_TY_RE_Trace</span></code> and trying a few regular expressions.
</p>


<pre class="display">
    <span class="plain">[ TEXT_TY_RE_SeekBacktrack token ftxt downwards ito report_only untried;</span>
        <span class="plain">for (: token ~= NULL: token = token--&gt;RE_NEXT) {</span>
            <span class="plain">if ((TEXT_TY_RE_Trace) &amp;&amp; (report_only == false)) {</span>
                <span class="plain">print "Scan for rewind: ";</span>
                <span class="plain">TEXT_TY_RE_DebugNode(token, ftxt, true);</span>
            <span class="plain">}</span>
            <span class="plain">if ((token--&gt;RE_CCLASS == SUBEXP_RE_CC) &amp;&amp;</span>
                <span class="plain">(token--&gt;RE_PAR2 == 1 or 2 or 4)) {</span>
                <span class="plain">if (downwards) rfalse;</span>
                <span class="plain">continue;</span>
            <span class="plain">}</span>
            <span class="plain">if (token--&gt;RE_DOWN ~= NULL) {</span>
                <span class="plain">if ((TEXT_TY_RE_Trace) &amp;&amp; (report_only == false)) print "Descend^";</span>
                <span class="plain">if (TEXT_TY_RE_SeekBacktrack(token--&gt;RE_DOWN, ftxt, false, ito, report_only)) rtrue;</span>
            <span class="plain">}</span>
            <span class="plain">untried = false;</span>
            <span class="plain">switch (token--&gt;RE_CCLASS) {</span>
                <span class="plain">DISJUNCTION_RE_CC:</span>
                    <span class="plain">if ((token--&gt;RE_DATA2 &gt;= 1) &amp;&amp;</span>
                        <span class="plain">(token--&gt;RE_DATA2 &lt; token--&gt;RE_PAR1) &amp;&amp;</span>
                        <span class="plain">(token--&gt;RE_CONSTRAINT &lt; token--&gt;RE_PAR1)) { ! Matched but earlier than last</span>
                        <span class="plain">if (report_only) rtrue;</span>
                        <span class="plain">if (token--&gt;RE_CONSTRAINT == -1)</span>
                            <span class="plain">token--&gt;RE_CONSTRAINT = 1;</span>
                        <span class="plain">else</span>
                            <span class="plain">(token--&gt;RE_CONSTRAINT)++;</span>
                        <span class="plain">untried = true;</span>
                    <span class="plain">}</span>
                <span class="plain">QUANTIFIER_RE_CC:</span>
                    <span class="plain">if (token--&gt;RE_CONSTRAINT ~= -2) {</span>
                        <span class="plain">if ((TEXT_TY_RE_Trace) &amp;&amp; (report_only == false)) {</span>
                            <span class="plain">print "Quant with cons not -2: ";</span>
                            <span class="plain">TEXT_TY_RE_DebugNode(token, ftxt, true);</span>
                        <span class="plain">}</span>
                        <span class="plain">if (token--&gt;RE_DATA2 &gt;= 0) {</span>
                            <span class="plain">if (report_only) rtrue;</span>
                            <span class="plain">token--&gt;RE_CONSTRAINT = token--&gt;RE_DATA2;</span>
                            <span class="plain">untried = true;</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">if (untried) {</span>
                <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                    <span class="plain">print "Grounds for rewind at: ";</span>
                    <span class="plain">TEXT_TY_RE_DebugNode(token, ftxt, true);</span>
                <span class="plain">}</span>
                <span class="plain">TEXT_TY_RE_EraseConstraints(token--&gt;RE_NEXT);</span>
                <span class="plain">TEXT_TY_RE_EraseConstraints(token--&gt;RE_DOWN);</span>
                <span class="plain">rtrue;</span>
            <span class="plain">}</span>
            <span class="plain">if (downwards) rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Fail Subexpressions. </b>Here, an attempt to make a complicated match against the node in <code class="display"><span class="extract">token</span></code> has
failed: that means that any subexpressions which were matched in the course of
the attempt must also in retrospect be considered unmatched. So we work down
through the subtree at <code class="display"><span class="extract">token</span></code> and empty any markers for subexpressions,
which in effect clears their backslash variables &mdash; this is important as,
otherwise, the contents left over could cause the alternative reading of the
<code class="display"><span class="extract">token</span></code> to be misparsed if it refers to the backslash variables in question.
(If you think nobody would ever be crazy enough to write a regular expression
like that, you haven't see Perl's test suite.)
</p>

<p class="inwebparagraph">If the <code class="display"><span class="extract">downwards</span></code> flag is clear, it not only invalidates subexpression
matches below the node but also to the right of the node &mdash; this is useful
for a backtrack which runs back quite some distance.
</p>


<pre class="display">
    <span class="plain">[ TEXT_TY_RE_FailSubexpressions token downwards;</span>
        <span class="plain">for (: token ~= NULL: token = token--&gt;RE_NEXT) {</span>
            <span class="plain">if (token--&gt;RE_DOWN ~= NULL) TEXT_TY_RE_FailSubexpressions(token--&gt;RE_DOWN);</span>
            <span class="plain">if (token--&gt;RE_CCLASS == SUBEXP_RE_CC) {</span>
                <span class="plain">token--&gt;RE_DATA1 = -1;</span>
                <span class="plain">token--&gt;RE_DATA2 = -1;</span>
            <span class="plain">}</span>
            <span class="plain">if (downwards) break;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15. Erasing Constraints. </b>As explained above, temporary constraints are placed on some nodes when we
are backtracking to test possible cases. When we do backtrack, though, it's
important to lift any constraints left over from the previous attempt to
parse material which is part of or subsequent to the token whose match
attempt has been abandoned.
</p>


<pre class="display">
    <span class="plain">[ TEXT_TY_RE_EraseConstraints token;</span>
        <span class="plain">while (token ~= NULL) {</span>
            <span class="plain">switch (token--&gt;RE_CCLASS) {</span>
                <span class="plain">DISJUNCTION_RE_CC: token--&gt;RE_CONSTRAINT = -1;</span>
                <span class="plain">QUANTIFIER_RE_CC: token--&gt;RE_CONSTRAINT = -1;</span>
            <span class="plain">}</span>
            <span class="plain">if (token--&gt;RE_DOWN) TEXT_TY_RE_EraseConstraints(token--&gt;RE_DOWN);</span>
            <span class="plain">token = token--&gt;RE_NEXT;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16. Matching Literal Text. </b>Here we attempt to make a match of the substring of the text <code class="display"><span class="extract">mtxt</span></code> which runs
from character <code class="display"><span class="extract">mfrom</span></code> to character <code class="display"><span class="extract">mto</span></code>, looking for it at the given
position <code class="display"><span class="extract">ipos</span></code> in the source text <code class="display"><span class="extract">txt</span></code>.
</p>


<pre class="display">
    <span class="plain">[ TEXT_TY_RE_MatchSubstring txt ipos mtxt mfrom mto insens</span>
        <span class="plain">i ch;</span>
        <span class="plain">if (mfrom &lt; 0) return 0;</span>
        <span class="plain">if (insens)</span>
            <span class="plain">for (i=mfrom:i&lt;mto:i++) {</span>
                <span class="plain">ch = BlkValueRead(mtxt, i);</span>
                <span class="plain">if (BlkValueRead(txt, ipos++) ~= ch or TEXT_TY_RevCase(ch))</span>
                    <span class="plain">return -1;</span>
            <span class="plain">}</span>
        <span class="plain">else</span>
            <span class="plain">for (i=mfrom:i&lt;mto:i++)</span>
                <span class="plain">if (BlkValueRead(txt, ipos++) ~= BlkValueRead(mtxt, i))</span>
                    <span class="plain">return -1;</span>
        <span class="plain">return mto-mfrom;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17. Matching Character Range. </b>Suppose that a character range is stored in <code class="display"><span class="extract">ftxt</span></code> between the character
positions <code class="display"><span class="extract">rf</span></code> and <code class="display"><span class="extract">rt</span></code>. Then <code class="display"><span class="extract">TEXT_TY_RE_Range(ch, ftxt, rf, rt, negate, insens)</span></code>
tests whether a given character <code class="display"><span class="extract">ch</span></code> lies within that character range,
negating the outcome if <code class="display"><span class="extract">negate</span></code> is set, and performing comparisons
case insensitively if <code class="display"><span class="extract">insens</span></code> is set.
</p>


<pre class="display">
    <span class="plain">[ TEXT_TY_RE_Range ch ftxt rf rt negate insens</span>
        <span class="plain">i chm upper crev;</span>
        <span class="plain">if (ch == 0) rfalse;</span>
        <span class="plain">if (negate == true) {</span>
            <span class="plain">if (TEXT_TY_RE_Range(ch, ftxt, rf, rt, false, insens)) rfalse;</span>
            <span class="plain">rtrue;</span>
        <span class="plain">}</span>
        <span class="plain">for (i=rf: i&lt;rt: i++) {</span>
            <span class="plain">chm = BlkValueRead(ftxt, i);</span>
            <span class="plain">if ((chm == '\') &amp;&amp; (i+1&lt;rt)) {</span>
                <span class="plain">chm = BlkValueRead(ftxt, ++i);</span>
                <span class="plain">switch (chm) {</span>
                    <span class="plain">'s':</span>
                        <span class="plain">if (ch == 10 or 13 or 32 or 9) rtrue;</span>
                    <span class="plain">'S':</span>
                        <span class="plain">if ((ch) &amp;&amp; (ch ~= 10 or 13 or 32 or 9)) rtrue;</span>
                    <span class="plain">'p':</span>
                        <span class="plain">if (ch == '.' or ',' or '!' or '?'</span>
                            <span class="plain">or '-' or '/' or '"' or ':' or ';'</span>
                            <span class="plain">or '(' or ')' or '[' or ']' or '{' or '}') rtrue;</span>
                    <span class="plain">'P':</span>
                        <span class="plain">if ((ch) &amp;&amp; (ch ~= '.' or ',' or '!' or '?'</span>
                            <span class="plain">or '-' or '/' or '"' or ':' or ';'</span>
                            <span class="plain">or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;</span>
                    <span class="plain">'w':</span>
                        <span class="plain">if ((ch) &amp;&amp; (ch ~= 10 or 13 or 32 or 9</span>
                            <span class="plain">or '.' or ',' or '!' or '?'</span>
                            <span class="plain">or '-' or '/' or '"' or ':' or ';'</span>
                            <span class="plain">or '(' or ')' or '[' or ']' or '{' or '}')) rtrue;</span>
                    <span class="plain">'W':</span>
                        <span class="plain">if (ch == 10 or 13 or 32 or 9</span>
                            <span class="plain">or '.' or ',' or '!' or '?'</span>
                            <span class="plain">or '-' or '/' or '"' or ':' or ';'</span>
                            <span class="plain">or '(' or ')' or '[' or ']' or '{' or '}') rtrue;</span>
                    <span class="plain">'d':</span>
                        <span class="plain">if (ch == '0' or '1' or '2' or '3' or '4'</span>
                            <span class="plain">or '5' or '6' or '7' or '8' or '9') rtrue;</span>
                    <span class="plain">'D':</span>
                        <span class="plain">if ((ch) &amp;&amp; (ch ~= '0' or '1' or '2' or '3' or '4'</span>
                            <span class="plain">or '5' or '6' or '7' or '8' or '9')) rtrue;</span>
                    <span class="plain">'l': if (CharIsOfCase(ch, 0)) rtrue;</span>
                    <span class="plain">'L': if (CharIsOfCase(ch, 0) == false) rtrue;</span>
                    <span class="plain">'u': if (CharIsOfCase(ch, 1)) rtrue;</span>
                    <span class="plain">'U': if (CharIsOfCase(ch, 1) == false) rtrue;</span>
                    <span class="plain">'n': if (ch == 10) rtrue;</span>
                    <span class="plain">'t': if (ch == 9) rtrue;</span>
                <span class="plain">}</span>
            <span class="plain">} else {</span>
                <span class="plain">if ((i+2&lt;rt) &amp;&amp; (BlkValueRead(ftxt, i+1) == '-')) {</span>
                    <span class="plain">upper = BlkValueRead(ftxt, i+2);</span>
                    <span class="plain">if ((ch &gt;= chm) &amp;&amp; (ch &lt;= upper)) rtrue;</span>
                    <span class="plain">if (insens) {</span>
                        <span class="plain">crev = TEXT_TY_RevCase(ch);</span>
                        <span class="plain">if ((crev &gt;= chm) &amp;&amp; (crev &lt;= upper)) rtrue;</span>
                    <span class="plain">}</span>
                    <span class="plain">i=i+2;</span>
                <span class="plain">} else {</span>
                    <span class="plain">if (chm == ch) rtrue;</span>
                    <span class="plain">if ((insens) &amp;&amp; (chm == TEXT_TY_RevCase(ch))) rtrue;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18. Search And Replace. </b>And finally, last but not least: the routine which searches an indexed
text <code class="display"><span class="extract">txt</span></code> trying to match it against <code class="display"><span class="extract">ftxt</span></code>. If <code class="display"><span class="extract">ftxtype</span></code> is set to
<code class="display"><span class="extract">REGEXP_BLOB</span></code> then <code class="display"><span class="extract">ftxt</span></code> is expected to be a regular expression such
as <code class="display"><span class="extract">ab+(c*de)?</span></code>, whereas if <code class="display"><span class="extract">ftxtype</span></code> is <code class="display"><span class="extract">CHR_BLOB</span></code> then it is expected
only to be a simple string of characters taken literally, such as <code class="display"><span class="extract">frog</span></code>.
</p>

<p class="inwebparagraph">Each match found is replaced with the contents of <code class="display"><span class="extract">rtxt</span></code>, except
that if the blob type is <code class="display"><span class="extract">REGEXP_BLOB</span></code> then we recognise a few syntaxes
as special: for instance, <code class="display"><span class="extract">\2</span></code> expands to the value of subexpression 2
as it was matched &mdash; see Writing with Inform for details.
</p>

<p class="inwebparagraph">The optional argument <code class="display"><span class="extract">insens</span></code> is a flag which, if set, causes the matching
to be done case insensitively; the optional argument <code class="display"><span class="extract">exactly</span></code>, if set,
causes the matching to work only if the entire <code class="display"><span class="extract">txt</span></code> is matched. (This
is not especially useful with regular expressions, because the effect can
equally be achieved by turning <code class="display"><span class="extract">ab+c</span></code>, say, into <code class="display"><span class="extract">^ab+c$</span></code>, but it is
indeed useful where the blob type is <code class="display"><span class="extract">CHR_BLOB</span></code>.)
</p>

<p class="inwebparagraph">For an explanation of the use of the word "blob", see "Text.i6t".
</p>


<pre class="display">
    <span class="plain">[ TEXT_TY_Replace_RE ftxtype txt ftxt rtxt insens exactly</span>
        <span class="plain">r p p1 p2 cp cp1 cp2;</span>
        <span class="plain">!print "Find: "; BlkValueDebug(ftxt); print "^";</span>
        <span class="plain">!print "Rep: "; BlkValueDebug(rtxt); print "^";</span>
        <span class="plain">!print "In: "; BlkValueDebug(txt); print "^";</span>
        <span class="plain">if (rtxt == 0 or 1) { cp = txt--&gt;0; p = TEXT_TY_Temporarily_Transmute(txt); }</span>
        <span class="plain">else TEXT_TY_Transmute(txt);</span>
        <span class="plain">cp1 = ftxt--&gt;0; p1 = TEXT_TY_Temporarily_Transmute(ftxt);</span>
        <span class="plain">cp2 = rtxt--&gt;0; p2 = TEXT_TY_Temporarily_Transmute(rtxt);</span>
        <span class="plain">r = TEXT_TY_Replace_REI(ftxtype, txt, ftxt, rtxt, insens, exactly);</span>
        <span class="plain">TEXT_TY_Untransmute(ftxt, p1, cp1);</span>
        <span class="plain">TEXT_TY_Untransmute(rtxt, p2, cp2);</span>
        <span class="plain">if (rtxt == 0 or 1) TEXT_TY_Untransmute(txt, p, cp);</span>
        <span class="plain">return r;</span>
    <span class="plain">];</span>

    <span class="plain">[ TEXT_TY_Replace_REI ftxtype txt ftxt rtxt insens exactly</span>
        <span class="plain">ctxt csize ilen i cl mpos cpos ch chm;</span>

        <span class="plain">ilen = TEXT_TY_CharacterLength(txt);</span>

        <span class="plain">TEXT_TY_RE_Err = 0;</span>
        <span class="plain">switch (ftxtype) {</span>
            <span class="plain">REGEXP_BLOB: i = TEXT_TY_RE_CompileTree(ftxt, exactly);</span>
            <span class="plain">CHR_BLOB: i = TEXT_TY_CHR_CompileTree(ftxt, exactly);</span>
            <span class="plain">default: "*** bad ftxtype ***";</span>
        <span class="plain">}</span>

        <span class="plain">if ((i&lt;0) || (i&gt;RE_MAX_PACKETS)) {</span>
            <span class="plain">TEXT_TY_RE_Err = i;</span>
            <span class="plain">print "*** Regular expression error: ", (string) TEXT_TY_RE_Err, " ***^";</span>
            <span class="plain">RunTimeProblem(RTP_REGEXPSYNTAXERROR);</span>
            <span class="plain">return 0;</span>
        <span class="plain">}</span>

        <span class="plain">if (TEXT_TY_RE_Trace) {</span>
            <span class="plain">TEXT_TY_RE_DebugTree(ftxt);</span>
            <span class="plain">print "(compiled to ", i, " packets)^";</span>
        <span class="plain">}</span>

        <span class="plain">if (ftxtype == REGEXP_BLOB) TEXT_TY_RE_EmptyMatchVars();</span>
        <span class="plain">mpos = 0; chm = 0; cpos = 0;</span>
        <span class="plain">while (TEXT_TY_RE_Parse(ftxt, txt, mpos, insens) &gt;= 0) {</span>
            <span class="plain">chm++;</span>

            <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                <span class="plain">print "^*** Match ", chm, " found (", RE_PACKET_space--&gt;RE_DATA1, ",",</span>
                    <span class="plain">RE_PACKET_space--&gt;RE_DATA2, "): ";</span>
                <span class="plain">if (RE_PACKET_space--&gt;RE_DATA1 == RE_PACKET_space--&gt;RE_DATA2) {</span>
                    <span class="plain">print "&lt;empty&gt;";</span>
                <span class="plain">}</span>
                <span class="plain">for (i=RE_PACKET_space--&gt;RE_DATA1:i&lt;RE_PACKET_space--&gt;RE_DATA2:i++) {</span>
                    <span class="plain">print (char) BlkValueRead(txt, i);</span>
                <span class="plain">}</span>
                <span class="plain">print " ***^";</span>
            <span class="plain">}</span>

            <span class="plain">if (rtxt == 0) break; ! Accept only one match, replace nothing</span>

            <span class="plain">if (rtxt ~= 0 or 1) {</span>
                <span class="plain">if (chm == 1) {</span>
                    <span class="plain">ctxt = BlkValueCreate(TEXT_TY);</span>
                    <span class="plain">TEXT_TY_Transmute(ctxt);</span>
                    <span class="plain">csize = BlkValueLBCapacity(ctxt);</span>
                <span class="plain">}</span>

                <span class="plain">for (i=cpos:i&lt;RE_PACKET_space--&gt;RE_DATA1:i++) {</span>
                    <span class="plain">ch = BlkValueRead(txt, i);</span>
                    <span class="plain">if (cl+1 &gt;= csize) {</span>
                        <span class="plain">if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;</span>
                        <span class="plain">csize = BlkValueLBCapacity(ctxt);</span>
                    <span class="plain">}</span>
                    <span class="plain">BlkValueWrite(ctxt, cl++, ch);</span>
                <span class="plain">}</span>
                <span class="plain">BlkValueWrite(ctxt, cl, 0);</span>

                <span class="plain">TEXT_TY_Concatenate(ctxt, rtxt, ftxtype, txt);</span>
                <span class="plain">csize = BlkValueLBCapacity(ctxt);</span>
                <span class="plain">cl = TEXT_TY_CharacterLength(ctxt);</span>
            <span class="plain">}</span>

            <span class="plain">mpos = RE_PACKET_space--&gt;RE_DATA2; cpos = mpos;</span>
            <span class="plain">if (RE_PACKET_space--&gt;RE_DATA1 == RE_PACKET_space--&gt;RE_DATA2)</span>
                <span class="plain">mpos++;</span>

            <span class="plain">if (TEXT_TY_RE_Trace) {</span>
                <span class="plain">if (chm == 100) { ! Purely to keep the output from being excessive</span>
                    <span class="plain">print "(Stopping after 100 matches.)^"; break;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">if (chm &gt; 0) {</span>
            <span class="plain">if (rtxt ~= 0 or 1) {</span>
                <span class="plain">for (i=cpos:i&lt;ilen:i++) {</span>
                    <span class="plain">ch = BlkValueRead(txt, i);</span>
                    <span class="plain">if (cl+1 &gt;= csize) {</span>
                        <span class="plain">if (BlkValueSetLBCapacity(ctxt, 2*cl) == false) break;</span>
                        <span class="plain">csize = BlkValueLBCapacity(ctxt);</span>
                    <span class="plain">}</span>
                    <span class="plain">BlkValueWrite(ctxt, cl++, ch);</span>
                <span class="plain">}</span>
            <span class="plain">}</span>

            <span class="plain">if (ftxtype == REGEXP_BLOB) {</span>
                <span class="plain">TEXT_TY_RE_CreateMatchVars(txt);</span>
                <span class="plain">if (TEXT_TY_RE_Trace)</span>
                    <span class="plain">TEXT_TY_RE_DebugMatchVars(txt);</span>
            <span class="plain">}</span>

            <span class="plain">if (rtxt ~= 0 or 1) {</span>
                <span class="plain">BlkValueWrite(ctxt, cl, 0);</span>
                <span class="plain">BlkValueCopy(txt, ctxt);</span>
                <span class="plain">BlkValueFree(ctxt);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">return chm;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19. Concatenation. </b>See the corresponding routine in "Text.i6t": this is a variation
which handles the special syntaxes used in search-and-replace.
</p>


<pre class="display">
    <span class="plain">[ TEXT_TY_RE_Concatenate txt_to txt_from blobtype txt_ref</span>
        <span class="plain">pos len ch i tosize x y case;</span>
        <span class="plain">if ((txt_to==0) || (BlkValueWeakKind(txt_to) ~= TEXT_TY)) rfalse;</span>
        <span class="plain">if ((txt_from==0) || (BlkValueWeakKind(txt_from) ~= TEXT_TY)) return txt_to;</span>
        <span class="plain">pos = TEXT_TY_CharacterLength(txt_to);</span>
        <span class="plain">tosize = BlkValueLBCapacity(txt_to);</span>
        <span class="plain">len = TEXT_TY_CharacterLength(txt_from);</span>
        <span class="plain">for (i=0:i&lt;len:i++) {</span>
            <span class="plain">ch = BlkValueRead(txt_from, i);</span>
            <span class="plain">if ((ch == '\') &amp;&amp; (i &lt; len-1)) {</span>
                <span class="plain">ch = BlkValueRead(txt_from, ++i);</span>
                <span class="plain">if (ch == 'n') ch = 10;</span>
                <span class="plain">if (ch == 't') ch = 9;</span>
                <span class="plain">case = -1;</span>
                <span class="plain">if (ch == 'l') case = 0;</span>
                <span class="plain">if (ch == 'u') case = 1;</span>
                <span class="plain">if (case &gt;= 0) ch = BlkValueRead(txt_from, ++i);</span>
                <span class="plain">if ((ch &gt;= '0') &amp;&amp; (ch &lt;= '9')) {</span>
                    <span class="plain">ch = ch - '0';</span>
                    <span class="plain">if (ch &lt; RE_Subexpressions--&gt;10) {</span>
                        <span class="plain">x = (RE_Subexpressions--&gt;ch)--&gt;RE_DATA1;</span>
                        <span class="plain">y = (RE_Subexpressions--&gt;ch)--&gt;RE_DATA2;</span>
                        <span class="plain">if (x &gt;= 0) {</span>
                            <span class="plain">for (:x&lt;y:x++) {</span>
                                <span class="plain">ch = BlkValueRead(txt_ref, x);</span>
                                <span class="plain">if (pos+1 &gt;= tosize) {</span>
                                    <span class="plain">if (BlkValueSetLBCapacity(txt_to, 2*tosize) == false) break;</span>
                                    <span class="plain">tosize = BlkValueLBCapacity(txt_to);</span>
                                <span class="plain">}</span>
                                <span class="plain">if (case &gt;= 0)</span>
                                    <span class="plain">BlkValueWrite(txt_to, pos++, CharToCase(ch, case));</span>
                                <span class="plain">else</span>
                                    <span class="plain">BlkValueWrite(txt_to, pos++, ch);</span>
                            <span class="plain">}</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                    <span class="plain">continue;</span>
                <span class="plain">}</span>

            <span class="plain">}</span>
            <span class="plain">if (pos+1 &gt;= tosize) {</span>
                <span class="plain">if (BlkValueSetLBCapacity(txt_to, 2*tosize) == false) break;</span>
                <span class="plain">tosize = BlkValueLBCapacity(txt_to);</span>
            <span class="plain">}</span>
            <span class="plain">BlkValueWrite(txt_to, pos++, ch);</span>
        <span class="plain">}</span>
        <span class="plain">BlkValueWrite(txt_to, pos, 0);</span>
        <span class="plain">return txt_to;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="S-prg.html">Back to 'Paragraphing'</a></li><li><a href="S-rkt.html">Continue with 'Relation Kind Template'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

