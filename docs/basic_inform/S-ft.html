<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>S/dt</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of 'S/ft' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">basic_inform Template Library</a></li><li><b>FileIO Template</b></li></ul><p class="purpose">Reading and writing external files, in the Glulx virtual machine only.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Language</a></li><li><a href="#SP2">&#167;2. Structure</a></li><li><a href="#SP3">&#167;3. Instances</a></li><li><a href="#SP4">&#167;4. Errors</a></li><li><a href="#SP5">&#167;5. Glulx Material</a></li><li><a href="#SP6">&#167;6. Existence</a></li><li><a href="#SP7">&#167;7. Readiness</a></li><li><a href="#SP8">&#167;8. Open File</a></li><li><a href="#SP9">&#167;9. Close File</a></li><li><a href="#SP10">&#167;10. Get Character</a></li><li><a href="#SP11">&#167;11. Put Character</a></li><li><a href="#SP12">&#167;12. Print Line</a></li><li><a href="#SP13">&#167;13. Print Contents</a></li><li><a href="#SP14">&#167;14. Print Text</a></li><li><a href="#SP15">&#167;15. Serialising Tables</a></li><li><a href="#SP16">&#167;16. Z-Machine Stubs</a></li><li><a href="#SP17">&#167;17. Back To Core</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Language. </b>This whole template contains material used only if the "Glulx external files"
element is part of Inform's current definition, so:
</p>


<pre class="display">
    <span class="plain">#IFDEF PLUGIN_FILES;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Structure. </b>The I7 kind of value "auxiliary-file" is an <code class="display"><span class="extract">--&gt;</span></code> array, holding a memory
structure containing information about external files. The following
constants specify memory offsets and values. Note the safety value stored
as the first word of the structure: this helps protect the routines below
from accidents. (16339, besides being prime, is a number interesting to the
author of Inform since it was the examination board identifying number of
his school, and so had to be filled in on all of the many papers he sat
during his formative years.)
</p>


<pre class="display">
    <span class="plain">Constant AUXF_MAGIC = 0; ! First word holds a safety constant</span>
    <span class="plain">Constant AUXF_MAGIC_VALUE = 16339; ! Should be first word of any valid file structure</span>
    <span class="plain">Constant AUXF_STATUS = 1; ! One of the following:</span>
        <span class="plain">Constant AUXF_STATUS_IS_CLOSED = 1; ! Currently closed, or perhaps doesn't exist</span>
        <span class="plain">Constant AUXF_STATUS_IS_OPEN_FOR_READ = 2;</span>
        <span class="plain">Constant AUXF_STATUS_IS_OPEN_FOR_WRITE = 3;</span>
        <span class="plain">Constant AUXF_STATUS_IS_OPEN_FOR_APPEND = 4;</span>
    <span class="plain">Constant AUXF_BINARY = 2; ! False for text files (I7 default), true for binary</span>
    <span class="plain">Constant AUXF_STREAM = 3; ! Stream for an open file (meaningless otherwise)</span>
    <span class="plain">Constant AUXF_FILENAME = 4; ! Packed address of constant string</span>
    <span class="plain">Constant AUXF_IFID_OF_OWNER = 5; ! UUID_ARRAY if owned by this project, or</span>
        <span class="plain">! string array of IFID of owner wrapped in //...//, or NULL to leave open</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Instances. </b>These structures are not dynamically created: they are precompiled by the NI
compiler, already filled in with the necessary values. The following command
generates them.
</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Errors. </b>This is used for I/O errors of all kinds: it isn't within the Glulx-only
code because one of the errors is to try to use these routines on the
Z-machine.
</p>


<pre class="display">
    <span class="plain">[ FileIO_Error extf err_text  struc;</span>
        <span class="plain">if ((extf &lt; 1) || (extf &gt; NO_EXTERNAL_FILES)) {</span>
            <span class="plain">print "^*** Error on unknown file: ", (string) err_text, " ***^";</span>
        <span class="plain">} else {</span>
            <span class="plain">struc = TableOfExternalFiles--&gt;extf;</span>
            <span class="plain">print "^*** Error on file '",</span>
                <span class="plain">(string) struc--&gt;AUXF_FILENAME, "': ",</span>
                <span class="plain">(string) err_text, " ***^";</span>
        <span class="plain">}</span>
        <span class="plain">RunTimeProblem(RTP_FILEIOERROR);</span>
        <span class="plain">return 0;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Glulx Material. </b></p>


<pre class="display">
    <span class="plain">#IFDEF TARGET_GLULX;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Existence. </b>Determine whether a file exists on disc. Note that we have no concept of
directories, or the file system structure on the host machine: indeed, it
is entirely up to the Glulx VM what it does when asked to look for a file.
By convention, though, files for a project are stored in the same folder
as the story file when out in the wild; when a project is developed within
the Inform user interface, they are either (for preference) stored in a
<code class="display"><span class="extract">Files</span></code> subfolder of the <code class="display"><span class="extract">Materials</span></code> folder for a project, or else stored
alongside the Inform project file.
</p>


<pre class="display">
    <span class="plain">[ FileIO_Exists extf  fref struc rv usage;</span>
        <span class="plain">if ((extf &lt; 1) || (extf &gt; NO_EXTERNAL_FILES)) rfalse;</span>
        <span class="plain">struc = TableOfExternalFiles--&gt;extf;</span>
        <span class="plain">if ((struc == 0) || (struc--&gt;AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;</span>
        <span class="plain">if (struc--&gt;AUXF_BINARY) usage = fileusage_BinaryMode;</span>
        <span class="plain">else usage = fileusage_TextMode;</span>
        <span class="plain">fref = glk_fileref_create_by_name(fileusage_Data + usage,</span>
            <span class="plain">Glulx_ChangeAnyToCString(struc--&gt;AUXF_FILENAME), 0);</span>
        <span class="plain">rv = glk_fileref_does_file_exist(fref);</span>
        <span class="plain">glk_fileref_destroy(fref);</span>
        <span class="plain">return rv;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Readiness. </b>One of our problems is that a file might be being used by another application:
perhaps even by another story file running in a second incarnation of Glulx,
like a parallel world of which we can know nothing. We actually want to
allow for this sort of thing, because one use for external files in I7
is as a sort of communications conduit for assisting applications.
</p>

<p class="inwebparagraph">Most operating systems solve this problem by means of locking a file, or
by creating a second lock-file, the existence of which indicates ownership
of the original. We haven't got much access to the file-system, though:
what we do is to set the first character of the file to an asterisk to
mark it as complete and ready for reading, or to a hyphen to mark it as
a work in progress.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">FileIO_Ready</span></code> determines whether or not a file is ready to be read
from: it has to exist on disc, and to be openable, and also to be ready
in having this marker asterisk.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">FileIO_MarkReady</span></code> changes the readiness state of a file, writing the
asterisk or hyphen into the initial character as needed.
</p>


<pre class="display">
    <span class="plain">[ FileIO_Ready extf  struc fref usage str ch;</span>
        <span class="plain">if ((extf &lt; 1) || (extf &gt; NO_EXTERNAL_FILES)) rfalse;</span>
        <span class="plain">struc = TableOfExternalFiles--&gt;extf;</span>
        <span class="plain">if ((struc == 0) || (struc--&gt;AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;</span>
        <span class="plain">if (struc--&gt;AUXF_BINARY) usage = fileusage_BinaryMode;</span>
        <span class="plain">else usage = fileusage_TextMode;</span>
        <span class="plain">fref = glk_fileref_create_by_name(fileusage_Data + usage,</span>
            <span class="plain">Glulx_ChangeAnyToCString(struc--&gt;AUXF_FILENAME), 0);</span>
        <span class="plain">if (glk_fileref_does_file_exist(fref) == false) {</span>
            <span class="plain">glk_fileref_destroy(fref);</span>
            <span class="plain">rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">str = glk_stream_open_file(fref, filemode_Read, 0);</span>
        <span class="plain">ch = glk_get_char_stream(str);</span>
        <span class="plain">glk_stream_close(str, 0);</span>
        <span class="plain">glk_fileref_destroy(fref);</span>
        <span class="plain">if (ch ~= '*') rfalse;</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>

    <span class="plain">[ FileIO_MarkReady extf readiness  struc fref str ch usage;</span>
        <span class="plain">if ((extf &lt; 1) || (extf &gt; NO_EXTERNAL_FILES))</span>
            <span class="plain">return FileIO_Error(extf, "tried to open a non-file");</span>
        <span class="plain">struc = TableOfExternalFiles--&gt;extf;</span>
        <span class="plain">if ((struc == 0) || (struc--&gt;AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;</span>
        <span class="plain">if (struc--&gt;AUXF_BINARY) usage = fileusage_BinaryMode;</span>
        <span class="plain">else usage = fileusage_TextMode;</span>
        <span class="plain">fref = glk_fileref_create_by_name(fileusage_Data + usage,</span>
            <span class="plain">Glulx_ChangeAnyToCString(struc--&gt;AUXF_FILENAME), 0);</span>
        <span class="plain">if (glk_fileref_does_file_exist(fref) == false) {</span>
            <span class="plain">glk_fileref_destroy(fref);</span>
            <span class="plain">return FileIO_Error(extf, "only existing files can be marked");</span>
        <span class="plain">}</span>
        <span class="plain">if (struc--&gt;AUXF_STATUS ~= AUXF_STATUS_IS_CLOSED) {</span>
            <span class="plain">glk_fileref_destroy(fref);</span>
            <span class="plain">return FileIO_Error(extf, "only closed files can be marked");</span>
        <span class="plain">}</span>
        <span class="plain">str = glk_stream_open_file(fref, filemode_ReadWrite, 0);</span>
        <span class="plain">glk_stream_set_position(str, 0, 0); ! seek start</span>
        <span class="plain">if (readiness) ch = '*'; else ch = '-';</span>
        <span class="plain">glk_put_char_stream(str, ch); ! mark as complete</span>
        <span class="plain">glk_stream_close(str, 0);</span>
        <span class="plain">glk_fileref_destroy(fref);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Open File. </b></p>


<pre class="display">
    <span class="plain">[ FileIO_Open extf write_flag append_flag</span>
        <span class="plain">struc fref str mode ix ch not_this_ifid owner force_header usage;</span>
        <span class="plain">if ((extf &lt; 1) || (extf &gt; NO_EXTERNAL_FILES))</span>
            <span class="plain">return FileIO_Error(extf, "tried to open a non-file");</span>
        <span class="plain">struc = TableOfExternalFiles--&gt;extf;</span>
        <span class="plain">if ((struc == 0) || (struc--&gt;AUXF_MAGIC ~= AUXF_MAGIC_VALUE)) rfalse;</span>
        <span class="plain">if (struc--&gt;AUXF_STATUS ~= AUXF_STATUS_IS_CLOSED)</span>
            <span class="plain">return FileIO_Error(extf, "tried to open a file already open");</span>
        <span class="plain">if (struc--&gt;AUXF_BINARY) usage = fileusage_BinaryMode;</span>
        <span class="plain">else usage = fileusage_TextMode;</span>
        <span class="plain">fref = glk_fileref_create_by_name(fileusage_Data + usage,</span>
            <span class="plain">Glulx_ChangeAnyToCString(struc--&gt;AUXF_FILENAME), 0);</span>
        <span class="plain">if (write_flag) {</span>
            <span class="plain">if (append_flag) {</span>
                <span class="plain">mode = filemode_WriteAppend;</span>
                <span class="plain">if (glk_fileref_does_file_exist(fref) == false)</span>
                    <span class="plain">force_header = true;</span>
            <span class="plain">}</span>
            <span class="plain">else mode = filemode_Write;</span>
        <span class="plain">} else {</span>
            <span class="plain">mode = filemode_Read;</span>
            <span class="plain">if (glk_fileref_does_file_exist(fref) == false) {</span>
                <span class="plain">glk_fileref_destroy(fref);</span>
                <span class="plain">return FileIO_Error(extf, "tried to open a file which does not exist");</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">str = glk_stream_open_file(fref, mode, 0);</span>
        <span class="plain">glk_fileref_destroy(fref);</span>
        <span class="plain">if (str == 0) return FileIO_Error(extf, "tried to open a file but failed");</span>
        <span class="plain">struc--&gt;AUXF_STREAM = str;</span>
        <span class="plain">if (write_flag) {</span>
            <span class="plain">if (append_flag)</span>
                <span class="plain">struc--&gt;AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_APPEND;</span>
            <span class="plain">else</span>
                <span class="plain">struc--&gt;AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_WRITE;</span>
            <span class="plain">glk_stream_set_current(str);</span>
            <span class="plain">if ((append_flag == false) || (force_header)) {</span>
                <span class="plain">print "- ";</span>
                <span class="plain">for (ix=6: ix &lt;= UUID_ARRAY-&gt;0: ix++) print (char) UUID_ARRAY-&gt;ix;</span>
                <span class="plain">print " ", (string) struc--&gt;AUXF_FILENAME, "^";</span>
            <span class="plain">}</span>
        <span class="plain">} else {</span>
            <span class="plain">struc--&gt;AUXF_STATUS = AUXF_STATUS_IS_OPEN_FOR_READ;</span>
            <span class="plain">ch = FileIO_GetC(extf);</span>
            <span class="plain">if (ch ~= '-' or '*') { jump BadFile; }</span>
            <span class="plain">if (ch == '-')</span>
                <span class="plain">return FileIO_Error(extf, "tried to open a file which was incomplete");</span>
            <span class="plain">ch = FileIO_GetC(extf);</span>
            <span class="plain">if (ch ~= ' ') { jump BadFile; }</span>
            <span class="plain">ch = FileIO_GetC(extf);</span>
            <span class="plain">if (ch ~= '/') { jump BadFile; }</span>
            <span class="plain">ch = FileIO_GetC(extf);</span>
            <span class="plain">if (ch ~= '/') { jump BadFile; }</span>
            <span class="plain">owner = struc--&gt;AUXF_IFID_OF_OWNER;</span>
            <span class="plain">ix = 3;</span>
            <span class="plain">if (owner == UUID_ARRAY) ix = 8;</span>
            <span class="plain">if (owner ~= NULL) {</span>
                <span class="plain">for (: ix &lt;= owner-&gt;0: ix++) {</span>
                    <span class="plain">ch = FileIO_GetC(extf);</span>
                    <span class="plain">if (ch == -1) { jump BadFile; }</span>
                    <span class="plain">if (ch ~= owner-&gt;ix) not_this_ifid = true;</span>
                    <span class="plain">if (ch == ' ') break;</span>
                <span class="plain">}</span>
                <span class="plain">if (not_this_ifid == false) {</span>
                    <span class="plain">ch = FileIO_GetC(extf);</span>
                    <span class="plain">if (ch ~= ' ') { jump BadFile; }</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">while (ch ~= -1) {</span>
                <span class="plain">ch = FileIO_GetC(extf);</span>
                <span class="plain">if (ch == 10 or 13) break;</span>
            <span class="plain">}</span>
            <span class="plain">if (not_this_ifid) {</span>
                <span class="plain">struc--&gt;AUXF_STATUS = AUXF_STATUS_IS_CLOSED;</span>
                <span class="plain">glk_stream_close(str, 0);</span>
                <span class="plain">return FileIO_Error(extf,</span>
                    <span class="plain">"tried to open a file owned by another project");</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">return struc--&gt;AUXF_STREAM;</span>
        <span class="plain">.BadFile;</span>
        <span class="plain">struc--&gt;AUXF_STATUS = AUXF_STATUS_IS_CLOSED;</span>
        <span class="plain">glk_stream_close(str, 0);</span>
        <span class="plain">return FileIO_Error(extf, "tried to open a file which seems to be malformed");</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Close File. </b>Note that a call to the following, in write mode, must be followed by a
<code class="display"><span class="extract">glk_stream_set_current()</span></code>, or else the next print statement will run into
Glk errors.
</p>


<pre class="display">
    <span class="plain">[ FileIO_Close extf  struc;</span>
        <span class="plain">if ((extf &lt; 1) || (extf &gt; NO_EXTERNAL_FILES))</span>
            <span class="plain">return FileIO_Error(extf, "tried to open a non-file");</span>
        <span class="plain">struc = TableOfExternalFiles--&gt;extf;</span>
        <span class="plain">if (struc--&gt;AUXF_STATUS ~=</span>
            <span class="plain">AUXF_STATUS_IS_OPEN_FOR_READ or</span>
            <span class="plain">AUXF_STATUS_IS_OPEN_FOR_WRITE or</span>
            <span class="plain">AUXF_STATUS_IS_OPEN_FOR_APPEND)</span>
            <span class="plain">return FileIO_Error(extf, "tried to close a file which is not open");</span>
        <span class="plain">if (struc--&gt;AUXF_STATUS ==</span>
            <span class="plain">AUXF_STATUS_IS_OPEN_FOR_WRITE or</span>
            <span class="plain">AUXF_STATUS_IS_OPEN_FOR_APPEND) {</span>
            <span class="plain">glk_stream_set_position(struc--&gt;AUXF_STREAM, 0, 0); ! seek start</span>
            <span class="plain">glk_put_char_stream(struc--&gt;AUXF_STREAM, '*'); ! mark as complete</span>
        <span class="plain">}</span>
        <span class="plain">glk_stream_close(struc--&gt;AUXF_STREAM, 0);</span>
        <span class="plain">struc--&gt;AUXF_STATUS = AUXF_STATUS_IS_CLOSED;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Get Character. </b></p>


<pre class="display">
    <span class="plain">[ FileIO_GetC extf  struc;</span>
        <span class="plain">if ((extf &lt; 1) || (extf &gt; NO_EXTERNAL_FILES)) return -1;</span>
        <span class="plain">struc = TableOfExternalFiles--&gt;extf;</span>
        <span class="plain">if (struc--&gt;AUXF_STATUS ~= AUXF_STATUS_IS_OPEN_FOR_READ) return -1;</span>
        <span class="plain">return glk_get_char_stream(struc--&gt;AUXF_STREAM);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Put Character. </b></p>


<pre class="display">
    <span class="plain">[ FileIO_PutC extf char  struc;</span>
        <span class="plain">if ((extf &lt; 1) || (extf &gt; NO_EXTERNAL_FILES)) return -1;</span>
            <span class="plain">return FileIO_Error(extf, "tried to write to a non-file");</span>
        <span class="plain">struc = TableOfExternalFiles--&gt;extf;</span>
        <span class="plain">if (struc--&gt;AUXF_STATUS ~=</span>
            <span class="plain">AUXF_STATUS_IS_OPEN_FOR_WRITE or</span>
            <span class="plain">AUXF_STATUS_IS_OPEN_FOR_APPEND)</span>
            <span class="plain">return FileIO_Error(extf,</span>
                <span class="plain">"tried to write to a file which is not open for writing");</span>
        <span class="plain">return glk_put_char_stream(struc--&gt;AUXF_STREAM, char);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Print Line. </b>We read characters from the supplied file until the next newline
character. (We allow for that to be encoded as either a single <code class="display"><span class="extract">0a</span></code> or a
single <code class="display"><span class="extract">0d</span></code>.) Each character is printed, and at the end we print a newline.
</p>


<pre class="display">
    <span class="plain">[ FileIO_PrintLine extf ch  struc;</span>
        <span class="plain">if ((extf &lt; 1) || (extf &gt; NO_EXTERNAL_FILES))</span>
            <span class="plain">return FileIO_Error(extf, "tried to write to a non-file");</span>
        <span class="plain">struc = TableOfExternalFiles--&gt;extf;</span>
        <span class="plain">for (::) {</span>
            <span class="plain">ch = FileIO_GetC(extf);</span>
            <span class="plain">if (ch == -1) rfalse;</span>
            <span class="plain">if (ch == 10 or 13) { print "^"; rtrue; }</span>
            <span class="plain">print (char) ch;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. Print Contents. </b>Repeating this until the file runs out is equivalent to the Unix command
<code class="display"><span class="extract">cat</span></code>, that is, it copies the stream of characters from the file to the
output stream. (This might well be another file, just as with <code class="display"><span class="extract">cat</span></code>, in
which case we have a copy utility.)
</p>


<pre class="display">
    <span class="plain">[ FileIO_PrintContents extf tab  struc;</span>
        <span class="plain">if ((extf &lt; 1) || (extf &gt; NO_EXTERNAL_FILES))</span>
            <span class="plain">return FileIO_Error(extf, "tried to access a non-file");</span>
        <span class="plain">struc = TableOfExternalFiles--&gt;extf;</span>
        <span class="plain">if (struc--&gt;AUXF_BINARY)</span>
            <span class="plain">return FileIO_Error(extf, "printing text will not work with binary files");</span>
        <span class="plain">if (FileIO_Open(extf, false) == 0) rfalse;</span>
        <span class="plain">while (FileIO_PrintLine(extf)) ;</span>
        <span class="plain">FileIO_Close(extf);</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Print Text. </b>The following writes a given piece of text as the new content of the file,
either as the whole file (if <code class="display"><span class="extract">append_flag</span></code> is false) or adding only to the
end (if true).
</p>


<pre class="display">
    <span class="plain">[ FileIO_PutContents extf text append_flag  struc str ch oldstream;</span>
        <span class="plain">if ((extf &lt; 1) || (extf &gt; NO_EXTERNAL_FILES))</span>
            <span class="plain">return FileIO_Error(extf, "tried to access a non-file");</span>
        <span class="plain">struc = TableOfExternalFiles--&gt;extf;</span>
        <span class="plain">if (struc--&gt;AUXF_BINARY)</span>
            <span class="plain">return FileIO_Error(extf, "writing text will not work with binary files");</span>
        <span class="plain">oldstream = glk_stream_get_current();</span>
        <span class="plain">str = FileIO_Open(extf, true, append_flag);</span>
        <span class="plain">if (str == 0) rfalse;</span>
        <span class="plain">@push say__p; @push say__pc;</span>
        <span class="plain">ClearParagraphing(19);</span>
        <span class="plain">TEXT_TY_Say(text);</span>
        <span class="plain">FileIO_Close(extf);</span>
        <span class="plain">if (oldstream) glk_stream_set_current(oldstream);</span>
        <span class="plain">@pull say__pc; @pull say__p;</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15. Serialising Tables. </b>The most important data structures to "serialise" &mdash; that is, to convert
from their binary representations in memory into text representations in an
external file &mdash; are Tables. Here we only carry out the file-handling; the
actual translations are in "Tables.i6t".
</p>


<pre class="display">
    <span class="plain">[ FileIO_PutTable extf tab rv  struc oldstream;</span>
        <span class="plain">if ((extf &lt; 1) || (extf &gt; NO_EXTERNAL_FILES))</span>
            <span class="plain">return FileIO_Error(extf, "tried to write table to a non-file");</span>
        <span class="plain">struc = TableOfExternalFiles--&gt;extf;</span>
        <span class="plain">if (struc--&gt;AUXF_BINARY)</span>
            <span class="plain">return FileIO_Error(extf, "writing a table will not work with binary files");</span>
        <span class="plain">oldstream = glk_stream_get_current();</span>
        <span class="plain">if (FileIO_Open(extf, true) == 0) rfalse;</span>
        <span class="plain">rv = TablePrint(tab);</span>
        <span class="plain">FileIO_Close(extf);</span>
        <span class="plain">if (oldstream) glk_stream_set_current(oldstream);</span>
        <span class="plain">if (rv) return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>

    <span class="plain">[ FileIO_GetTable extf tab  struc;</span>
        <span class="plain">if ((extf &lt; 1) || (extf &gt; NO_EXTERNAL_FILES))</span>
            <span class="plain">return FileIO_Error(extf, "tried to read table from a non-file");</span>
        <span class="plain">struc = TableOfExternalFiles--&gt;extf;</span>
        <span class="plain">if (struc--&gt;AUXF_BINARY)</span>
            <span class="plain">return FileIO_Error(extf, "reading a table will not work with binary files");</span>
        <span class="plain">if (FileIO_Open(extf, false) == 0) rfalse;</span>
        <span class="plain">TableRead(tab, extf);</span>
        <span class="plain">FileIO_Close(extf);</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16. Z-Machine Stubs. </b>These routines do the minimum possible, but equally, they only generate a
run-time problem when there is no alternative.
</p>


<pre class="display">
    <span class="plain">#IFNOT; ! TARGET_GLULX</span>
    <span class="plain">[ FileIO_Exists extf; rfalse; ];</span>
    <span class="plain">[ FileIO_Ready extf; rfalse; ];</span>
    <span class="plain">[ FileIO_GetC extf; return -1; ];</span>
    <span class="plain">[ FileIO_PutTable extf tab;</span>
        <span class="plain">return FileIO_Error(extf, "external files can only be used under Glulx");</span>
    <span class="plain">];</span>
    <span class="plain">[ FileIO_MarkReady extf status; FileIO_PutTable(extf); ];</span>
    <span class="plain">[ FileIO_GetTable extf tab; FileIO_PutTable(extf); ];</span>
    <span class="plain">[ FileIO_PrintContents extf; FileIO_PutTable(extf); ];</span>
    <span class="plain">[ FileIO_PutContents extf; FileIO_PutTable(extf); ];</span>
    <span class="plain">#ENDIF; ! TARGET_GLULX</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17. Back To Core. </b></p>


<pre class="display">
    <span class="plain">#IFNOT; ! PLUGIN_FILES</span>
    <span class="plain">[ FileIO_GetC extf; return -1; ];</span>
    <span class="plain">#ENDIF; ! PLUGIN_FILES</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="S-dt.html">Back to 'Definitions Template'</a></li><li><a href="S-ft2.html">Continue with 'Flex Template'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

