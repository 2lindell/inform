<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>S/rt</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of 'S/rkt' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">basic_inform Template Library</a></li><li><b>Relation Kind Template</b></li></ul><p class="purpose">Code to support the relation kind.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Block Format</a></li><li><a href="#SP2">&#167;2. KOV Support</a></li><li><a href="#SP3">&#167;3. Other Definitions</a></li><li><a href="#SP4">&#167;4. Tunable Parameters</a></li><li><a href="#SP5">&#167;5. Abstract Relations</a></li><li><a href="#SP6">&#167;6. Empty Relations</a></li><li><a href="#SP7">&#167;7. Creation</a></li><li><a href="#SP8">&#167;8. Destruction</a></li><li><a href="#SP9">&#167;9. Copying</a></li><li><a href="#SP10">&#167;10. Comparison</a></li><li><a href="#SP11">&#167;11. Printing</a></li><li><a href="#SP12">&#167;12. Naming</a></li><li><a href="#SP13">&#167;13. Choose Relation Handler</a></li><li><a href="#SP14">&#167;14. Valency</a></li><li><a href="#SP15">&#167;15. Double Hash Set Relation Handler</a></li><li><a href="#SP16">&#167;16. Hash List Relation Handler</a></li><li><a href="#SP17">&#167;17. Hash Table Relation Handler</a></li><li><a href="#SP18">&#167;18. Reversed Hash Table Relation Handler</a></li><li><a href="#SP19">&#167;19. Symmetric Relation Handlers</a></li><li><a href="#SP20">&#167;20. Hash Core Relation Handler</a></li><li><a href="#SP21">&#167;21. Equivalence Hash Table Relation Handler</a></li><li><a href="#SP22">&#167;22. Two-In-One Hash Table Relation Handler</a></li><li><a href="#SP23">&#167;23. Empty</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Block Format. </b>Inform uses a rich variety of relations, with many different data representations,
but we aim to hide that complexity from the user. At run-time, a relation is
represented by a block value. The short block of this BV is simply a pointer
to a long block. This always begins with at least six words of metadata, but
actual data sometimes follows on, and sometimes doesn't: and its format is
something the customer needn't know about.
</p>

<p class="inwebparagraph">The low-level routines in "Relations.i6t" access this metadata by direct use
of <code class="display"><span class="extract">--&gt;</span></code>, for speed, and they use the offset constants <code class="display"><span class="extract">RR_NAME</span></code> and so on;
but we will use the <code class="display"><span class="extract">BlkValueRead</span></code> and <code class="display"><span class="extract">BlkValueWrite</span></code> routines in this
section, which need offsets in the form <code class="display"><span class="extract">RRV_NAME</span></code>. (The discrepancy of 5 is
to allow for the five-word block header.)
</p>


<pre class="display">
    <span class="plain">Constant RRV_NAME     		RR_NAME-5;        ! Packed string, e.g. "containment relation"</span>
    <span class="plain">Constant RRV_PERMISSIONS	RR_PERMISSIONS-5; ! A bitmap of what operations this supports</span>
    <span class="plain">Constant RRV_STORAGE		RR_STORAGE-5;     ! Data location, depending on format</span>
    <span class="plain">Constant RRV_KIND			RR_KIND-5;        ! Strong kind ID of the relation</span>
    <span class="plain">Constant RRV_HANDLER		RR_HANDLER-5;     ! Routine to perform operations on this</span>
    <span class="plain">Constant RRV_DESCRIPTION	RR_DESCRIPTION-5; ! Packed string, e.g. "contains"</span>
    <span class="plain">Constant RRV_USED			6;</span>
    <span class="plain">Constant RRV_FILLED			7;</span>
    <span class="plain">Constant RRV_DATA_BASE		8;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. KOV Support. </b>See the "BlockValues.i6t" segment for the specification of the following
routines.
</p>


<pre class="display">
    <span class="plain">[ RELATION_TY_Support task arg1 arg2 arg3;</span>
        <span class="plain">switch(task) {</span>
            <span class="plain">CREATE_KOVS:      return RELATION_TY_Create(arg1, 0, arg2);</span>
            <span class="plain">DESTROY_KOVS:     RELATION_TY_Destroy(arg1);</span>
            <span class="plain">MAKEMUTABLE_KOVS: return 1;</span>
            <span class="plain">COPYQUICK_KOVS:   rtrue;</span>
            <span class="plain">COPYSB_KOVS:	  BlkValueCopySB1(arg1, arg2);</span>
            <span class="plain">KINDDATA_KOVS:    return 0;</span>
            <span class="plain">EXTENT_KOVS:      return -1;</span>
            <span class="plain">COPY_KOVS:        RELATION_TY_Copy(arg1, arg2);</span>
            <span class="plain">COMPARE_KOVS:     return RELATION_TY_Compare(arg1, arg2);</span>
            <span class="plain">HASH_KOVS:        return arg1;</span>
            <span class="plain">DEBUG_KOVS:       print " = ", (RELATION_TY_Say) arg1;</span>
        <span class="plain">}</span>
        <span class="plain">! We choose not to respond to: CAST_KOVS, COPYKIND_KOVS, READ_FILE_KOVS, WRITE_FILE_KOVS</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Other Definitions. </b></p>


<pre class="display">
    <span class="plain">! valencies</span>
    <span class="plain">Constant RRVAL_V_TO_V		0;</span>
    <span class="plain">Constant RRVAL_V_TO_O		RELS_Y_UNIQUE;</span>
    <span class="plain">Constant RRVAL_O_TO_V		RELS_X_UNIQUE;</span>
    <span class="plain">Constant RRVAL_O_TO_O		RELS_X_UNIQUE+RELS_Y_UNIQUE;</span>
    <span class="plain">Constant RRVAL_EQUIV		RELS_EQUIVALENCE+RELS_SYMMETRIC;</span>
    <span class="plain">Constant RRVAL_SYM_V_TO_V	RELS_SYMMETRIC;</span>
    <span class="plain">Constant RRVAL_SYM_O_TO_O	RELS_SYMMETRIC+RELS_X_UNIQUE+RELS_Y_UNIQUE;</span>

    <span class="plain">! dictionary entry flags</span>
    <span class="plain">Constant RRF_USED		$0001;	! entry contains a value</span>
    <span class="plain">Constant RRF_DELETED	$0002;	! entry used to contain a value</span>
    <span class="plain">Constant RRF_SINGLE		$0004;	! entry's Y is a value, not a list</span>
    <span class="plain">Constant RRF_HASX		$0010;	! 2-in-1 entry contains a corresponding key</span>
    <span class="plain">Constant RRF_HASY		$0020;	! 2-in-1 entry contains a corresponding value</span>
    <span class="plain">Constant RRF_ENTKEYX	$0040;	! 2-in-1 entry key is left side KOV</span>
    <span class="plain">Constant RRF_ENTKEYY	$0080;	! 2-in-1 entry key is right side KOV</span>

    <span class="plain">! permission/task constants (those commented out here are generated by I7)</span>
    <span class="plain">!Constant RELS_SYMMETRIC $8000;</span>
    <span class="plain">!Constant RELS_EQUIVALENCE $4000;</span>
    <span class="plain">!Constant RELS_X_UNIQUE $2000;</span>
    <span class="plain">!Constant RELS_Y_UNIQUE $1000;</span>
    <span class="plain">!Constant RELS_TEST $0800;</span>
    <span class="plain">!Constant RELS_ASSERT_TRUE $0400;</span>
    <span class="plain">!Constant RELS_ASSERT_FALSE $0200;</span>
    <span class="plain">!Constant RELS_SHOW $0100;</span>
    <span class="plain">!Constant RELS_ROUTE_FIND $0080;</span>
    <span class="plain">!Constant RELS_ROUTE_FIND_COUNT $0040;</span>
    <span class="plain">Constant RELS_COPY $0020;</span>
    <span class="plain">Constant RELS_DESTROY $0010;</span>
    <span class="plain">!Constant RELS_LOOKUP_ANY $0008;</span>
    <span class="plain">!Constant RELS_LOOKUP_ALL_X $0004;</span>
    <span class="plain">!Constant RELS_LOOKUP_ALL_Y $0002;</span>
    <span class="plain">!Constant RELS_LIST $0001;</span>

    <span class="plain">Constant RELS_EMPTY $0003;</span>
    <span class="plain">Constant RELS_SET_VALENCY $0005;</span>

    <span class="plain">! RELS_LOOKUP_ANY mode selection constants</span>
    <span class="plain">Constant RLANY_GET_X 1;</span>
    <span class="plain">Constant RLANY_GET_Y 2;</span>
    <span class="plain">Constant RLANY_CAN_GET_X 3;</span>
    <span class="plain">Constant RLANY_CAN_GET_Y 4;</span>

    <span class="plain">! RELS_LIST mode selection constant</span>
    <span class="plain">Constant RLIST_ALL_X 1;</span>
    <span class="plain">Constant RLIST_ALL_Y 2;</span>
    <span class="plain">Constant RLIST_ALL_PAIRS 3;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Tunable Parameters. </b>These constants affect the performance characteristics of the dictionary
structures used for relations on the heap. Changing their values may alter the
balance between memory consumption and running time.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">RRP_MIN_SIZE</span></code>, <code class="display"><span class="extract">RRP_RESIZE_SMALL</span></code>, and <code class="display"><span class="extract">RRP_RESIZE_LARGE</span></code> must all be
powers of two.
</p>


<pre class="display">
    <span class="plain">Constant RRP_MIN_SIZE      8;   ! minimum number of entries (DO NOT CHANGE)</span>
    <span class="plain">Constant RRP_PERTURB_SHIFT 5;   ! affects the probe sequence</span>
    <span class="plain">Constant MINUS_RRP_PERTURB_SHIFT -5;   ! affects the probe sequence</span>
    <span class="plain">Constant RRP_RESIZE_SMALL  4;   ! resize factor for small tables</span>
    <span class="plain">Constant RRP_RESIZE_LARGE  2;   ! resize factor for large tables</span>
    <span class="plain">Constant RRP_LARGE_IS      256; ! how many entries make a table "large"?</span>
    <span class="plain">Constant RRP_CROWDED_IS    2;   ! when filled entries outnumber unfilled by _ to 1</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Abstract Relations. </b>As the following shows, we can abstractly use a relation &mdash; that is, we can
use a relation whose identity we know little about &mdash; by calling its handler
routine <code class="display"><span class="extract">R</span></code> in the form <code class="display"><span class="extract">R(rel, task, X, Y)</span></code>.
</p>

<p class="inwebparagraph">The task should be one of: <code class="display"><span class="extract">RELS_TEST</span></code>, <code class="display"><span class="extract">RELS_ASSERT_TRUE</span></code>, <code class="display"><span class="extract">RELS_ASSERT_FALSE</span></code>,
<code class="display"><span class="extract">RELS_SHOW</span></code>, <code class="display"><span class="extract">RELS_ROUTE_FIND</span></code>, <code class="display"><span class="extract">RELS_ROUTE_FIND_COUNT</span></code>, <code class="display"><span class="extract">RELS_COPY</span></code>,
<code class="display"><span class="extract">RELS_DESTROY</span></code>, <code class="display"><span class="extract">RELS_LOOKUP_ANY</span></code>, <code class="display"><span class="extract">RELS_LOOKUP_ALL_X</span></code>, <code class="display"><span class="extract">RELS_LOOKUP_ALL_Y</span></code>,
<code class="display"><span class="extract">RELS_LIST</span></code>, or <code class="display"><span class="extract">RELS_EMPTY</span></code>.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">RELS_SHOW</span></code> produces output for the SHOWME testing command.
<code class="display"><span class="extract">RELS_ROUTE_FIND</span></code> finds the next step in a route from <code class="display"><span class="extract">X</span></code> to <code class="display"><span class="extract">Y</span></code>, and
<code class="display"><span class="extract">RELS_ROUTE_FIND_COUNT</span></code> counts the shortest number of steps or returns -1
if no route exists. <code class="display"><span class="extract">RELS_COPY</span></code> makes a deep copy of the relation by
replacing all block values with duplicates, and <code class="display"><span class="extract">RELS_DESTROY</span></code> frees all
block values. <code class="display"><span class="extract">RELS_LOOKUP_ANY</span></code> finds any one of the <code class="display"><span class="extract">X</span></code> values related to
a given <code class="display"><span class="extract">Y</span></code>, or vice versa, or checks whether such an <code class="display"><span class="extract">X</span></code> or <code class="display"><span class="extract">Y</span></code> value
exists. <code class="display"><span class="extract">RELS_LOOKUP_ALL_X</span></code> and <code class="display"><span class="extract">RELS_LOOKUP_ALL_Y</span></code> produce a list of all
the <code class="display"><span class="extract">X</span></code> values related to a given <code class="display"><span class="extract">Y</span></code>, or vice versa. <code class="display"><span class="extract">RELS_LIST</span></code> produces
a list of all <code class="display"><span class="extract">X</span></code> values for which a corresponding <code class="display"><span class="extract">Y</span></code> exists, or vice
versa, or a list of all <code class="display"><span class="extract">(X,Y)</span></code> pairs for which <code class="display"><span class="extract">X</span></code> is related to <code class="display"><span class="extract">Y</span></code>.
<code class="display"><span class="extract">RELS_EMPTY</span></code> either makes the relation empty (if <code class="display"><span class="extract">X</span></code> is 1) or non-empty (if
<code class="display"><span class="extract">X</span></code> is 0) or makes no change (if <code class="display"><span class="extract">X</span></code> is negative), and in any case returns
true or false indicating whether the relation is now empty.
</p>

<p class="inwebparagraph">Because not every relation supports all of these operations, the
"permissions" word in the block is always a bitmap which is a sum of those
operations it does offer.
</p>

<p class="inwebparagraph">At present, these permissions are not checked as rigorously as they should be
(they're correctly set, but not much monitored).
</p>


<pre class="display">
    <span class="plain">[ RelationTest relation task X Y  handler rv;</span>
        <span class="plain">handler = RlnGetF(relation, RR_HANDLER);</span>
        <span class="plain">return handler(relation, task, X, Y);</span>
    <span class="plain">];</span>

    <span class="plain">[ RlnGetF rel fld i;</span>
        <span class="plain">rel = BlkValueGetLongBlock(rel);</span>
        <span class="plain">return rel--&gt;fld;</span>
    <span class="plain">];</span>

    <span class="plain">[ RlnSetF rel fld v;</span>
        <span class="plain">rel = BlkValueGetLongBlock(rel);</span>
        <span class="plain">rel--&gt;fld = v;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Empty Relations. </b>The absolute minimum relation is one which can only be tested, and which is
always empty, that is, where no two values are ever related to each other.
The necessary handler routine is <code class="display"><span class="extract">EmptyRelationHandler</span></code>.
</p>


<pre class="display">
    <span class="plain">[ EmptyRelationHandler relation task X Y;</span>
        <span class="plain">if (task == RELS_EMPTY) rtrue;</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Creation. </b>Something we have to be careful about is what we mean by copying, or indeed
creating, a relation. For example, if we write
</p>

<blockquote>
    <p>let Q be a relation of objects to objects;</p>

</blockquote>

<blockquote>
    <p>let Q be the containment relation;</p>

</blockquote>

<p class="inwebparagraph">...we aren't literally asking for Q to be a duplicate copy of containment,
which can then independently evolve &mdash; we mean in some sense that Q is a
pointer to the one and only containment relation. On the other hand, if we
write
</p>

<blockquote>
    <p>let Q be a relation of numbers to numbers;</p>

</blockquote>

<blockquote>
    <p>make Q relate 3 to 7;</p>

</blockquote>

<p class="inwebparagraph">then the second line clearly expects Q to be its own relation, newly created.
</p>

<p class="inwebparagraph">We cope with this at creation time. If we're invited to create a copy of an
existing relation, we look to see if it is empty &mdash; which we detect by its
use of the <code class="display"><span class="extract">EmptyRelationHandler</span></code> handler. The empty relations are exactly
those used as default values for the relation kinds; thus that's what will
happen when Q is created. If we find this handler, we intercept and replace
it with one of the heap relation handlers, which thus makes the relation a
newly constructed data structure which can grow freely from here.
</p>


<pre class="display">
    <span class="plain">[ RELATION_TY_Create kov from sb rel i skov handler;</span>
        <span class="plain">rel = FlexAllocate((RRV_DATA_BASE + 3*RRP_MIN_SIZE)*WORDSIZE,</span>
            <span class="plain">RELATION_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);</span>
        <span class="plain">if ((from == 0) &amp;&amp; (kov ~= 0)) from = DefaultValueFinder(kov);</span>
        <span class="plain">if (from) {</span>
            <span class="plain">for (i=0: i&lt;RRV_DATA_BASE: i++) BlkValueWrite(rel, i, BlkValueRead(from, i), true);</span>
            <span class="plain">if (BlkValueRead(from, RRV_HANDLER) == EmptyRelationHandler) {</span>
                <span class="plain">handler = ChooseRelationHandler(BlkValueRead(rel, RRV_KIND, true));</span>
                <span class="plain">BlkValueWrite(rel, RRV_NAME, "anonymous relation", true);</span>
                <span class="plain">BlkValueWrite(rel, RRV_PERMISSIONS,</span>
                    <span class="plain">RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW, true);</span>
                <span class="plain">BlkValueWrite(rel, RRV_HANDLER, handler, true);</span>
                <span class="plain">BlkValueWrite(rel, RRV_STORAGE, RRP_MIN_SIZE-1, true);</span>
                <span class="plain">BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation", true);</span>
                <span class="plain">BlkValueWrite(rel, RRV_USED, 0, true);</span>
                <span class="plain">BlkValueWrite(rel, RRV_FILLED, 0, true);</span>
            <span class="plain">}</span>
        <span class="plain">} else {</span>
            <span class="plain">handler = ChooseRelationHandler(kov);</span>
            <span class="plain">BlkValueWrite(rel, RRV_NAME, "anonymous relation", true);</span>
            <span class="plain">BlkValueWrite(rel, RRV_PERMISSIONS,</span>
                <span class="plain">RELS_TEST+RELS_ASSERT_TRUE+RELS_ASSERT_FALSE+RELS_SHOW, true);</span>
            <span class="plain">BlkValueWrite(rel, RRV_STORAGE, RRP_MIN_SIZE-1, true);</span>
            <span class="plain">BlkValueWrite(rel, RRV_KIND, kov, true);</span>
            <span class="plain">BlkValueWrite(rel, RRV_HANDLER, handler, true);</span>
            <span class="plain">BlkValueWrite(rel, RRV_DESCRIPTION, "an anonymous relation", true);</span>
            <span class="plain">BlkValueWrite(rel, RRV_USED, 0, true);</span>
            <span class="plain">BlkValueWrite(rel, RRV_FILLED, 0, true);</span>
        <span class="plain">}</span>

        <span class="plain">return BlkValueCreateSB1(sb, rel);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Destruction. </b>If the relation stores block values on either side, invoke the handler using a special task
value to free the memory associated with them.
</p>


<pre class="display">
    <span class="plain">[ RELATION_TY_Destroy rel  handler;</span>
        <span class="plain">handler = BlkValueRead(rel, RRV_HANDLER);</span>
        <span class="plain">handler(rel, RELS_DESTROY);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Copying. </b>Same as destruction: invoke the handler using a special value to tell it to perform
deep copying.
</p>


<pre class="display">
    <span class="plain">[ RELATION_TY_Copy lto lfrom  handler;</span>
        <span class="plain">handler = BlkValueRead(lto, RRV_HANDLER);</span>
        <span class="plain">handler(lto, RELS_COPY);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Comparison. </b>It really isn't clear how to define equality for relations, but we follow
the doctrine above. What we don't do is to test its actual state &mdash; that
would be very slow and might be impossible.
</p>


<pre class="display">
    <span class="plain">[ RELATION_TY_Compare rleft rright ind1 ind2;</span>
        <span class="plain">ind1 = BlkValueRead(rleft, RRV_HANDLER);</span>
        <span class="plain">ind2 = BlkValueRead(rright, RRV_HANDLER);</span>
        <span class="plain">if (ind1 ~= ind2) return ind1 - ind2;</span>
        <span class="plain">if (IsMutableRelationHandler(ind1) == false) return 0;</span>
        <span class="plain">return rleft - rright;</span>
    <span class="plain">];</span>

    <span class="plain">[ RELATION_TY_Distinguish rleft rright;</span>
        <span class="plain">if (RELATION_TY_Compare(rleft, rright) == 0) rfalse;</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Printing. </b></p>


<pre class="display">
    <span class="plain">[ RELATION_TY_Say rel;</span>
        <span class="plain">if (rel == 0) print "(null relation)"; ! shouldn't happen</span>
        <span class="plain">else print (string) RlnGetF(rel, RR_NAME);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Naming. </b></p>


<pre class="display">
    <span class="plain">[ RELATION_TY_Name rel txt;</span>
        <span class="plain">if (rel) {</span>
            <span class="plain">BlkValueWrite(rel, RRV_NAME, txt);</span>
            <span class="plain">BlkValueWrite(rel, RRV_DESCRIPTION, txt);</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. Choose Relation Handler. </b>We implement two different various-to-various handler routines for the
sake of efficiency. The choice of handler routines is made based on
the kinds of value being related. Each handler also has a corresponding
wrapper for symmetric relations.
</p>


<pre class="display">
    <span class="plain">[ ChooseRelationHandler kov sym;</span>
        <span class="plain">if (KOVIsBlockValue(KindBaseTerm(kov, 0))) {</span>
            <span class="plain">if (sym) return SymHashListRelationHandler;</span>
            <span class="plain">return HashListRelationHandler;</span>
        <span class="plain">}</span>
        <span class="plain">if (sym) return SymDoubleHashSetRelationHandler;</span>
        <span class="plain">return DoubleHashSetRelationHandler;</span>
    <span class="plain">];</span>

    <span class="plain">[ IsMutableRelationHandler h;</span>
        <span class="plain">if (h == SymHashListRelationHandler or HashListRelationHandler or</span>
            <span class="plain">SymDoubleHashSetRelationHandler or DoubleHashSetRelationHandler) rtrue;</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Valency. </b>"Valency" refers to the number of participants allowed on either side
of the relation: various-to-various, one-to-various, various-to-one, or
one-to-one. A newly created relation is always various-to-various. We
allow the author to change the valency, but only if no entries have
been added yet.
</p>


<pre class="display">
    <span class="plain">[ RELATION_TY_SetValency rel val  kov filled cur handler ext;</span>
        <span class="plain">filled = BlkValueRead(rel, RRV_FILLED);</span>
        <span class="plain">if (filled) { RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE); rfalse; }</span>
        <span class="plain">kov = BlkValueRead(rel, RRV_KIND);</span>
        <span class="plain">if (val == RRVAL_EQUIV or RRVAL_SYM_V_TO_V or RRVAL_SYM_O_TO_O) {</span>
            <span class="plain">if (KindBaseTerm(kov, 0) ~= KindBaseTerm(kov, 1)) {</span>
                <span class="plain">RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE); rfalse;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">cur = BlkValueRead(rel, RRV_HANDLER);</span>
        <span class="plain">switch (val) {</span>
            <span class="plain">RRVAL_V_TO_V:		handler = ChooseRelationHandler(kov, false);</span>
            <span class="plain">RRVAL_V_TO_O:		handler = HashTableRelationHandler;</span>
            <span class="plain">RRVAL_O_TO_V:		handler = ReversedHashTableRelationHandler;</span>
            <span class="plain">RRVAL_O_TO_O:		handler = TwoInOneHashTableRelationHandler;</span>
            <span class="plain">RRVAL_EQUIV:		handler = EquivHashTableRelationHandler;</span>
            <span class="plain">RRVAL_SYM_V_TO_V:	handler = ChooseRelationHandler(kov, true);</span>
            <span class="plain">RRVAL_SYM_O_TO_O:	handler = Sym2in1HashTableRelationHandler;</span>
            <span class="plain">default:			RunTimeProblem(RTP_RELATIONCHANGEIMPOSSIBLE); rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">if (cur == handler) rtrue;</span>
        <span class="plain">! adjust size when going to or from 2-in-1</span>
        <span class="plain">if (cur == TwoInOneHashTableRelationHandler) {</span>
            <span class="plain">ext = BlkValueRead(rel, RRV_STORAGE) + 1;</span>
            <span class="plain">BlkValueSetLBCapacity(rel, RRV_DATA_BASE + 3*ext);</span>
        <span class="plain">} else if (handler == TwoInOneHashTableRelationHandler) {</span>
            <span class="plain">ext = BlkValueRead(rel, RRV_STORAGE) + 1;</span>
            <span class="plain">BlkValueSetLBCapacity(rel, RRV_DATA_BASE + 4*ext);</span>
        <span class="plain">}</span>
        <span class="plain">BlkValueWrite(rel, RRV_HANDLER, handler);</span>
    <span class="plain">];</span>

    <span class="plain">[ RELATION_TY_GetValency rel  handler;</span>
        <span class="plain">return BlkValueRead(rel, RRV_PERMISSIONS) &amp; VALENCY_MASK;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15. Double Hash Set Relation Handler. </b>This implements relations which are stored as a double-hashed set.
The storage comprises a list of three-word entries (F, X, Y), where
F is a flags word. The ordering of the list is determined by a probe
sequence which depends on the combined hash values of X and Y.
</p>

<p class="inwebparagraph">The "storage" word in the header stores one less than the number of
entries in the list; the number of entries in the list is always a
power of two, so this will always be a bit mask. The "used" and
"filled" words store the number of entries which currently hold a
value, and the number of entries which have ever held a value (even
if it was since deleted), respectively.
</p>

<p class="inwebparagraph">The utility routine <code class="display"><span class="extract">DoubleHashSetLookUp</span></code> locates the hash entry for
a key/value pair. It returns either the (non-negative) number of the
entry where the pair was found, or the (negative) bitwise NOT of the
number of the first unused entry where the pair could be inserted. It
uses the utility routine <code class="display"><span class="extract">DoubleHashSetEntryMatches</span></code> to compare
entries to the sought pair.
</p>

<p class="inwebparagraph">The utility routine <code class="display"><span class="extract">DoubleHashSetCheckResize</span></code> checks whether the
dictionary has become too full after inserting a pair, and expands it
if so.
</p>


<pre class="display">
    <span class="plain">[ DoubleHashSetRelationHandler rel task X Y sym  kov kx ky at tmp v;</span>
        <span class="plain">kov = BlkValueRead(rel, RRV_KIND);</span>
        <span class="plain">kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);</span>
        <span class="plain">if (task == RELS_SET_VALENCY) {</span>
            <span class="plain">return RELATION_TY_SetValency(rel, X);</span>
        <span class="plain">} else if (task == RELS_DESTROY) {</span>
            <span class="plain">! clear</span>
            <span class="plain">kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);</span>
            <span class="plain">if (~~(kx || ky)) return;</span>
            <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);</span>
                <span class="plain">if (tmp &amp; RRF_USED) {</span>
                    <span class="plain">if (kx) BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));</span>
                    <span class="plain">if (ky) BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));</span>
                <span class="plain">}</span>
                <span class="plain">at--;</span>
            <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">} else if (task == RELS_COPY) {</span>
            <span class="plain">X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);</span>
            <span class="plain">if (~~(X || Y)) return;</span>
            <span class="plain">at = BlkValueRead(rel, RRV_STORAGE);</span>
            <span class="plain">while (at &gt;= 0) {</span>
                <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);</span>
                <span class="plain">if (tmp &amp; RRF_USED) {</span>
                    <span class="plain">if (X) {</span>
                        <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);</span>
                        <span class="plain">tmp = BlkValueCopy(BlkValueCreate(kx), tmp);</span>
                        <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, tmp);</span>
                    <span class="plain">}</span>
                    <span class="plain">if (Y) {</span>
                        <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);</span>
                        <span class="plain">tmp = BlkValueCopy(BlkValueCreate(ky), tmp);</span>
                        <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
                <span class="plain">at--;</span>
            <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">} else if (task == RELS_SHOW) {</span>
            <span class="plain">print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";</span>
            <span class="plain">if (sym) {</span>
                <span class="plain">kov = KOVComparisonFunction(kx);</span>
                <span class="plain">if (~~kov) kov = UnsignedCompare;</span>
            <span class="plain">}</span>
            <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at);</span>
                <span class="plain">if (tmp &amp; RRF_USED) {</span>
                    <span class="plain">X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);</span>
                    <span class="plain">Y = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);</span>
                    <span class="plain">if (sym &amp;&amp; (kov(X, Y) &gt; 0)) continue;</span>
                    <span class="plain">print "  ";</span>
                    <span class="plain">PrintKindValuePair(kx, X);</span>
                    <span class="plain">if (sym) print " &lt;=&gt; "; else print " &gt;=&gt; ";</span>
                    <span class="plain">PrintKindValuePair(ky, Y);</span>
                    <span class="plain">print "^";</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">} else if (task == RELS_EMPTY) {</span>
            <span class="plain">if (BlkValueRead(rel, RRV_USED) == 0) rtrue;</span>
            <span class="plain">if (X == 1) {</span>
                <span class="plain">DoubleHashSetRelationHandler(rel, RELS_DESTROY);</span>
                <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                    <span class="plain">tmp = RRV_DATA_BASE + 3*at;</span>
                    <span class="plain">BlkValueWrite(rel, tmp, 0);</span>
                    <span class="plain">BlkValueWrite(rel, tmp + 1, 0);</span>
                    <span class="plain">BlkValueWrite(rel, tmp + 2, 0);</span>
                <span class="plain">}</span>
                <span class="plain">BlkValueWrite(rel, RRV_USED, 0);</span>
                <span class="plain">BlkValueWrite(rel, RRV_FILLED, 0);</span>
                <span class="plain">rtrue;</span>
            <span class="plain">}</span>
            <span class="plain">rfalse;</span>
        <span class="plain">} else if (task == RELS_LOOKUP_ANY) {</span>
            <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                <span class="plain">tmp = RRV_DATA_BASE + 3*at;</span>
                <span class="plain">if (BlkValueRead(rel, tmp) &amp; RRF_USED) {</span>
                    <span class="plain">if (Y == RLANY_GET_X or RLANY_CAN_GET_X) {</span>
                        <span class="plain">v = BlkValueRead(rel, tmp + 2);</span>
                        <span class="plain">if (KOVIsBlockValue(ky)) {</span>
                            <span class="plain">if (BlkValueCompare(v, X) ~= 0) continue;</span>
                        <span class="plain">} else {</span>
                            <span class="plain">if (v ~= X) continue;</span>
                        <span class="plain">}</span>
                        <span class="plain">if (Y == RLANY_CAN_GET_X) rtrue;</span>
                        <span class="plain">return BlkValueRead(rel, tmp + 1);</span>
                    <span class="plain">} else {</span>
                        <span class="plain">v = BlkValueRead(rel, tmp + 1);</span>
                        <span class="plain">if (KOVIsBlockValue(kx)) {</span>
                            <span class="plain">if (BlkValueCompare(v, X) ~= 0) continue;</span>
                        <span class="plain">} else {</span>
                            <span class="plain">if (v ~= X) continue;</span>
                        <span class="plain">}</span>
                        <span class="plain">if (Y == RLANY_CAN_GET_Y) rtrue;</span>
                        <span class="plain">return BlkValueRead(rel, tmp + 2);</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">if (Y == RLANY_GET_X or RLANY_GET_Y)</span>
                <span class="plain">print "*** Lookup failed: value not found ***^";</span>
            <span class="plain">rfalse;</span>
        <span class="plain">} else if (task == RELS_LOOKUP_ALL_X) {</span>
            <span class="plain">if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;</span>
            <span class="plain">LIST_OF_TY_SetLength(Y, 0);</span>
            <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                <span class="plain">tmp = RRV_DATA_BASE + 3*at;</span>
                <span class="plain">if (BlkValueRead(rel, tmp) &amp; RRF_USED) {</span>
                    <span class="plain">v = BlkValueRead(rel, tmp + 2);</span>
                    <span class="plain">if (KOVIsBlockValue(ky)) {</span>
                        <span class="plain">if (BlkValueCompare(v, X) ~= 0) continue;</span>
                    <span class="plain">} else {</span>
                        <span class="plain">if (v ~= X) continue;</span>
                    <span class="plain">}</span>
                    <span class="plain">LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">return Y;</span>
        <span class="plain">} else if (task == RELS_LOOKUP_ALL_Y) {</span>
            <span class="plain">if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;</span>
            <span class="plain">LIST_OF_TY_SetLength(Y, 0);</span>
            <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                <span class="plain">tmp = RRV_DATA_BASE + 3*at;</span>
                <span class="plain">if (BlkValueRead(rel, tmp) &amp; RRF_USED) {</span>
                    <span class="plain">v = BlkValueRead(rel, tmp + 1);</span>
                    <span class="plain">if (KOVIsBlockValue(kx)) {</span>
                        <span class="plain">if (BlkValueCompare(v, X) ~= 0) continue;</span>
                    <span class="plain">} else {</span>
                        <span class="plain">if (v ~= X) continue;</span>
                    <span class="plain">}</span>
                    <span class="plain">LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 2));</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">return Y;</span>
        <span class="plain">} else if (task == RELS_LIST) {</span>
            <span class="plain">if (X == 0 || BlkValueWeakKind(X) ~= LIST_OF_TY) rfalse;</span>
            <span class="plain">LIST_OF_TY_SetLength(X, 0);</span>
            <span class="plain">switch (Y) {</span>
                <span class="plain">RLIST_ALL_X, RLIST_ALL_Y:</span>
                    <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                        <span class="plain">tmp = RRV_DATA_BASE + 3*at;</span>
                        <span class="plain">if (BlkValueRead(rel, tmp) &amp; RRF_USED) {</span>
                            <span class="plain">tmp++;</span>
                            <span class="plain">if (Y == RLIST_ALL_Y) tmp++;</span>
                            <span class="plain">v = BlkValueRead(rel, tmp);</span>
                            <span class="plain">LIST_OF_TY_InsertItem(X, v, false, 0, true);</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                    <span class="plain">return X;</span>
                <span class="plain">RLIST_ALL_PAIRS:</span>
                    <span class="plain">! LIST_OF_TY_InsertItem will make a deep copy of the item,</span>
                    <span class="plain">! so we can reuse a single combination value here</span>

                    <span class="plain">Y = BlkValueCreate(kov);</span>
                    <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                        <span class="plain">tmp = RRV_DATA_BASE + 3*at;</span>
                        <span class="plain">if (BlkValueRead(rel, tmp) &amp; RRF_USED) {</span>
                            <span class="plain">v = BlkValueRead(rel, tmp + 1);</span>
                            <span class="plain">BlkValueWrite(Y, COMBINATION_ITEM_BASE, v);</span>
                            <span class="plain">v = BlkValueRead(rel, tmp + 2);</span>
                            <span class="plain">BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, v);</span>
                            <span class="plain">LIST_OF_TY_InsertItem(X, Y);</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                    <span class="plain">BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);</span>
                    <span class="plain">BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);</span>
                    <span class="plain">BlkValueFree(Y);</span>
                    <span class="plain">return X;</span>
            <span class="plain">}</span>
            <span class="plain">rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">at = DoubleHashSetLookUp(rel, kx, ky, X, Y);</span>
        <span class="plain">switch(task) {</span>
            <span class="plain">RELS_TEST:</span>
                <span class="plain">if (at &gt;= 0) rtrue;</span>
                <span class="plain">rfalse;</span>
            <span class="plain">RELS_ASSERT_TRUE:</span>
                <span class="plain">if (at &gt;= 0) rtrue;</span>
                <span class="plain">at = ~at;</span>
                <span class="plain">BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);</span>
                <span class="plain">if (BlkValueRead(rel, RRV_DATA_BASE + 3*at) == 0)</span>
                    <span class="plain">BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);</span>
                <span class="plain">if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }</span>
                <span class="plain">if (KOVIsBlockValue(ky)) { Y = BlkValueCopy(BlkValueCreate(ky), Y); }</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);</span>
                <span class="plain">DoubleHashSetCheckResize(rel);</span>
                <span class="plain">rtrue;</span>
            <span class="plain">RELS_ASSERT_FALSE:</span>
                <span class="plain">if (at &lt; 0) rtrue;</span>
                <span class="plain">BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);</span>
                <span class="plain">if (KOVIsBlockValue(kx))</span>
                    <span class="plain">BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));</span>
                <span class="plain">if (KOVIsBlockValue(ky))</span>
                    <span class="plain">BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);</span>
                <span class="plain">rtrue;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ DoubleHashSetLookUp rel kx ky X Y  hashv i free mask perturb flags;</span>
        <span class="plain">! calculate a hash value for the pair</span>
        <span class="plain">hashv = GetHashValue(kx, X) + GetHashValue(ky, Y);</span>
        <span class="plain">! look in the first expected slot</span>
        <span class="plain">mask = BlkValueRead(rel, RRV_STORAGE);</span>
        <span class="plain">i = hashv &amp; mask;</span>
        <span class="plain">flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);</span>
        <span class="plain">if (flags == 0) return ~i;</span>
        <span class="plain">if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y)) return i;</span>
        <span class="plain">! not here, keep looking in sequence</span>
        <span class="plain">free = -1;</span>
        <span class="plain">if (flags &amp; RRF_DELETED) free = i;</span>
        <span class="plain">perturb = hashv;</span>
        <span class="plain">hashv = i;</span>
        <span class="plain">for (::) {</span>
            <span class="plain">hashv = hashv*5 + perturb + 1;</span>
            <span class="plain">i = hashv &amp; mask;</span>
            <span class="plain">flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);</span>
            <span class="plain">if (flags == 0) {</span>
                <span class="plain">if (free &gt;= 0) return ~free;</span>
                <span class="plain">return ~i;</span>
            <span class="plain">}</span>
            <span class="plain">if (DoubleHashSetEntryMatches(rel, i, kx, ky, X, Y))</span>
                <span class="plain">return i;</span>
            <span class="plain">if ((free &lt; 0) &amp;&amp; (flags &amp; RRF_DELETED)) free = i;</span>
            <span class="plain">#ifdef TARGET_ZCODE;</span>
            <span class="plain">@log_shift perturb MINUS_RRP_PERTURB_SHIFT -&gt; perturb;</span>
            <span class="plain">#ifnot;</span>
            <span class="plain">@ushiftr perturb RRP_PERTURB_SHIFT perturb;</span>
            <span class="plain">#endif;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ DoubleHashSetCheckResize rel  filled ext newext temp i at kov kx ky F X Y;</span>
        <span class="plain">filled = BlkValueRead(rel, RRV_FILLED);</span>
        <span class="plain">ext = BlkValueRead(rel, RRV_STORAGE) + 1;</span>
        <span class="plain">if (filled &gt;= (ext - filled) * RRP_CROWDED_IS) {</span>
            <span class="plain">! copy entries to temporary space</span>
            <span class="plain">temp = FlexAllocate(ext * (3*WORDSIZE), TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);</span>
            <span class="plain">for (i=0: i&lt;ext*3: i++)</span>
                <span class="plain">BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i), true);</span>
            <span class="plain">! resize and clear our data</span>
            <span class="plain">if (ext &gt;= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;</span>
            <span class="plain">else newext = ext * RRP_RESIZE_SMALL;</span>
            <span class="plain">BlkValueSetLBCapacity(rel, RRV_DATA_BASE + newext*3);</span>
            <span class="plain">BlkValueWrite(rel, RRV_STORAGE, newext - 1);</span>
            <span class="plain">BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));</span>
            <span class="plain">for (i=0: i&lt;newext*3: i++)</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE+i, 0);</span>
            <span class="plain">! copy entries back from temporary space</span>
            <span class="plain">kov = BlkValueRead(rel, RRV_KIND);</span>
            <span class="plain">kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);</span>
            <span class="plain">for (i=0: i&lt;ext: i++) {</span>
                <span class="plain">F = BlkValueRead(temp, 3*i, true);</span>
                <span class="plain">if (F == 0 || (F &amp; RRF_DELETED)) continue;</span>
                <span class="plain">X = BlkValueRead(temp, 3*i + 1, true);</span>
                <span class="plain">Y = BlkValueRead(temp, 3*i + 2, true);</span>
                <span class="plain">at = DoubleHashSetLookUp(rel, kx, ky, X, Y);</span>
                <span class="plain">if (at &gt;= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }</span>
                <span class="plain">at = ~at;</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at, F);</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);</span>
            <span class="plain">}</span>
            <span class="plain">! done with temporary space</span>
            <span class="plain">FlexFree(temp);</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ DoubleHashSetEntryMatches rel at kx ky X Y  cx cy;</span>
        <span class="plain">cx = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);</span>
        <span class="plain">if (KOVIsBlockValue(kx)) {</span>
            <span class="plain">if (BlkValueCompare(cx, X) ~= 0) rfalse;</span>
        <span class="plain">} else {</span>
            <span class="plain">if (cx ~= X) rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">cy = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);</span>
        <span class="plain">if (KOVIsBlockValue(ky)) {</span>
            <span class="plain">if (BlkValueCompare(cy, Y) ~= 0) rfalse;</span>
        <span class="plain">} else {</span>
            <span class="plain">if (cy ~= Y) rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16. Hash List Relation Handler. </b>This implements relations which are stored as a hash table mapping
keys to either single values or lists of values. The storage comprises a list
of three-word entries, either (F, X, Y) or (F, X, L), where F is a
flags word distinguishing between the two cases (among other things). In the
latter case, L is a pointer to a list (<code class="display"><span class="extract">LIST_OF_TY</span></code>) containing the values.
</p>

<p class="inwebparagraph">The "storage", "used", and "filled" words have the same meanings as
above.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">HashListRelationHandler</span></code> is a thin wrapper around <code class="display"><span class="extract">HashCoreRelationHandler</span></code>,
which is shared with two other handlers below.
</p>


<pre class="display">
    <span class="plain">[ HashListRelationHandler rel task X Y  sym kov kx ky;</span>
        <span class="plain">kov = BlkValueRead(rel, RRV_KIND);</span>
        <span class="plain">kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);</span>
        <span class="plain">return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 1);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17. Hash Table Relation Handler. </b>This is the same as the Hash List Relation Handler above, except that only
one value may be stored for each key. This implements various-to-one
relations.
</p>


<pre class="display">
    <span class="plain">[ HashTableRelationHandler rel task X Y  kov kx ky;</span>
        <span class="plain">kov = BlkValueRead(rel, RRV_KIND);</span>
        <span class="plain">kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);</span>
        <span class="plain">return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18. Reversed Hash Table Relation Handler. </b>This is the same as the Hash Table Relation Handler except that the sides
are reversed. This implements one-to-various relations.
</p>


<pre class="display">
    <span class="plain">[ ReversedHashTableRelationHandler rel task X Y  kov kx ky swap;</span>
        <span class="plain">kov = BlkValueRead(rel, RRV_KIND);</span>
        <span class="plain">kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);</span>
        <span class="plain">switch (task) {</span>
            <span class="plain">RELS_SET_VALENCY:</span>
                <span class="plain">return RELATION_TY_SetValency(rel, X);</span>
            <span class="plain">RELS_TEST, RELS_ASSERT_TRUE, RELS_ASSERT_FALSE:</span>
                <span class="plain">return HashCoreRelationHandler(rel, task, ky, kx, Y, X, 0);</span>
            <span class="plain">RELS_LOOKUP_ANY:</span>
                <span class="plain">switch (Y) {</span>
                    <span class="plain">RLANY_GET_X: Y = RLANY_GET_Y;</span>
                    <span class="plain">RLANY_GET_Y: Y = RLANY_GET_X;</span>
                    <span class="plain">RLANY_CAN_GET_X: Y = RLANY_CAN_GET_Y;</span>
                    <span class="plain">RLANY_CAN_GET_Y: Y = RLANY_CAN_GET_X;</span>
                <span class="plain">}</span>
            <span class="plain">RELS_LOOKUP_ALL_X:</span>
                <span class="plain">task = RELS_LOOKUP_ALL_Y;</span>
            <span class="plain">RELS_LOOKUP_ALL_Y:</span>
                <span class="plain">task = RELS_LOOKUP_ALL_X;</span>
            <span class="plain">RELS_SHOW:</span>
                <span class="plain">swap=X; X=Y; Y=swap;</span>
                <span class="plain">swap=kx; kx=ky; ky=swap;</span>
            <span class="plain">RELS_LIST:</span>
                <span class="plain">switch (Y) {</span>
                    <span class="plain">RLIST_ALL_X: Y = RLIST_ALL_Y;</span>
                    <span class="plain">RLIST_ALL_Y: Y = RLIST_ALL_X;</span>
                <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">return HashCoreRelationHandler(rel, task, kx, ky, X, Y, 0);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19. Symmetric Relation Handlers. </b>These are simple wrappers around the asymmetric handlers defined above.
When a pair is inserted or removed, the wrappers insert or remove the
reversed pair as well.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">SymDoubleHashSetRelationHandler</span></code> and <code class="display"><span class="extract">SymHashListRelationHandler</span></code>
implement symmetric V-to-V relations.
<code class="display"><span class="extract">Sym2in1HashTableRelationHandler</span></code> implements symmetric 1-to-1.
("<code class="display"><span class="extract">SymTwoInOneHashTableRelationHandler</span></code>" would have
exceeded Inform 6's 32-character name limit.)
</p>


<pre class="display">
    <span class="plain">[ SymDoubleHashSetRelationHandler rel task X Y;</span>
        <span class="plain">if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)</span>
            <span class="plain">DoubleHashSetRelationHandler(rel, task, Y, X);</span>
        <span class="plain">return DoubleHashSetRelationHandler(rel, task, X, Y, 1);</span>
    <span class="plain">];</span>

    <span class="plain">[ SymHashListRelationHandler rel task X Y;</span>
        <span class="plain">if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)</span>
            <span class="plain">HashListRelationHandler(rel, task, Y, X);</span>
        <span class="plain">return HashListRelationHandler(rel, task, X, Y);</span>
    <span class="plain">];</span>

    <span class="plain">[ Sym2in1HashTableRelationHandler rel task X Y;</span>
        <span class="plain">if (task == RELS_ASSERT_TRUE or RELS_ASSERT_FALSE)</span>
            <span class="plain">TwoInOneHashTableRelationHandler(rel, task, Y, X);</span>
        <span class="plain">return TwoInOneHashTableRelationHandler(rel, task, X, Y, 1);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP20"></a><b>&#167;20. Hash Core Relation Handler. </b>This implements the core functionality that is shared between
<code class="display"><span class="extract">HashListRelationHandler</span></code>, <code class="display"><span class="extract">HashTableRelationHandler</span></code>, and
<code class="display"><span class="extract">ReversedHashTableRelationHandler</span></code>. All three handlers are the same except
for whether the left or right side is the "key" and whether or not
multiple values may be stored for a single key.
</p>

<p class="inwebparagraph">As noted above, the table contains three-word entries, (F, X, Y),
where F is a flags word. Only the hash code of X is used. If F
includes <code class="display"><span class="extract">RRF_SINGLE</span></code>, Y is a single value; otherwise, Y is a list
(<code class="display"><span class="extract">LIST_OF_TY</span></code>) of values. If <code class="display"><span class="extract">mult</span></code> is zero, <code class="display"><span class="extract">RRF_SINGLE</span></code> must always be
set, allowing only one value per key: a new pair (X, Y') will replace
the existing pair (X, Y).
</p>


<pre class="display">
    <span class="plain">[ HashCoreRelationHandler rel task kx ky X Y mult  sym rev at tmp fl;</span>
        <span class="plain">if (task == RELS_SET_VALENCY) {</span>
            <span class="plain">return RELATION_TY_SetValency(rel, X);</span>
        <span class="plain">} else if (task == RELS_DESTROY) {</span>
            <span class="plain">! clear</span>
            <span class="plain">kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);</span>
            <span class="plain">if (~~(kx || ky)) return;</span>
            <span class="plain">at = BlkValueRead(rel, RRV_STORAGE);</span>
            <span class="plain">while (at &gt;= 0) {</span>
                <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);</span>
                <span class="plain">if (fl &amp; RRF_USED) {</span>
                    <span class="plain">if (kx) BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));</span>
                    <span class="plain">if (ky || ~~(fl &amp; RRF_SINGLE))</span>
                        <span class="plain">BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));</span>
                <span class="plain">}</span>
                <span class="plain">at--;</span>
            <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">} else if (task == RELS_COPY) {</span>
            <span class="plain">X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);</span>
            <span class="plain">if (~~(X || Y)) return;</span>
            <span class="plain">at = BlkValueRead(rel, RRV_STORAGE);</span>
            <span class="plain">while (at &gt;= 0) {</span>
                <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);</span>
                <span class="plain">if (fl &amp; RRF_USED) {</span>
                    <span class="plain">if (X) {</span>
                        <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);</span>
                        <span class="plain">tmp = BlkValueCopy(BlkValueCreate(kx), tmp);</span>
                        <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, tmp);</span>
                    <span class="plain">}</span>
                    <span class="plain">if (Y || ~~(fl &amp; RRF_SINGLE)) {</span>
                        <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);</span>
                        <span class="plain">tmp = BlkValueCopy(BlkValueCreate(BlkValueWeakKind(tmp)), tmp);</span>
                        <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
                <span class="plain">at--;</span>
            <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">} else if (task == RELS_SHOW) {</span>
            <span class="plain">print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";</span>
            <span class="plain">! Z-machine doesn't have the room to let us pass sym/rev as parameters</span>
            <span class="plain">switch (RELATION_TY_GetValency(rel)) {</span>
                <span class="plain">RRVAL_SYM_V_TO_V:</span>
                    <span class="plain">sym = 1;</span>
                    <span class="plain">tmp = KOVComparisonFunction(kx);</span>
                    <span class="plain">if (~~tmp) tmp = UnsignedCompare;</span>
                <span class="plain">RRVAL_O_TO_V:</span>
                    <span class="plain">rev = 1;</span>
            <span class="plain">}</span>
            <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);</span>
                <span class="plain">if (fl &amp; RRF_USED) {</span>
                    <span class="plain">X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);</span>
                    <span class="plain">Y = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);</span>
                    <span class="plain">if (fl &amp; RRF_SINGLE) {</span>
                        <span class="plain">if (sym &amp;&amp; tmp(X, Y) &gt; 0) continue;</span>
                        <span class="plain">print "  ";</span>
                        <span class="plain">if (rev) PrintKindValuePair(ky, Y);</span>
                        <span class="plain">else PrintKindValuePair(kx, X);</span>
                        <span class="plain">if (sym) print " &lt;=&gt; "; else print " &gt;=&gt; ";</span>
                        <span class="plain">if (rev) PrintKindValuePair(kx, X);</span>
                        <span class="plain">else PrintKindValuePair(ky, Y);</span>
                        <span class="plain">print "^";</span>
                    <span class="plain">} else {</span>
                        <span class="plain">for (mult=1: mult&lt;=LIST_OF_TY_GetLength(Y): mult++) {</span>
                            <span class="plain">fl = LIST_OF_TY_GetItem(Y, mult);</span>
                            <span class="plain">if (sym &amp;&amp; tmp(X, fl) &gt; 0) continue;</span>
                            <span class="plain">print "  ";</span>
                            <span class="plain">if (rev) PrintKindValuePair(ky, fl);</span>
                            <span class="plain">else PrintKindValuePair(kx, X);</span>
                            <span class="plain">if (sym) print " &lt;=&gt; "; else print " &gt;=&gt; ";</span>
                            <span class="plain">if (rev) PrintKindValuePair(kx, X);</span>
                            <span class="plain">else PrintKindValuePair(ky, fl);</span>
                            <span class="plain">print "^";</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">} else if (task == RELS_EMPTY) {</span>
            <span class="plain">if (BlkValueRead(rel, RRV_USED) == 0) rtrue;</span>
            <span class="plain">if (X == 1) {</span>
                <span class="plain">HashCoreRelationHandler(rel, RELS_DESTROY);</span>
                <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                    <span class="plain">tmp = RRV_DATA_BASE + 3*at;</span>
                    <span class="plain">BlkValueWrite(rel, tmp, 0);</span>
                    <span class="plain">BlkValueWrite(rel, tmp + 1, 0);</span>
                    <span class="plain">BlkValueWrite(rel, tmp + 2, 0);</span>
                <span class="plain">}</span>
                <span class="plain">BlkValueWrite(rel, RRV_USED, 0);</span>
                <span class="plain">BlkValueWrite(rel, RRV_FILLED, 0);</span>
                <span class="plain">rtrue;</span>
            <span class="plain">}</span>
            <span class="plain">rfalse;</span>
        <span class="plain">} else if (task == RELS_LOOKUP_ANY) {</span>
            <span class="plain">if (Y == RLANY_GET_Y or RLANY_CAN_GET_Y) {</span>
                <span class="plain">at = HashCoreLookUp(rel, kx, X);</span>
                <span class="plain">if (at &gt;= 0) {</span>
                    <span class="plain">if (Y == RLANY_CAN_GET_Y) rtrue;</span>
                    <span class="plain">tmp = RRV_DATA_BASE + 3*at;</span>
                    <span class="plain">fl = BlkValueRead(rel, tmp);</span>
                    <span class="plain">tmp = BlkValueRead(rel, tmp + 2);</span>
                    <span class="plain">if (fl &amp; RRF_SINGLE) return tmp;</span>
                    <span class="plain">return LIST_OF_TY_GetItem(tmp, 1);</span>
                <span class="plain">}</span>
            <span class="plain">} else {</span>
                <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                    <span class="plain">tmp = RRV_DATA_BASE + 3*at;</span>
                    <span class="plain">fl = BlkValueRead(rel, tmp);</span>
                    <span class="plain">if (fl &amp; RRF_USED) {</span>
                        <span class="plain">sym = BlkValueRead(rel, tmp + 2);</span>
                        <span class="plain">if (fl &amp; RRF_SINGLE) {</span>
                            <span class="plain">if (KOVIsBlockValue(ky)) {</span>
                                <span class="plain">if (BlkValueCompare(X, sym) ~= 0) continue;</span>
                            <span class="plain">} else {</span>
                                <span class="plain">if (X ~= sym) continue;</span>
                            <span class="plain">}</span>
                        <span class="plain">} else {</span>
                            <span class="plain">if (LIST_OF_TY_FindItem(sym, X) == 0) continue;</span>
                        <span class="plain">}</span>
                        <span class="plain">if (Y == RLANY_CAN_GET_X) rtrue;</span>
                        <span class="plain">return BlkValueRead(rel, tmp + 1);</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">if (Y == RLANY_GET_X or RLANY_GET_Y)</span>
                <span class="plain">print "*** Lookup failed: value not found ***^";</span>
            <span class="plain">rfalse;</span>
        <span class="plain">} else if (task == RELS_LOOKUP_ALL_X) {</span>
            <span class="plain">if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;</span>
            <span class="plain">LIST_OF_TY_SetLength(Y, 0);</span>
            <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                <span class="plain">tmp = RRV_DATA_BASE + 3*at;</span>
                <span class="plain">fl = BlkValueRead(rel, tmp);</span>
                <span class="plain">if (fl &amp; RRF_USED) {</span>
                    <span class="plain">sym = BlkValueRead(rel, tmp + 2);</span>
                    <span class="plain">if (fl &amp; RRF_SINGLE) {</span>
                        <span class="plain">if (KOVIsBlockValue(ky)) {</span>
                            <span class="plain">if (BlkValueCompare(X, sym) ~= 0) continue;</span>
                        <span class="plain">} else {</span>
                            <span class="plain">if (X ~= sym) continue;</span>
                        <span class="plain">}</span>
                    <span class="plain">} else {</span>
                        <span class="plain">if (LIST_OF_TY_FindItem(sym, X) == 0) continue;</span>
                    <span class="plain">}</span>
                    <span class="plain">LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">return Y;</span>
        <span class="plain">} else if (task == RELS_LOOKUP_ALL_Y) {</span>
            <span class="plain">if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;</span>
            <span class="plain">LIST_OF_TY_SetLength(Y, 0);</span>
            <span class="plain">at = HashCoreLookUp(rel, kx, X);</span>
            <span class="plain">if (at &gt;= 0) {</span>
                <span class="plain">tmp = RRV_DATA_BASE + 3*at;</span>
                <span class="plain">fl = BlkValueRead(rel, tmp);</span>
                <span class="plain">tmp = BlkValueRead(rel, tmp + 2);</span>
                <span class="plain">if (fl &amp; RRF_SINGLE)</span>
                    <span class="plain">LIST_OF_TY_InsertItem(Y, tmp);</span>
                <span class="plain">else</span>
                    <span class="plain">LIST_OF_TY_AppendList(Y, tmp);</span>
            <span class="plain">}</span>
            <span class="plain">return Y;</span>
        <span class="plain">} else if (task == RELS_LIST) {</span>
            <span class="plain">if (BlkValueWeakKind(X) ~= LIST_OF_TY) rfalse;</span>
            <span class="plain">LIST_OF_TY_SetLength(X, 0);</span>
            <span class="plain">switch (Y) {</span>
                <span class="plain">RLIST_ALL_X:</span>
                    <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                        <span class="plain">tmp = RRV_DATA_BASE + 3*at;</span>
                        <span class="plain">fl = BlkValueRead(rel, tmp);</span>
                        <span class="plain">if (fl &amp; RRF_USED)</span>
                            <span class="plain">LIST_OF_TY_InsertItem(X, BlkValueRead(rel, tmp + 1));</span>
                    <span class="plain">}</span>
                    <span class="plain">return X;</span>
                <span class="plain">RLIST_ALL_Y:</span>
                    <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                        <span class="plain">tmp = RRV_DATA_BASE + 3*at;</span>
                        <span class="plain">fl = BlkValueRead(rel, tmp);</span>
                        <span class="plain">if (fl &amp; RRF_USED) {</span>
                            <span class="plain">tmp = BlkValueRead(rel, tmp + 2);</span>
                            <span class="plain">if (fl &amp; RRF_SINGLE)</span>
                                <span class="plain">LIST_OF_TY_InsertItem(X, tmp, false, 0, true);</span>
                            <span class="plain">else</span>
                                <span class="plain">LIST_OF_TY_AppendList(X, tmp, false, 0, true);</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                    <span class="plain">return X;</span>
                <span class="plain">RLIST_ALL_PAIRS:</span>
                    <span class="plain">if (RELATION_TY_GetValency(rel) == RRVAL_O_TO_V) rev = 1;</span>
                    <span class="plain">! LIST_OF_TY_InsertItem will make a deep copy of the item,</span>
                    <span class="plain">! so we can reuse a single combination value here</span>
                    <span class="plain">Y = BlkValueCreate(COMBINATION_TY, tmp);</span>
                    <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                        <span class="plain">tmp = RRV_DATA_BASE + 3*at;</span>
                        <span class="plain">fl = BlkValueRead(rel, tmp);</span>
                        <span class="plain">if (fl &amp; RRF_USED) {</span>
                            <span class="plain">BlkValueWrite(Y, COMBINATION_ITEM_BASE + rev, BlkValueRead(rel, tmp + 1));</span>
                            <span class="plain">tmp = BlkValueRead(rel, tmp + 2);</span>
                            <span class="plain">if (fl &amp; RRF_SINGLE) {</span>
                                <span class="plain">BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1 - rev, tmp);</span>
                                <span class="plain">LIST_OF_TY_InsertItem(X, Y);</span>
                            <span class="plain">} else {</span>
                                <span class="plain">for (mult = LIST_OF_TY_GetLength(tmp): mult &gt; 0: mult--) {</span>
                                    <span class="plain">BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1 - rev,</span>
                                        <span class="plain">LIST_OF_TY_GetItem(tmp, mult));</span>
                                    <span class="plain">LIST_OF_TY_InsertItem(X, Y);</span>
                                <span class="plain">}</span>
                            <span class="plain">}</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                    <span class="plain">BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);</span>
                    <span class="plain">BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);</span>
                    <span class="plain">BlkValueFree(Y);</span>
                    <span class="plain">return X;</span>
            <span class="plain">}</span>
            <span class="plain">rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">at = HashCoreLookUp(rel, kx, X);</span>
        <span class="plain">switch(task) {</span>
            <span class="plain">RELS_TEST:</span>
                <span class="plain">if (at &lt; 0) rfalse;</span>
                <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);</span>
                <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);</span>
                <span class="plain">if (fl &amp; RRF_SINGLE) {</span>
                    <span class="plain">if (KOVIsBlockValue(ky)) {</span>
                        <span class="plain">if (BlkValueCompare(tmp, Y) == 0) rtrue;</span>
                    <span class="plain">} else {</span>
                        <span class="plain">if (tmp == Y) rtrue;</span>
                    <span class="plain">}</span>
                    <span class="plain">rfalse;</span>
                <span class="plain">} else {</span>
                    <span class="plain">return LIST_OF_TY_FindItem(tmp, Y);</span>
                <span class="plain">}</span>
            <span class="plain">RELS_ASSERT_TRUE:</span>
                <span class="plain">if (at &lt; 0) {</span>
                    <span class="plain">! no entry exists for this key, just add one</span>
                    <span class="plain">at = ~at;</span>
                    <span class="plain">BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);</span>
                    <span class="plain">if (BlkValueRead(rel, RRV_DATA_BASE + 3*at) == 0)</span>
                        <span class="plain">BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);</span>
                    <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);</span>
                    <span class="plain">if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }</span>
                    <span class="plain">if (KOVIsBlockValue(ky)) { Y = BlkValueCopy(BlkValueCreate(ky), Y); }</span>
                    <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);</span>
                    <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);</span>
                    <span class="plain">HashCoreCheckResize(rel);</span>
                    <span class="plain">break;</span>
                <span class="plain">}</span>
                <span class="plain">! an entry exists: could be a list or a single value</span>
                <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);		! flags</span>
                <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! value or list</span>
                <span class="plain">if (fl &amp; RRF_SINGLE) {</span>
                    <span class="plain">! if Y is the same as the stored key, we have nothing to do</span>
                    <span class="plain">if (KOVIsBlockValue(ky)) {</span>
                        <span class="plain">if (BlkValueCompare(tmp, Y) == 0) rtrue;</span>
                    <span class="plain">} else {</span>
                        <span class="plain">if (tmp == Y) rtrue;</span>
                    <span class="plain">}</span>
                    <span class="plain">! it's different: either replace it or expand into a list,</span>
                    <span class="plain">! depending on the value of mult</span>
                    <span class="plain">if (mult) {</span>
                        <span class="plain">fl = BlkValueCreate(LIST_OF_TY);	! new list</span>
                        <span class="plain">BlkValueWrite(fl, LIST_ITEM_KOV_F, ky);</span>
                        <span class="plain">LIST_OF_TY_SetLength(fl, 2);</span>
                        <span class="plain">BlkValueWrite(fl, LIST_ITEM_BASE, tmp);	! do not copy</span>
                        <span class="plain">LIST_OF_TY_PutItem(fl, 2, Y);		! copy if needed</span>
                        <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, fl);</span>
                        <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED);</span>
                    <span class="plain">} else {</span>
                        <span class="plain">if (KOVIsBlockValue(ky)) {</span>
                            <span class="plain">BlkValueFree(tmp);</span>
                            <span class="plain">Y = BlkValueCopy(BlkValueCreate(ky), Y);</span>
                        <span class="plain">}</span>
                        <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);</span>
                    <span class="plain">}</span>
                <span class="plain">} else {</span>
                    <span class="plain">! if Y is present already, do nothing. otherwise add it.</span>
                    <span class="plain">LIST_OF_TY_InsertItem(tmp, Y, 0, 0, 1);</span>
                <span class="plain">}</span>
                <span class="plain">rtrue;</span>
            <span class="plain">RELS_ASSERT_FALSE:</span>
                <span class="plain">if (at &lt; 0) rtrue;</span>
                <span class="plain">! an entry exists: could be a list or a single value</span>
                <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);		! flags</span>
                <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! value or list</span>
                <span class="plain">if (fl &amp; RRF_SINGLE) {</span>
                    <span class="plain">! if the stored key isn't Y, we have nothing to do</span>
                    <span class="plain">if (KOVIsBlockValue(ky)) {</span>
                        <span class="plain">if (BlkValueCompare(tmp, Y) ~= 0) rtrue;</span>
                    <span class="plain">} else {</span>
                        <span class="plain">if (tmp ~= Y) rtrue;</span>
                    <span class="plain">}</span>
                    <span class="plain">! delete the entry</span>
                    <span class="plain">if (KOVIsBlockValue(ky))</span>
                        <span class="plain">BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2));</span>
                    <span class="plain">.DeleteEntryIgnoringY;</span>
                    <span class="plain">BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);</span>
                    <span class="plain">if (KOVIsBlockValue(kx))</span>
                        <span class="plain">BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));</span>
                    <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);</span>
                    <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);</span>
                    <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);</span>
                <span class="plain">} else {</span>
                    <span class="plain">! remove Y from the list if present</span>
                    <span class="plain">LIST_OF_TY_RemoveValue(tmp, Y, 1);</span>
                    <span class="plain">! if the list is now empty, delete the whole entry</span>
                    <span class="plain">if (LIST_OF_TY_GetLength(tmp) == 0) {</span>
                        <span class="plain">BlkValueFree(tmp);</span>
                        <span class="plain">jump DeleteEntryIgnoringY;</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
                <span class="plain">rtrue;</span>
        <span class="plain">}</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>

    <span class="plain">[ HashCoreLookUp rel kx X  hashv i free mask perturb flags;</span>
    <span class="plain">!print "[HCLU rel=", rel, " kx=", kx, " X=", X, ": ";</span>
        <span class="plain">! calculate a hash value for the key</span>
        <span class="plain">hashv = GetHashValue(kx, X);</span>
        <span class="plain">! look in the first expected slot</span>
        <span class="plain">mask = BlkValueRead(rel, RRV_STORAGE);</span>
        <span class="plain">i = hashv &amp; mask;</span>
    <span class="plain">!print "hv=", hashv, ", trying ", i;</span>
        <span class="plain">flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);</span>
        <span class="plain">if (flags == 0) {</span>
    <span class="plain">!print " - not found]^";</span>
            <span class="plain">return ~i;</span>
        <span class="plain">}</span>
        <span class="plain">if (HashCoreEntryMatches(rel, i, kx, X)) {</span>
    <span class="plain">!print " - found]^";</span>
            <span class="plain">return i;</span>
        <span class="plain">}</span>
        <span class="plain">! not here, keep looking in sequence</span>
        <span class="plain">free = -1;</span>
        <span class="plain">if (flags &amp; RRF_DELETED) free = i;</span>
        <span class="plain">perturb = hashv;</span>
        <span class="plain">hashv = i;</span>
        <span class="plain">for (::) {</span>
            <span class="plain">hashv = hashv*5 + perturb + 1;</span>
            <span class="plain">i = hashv &amp; mask;</span>
    <span class="plain">!print ", ", i;</span>
            <span class="plain">flags = BlkValueRead(rel, RRV_DATA_BASE + 3*i);</span>
            <span class="plain">if (flags == 0) {</span>
    <span class="plain">!print " - not found]^";</span>
                <span class="plain">if (free &gt;= 0) return ~free;</span>
                <span class="plain">return ~i;</span>
            <span class="plain">}</span>
            <span class="plain">if (HashCoreEntryMatches(rel, i, kx, X)) {</span>
    <span class="plain">!print " - found]^";</span>
                <span class="plain">return i;</span>
            <span class="plain">}</span>
            <span class="plain">if ((free &lt; 0) &amp;&amp; (flags &amp; RRF_DELETED)) free = i;</span>
            <span class="plain">#ifdef TARGET_ZCODE;</span>
            <span class="plain">@log_shift perturb MINUS_RRP_PERTURB_SHIFT -&gt; perturb;</span>
            <span class="plain">#ifnot;</span>
            <span class="plain">@ushiftr perturb RRP_PERTURB_SHIFT perturb;</span>
            <span class="plain">#endif;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ HashCoreCheckResize rel  filled ext newext temp i at kov kx F X Y;</span>
        <span class="plain">filled = BlkValueRead(rel, RRV_FILLED);</span>
        <span class="plain">ext = BlkValueRead(rel, RRV_STORAGE) + 1;</span>
        <span class="plain">if (filled &gt;= (ext - filled) * RRP_CROWDED_IS) {</span>
            <span class="plain">! copy entries to temporary space</span>
            <span class="plain">temp = FlexAllocate(ext * (3*WORDSIZE), TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);</span>
            <span class="plain">for (i=0: i&lt;ext*3: i++)</span>
                <span class="plain">BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i), true);</span>
            <span class="plain">! resize and clear our data</span>
            <span class="plain">if (ext &gt;= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;</span>
            <span class="plain">else newext = ext * RRP_RESIZE_SMALL;</span>
            <span class="plain">BlkValueSetLBCapacity(rel, RRV_DATA_BASE + newext*3);</span>
            <span class="plain">BlkValueWrite(rel, RRV_STORAGE, newext - 1);</span>
            <span class="plain">BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));</span>
            <span class="plain">for (i=0: i&lt;newext*3: i++)</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE+i, 0);</span>
            <span class="plain">! copy entries back from temporary space</span>
            <span class="plain">kov = BlkValueRead(rel, RRV_KIND);</span>
            <span class="plain">kx = KindBaseTerm(kov, 0);</span>
            <span class="plain">for (i=0: i&lt;ext: i++) {</span>
                <span class="plain">F = BlkValueRead(temp, 3*i, true);</span>
                <span class="plain">if (F == 0 || (F &amp; RRF_DELETED)) continue;</span>
                <span class="plain">X = BlkValueRead(temp, 3*i + 1, true);</span>
                <span class="plain">Y = BlkValueRead(temp, 3*i + 2, true);</span>
                <span class="plain">at = HashCoreLookUp(rel, kx, X);</span>
                <span class="plain">if (at &gt;= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }</span>
                <span class="plain">at = ~at;</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at, F);</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, Y);</span>
            <span class="plain">}</span>
            <span class="plain">! done with temporary space</span>
            <span class="plain">FlexFree(temp);</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ HashCoreEntryMatches rel at kx X  cx cy;</span>
        <span class="plain">cx = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);</span>
        <span class="plain">if (KOVIsBlockValue(kx)) {</span>
            <span class="plain">if (BlkValueCompare(cx, X) ~= 0) rfalse;</span>
        <span class="plain">} else {</span>
            <span class="plain">if (cx ~= X) rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP21"></a><b>&#167;21. Equivalence Hash Table Relation Handler. </b>This implements group relations. The table format is identical to that used
by <code class="display"><span class="extract">HashCoreRelationHandler</span></code>, but we use it differently. Although the
relation appears to relate Xs to Xs as far as the game is concerned, the
table actually relates Xs to numbers, where each number identifies a
group of related items. Any X not listed in the table is implicitly in
a single-member group.
</p>

<p class="inwebparagraph">When a pair (X, Y) is inserted, one of four cases occurs:
</p>

<p class="inwebparagraph">1. Neither X nor Y has a table entry. We search the table to find the
next unused group number, then add both X and Y to that group.
</p>

<p class="inwebparagraph">2. Both X and Y have existing table entries. If the group numbers
differ, we walk through the table and change all occurrences of the
higher number to the lower one.
</p>

<p class="inwebparagraph">3. X has an existing table entry but Y does not. We add a Y entry
using the group number of X.
</p>

<p class="inwebparagraph">4. Y has an existing table entry but X does not. We add an X entry
using the group number of Y.
</p>

<p class="inwebparagraph">When a pair (X, Y) is removed, we first verify that X and Y are
in the same group, then delete the table entry for X. This may leave
Y in a single-member group, which could be deleted, but detecting that
situation would be inefficient, so we keep the Y entry regardless.
</p>

<p class="inwebparagraph">This code uses the Hash Core utility functions defined above.
</p>


<pre class="display">
    <span class="plain">[ EquivHashTableRelationHandler rel task X Y  kx at at2 tmp fl i ext;</span>
        <span class="plain">kx = KindBaseTerm(BlkValueRead(rel, RRV_KIND), 0);</span>
        <span class="plain">if (task == RELS_SET_VALENCY) {</span>
            <span class="plain">return RELATION_TY_SetValency(rel, X);</span>
        <span class="plain">} else if (task == RELS_DESTROY) {</span>
            <span class="plain">! clear</span>
            <span class="plain">if (KOVIsBlockValue(kx)) {</span>
                <span class="plain">at = BlkValueRead(rel, RRV_STORAGE);</span>
                <span class="plain">while (at &gt;= 0) {</span>
                    <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);</span>
                    <span class="plain">if (fl &amp; RRF_USED) {</span>
                        <span class="plain">BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));</span>
                    <span class="plain">}</span>
                    <span class="plain">at--;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">} else if (task == RELS_COPY) {</span>
            <span class="plain">if (KOVIsBlockValue(kx)) {</span>
                <span class="plain">at = BlkValueRead(rel, RRV_STORAGE);</span>
                <span class="plain">while (at &gt;= 0) {</span>
                    <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);</span>
                    <span class="plain">if (fl &amp; RRF_USED) {</span>
                        <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1);</span>
                        <span class="plain">tmp = BlkValueCopy(BlkValueCreate(kx), tmp);</span>
                        <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1);</span>
                    <span class="plain">}</span>
                    <span class="plain">at--;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">} else if (task == RELS_SHOW) {</span>
            <span class="plain">print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";</span>
            <span class="plain">ext = BlkValueRead(rel, RRV_STORAGE);</span>
            <span class="plain">! flag all items by negating their group numbers</span>
            <span class="plain">for (at=0, X=RRV_DATA_BASE: at&lt;=ext: at++, X=X+3)</span>
                <span class="plain">if (BlkValueRead(rel, X) &amp; RRF_USED)</span>
                    <span class="plain">BlkValueWrite(rel, X + 2, -(BlkValueRead(rel, X + 2)));</span>
            <span class="plain">! display groups, unflagging them as we go</span>
            <span class="plain">for (at=0, X=RRV_DATA_BASE, fl=0: at&lt;=ext: at++, X=X+3, fl=0) {</span>
                <span class="plain">if (BlkValueRead(rel, X) &amp; RRF_USED) {</span>
                    <span class="plain">fl = BlkValueRead(rel, X + 2);</span>
                    <span class="plain">if (fl &gt; 0) continue;		! already visited</span>
                    <span class="plain">BlkValueWrite(rel, X + 2, -fl);	! unflag it</span>
                    <span class="plain">! display the group starting with this member, but only</span>
                    <span class="plain">! if there are more members in the group</span>
                    <span class="plain">tmp = BlkValueRead(rel, X + 1);</span>
                    <span class="plain">i = 0;</span>
                    <span class="plain">for (at2=at+1, Y=RRV_DATA_BASE+3*at2: at2&lt;=ext: at2++, Y=Y+3) {</span>
                        <span class="plain">if (BlkValueRead(rel, Y) &amp; RRF_USED) {</span>
                            <span class="plain">if (BlkValueRead(rel, Y + 2) ~= fl) continue;</span>
                            <span class="plain">BlkValueWrite(rel, Y + 2, -fl);</span>
                            <span class="plain">if (~~i) {</span>
                                <span class="plain">! print the saved first member</span>
                                <span class="plain">print "  { ";</span>
                                <span class="plain">PrintKindValuePair(kx, tmp);</span>
                                <span class="plain">i = 1;</span>
                            <span class="plain">}</span>
                            <span class="plain">print ", ";</span>
                            <span class="plain">PrintKindValuePair(kx, BlkValueRead(rel, Y + 1));</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                    <span class="plain">if (i) print " }^";</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">} else if (task == RELS_EMPTY) {</span>
            <span class="plain">! never empty since R(x,x) is always true</span>
            <span class="plain">rfalse;</span>
        <span class="plain">} else if (task == RELS_LOOKUP_ANY) {</span>
            <span class="plain">! kind of a cheat, but it's faster than searching for a better value to return</span>
            <span class="plain">if (Y == RLANY_CAN_GET_X or RLANY_CAN_GET_Y) rtrue;</span>
            <span class="plain">return X;</span>
        <span class="plain">} else if (task == RELS_LOOKUP_ALL_X or RELS_LOOKUP_ALL_Y) {</span>
            <span class="plain">if (BlkValueWeakKind(Y) ~= LIST_OF_TY) rfalse;</span>
            <span class="plain">LIST_OF_TY_SetLength(Y, 0);</span>
            <span class="plain">BlkValueWrite(Y, LIST_ITEM_KOV_F, kx);</span>
            <span class="plain">at = HashCoreLookUp(rel, kx, X);</span>
            <span class="plain">if (at &lt; 0) {</span>
                <span class="plain">LIST_OF_TY_InsertItem(Y, X);</span>
            <span class="plain">} else {</span>
                <span class="plain">X = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);</span>
                <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                    <span class="plain">tmp = RRV_DATA_BASE + 3*at;</span>
                    <span class="plain">fl = BlkValueRead(rel, tmp);</span>
                    <span class="plain">if (fl &amp; RRF_USED) {</span>
                        <span class="plain">if (BlkValueRead(rel, tmp + 2) ~= X) continue;</span>
                        <span class="plain">LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 1));</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">return Y;</span>
        <span class="plain">} else if (task == RELS_LIST) {</span>
            <span class="plain">print "*** Domains of equivalence relations cannot be listed ***^";</span>
            <span class="plain">return X;</span>
        <span class="plain">}</span>
        <span class="plain">at = HashCoreLookUp(rel, kx, X);</span>
        <span class="plain">at2 = HashCoreLookUp(rel, kx, Y);</span>
        <span class="plain">switch(task) {</span>
            <span class="plain">RELS_TEST:</span>
                <span class="plain">if (at &lt; 0) {</span>
                    <span class="plain">! X is a loner, but could still be true if X == Y</span>
                    <span class="plain">if (KOVIsBlockValue(kx)) {</span>
                        <span class="plain">if (BlkValueCompare(X, Y) == 0) rtrue;</span>
                    <span class="plain">} else {</span>
                        <span class="plain">if (X == Y) rtrue;</span>
                    <span class="plain">}</span>
                    <span class="plain">rfalse;</span>
                <span class="plain">}</span>
                <span class="plain">if (at2 &lt; 0) rfalse;</span>
                <span class="plain">if (at == at2) rtrue;</span>
                <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);</span>
                <span class="plain">if (BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2) == tmp) rtrue;</span>
                <span class="plain">rfalse;</span>
            <span class="plain">RELS_ASSERT_TRUE:</span>
                <span class="plain">! if X and Y are the same, we have nothing to do</span>
                <span class="plain">if (KOVIsBlockValue(kx)) {</span>
                    <span class="plain">if (BlkValueCompare(X, Y) == 0) rtrue;</span>
                <span class="plain">} else {</span>
                    <span class="plain">if (X == Y) rtrue;</span>
                <span class="plain">}</span>
                <span class="plain">if (at &lt; 0) {</span>
                    <span class="plain">if (at2 &lt; 0) {</span>
                        <span class="plain">! X and Y both missing: find a new group number and add both entries</span>
                        <span class="plain">tmp = 0;		! candidate group number</span>
                        <span class="plain">ext = BlkValueRead(rel, RRV_STORAGE);</span>
                        <span class="plain">for (i=0: i&lt;=ext: i++) {</span>
                            <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 3*i);</span>
                            <span class="plain">if (fl &amp; RRF_USED) {</span>
                                <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 3*i + 2);</span>
                                <span class="plain">if (fl &gt; tmp) tmp = fl;</span>
                            <span class="plain">}</span>
                        <span class="plain">}</span>
                        <span class="plain">tmp++;			! new group number</span>
                        <span class="plain">BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 2);</span>
                        <span class="plain">! add X entry</span>
                        <span class="plain">at = ~at;</span>
                        <span class="plain">if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }</span>
                        <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);</span>
                        <span class="plain">if (fl == 0)</span>
                            <span class="plain">BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);</span>
                        <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);</span>
                        <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);</span>
                        <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);</span>
                        <span class="plain">! add Y entry. at2 might change if X and Y have the same hash code.</span>
                        <span class="plain">at2 = ~(HashCoreLookUp(rel, kx, Y));</span>
                        <span class="plain">if (KOVIsBlockValue(kx)) { Y = BlkValueCopy(BlkValueCreate(kx), Y); }</span>
                        <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2);</span>
                        <span class="plain">if (fl == 0)</span>
                            <span class="plain">BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);</span>
                        <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at2, RRF_USED+RRF_SINGLE);</span>
                        <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 1, Y);</span>
                        <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 2, tmp);</span>
                        <span class="plain">jump CheckResize;</span>
                    <span class="plain">}</span>
                    <span class="plain">! X missing, Y present: add a new X entry</span>
                    <span class="plain">at = ~at;</span>
                    <span class="plain">if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }</span>
                    <span class="plain">BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);</span>
                    <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at);</span>
                    <span class="plain">if (fl == 0)</span>
                        <span class="plain">BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);</span>
                    <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_USED+RRF_SINGLE);</span>
                    <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, X);</span>
                    <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2);</span>
                    <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, tmp);</span>
                    <span class="plain">jump CheckResize;</span>
                <span class="plain">}</span>
                <span class="plain">if (at2 &lt; 0) {</span>
                    <span class="plain">! X present, Y missing: add a new Y entry</span>
                    <span class="plain">at2 = ~at2;</span>
                    <span class="plain">if (KOVIsBlockValue(kx)) { Y = BlkValueCopy(BlkValueCreate(kx), Y); }</span>
                    <span class="plain">BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);</span>
                    <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2);</span>
                    <span class="plain">if (fl == 0)</span>
                        <span class="plain">BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);</span>
                    <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at2, RRF_USED+RRF_SINGLE);</span>
                    <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 1, Y);</span>
                    <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);</span>
                    <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at2 + 2, tmp);</span>
                    <span class="plain">jump CheckResize;</span>
                <span class="plain">}</span>
                <span class="plain">! X and Y both present: merge higher group into lower group</span>
                <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);	! higher group</span>
                <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2);	! lower group</span>
                <span class="plain">if (tmp &lt; fl) { i = tmp; tmp = fl; fl = i; }</span>
                <span class="plain">ext = BlkValueRead(rel, RRV_STORAGE);</span>
                <span class="plain">for (at=0: at&lt;=ext: at++) {</span>
                    <span class="plain">i = RRV_DATA_BASE + 3*at + 2;</span>
                    <span class="plain">if (BlkValueRead(rel, i) == tmp)</span>
                        <span class="plain">BlkValueWrite(rel, i, fl);</span>
                <span class="plain">}</span>
                <span class="plain">.CheckResize;</span>
                <span class="plain">HashCoreCheckResize(rel);</span>
                <span class="plain">rtrue;</span>
            <span class="plain">RELS_ASSERT_FALSE:</span>
                <span class="plain">! if X and Y are already in different groups, we have nothing to do</span>
                <span class="plain">if (at &lt; 0 || at2 &lt; 0) rtrue;</span>
                <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 3*at + 2);</span>
                <span class="plain">if (BlkValueRead(rel, RRV_DATA_BASE + 3*at2 + 2) ~= tmp) rtrue;</span>
                <span class="plain">! delete the entry for X</span>
                <span class="plain">BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);</span>
                <span class="plain">if (KOVIsBlockValue(kx))</span>
                    <span class="plain">BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 3*at + 1));</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at, RRF_DELETED);</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 1, 0);</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 3*at + 2, 0);</span>
                <span class="plain">rtrue;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP22"></a><b>&#167;22. Two-In-One Hash Table Relation Handler. </b>This implements one-to-one relations, which are stored as a hash table
mapping keys to single values and vice versa. To enforce the one-to-one
constraint, we need the ability to quickly check whether a value is
present. This could be done with two separate hash tables, one mapping X to Y
and one the opposite, but in the interest of conserving memory, we use a
single table for both.
</p>

<p class="inwebparagraph">Each four-word entry (F, E, K, V) consists of a flags word F, an entry
key E (which may be a "key" or "value" in the hash table sense), a
corresponding key K (when E is used as a value), and a corresponding
value V (when E is used as a key). The pair of related values (X, Y)
is represented as two table entries: (F, X, _, Y) and (F, Y, X, _).
</p>

<p class="inwebparagraph">To conserve memory when block values are used, we only create one copy
of X and/or Y to share between both entries. When adding a key or value
which already exists on either side of the relation, the previous copy will
be used. Copies are freed when they are no longer used as entry keys.
</p>

<p class="inwebparagraph">Each entry's flags word F indicates, in addition to the standard flags
<code class="display"><span class="extract">RRF_USED</span></code> and <code class="display"><span class="extract">RRF_DELETED</span></code>, also whether the entry contains a
corresponding key K and/or value V (<code class="display"><span class="extract">RRF_HASX</span></code>, <code class="display"><span class="extract">RRF_HASY</span></code>) and
whether the entry's key is the same kind of value as X or Y
(<code class="display"><span class="extract">RRF_ENTKEYX</span></code>, <code class="display"><span class="extract">RRF_ENTKEYY</span></code>). If both sides of the relation use the
same kind of value, or if both sides are word values, both <code class="display"><span class="extract">RRF_ENTKEYX</span></code>
and <code class="display"><span class="extract">RRF_ENTKEYY</span></code> will be set on every used entry.
</p>

<p class="inwebparagraph">Of particular note for this handler is the utility function <code class="display"><span class="extract">TwoInOneDelete</span></code>,
which clears one half of an entry (given its entry key), and optionally
clears the corresponding other half stored in a different entry. That is,
given the entries (F, X, _, Y) at index <code class="display"><span class="extract">i</span></code> and (F, Y, X, _) elsewhere,
<code class="display"><span class="extract">TwoInOneDelete(rel, i, kx, ky, RRF_ENTKEYX, 1)</span></code> will clear both entries
and mark them as deleted. If, however, those entries overlap with other
pairs &mdash; say they're (F, X, A, Y) and (F, Y, X, B) &mdash; then the same call
to <code class="display"><span class="extract">TwoInOneDelete</span></code> will leave us with (F, X, A, _) and (F, Y, _, B),
having cleared the parts corresponding to the pair (X, Y) but not the
parts corresponding to the pairs (A, X) and (Y, B), and will not mark
either as deleted. (Such overlap is only possible when the domains of X
and Y are the same kind of value.)
</p>


<pre class="display">
    <span class="plain">[ TwoInOneHashTableRelationHandler rel task X Y sym  kov kx ky at at2 tmp fl;</span>
        <span class="plain">kov = BlkValueRead(rel, RRV_KIND);</span>
        <span class="plain">kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);</span>
        <span class="plain">if (task == RELS_SET_VALENCY) {</span>
            <span class="plain">return RELATION_TY_SetValency(rel, X);</span>
        <span class="plain">} else if (task == RELS_DESTROY) {</span>
            <span class="plain">! clear</span>
            <span class="plain">kx = KOVIsBlockValue(kx); ky = KOVIsBlockValue(ky);</span>
            <span class="plain">if (~~(kx || ky)) return;</span>
            <span class="plain">at = BlkValueRead(rel, RRV_STORAGE);</span>
            <span class="plain">while (at &gt;= 0) {</span>
                <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);</span>
                <span class="plain">if (fl &amp; RRF_USED)</span>
                    <span class="plain">if ((kx &amp;&amp; (fl &amp; RRF_ENTKEYX)) || (ky &amp;&amp; (fl &amp; RRF_ENTKEYY))) {</span>
                        <span class="plain">BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1));</span>
                    <span class="plain">}</span>
                <span class="plain">at--;</span>
            <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">} else if (task == RELS_COPY) {</span>
            <span class="plain">X = KOVIsBlockValue(kx); Y = KOVIsBlockValue(ky);</span>
            <span class="plain">if (~~(X || Y)) return;</span>
            <span class="plain">at = BlkValueRead(rel, RRV_STORAGE);</span>
            <span class="plain">while (at &gt;= 0) {</span>
                <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);</span>
                <span class="plain">if (fl &amp; RRF_USED) {</span>
                    <span class="plain">if ((X &amp;&amp; (fl &amp; RRF_ENTKEYX)) || (Y &amp;&amp; (fl &amp; RRF_ENTKEYY))) {</span>
                        <span class="plain">! copy the entry key</span>
                        <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);</span>
                        <span class="plain">if (fl &amp; RRF_ENTKEYX)</span>
                            <span class="plain">tmp = BlkValueCopy(BlkValueCreate(kx), tmp);</span>
                        <span class="plain">else</span>
                            <span class="plain">tmp = BlkValueCopy(BlkValueCreate(ky), tmp);</span>
                        <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, tmp);</span>
                        <span class="plain">! update references in X/Y fields pointing here</span>
                        <span class="plain">if (fl &amp; RRF_HASX) {</span>
                            <span class="plain">at2 = TwoInOneLookUp(rel, kx,</span>
                                <span class="plain">BlkValueRead(rel, RRV_DATA_BASE + 4*at + 2),</span>
                                <span class="plain">RRF_ENTKEYX);</span>
                            <span class="plain">if (at2 &gt;= 0)</span>
                                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 3, tmp);</span>
                        <span class="plain">}</span>
                        <span class="plain">if (fl &amp; RRF_HASY) {</span>
                            <span class="plain">at2 = TwoInOneLookUp(rel, ky,</span>
                                <span class="plain">BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3),</span>
                                <span class="plain">RRF_ENTKEYY);</span>
                            <span class="plain">if (at2 &gt;= 0)</span>
                                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 2, tmp);</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
                <span class="plain">at--;</span>
            <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">} else if (task == RELS_SHOW) {</span>
            <span class="plain">print (string) BlkValueRead(rel, RRV_DESCRIPTION), ":^";</span>
            <span class="plain">if (sym) {</span>
                <span class="plain">kov = KOVComparisonFunction(kx);</span>
                <span class="plain">if (~~kov) kov = UnsignedCompare;</span>
            <span class="plain">}</span>
            <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);</span>
                <span class="plain">if ((fl &amp; (RRF_USED+RRF_ENTKEYX+RRF_HASY)) ==</span>
                    <span class="plain">(RRF_USED+RRF_ENTKEYX+RRF_HASY)) {</span>
                    <span class="plain">X = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);</span>
                    <span class="plain">Y = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);</span>
                    <span class="plain">if (sym &amp;&amp; kov(X, Y) &gt; 0) continue;</span>
                    <span class="plain">print "  ";</span>
                    <span class="plain">PrintKindValuePair(kx, X);</span>
                    <span class="plain">if (sym) print " &lt;=&gt; "; else print " &gt;=&gt; ";</span>
                    <span class="plain">PrintKindValuePair(ky, Y);</span>
                    <span class="plain">print "^";</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">} else if (task == RELS_EMPTY) {</span>
            <span class="plain">if (BlkValueRead(rel, RRV_USED) == 0) rtrue;</span>
            <span class="plain">if (X == 1) {</span>
                <span class="plain">TwoInOneHashTableRelationHandler(rel, RELS_DESTROY);</span>
                <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                    <span class="plain">tmp = RRV_DATA_BASE + 4*at;</span>
                    <span class="plain">BlkValueWrite(rel, tmp, 0);</span>
                    <span class="plain">BlkValueWrite(rel, tmp + 1, 0);</span>
                    <span class="plain">BlkValueWrite(rel, tmp + 2, 0);</span>
                    <span class="plain">BlkValueWrite(rel, tmp + 3, 0);</span>
                <span class="plain">}</span>
                <span class="plain">BlkValueWrite(rel, RRV_USED, 0);</span>
                <span class="plain">BlkValueWrite(rel, RRV_FILLED, 0);</span>
                <span class="plain">rtrue;</span>
            <span class="plain">}</span>
            <span class="plain">rfalse;</span>
        <span class="plain">} else if (task == RELS_LOOKUP_ANY) {</span>
            <span class="plain">switch (Y) {</span>
                <span class="plain">RLANY_GET_X, RLANY_CAN_GET_X:</span>
                    <span class="plain">at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY);</span>
                    <span class="plain">if (at &gt;= 0) {</span>
                        <span class="plain">tmp = RRV_DATA_BASE + 4*at;</span>
                        <span class="plain">if (BlkValueRead(rel, tmp) &amp; RRF_HASX) {</span>
                            <span class="plain">if (Y == RLANY_CAN_GET_X) rtrue;</span>
                            <span class="plain">return BlkValueRead(rel, tmp + 2);</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                <span class="plain">RLANY_GET_Y, RLANY_CAN_GET_Y:</span>
                    <span class="plain">at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);</span>
                    <span class="plain">if (at &gt;= 0) {</span>
                        <span class="plain">tmp = RRV_DATA_BASE + 4*at;</span>
                        <span class="plain">if (BlkValueRead(rel, tmp) &amp; RRF_HASY) {</span>
                            <span class="plain">if (Y == RLANY_CAN_GET_Y) rtrue;</span>
                            <span class="plain">return BlkValueRead(rel, tmp + 3);</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">if (Y == RLANY_GET_X or RLANY_GET_Y)</span>
                <span class="plain">print "*** Lookup failed: value not found ***^";</span>
            <span class="plain">rfalse;</span>
        <span class="plain">} else if (task == RELS_LOOKUP_ALL_X) {</span>
            <span class="plain">at = TwoInOneLookUp(rel, ky, X, RRF_ENTKEYY);</span>
            <span class="plain">if (at &gt;= 0) {</span>
                <span class="plain">tmp = RRV_DATA_BASE + 4*at;</span>
                <span class="plain">if (BlkValueRead(rel, tmp) &amp; RRF_HASX)</span>
                    <span class="plain">LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 2));</span>
            <span class="plain">}</span>
            <span class="plain">return Y;</span>
        <span class="plain">} else if (task == RELS_LOOKUP_ALL_Y) {</span>
            <span class="plain">at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);</span>
            <span class="plain">if (at &gt;= 0) {</span>
                <span class="plain">tmp = RRV_DATA_BASE + 4*at;</span>
                <span class="plain">if (BlkValueRead(rel, tmp) &amp; RRF_HASY)</span>
                    <span class="plain">LIST_OF_TY_InsertItem(Y, BlkValueRead(rel, tmp + 3));</span>
            <span class="plain">}</span>
            <span class="plain">return Y;</span>
        <span class="plain">} else if (task == RELS_LIST) {</span>
            <span class="plain">switch (Y) {</span>
                <span class="plain">RLIST_ALL_X:</span>
                    <span class="plain">fl = RRF_USED+RRF_ENTKEYX+RRF_HASY;</span>
                    <span class="plain">jump ListEntryKeys;</span>
                <span class="plain">RLIST_ALL_Y:</span>
                    <span class="plain">fl = RRF_USED+RRF_ENTKEYY+RRF_HASX;</span>
                    <span class="plain">.ListEntryKeys;</span>
                    <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                        <span class="plain">tmp = RRV_DATA_BASE + 4*at;</span>
                        <span class="plain">if ((BlkValueRead(rel, tmp) &amp; fl) == fl)</span>
                            <span class="plain">LIST_OF_TY_InsertItem(X, BlkValueRead(rel, tmp + 1), false, 0, true);</span>
                    <span class="plain">}</span>
                <span class="plain">RLIST_ALL_PAIRS:</span>
                    <span class="plain">tmp = BlkValueRead(X, LIST_ITEM_KOV_F);</span>
                    <span class="plain">if (KindAtomic(tmp) ~= COMBINATION_TY) rfalse;</span>
                    <span class="plain">! LIST_OF_TY_InsertItem will make a deep copy of the item,</span>
                    <span class="plain">! so we can reuse a single combination value here</span>
                    <span class="plain">Y = BlkValueCreate(tmp);</span>
                    <span class="plain">for (at = BlkValueRead(rel, RRV_STORAGE): at &gt;= 0: at--) {</span>
                        <span class="plain">tmp = RRV_DATA_BASE + 4*at;</span>
                        <span class="plain">fl = BlkValueRead(rel, tmp);</span>
                        <span class="plain">if ((fl &amp; (RRF_USED+RRF_ENTKEYX+RRF_HASY)) ==</span>
                            <span class="plain">(RRF_USED+RRF_ENTKEYX+RRF_HASY)) {</span>
                            <span class="plain">BlkValueWrite(Y, COMBINATION_ITEM_BASE, BlkValueRead(rel, tmp + 1));</span>
                            <span class="plain">BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, BlkValueRead(rel, tmp + 3));</span>
                            <span class="plain">LIST_OF_TY_InsertItem(X, Y);</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                    <span class="plain">BlkValueWrite(Y, COMBINATION_ITEM_BASE, 0);</span>
                    <span class="plain">BlkValueWrite(Y, COMBINATION_ITEM_BASE + 1, 0);</span>
                    <span class="plain">BlkValueFree(Y);</span>
                    <span class="plain">return X;</span>
            <span class="plain">}</span>
            <span class="plain">return X;</span>
        <span class="plain">}</span>
        <span class="plain">at = TwoInOneLookUp(rel, kx, X, RRF_ENTKEYX);</span>
        <span class="plain">switch(task) {</span>
            <span class="plain">RELS_TEST:</span>
                <span class="plain">if (at &lt; 0) rfalse;</span>
                <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);</span>
                <span class="plain">if (~~(fl &amp; RRF_HASY)) rfalse;</span>
                <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);</span>
                <span class="plain">if (KOVIsBlockValue(ky)) {</span>
                    <span class="plain">if (BlkValueCompare(tmp, Y) == 0) rtrue;</span>
                <span class="plain">} else {</span>
                    <span class="plain">if (tmp == Y) rtrue;</span>
                <span class="plain">}</span>
                <span class="plain">rfalse;</span>
            <span class="plain">RELS_ASSERT_TRUE:</span>
                <span class="plain">if (at &lt; 0) {</span>
                    <span class="plain">! create a new forward entry</span>
                    <span class="plain">at = ~at;</span>
                    <span class="plain">BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);</span>
                    <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);</span>
                    <span class="plain">if (fl == 0)</span>
                        <span class="plain">BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);</span>
                    <span class="plain">fl = RRF_USED+RRF_HASY+RRF_ENTKEYX;</span>
                    <span class="plain">if (kx == ky || ~~(KOVIsBlockValue(kx) || KOVIsBlockValue(ky)))</span>
                        <span class="plain">fl = fl + RRF_ENTKEYY;</span>
                    <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl);</span>
                    <span class="plain">if (KOVIsBlockValue(kx)) { X = BlkValueCopy(BlkValueCreate(kx), X); }</span>
                    <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, X);</span>
                    <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, 0);</span>
                <span class="plain">} else {</span>
                    <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);</span>
                    <span class="plain">if (fl &amp; RRF_HASY) {</span>
                        <span class="plain">! if the Y we're inserting is already there, we're done</span>
                        <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);</span>
                        <span class="plain">if (KOVIsBlockValue(ky)) {</span>
                            <span class="plain">if (BlkValueCompare(tmp, Y) == 0) rtrue;</span>
                        <span class="plain">} else {</span>
                            <span class="plain">if (tmp == Y) rtrue;</span>
                        <span class="plain">}</span>
                        <span class="plain">! it's different, so delete the reverse entry</span>
                        <span class="plain">at2 = TwoInOneLookUp(rel, ky, tmp, RRF_ENTKEYY);</span>
                        <span class="plain">if (at2 &gt;= 0) TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);</span>
                    <span class="plain">} else {</span>
                        <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl + RRF_HASY);</span>
                    <span class="plain">}</span>
                    <span class="plain">! use the existing copy of X</span>
                    <span class="plain">X = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);</span>
                <span class="plain">}</span>
                <span class="plain">! use the existing copy of Y if there is one</span>
                <span class="plain">at2 = TwoInOneLookUp(rel, ky, Y, RRF_ENTKEYY);</span>
                <span class="plain">if (KOVIsBlockValue(ky)) {</span>
                    <span class="plain">if (at2 &gt;= 0)</span>
                        <span class="plain">Y = BlkValueRead(rel, RRV_DATA_BASE + 4*at2 + 1);</span>
                    <span class="plain">else</span>
                        <span class="plain">Y = BlkValueCopy(BlkValueCreate(ky), Y);</span>
                <span class="plain">}</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, Y);</span>
                <span class="plain">if (at2 &gt;= 0) {</span>
                    <span class="plain">! delete existing reverse entry (and its own forward entry)</span>
                    <span class="plain">TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY, 1);</span>
                <span class="plain">} else {</span>
                    <span class="plain">at2 = ~at2;</span>
                <span class="plain">}</span>
                <span class="plain">! create reverse entry</span>
                <span class="plain">BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) + 1);</span>
                <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at2);</span>
                <span class="plain">if (fl == 0)</span>
                    <span class="plain">BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_FILLED) + 1);</span>
                <span class="plain">fl = fl | (RRF_USED+RRF_HASX+RRF_ENTKEYY);</span>
                <span class="plain">if (kx == ky || ~~(KOVIsBlockValue(kx) || KOVIsBlockValue(ky)))</span>
                    <span class="plain">fl = fl | RRF_ENTKEYX;</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at2, fl);</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 1, Y);</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at2 + 2, X);</span>
                <span class="plain">TwoInOneCheckResize(rel);</span>
                <span class="plain">rtrue;</span>
            <span class="plain">RELS_ASSERT_FALSE:</span>
                <span class="plain">! we only have work to do if the entry exists and has a Y which</span>
                <span class="plain">! matches the Y we're deleting</span>
                <span class="plain">if (at &lt; 0) rtrue;</span>
                <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);</span>
                <span class="plain">if ((fl &amp; RRF_HASY) == 0) rtrue;</span>
                <span class="plain">tmp = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 3);</span>
                <span class="plain">if (KOVIsBlockValue(ky)) {</span>
                    <span class="plain">if (BlkValueCompare(tmp, Y) ~= 0) rtrue;</span>
                <span class="plain">} else {</span>
                    <span class="plain">if (tmp ~= Y) rtrue;</span>
                <span class="plain">}</span>
                <span class="plain">TwoInOneDelete(rel, at, kx, ky, RRF_ENTKEYX, 1);</span>
                <span class="plain">rtrue;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ TwoInOneDelete rel at kx ky ekflag both  fl at2 E i;</span>
    <span class="plain">!print "[2in1DEL at=", at, " (E=", BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1), ") ekflag=", ekflag, " both=", both, "]^";</span>
        <span class="plain">fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);</span>
        <span class="plain">if (ekflag == RRF_ENTKEYX) {</span>
            <span class="plain">if (fl &amp; RRF_HASY) {</span>
                <span class="plain">i = RRV_DATA_BASE + 4*at + 3;</span>
                <span class="plain">if (both) E = BlkValueRead(rel, i);</span>
                <span class="plain">BlkValueWrite(rel, i, 0);</span>
                <span class="plain">! delete matching Y&lt;-X entry if needed</span>
                <span class="plain">if (both) {</span>
                    <span class="plain">at2 = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY);</span>
                    <span class="plain">if (at2 &gt;= 0) TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYY);</span>
                    <span class="plain">if (at2 == at) fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);</span>
                <span class="plain">}</span>
                <span class="plain">fl = fl &amp; ~RRF_HASY;</span>
            <span class="plain">}</span>
        <span class="plain">} else {</span>
            <span class="plain">if (fl &amp; RRF_HASX) {</span>
                <span class="plain">i = RRV_DATA_BASE + 4*at + 2;</span>
                <span class="plain">if (both) E = BlkValueRead(rel, i);</span>
                <span class="plain">BlkValueWrite(rel, i, 0);</span>
                <span class="plain">! delete matching X-&gt;Y entry if needed</span>
                <span class="plain">if (both) {</span>
                    <span class="plain">at2 = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX);</span>
                    <span class="plain">if (at2 &gt;= 0) {</span>
                        <span class="plain">TwoInOneDelete(rel, at2, kx, ky, RRF_ENTKEYX);</span>
                        <span class="plain">if (at2 == at) fl = BlkValueRead(rel, RRV_DATA_BASE + 4*at);</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
                <span class="plain">fl = fl &amp; ~RRF_HASX;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">if ((fl &amp; (RRF_HASX+RRF_HASY)) == 0) {</span>
            <span class="plain">! entry is now empty, mark it deleted</span>
            <span class="plain">if (((fl &amp; RRF_ENTKEYX) &amp;&amp; KOVIsBlockValue(kx)) ||</span>
                <span class="plain">((ky ~= kx) &amp;&amp; (fl &amp; RRF_ENTKEYY) &amp;&amp; KOVIsBlockValue(ky))) {</span>
                <span class="plain">BlkValueFree(BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1));</span>
            <span class="plain">}</span>
            <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at, RRF_DELETED);</span>
            <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, 0);</span>
            <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, 0);</span>
            <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, 0);</span>
            <span class="plain">BlkValueWrite(rel, RRV_USED, BlkValueRead(rel, RRV_USED) - 1);</span>
        <span class="plain">} else {</span>
            <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at, fl);</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ TwoInOneLookUp rel ke E ekflag  hashv i free mask perturb flags;</span>
    <span class="plain">!print "[2in1LU rel=", rel, " ke=", ke, " E=", E, " ekf=", ekflag, ": ";</span>
        <span class="plain">! calculate a hash value for the key</span>
        <span class="plain">hashv = GetHashValue(ke, E);</span>
        <span class="plain">! look in the first expected slot</span>
        <span class="plain">mask = BlkValueRead(rel, RRV_STORAGE);</span>
        <span class="plain">i = hashv &amp; mask;</span>
    <span class="plain">!print "hv=", hashv, ", trying ", i;</span>
        <span class="plain">flags = BlkValueRead(rel, RRV_DATA_BASE + 4*i);</span>
        <span class="plain">if (flags == 0) {</span>
    <span class="plain">!print " - not found]^";</span>
            <span class="plain">return ~i;</span>
        <span class="plain">}</span>
        <span class="plain">if ((flags &amp; ekflag) &amp;&amp; TwoInOneEntryMatches(rel, i, ke, E)) {</span>
    <span class="plain">!print " - found]^";</span>
            <span class="plain">return i;</span>
        <span class="plain">}</span>
        <span class="plain">! not here, keep looking in sequence</span>
        <span class="plain">free = -1;</span>
        <span class="plain">if (flags &amp; RRF_DELETED) free = i;</span>
        <span class="plain">perturb = hashv;</span>
        <span class="plain">hashv = i;</span>
        <span class="plain">for (::) {</span>
            <span class="plain">hashv = hashv*5 + perturb + 1;</span>
            <span class="plain">i = hashv &amp; mask;</span>
    <span class="plain">!print ", ", i;</span>
            <span class="plain">flags = BlkValueRead(rel, RRV_DATA_BASE + 4*i);</span>
            <span class="plain">if (flags == 0) {</span>
    <span class="plain">!print " - not found]^";</span>
                <span class="plain">if (free &gt;= 0) return ~free;</span>
                <span class="plain">return ~i;</span>
            <span class="plain">}</span>
            <span class="plain">if ((flags &amp; ekflag) &amp;&amp; TwoInOneEntryMatches(rel, i, ke, E)) {</span>
    <span class="plain">!print " - found]^";</span>
                <span class="plain">return i;</span>
            <span class="plain">}</span>
            <span class="plain">if ((free &lt; 0) &amp;&amp; (flags &amp; RRF_DELETED)) free = i;</span>
            <span class="plain">#ifdef TARGET_ZCODE;</span>
            <span class="plain">@log_shift perturb MINUS_RRP_PERTURB_SHIFT -&gt; perturb;</span>
            <span class="plain">#ifnot;</span>
            <span class="plain">@ushiftr perturb RRP_PERTURB_SHIFT perturb;</span>
            <span class="plain">#endif;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ TwoInOneCheckResize rel  filled ext newext temp i at kov kx ky F E X Y;</span>
        <span class="plain">filled = BlkValueRead(rel, RRV_FILLED);</span>
        <span class="plain">ext = BlkValueRead(rel, RRV_STORAGE) + 1;</span>
        <span class="plain">if (filled &gt;= (ext - filled) * RRP_CROWDED_IS) {</span>
            <span class="plain">! copy entries to temporary space</span>
            <span class="plain">temp = FlexAllocate(ext * (4*WORDSIZE), TEXT_TY, BLK_FLAG_WORD+BLK_FLAG_MULTIPLE);</span>
            <span class="plain">for (i=0: i&lt;ext*4: i++)</span>
                <span class="plain">BlkValueWrite(temp, i, BlkValueRead(rel, RRV_DATA_BASE+i), true);</span>
            <span class="plain">! resize and clear our data</span>
            <span class="plain">if (ext &gt;= RRP_LARGE_IS) newext = ext * RRP_RESIZE_LARGE;</span>
            <span class="plain">else newext = ext * RRP_RESIZE_SMALL;</span>
            <span class="plain">BlkValueSetLBCapacity(rel, RRV_DATA_BASE + newext*4);</span>
            <span class="plain">BlkValueWrite(rel, RRV_STORAGE, newext - 1);</span>
            <span class="plain">BlkValueWrite(rel, RRV_FILLED, BlkValueRead(rel, RRV_USED));</span>
            <span class="plain">for (i=0: i&lt;newext*4: i++)</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE+i, 0);</span>
            <span class="plain">! copy entries back from temporary space</span>
            <span class="plain">kov = BlkValueRead(rel, RRV_KIND);</span>
            <span class="plain">kx = KindBaseTerm(kov, 0); ky = KindBaseTerm(kov, 1);</span>
            <span class="plain">for (i=0: i&lt;ext: i++) {</span>
                <span class="plain">F = BlkValueRead(temp, 4*i, true);</span>
                <span class="plain">if (F == 0 || (F &amp; RRF_DELETED)) continue;</span>
                <span class="plain">E = BlkValueRead(temp, 4*i + 1, true);</span>
                <span class="plain">X = BlkValueRead(temp, 4*i + 2, true);</span>
                <span class="plain">Y = BlkValueRead(temp, 4*i + 3, true);</span>
                <span class="plain">if (F &amp; RRF_ENTKEYX) at = TwoInOneLookUp(rel, kx, E, RRF_ENTKEYX);</span>
                <span class="plain">else at = TwoInOneLookUp(rel, ky, E, RRF_ENTKEYY);</span>
                <span class="plain">if (at &gt;= 0) { print "*** Duplicate entry while resizing ***^"; rfalse; }</span>
                <span class="plain">at = ~at;</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at, F);</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 1, E);</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 2, X);</span>
                <span class="plain">BlkValueWrite(rel, RRV_DATA_BASE + 4*at + 3, Y);</span>
            <span class="plain">}</span>
            <span class="plain">! done with temporary space</span>
            <span class="plain">FlexFree(temp);</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ TwoInOneEntryMatches rel at ke E  ce;</span>
        <span class="plain">ce = BlkValueRead(rel, RRV_DATA_BASE + 4*at + 1);</span>
        <span class="plain">if (KOVIsBlockValue(ke)) {</span>
            <span class="plain">if (BlkValueCompare(ce, E) ~= 0) rfalse;</span>
        <span class="plain">} else {</span>
            <span class="plain">if (ce ~= E) rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP23"></a><b>&#167;23. Empty. </b>This implements the "empty" adjective. We can always check whether a relation
is empty. For most relation types, we can cause the relation to become empty by
removing all pairs: but this is impossible for equivalence relations, which are
never empty, since any X is equivalent to itself. And we can never force a
relation to become non-empty, since that would require making up data.
</p>

<p class="inwebparagraph">In any case, the implementation is delegated to the relation handler.
</p>


<pre class="display">
    <span class="plain">[ RELATION_TY_Empty rel set  handler;</span>
        <span class="plain">handler = RlnGetF(rel, RR_HANDLER);</span>
        <span class="plain">return handler(rel, RELS_EMPTY, set);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="S-rt.html">Back to 'RegExp Template'</a></li><li><a href="S-rt2.html">Continue with 'Relations Template'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

