<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>S/st</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of 'S/tt' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">basic_inform Template Library</a></li><li><b>Tables Template</b></li></ul><p class="purpose">To read, write, search and allocate rows in the Table data structure.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Format</a></li><li><a href="#SP2">&#167;2. Find Column</a></li><li><a href="#SP3">&#167;3. Number of Rows</a></li><li><a href="#SP4">&#167;4. Blanks</a></li><li><a href="#SP5">&#167;5. Masks</a></li><li><a href="#SP6">&#167;6. Testing Blankness</a></li><li><a href="#SP7">&#167;7. Force Entry Blank</a></li><li><a href="#SP8">&#167;8. Force Entry Non-Blank</a></li><li><a href="#SP9">&#167;9. Swapping Blank Bits</a></li><li><a href="#SP10">&#167;10. Moving Blank Bits Down</a></li><li><a href="#SP11">&#167;11. Table Row Corresponding</a></li><li><a href="#SP12">&#167;12. Table Look Up Corresponding Row</a></li><li><a href="#SP13">&#167;13. Table Look Up Entry</a></li><li><a href="#SP14">&#167;14. Blank Rows</a></li><li><a href="#SP15">&#167;15. Random Row</a></li><li><a href="#SP16">&#167;16. Swap Rows</a></li><li><a href="#SP17">&#167;17. Compare Rows</a></li><li><a href="#SP18">&#167;18. Move Row Down</a></li><li><a href="#SP19">&#167;19. Shuffle</a></li><li><a href="#SP20">&#167;20. Next Row</a></li><li><a href="#SP21">&#167;21. Move Blanks to Back</a></li><li><a href="#SP22">&#167;22. Sort</a></li><li><a href="#SP23">&#167;23. Print Table to File</a></li><li><a href="#SP24">&#167;24. Read Table from File</a></li><li><a href="#SP25">&#167;25. Debugging</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Format. </b>The I7 Table structure is not to be confused with the I6 <code class="display"><span class="extract">table</span></code> form of
array: it is essentially a two-dimensional array which has some metadata
at the top of each column.
</p>

<p class="inwebparagraph">The run-time representation for a Table is the address <code class="display"><span class="extract">T</span></code> of an I6 <code class="display"><span class="extract">table</span></code>
array: that is, <code class="display"><span class="extract">T--&gt;0</span></code> holds the number of columns (which is at most 99)
and <code class="display"><span class="extract">T--&gt;i</span></code> is the address of column number <code class="display"><span class="extract">i</span></code>. Columns are therefore
numbered from 1 to <code class="display"><span class="extract">T--&gt;0</span></code>, but they are also identified by an ID number of
100 or more, with each different column name having its own ID number.
(This is so that multiple tables can share columns with the same name, and
correlate them: it also means that NI's type-checking machinery can know
the kind of value of a table entry from the name of the column alone.)
</p>

<p class="inwebparagraph">Each column <code class="display"><span class="extract">C</span></code> is also a <code class="display"><span class="extract">table</span></code> array, with <code class="display"><span class="extract">C--&gt;1</span></code> holding the unique
ID number for the column's name, <code class="display"><span class="extract">C--&gt;2</span></code> holding the blank entry flags
offset and <code class="display"><span class="extract">C--&gt;3</span></code> up to <code class="display"><span class="extract">C--&gt;(C--&gt;0)</span></code> holding the entries.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">C--&gt;1</span></code> also contains seven upper bit flags. These are also defined in
"Tables.w" in the NI source, and the values must agree.
</p>


<pre class="display">
    <span class="plain">Constant TB_COLUMN_REAL        $8000;</span>
    <span class="plain">Constant TB_COLUMN_SIGNED      $4000;</span>
    <span class="plain">Constant TB_COLUMN_TOPIC       $2000;</span>
    <span class="plain">Constant TB_COLUMN_DONTSORTME  $1000;</span>
    <span class="plain">Constant TB_COLUMN_NOBLANKBITS $0800;</span>
    <span class="plain">Constant TB_COLUMN_CANEXCHANGE $0400;</span>
    <span class="plain">Constant TB_COLUMN_ALLOCATED   $0200;</span>
    <span class="plain">Constant TB_COLUMN_NUMBER      $01ff; ! Mask to remove upper bit flags</span>

    <span class="plain">Constant COL_HSIZE 2; ! Column header size: two words (ID/flags, blank bits)</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Find Column. </b>Columns can be referenced either by their physical column numbers &mdash; from 1
to, potentially, 99 &mdash; or else by unique ID numbers associated with column
names. For instance, if a table has a column called "liquid capacity",
then all references to its "liquid capacity entry" are via the ID number
associated with this column name, which will be &gt;= 100 and on the other
hand &lt;= <code class="display"><span class="extract">TB_COLUMN_NUMBER</span></code>. At present, this is only 511, so there can
be at most 411 different column names across all the tables present in the
source text. (It is just about possible to imagine this being a problem on
a very large work, so we will probably one day revise the above to make
use of the larger word-size in Glulx and so raise this limit. But so far
nobody has got even close to it.)
</p>


<pre class="display">
    <span class="plain">[ TableFindCol tab col f i no_cols n;</span>
        <span class="plain">no_cols = tab--&gt;0;</span>
        <span class="plain">for (i=1: i&lt;=no_cols: i++)</span>
            <span class="plain">if (col == ((tab--&gt;i)--&gt;1) &amp; TB_COLUMN_NUMBER) return i;</span>
        <span class="plain">if (f) { RunTimeProblem(RTP_TABLE_NOCOL, tab); return 0; }</span>
        <span class="plain">return 0;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. Number of Rows. </b>The columns in a table can be assumed all to have the same height (i.e.,
number of rows): thus the number of rows in <code class="display"><span class="extract">T</span></code> can be calculated by
looking at column 1, thus...
</p>


<pre class="display">
    <span class="plain">[ TableRows tab first_col;</span>
        <span class="plain">first_col = tab--&gt;1; if (first_col == 0) return 0;</span>
        <span class="plain">return (first_col--&gt;0) - COL_HSIZE;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Blanks. </b>Each table entry is stored in a single word in memory: indeed, column <code class="display"><span class="extract">C</span></code>
row <code class="display"><span class="extract">R</span></code> is at address <code class="display"><span class="extract">(T--&gt;C)--&gt;(R+COL_HSIZE)</span></code>.
</p>

<p class="inwebparagraph">But this is not sufficient storage in all cases, because each entry can be
either a value or can be designated "blank". Since, for some columns at
least, the possible values include every number, we find that we have to
store 2^{16}+1 possibilities given only a 16-bit memory word. (Well, or
2^{32}+1 with a 32-bit word, depending on the virtual machine.) This
cannot be done.
</p>

<p class="inwebparagraph">We therefore need, at least in some cases, an additional bit of storage for
each table entry which indicates whether or not it is blank. If we provided
such a bit for every table entry, that would be a fairly simple system to
implement, but it would also be wasteful of memory, with an overhead of
about 5\% in practice: and memory in the virtual machine is in very short
supply. The reason such a system would be wasteful is that many columns
are known to hold values which are in a narrow range; for instance, a time
of day cannot exceed 1440, and there will never be more than 10,000 rulebooks
or scenes, and so on. For such columns it would be more efficient and indeed
faster to indicate blankness by using an exceptional value in the memory
cell which is such that it cannot be valid for the kind of value stored
in the column. We therefore provide a "blanks bitmap" for only some
columns.
</p>

<p class="inwebparagraph">This leads us to define the following dummy value, chosen so that it is
both impossible for most kinds of value &mdash; which is easy to arrange &mdash; and
also unlikely for even those kinds of value where it is legal. For
instance, -1 would be impossible for enumerative kinds of value such as
rulebooks and scenes, but it would be a poor choice for the dummy value
because it occurs pretty often as an integer. Instead we use the constant
<code class="display"><span class="extract">IMPROBABLE_VALUE</span></code>, whose value depends on the word size of the virtual
machine, and which is declared in "Definitions.i6t".
</p>

<p class="inwebparagraph">An entry is therefore blank if and only if either
</p>

<ul class="items"><li>(a) its column has no blanks bitmap and the stored entry is <code class="display"><span class="extract">TABLE_NOVALUE</span></code>, or
</li><li>(b) its column does have a blanks bitmap, the blanks bit for this entry is set,
and the stored entry is also <code class="display"><span class="extract">TABLE_NOVALUE</span></code>.
</li></ul>
<p class="inwebparagraph">To look up the blanks bitmap is a little slower than to access the stored
entry directly. Most of the time, entries accessed will be non-blank: so it
is efficient to have a system where we can quickly determine this. If we
look at the entry and find that it is not <code class="display"><span class="extract">TABLE_NOVALUE</span></code>, then we know
it is not a blank. If we find that it is <code class="display"><span class="extract">TABLE_NOVALUE</span></code>, on the other
hand, then quite often the column has no blanks bitmap and again we have
a quick answer: it's blank. Only if the column also has a blanks bitmap do
we need to check that we haven't got a false negative. (The more improbable
<code class="display"><span class="extract">TABLE_NOVALUE</span></code> is as a stored value, the rarer it is that we have to
check the blanks bitmap for a non-blank entry.)
</p>


<pre class="display">
    <span class="plain">Constant TABLE_NOVALUE = IMPROBABLE_VALUE;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Masks. </b>The blanks bitmaps are stored as bytes; we therefore need a quick way to
test or set whether bit number i of a byte is zero, where 0&lt;= i&lt;= 7.
I6 provides no very useful operators here, whereas memory lookup is cheap,
so we use two arrays of bitmaps:
</p>


<pre class="display">
    <span class="plain">Array CheckTableEntryIsBlank_LU</span>
        <span class="plain">-&gt;	$$00000001</span>
            <span class="plain">$$00000010</span>
            <span class="plain">$$00000100</span>
            <span class="plain">$$00001000</span>
            <span class="plain">$$00010000</span>
            <span class="plain">$$00100000</span>
            <span class="plain">$$01000000</span>
            <span class="plain">$$10000000;</span>
    <span class="plain">Array CheckTableEntryIsNonBlank_LU</span>
        <span class="plain">-&gt;	$$11111110</span>
            <span class="plain">$$11111101</span>
            <span class="plain">$$11111011</span>
            <span class="plain">$$11110111</span>
            <span class="plain">$$11101111</span>
            <span class="plain">$$11011111</span>
            <span class="plain">$$10111111</span>
            <span class="plain">$$01111111;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Testing Blankness. </b>The following routine is the one which checks that there is no false negative:
it should be used when we know that the table entry is <code class="display"><span class="extract">TABLE_NOVALUE</span></code>
and we need to check the blank bit, if there is one, to make sure the entry
is indeed blank.
</p>

<p class="inwebparagraph">The second word in the column table header, <code class="display"><span class="extract">C--&gt;2</span></code>, holds the address of the
blanks bitmap: this in turn contains one bit for each row, starting with the
least significant bit of the first byte. If the table contains a number of
rows which isn't a multiple of 8, the spare bits at the end of the last byte
in the blanks bitmap are wasted, but this is an acceptable overhead in
practice.
</p>


<pre class="display">
    <span class="plain">[ CheckTableEntryIsBlank tab col row i at;</span>
        <span class="plain">if (col &gt;= 100) col = TableFindCol(tab, col);</span>
        <span class="plain">if (col == 0) rtrue;</span>
        <span class="plain">if ((tab--&gt;col)--&gt;(row+COL_HSIZE) ~= TABLE_NOVALUE) {</span>
            <span class="plain">print "*** CTEIB on nonblank value ", tab, " ", col, " ", row, " ***^";</span>
        <span class="plain">}</span>
        <span class="plain">if (((tab--&gt;col)--&gt;1) &amp; TB_COLUMN_NOBLANKBITS) rtrue;</span>
        <span class="plain">row--;</span>
        <span class="plain">at = ((tab--&gt;col)--&gt;2) + (row/8);</span>
        <span class="plain">if ((TB_Blanks-&gt;at) &amp; (CheckTableEntryIsBlank_LU-&gt;(row%8))) rtrue;</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Force Entry Blank. </b>We blank a table cell by storing <code class="display"><span class="extract">TABLE_NOVALUE</span></code> in its entry word and
also setting the relevant bit in the blanks bitmap, if there is one.
</p>

<p class="inwebparagraph">We need to be careful if the column holds a kind of value where values are
pointers to blocks of allocated memory, because if so then overwriting such
a value might lead to a memory leak. So in such cases we call <code class="display"><span class="extract">BlkValueFree</span></code>
to free the memory block. (Note that each memory block is pointed to by one
and only one I7 value at any given time: we are using them as values, not
pointers to values. So if this reference is deleted, it's by definition the
only one.) <code class="display"><span class="extract">TABLE_NOVALUE</span></code> is chosen such that it cannot be an address
of a memory block, which is convenient here. (The value 0 means "no memory
block allocated yet".)
</p>


<pre class="display">
    <span class="plain">[ ForceTableEntryBlank tab col row i at oldv flags;</span>
        <span class="plain">if (col &gt;= 100) col = TableFindCol(tab, col);</span>
        <span class="plain">if (col == 0) rtrue;</span>
        <span class="plain">flags = (tab--&gt;col)--&gt;1;</span>
        <span class="plain">oldv = (tab--&gt;col)--&gt;(row+COL_HSIZE);</span>
        <span class="plain">if ((flags &amp; TB_COLUMN_ALLOCATED) &amp;&amp; (oldv ~= 0 or TABLE_NOVALUE))</span>
            <span class="plain">BlkValueFree(oldv);</span>
        <span class="plain">(tab--&gt;col)--&gt;(row+COL_HSIZE) = TABLE_NOVALUE;</span>
        <span class="plain">if (flags &amp; TB_COLUMN_NOBLANKBITS) return;</span>
        <span class="plain">row--;</span>
        <span class="plain">at = ((tab--&gt;col)--&gt;2) + (row/8);</span>
        <span class="plain">(TB_Blanks-&gt;at) = (TB_Blanks-&gt;at) | (CheckTableEntryIsBlank_LU-&gt;(row%8));</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Force Entry Non-Blank. </b>To unblank a cell, we need to clear the relevant bit in the bitmap. We then
go on to write a new value in to the entry &mdash; thus overwriting the
<code class="display"><span class="extract">TABLE_NOVALUE</span></code> value &mdash; but that isn't done here; the expectation is
that whoever calls this routine is just about to write a new entry anyway.
</p>

<p class="inwebparagraph">The exception is again for columns holding a kind of value pointing to a
memory block, where we create a suitable initialised but uninteresting
memory block for the KOV in question, and set the entry to that.
</p>


<pre class="display">
    <span class="plain">[ ForceTableEntryNonBlank tab col row i at oldv flags tc kov;</span>
        <span class="plain">if (col &gt;= 100) col=TableFindCol(tab, col);</span>
        <span class="plain">if (col == 0) rtrue;</span>
        <span class="plain">if (((tab--&gt;col)--&gt;1) &amp; TB_COLUMN_NOBLANKBITS) return;</span>
        <span class="plain">flags = (tab--&gt;col)--&gt;1;</span>
        <span class="plain">oldv = (tab--&gt;col)--&gt;(row+COL_HSIZE);</span>
        <span class="plain">if ((flags &amp; TB_COLUMN_ALLOCATED) &amp;&amp;</span>
            <span class="plain">(oldv == 0 or TABLE_NOVALUE)) {</span>
            <span class="plain">kov = UNKNOWN_TY;</span>
            <span class="plain">tc = ((tab--&gt;col)--&gt;1) &amp; TB_COLUMN_NUMBER;</span>
            <span class="plain">kov = TC_KOV(tc);</span>
            <span class="plain">if (kov ~= UNKNOWN_TY) {</span>
                <span class="plain">(tab--&gt;col)--&gt;(row+COL_HSIZE) = BlkValueCreate(kov);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">row--;</span>
        <span class="plain">at = ((tab--&gt;col)--&gt;2) + (row/8);</span>
        <span class="plain">(TB_Blanks-&gt;at) = (TB_Blanks-&gt;at) &amp; (CheckTableEntryIsNonBlank_LU-&gt;(row%8));</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Swapping Blank Bits. </b>When sorting a table, we obviously need to swap rows from time to time; if
any of its columns have blanks bitmaps, then the relevant bits in them
need to be swapped to match, and the following routine performs this operation
for two rows in a given column.
</p>


<pre class="display">
    <span class="plain">[ TableSwapBlankBits tab row1 row2 col at1 at2 bit1 bit2;</span>
        <span class="plain">if (col &gt;= 100) col=TableFindCol(tab, col);</span>
        <span class="plain">if (col == 0) rtrue;</span>
        <span class="plain">if (((tab--&gt;col)--&gt;1) &amp; TB_COLUMN_NOBLANKBITS) return;</span>
        <span class="plain">row1--;</span>
        <span class="plain">at1 = ((tab--&gt;col)--&gt;2) + (row1/8);</span>
        <span class="plain">row2--;</span>
        <span class="plain">at2 = ((tab--&gt;col)--&gt;2) + (row2/8);</span>
        <span class="plain">bit1 = ((TB_Blanks-&gt;at1) &amp; (CheckTableEntryIsBlank_LU-&gt;(row1%8)));</span>
        <span class="plain">bit2 = ((TB_Blanks-&gt;at2) &amp; (CheckTableEntryIsBlank_LU-&gt;(row2%8)));</span>
        <span class="plain">if (bit1) bit1 = true;</span>
        <span class="plain">if (bit2) bit2 = true;</span>
        <span class="plain">if (bit1 == bit2) return;</span>
        <span class="plain">if (bit1) {</span>
            <span class="plain">(TB_Blanks-&gt;at1)</span>
                <span class="plain">= (TB_Blanks-&gt;at1) &amp; (CheckTableEntryIsNonBlank_LU-&gt;(row1%8));</span>
            <span class="plain">(TB_Blanks-&gt;at2)</span>
                <span class="plain">= (TB_Blanks-&gt;at2) | (CheckTableEntryIsBlank_LU-&gt;(row2%8));</span>
        <span class="plain">} else {</span>
            <span class="plain">(TB_Blanks-&gt;at1)</span>
                <span class="plain">= (TB_Blanks-&gt;at1) | (CheckTableEntryIsBlank_LU-&gt;(row1%8));</span>
            <span class="plain">(TB_Blanks-&gt;at2)</span>
                <span class="plain">= (TB_Blanks-&gt;at2) &amp; (CheckTableEntryIsNonBlank_LU-&gt;(row2%8));</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Moving Blank Bits Down. </b>Another common table operation is to compress it by moving all the blank
rows down to the bottom, so that non-blank rows occur in a contiguous block
at the top: this means table sorting can be done without having to refer
continually to the blanks bitmaps. The following operation is useful for
keeping the blanks bitmaps up to date when blank rows are moved down.
</p>


<pre class="display">
    <span class="plain">[ TableMoveBlankBitsDown tab row1 row2 col at atp1 bit rx;</span>
        <span class="plain">if (col &gt;= 100) col=TableFindCol(tab, col);</span>
        <span class="plain">if (col == 0) rtrue;</span>
        <span class="plain">if (((tab--&gt;col)--&gt;1) &amp; TB_COLUMN_NOBLANKBITS) return;</span>
        <span class="plain">row1--; row2--;</span>
        <span class="plain">! Read blank bit for row1:</span>
        <span class="plain">at = ((tab--&gt;col)--&gt;2) + (row1/8);</span>
        <span class="plain">bit = ((TB_Blanks-&gt;at) &amp; (CheckTableEntryIsBlank_LU-&gt;(row1%8)));</span>
        <span class="plain">if (bit) bit = true;</span>
        <span class="plain">! Loop through, setting each blank bit to the next:</span>
        <span class="plain">for (rx=row1:rx&lt;row2:rx++) {</span>
            <span class="plain">atp1 = ((tab--&gt;col)--&gt;2) + ((rx+1)/8);</span>
            <span class="plain">at = ((tab--&gt;col)--&gt;2) + (rx/8);</span>
            <span class="plain">if ((TB_Blanks-&gt;atp1) &amp; (CheckTableEntryIsBlank_LU-&gt;((rx+1)%8))) {</span>
                <span class="plain">(TB_Blanks-&gt;at)</span>
                    <span class="plain">= (TB_Blanks-&gt;at) | (CheckTableEntryIsBlank_LU-&gt;(rx%8));</span>
            <span class="plain">} else {</span>
                <span class="plain">(TB_Blanks-&gt;at)</span>
                    <span class="plain">= (TB_Blanks-&gt;at) &amp; (CheckTableEntryIsNonBlank_LU-&gt;(rx%8));</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">! Write bit to blank bit for row2:</span>
        <span class="plain">at = ((tab--&gt;col)--&gt;2) + (row2/8);</span>
        <span class="plain">if (bit) {</span>
            <span class="plain">(TB_Blanks-&gt;at)</span>
                <span class="plain">= (TB_Blanks-&gt;at) | (CheckTableEntryIsBlank_LU-&gt;(row2%8));</span>
        <span class="plain">} else {</span>
            <span class="plain">(TB_Blanks-&gt;at)</span>
                <span class="plain">= (TB_Blanks-&gt;at) &amp; (CheckTableEntryIsNonBlank_LU-&gt;(row2%8));</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Table Row Corresponding. </b><code class="display"><span class="extract">TableRowCorr(T, C, V)</span></code> returns the first row on which value <code class="display"><span class="extract">V</span></code> appears in
column <code class="display"><span class="extract">C</span></code> of table <code class="display"><span class="extract">T</span></code>, or prints an error if it doesn't.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">ExistsTableRowCorr(T, C, V)</span></code> returns the first row on which <code class="display"><span class="extract">V</span></code> appears in
column <code class="display"><span class="extract">C</span></code> of table <code class="display"><span class="extract">T</span></code>, or 0 if <code class="display"><span class="extract">V</span></code> does not occur at all. If the column
is a topic, then we match the entry as a snippet against the value as a
general parsing routine.
</p>


<pre class="display">
    <span class="plain">[ TableRowCorr tab col lookup_value lookup_col i j f v;</span>
        <span class="plain">if (col &gt;= 100) col=TableFindCol(tab, col, true);</span>
        <span class="plain">lookup_col = tab--&gt;col;</span>
        <span class="plain">j = lookup_col--&gt;0 - COL_HSIZE;</span>
        <span class="plain">if (((tab--&gt;col)--&gt;1) &amp; TB_COLUMN_ALLOCATED) f=1;</span>
        <span class="plain">if (f) {</span>
            <span class="plain">for (i=1:i&lt;=j:i++) {</span>
                <span class="plain">v = lookup_col--&gt;(i+COL_HSIZE);</span>
                <span class="plain">if ((v == TABLE_NOVALUE) &amp;&amp;</span>
                    <span class="plain">(CheckTableEntryIsBlank(tab,col,i))) continue;</span>
                <span class="plain">if (BlkValueCompare(v, lookup_value) == 0)</span>
                    <span class="plain">return i;</span>
            <span class="plain">}</span>
        <span class="plain">} else {</span>
            <span class="plain">for (i=1:i&lt;=j:i++) {</span>
                <span class="plain">if ((lookup_value == TABLE_NOVALUE) &amp;&amp;</span>
                    <span class="plain">(CheckTableEntryIsBlank(tab,col,i))) continue;</span>
                <span class="plain">if (lookup_col--&gt;(i+COL_HSIZE) == lookup_value) return i;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">return RunTimeProblem(RTP_TABLE_NOCORR, tab);</span>
    <span class="plain">];</span>

    <span class="plain">[ ExistsTableRowCorr tab col entry i k v f kov;</span>
        <span class="plain">if (col &gt;= 100) col=TableFindCol(tab, col);</span>
        <span class="plain">if (col == 0) rfalse;</span>
        <span class="plain">f=0;</span>
        <span class="plain">if (((tab--&gt;col)--&gt;1) &amp; TB_COLUMN_TOPIC) f=1;</span>
        <span class="plain">else if (((tab--&gt;col)--&gt;1) &amp; TB_COLUMN_ALLOCATED) f=2;</span>
        <span class="plain">k = TableRows(tab);</span>
        <span class="plain">for (i=1:i&lt;=k:i++) {</span>
            <span class="plain">v = (tab--&gt;col)--&gt;(i+COL_HSIZE);</span>
            <span class="plain">if ((v == TABLE_NOVALUE) &amp;&amp; (CheckTableEntryIsBlank(tab,col,i))) continue;</span>
            <span class="plain">switch (f) {</span>
                <span class="plain">1: if ((v)(entry/100, entry%100) ~= GPR_FAIL) return i;</span>
                <span class="plain">2: if (BlkValueCompare(v, entry) == 0) return i;</span>
                <span class="plain">default: if (v == entry) return i;</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">! print "Giving up^";</span>
        <span class="plain">return 0;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Table Look Up Corresponding Row. </b><code class="display"><span class="extract">TableLookUpCorr(T, C1, C2, V)</span></code> finds the first row on which value <code class="display"><span class="extract">V</span></code>
appears in column <code class="display"><span class="extract">C2</span></code>, and returns the corresponding value in <code class="display"><span class="extract">C1</span></code>, or
prints an error if the value <code class="display"><span class="extract">V</span></code> cannot be found or has no corresponding
value in <code class="display"><span class="extract">C1</span></code>.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">ExistsTableLookUpCorr(T, C1, C2, V)</span></code> returns <code class="display"><span class="extract">true</span></code> if the operation
<code class="display"><span class="extract">TableLookUpCorr(T, C1, C2, V)</span></code> can be done, <code class="display"><span class="extract">false</span></code> otherwise.
</p>


<pre class="display">
    <span class="plain">[ TableLookUpCorr tab col1 col2 lookup_value write_flag write_value cola1 cola2 i j v f;</span>
        <span class="plain">if (col1 &gt;= 100) col1=TableFindCol(tab, col1, true);</span>
        <span class="plain">if (col2 &gt;= 100) col2=TableFindCol(tab, col2, true);</span>
        <span class="plain">cola1 = tab--&gt;col1;</span>
        <span class="plain">cola2 = tab--&gt;col2;</span>
        <span class="plain">j = cola2--&gt;0;</span>
        <span class="plain">f=0;</span>
        <span class="plain">if (((tab--&gt;col2)--&gt;1) &amp; TB_COLUMN_ALLOCATED) f=1;</span>
        <span class="plain">if (((tab--&gt;col2)--&gt;1) &amp; TB_COLUMN_TOPIC) f=2;</span>
        <span class="plain">for (i=1+COL_HSIZE:i&lt;=j:i++) {</span>
            <span class="plain">v = cola2--&gt;i;</span>

            <span class="plain">if ((v == TABLE_NOVALUE) &amp;&amp; (CheckTableEntryIsBlank(tab,col2,i-COL_HSIZE))) continue;</span>
            <span class="plain">if (f == 1) {</span>
                <span class="plain">if (BlkValueCompare(v, lookup_value) ~= 0) continue;</span>
            <span class="plain">} else if (f == 2) {</span>
                <span class="plain">if ((v)(lookup_value/100, lookup_value%100) == GPR_FAIL) continue;</span>
            <span class="plain">} else {</span>
                <span class="plain">if (v ~= lookup_value) continue;</span>
            <span class="plain">}</span>
            <span class="plain">if (write_flag) {</span>
                <span class="plain">if (write_flag == 4) ForceTableEntryBlank(tab,col1,i-COL_HSIZE);</span>
                <span class="plain">else ForceTableEntryNonBlank(tab,col1,i-COL_HSIZE);</span>
                <span class="plain">switch (write_flag) {</span>
                    <span class="plain">1: cola1--&gt;i = write_value;</span>
                    <span class="plain">2: cola1--&gt;i = cola1--&gt;i + write_value;</span>
                    <span class="plain">3: cola1--&gt;i = cola1--&gt;i - write_value;</span>
                    <span class="plain">5: return cola1--&gt;i;</span>
                <span class="plain">}</span>
                <span class="plain">rfalse;</span>
            <span class="plain">}</span>
            <span class="plain">v = cola1--&gt;i;</span>
            <span class="plain">if ((v == TABLE_NOVALUE) &amp;&amp;</span>
                <span class="plain">(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;</span>
            <span class="plain">return v;</span>
        <span class="plain">}</span>
        <span class="plain">return RunTimeProblem(RTP_TABLE_NOCORR, tab);</span>
    <span class="plain">];</span>

    <span class="plain">[ ExistsTableLookUpCorr tab col1 col2 lookup_value cola1 cola2 i j f;</span>
        <span class="plain">if (col1 &gt;= 100) col1=TableFindCol(tab, col1, false);</span>
        <span class="plain">if (col2 &gt;= 100) col2=TableFindCol(tab, col2, false);</span>
        <span class="plain">if (col1*col2 == 0) rfalse;</span>
        <span class="plain">cola1 = tab--&gt;col1; cola2 = tab--&gt;col2;</span>
        <span class="plain">j = cola2--&gt;0;</span>
        <span class="plain">f=0;</span>
        <span class="plain">if (((tab--&gt;col2)--&gt;1) &amp; TB_COLUMN_ALLOCATED) f=1;</span>
        <span class="plain">if (((tab--&gt;col2)--&gt;1) &amp; TB_COLUMN_TOPIC) f=2;</span>
        <span class="plain">for (i=1+COL_HSIZE:i&lt;=j:i++) {</span>
            <span class="plain">if ((cola1--&gt;i == TABLE_NOVALUE) &amp;&amp;</span>
                <span class="plain">(CheckTableEntryIsBlank(tab,col1,i-COL_HSIZE))) continue;</span>
            <span class="plain">if (f == 1) {</span>
                <span class="plain">if (BlkValueCompare(cola2--&gt;i, lookup_value) ~= 0) continue;</span>
            <span class="plain">} else if (f == 2) {</span>
                <span class="plain">if ((cola2--&gt;i)(lookup_value/100, lookup_value%100) == GPR_FAIL) continue;</span>
            <span class="plain">} else {</span>
                <span class="plain">if (cola2--&gt;i ~= lookup_value) continue;</span>
            <span class="plain">}</span>
            <span class="plain">rtrue;</span>
        <span class="plain">}</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. Table Look Up Entry. </b><code class="display"><span class="extract">TableLookUpEntry(T, C, R)</span></code> returns the value at column <code class="display"><span class="extract">C</span></code>, row <code class="display"><span class="extract">R</span></code>, printing
an error if that doesn't exist.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">ExistsTableLookUpEntry(T, C, R)</span></code> returns true if a value exists at column
<code class="display"><span class="extract">C</span></code>, row <code class="display"><span class="extract">R</span></code>, false otherwise.
</p>


<pre class="display">
    <span class="plain">[ TableLookUpEntry tab col index write_flag write_value v;</span>
        <span class="plain">if (tab == 0) return RunTimeProblem(RTP_TABLE_NOTABLE2);</span>
        <span class="plain">if (col &gt;= 100) col=TableFindCol(tab, col, true);</span>
        <span class="plain">if ((index &lt; 1) || (index &gt; TableRows(tab))) {</span>
            <span class="plain">RunTimeProblem(RTP_TABLE_NOROW, tab, index); index = 1;</span>
        <span class="plain">}</span>
        <span class="plain">if (write_flag) {</span>
            <span class="plain">switch(write_flag) {</span>
                <span class="plain">1:	ForceTableEntryNonBlank(tab,col,index);</span>
                    <span class="plain">(tab--&gt;col)--&gt;(index+COL_HSIZE) = write_value;</span>
                <span class="plain">2:	ForceTableEntryNonBlank(tab,col,index);</span>
                    <span class="plain">(tab--&gt;col)--&gt;(index+COL_HSIZE) =</span>
                        <span class="plain">((tab--&gt;col)--&gt;(index+COL_HSIZE)) + write_value;</span>
                <span class="plain">3:	ForceTableEntryNonBlank(tab,col,index);</span>
                    <span class="plain">(tab--&gt;col)--&gt;(index+COL_HSIZE) =</span>
                        <span class="plain">((tab--&gt;col)--&gt;(index+COL_HSIZE)) - write_value;</span>
                <span class="plain">4:	ForceTableEntryBlank(tab,col,index);</span>
                <span class="plain">5:	ForceTableEntryNonBlank(tab,col,index);</span>
                    <span class="plain">return ((tab--&gt;col)--&gt;(index+COL_HSIZE));</span>
            <span class="plain">}</span>
            <span class="plain">rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">v = ((tab--&gt;col)--&gt;(index+COL_HSIZE));</span>
        <span class="plain">if ((v == TABLE_NOVALUE) &amp;&amp; (CheckTableEntryIsBlank(tab,col,index))) {</span>
            <span class="plain">RunTimeProblem(RTP_TABLE_NOENTRY, tab, col, index); rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">return v;</span>
    <span class="plain">];</span>

    <span class="plain">[ ExistsTableLookUpEntry tab col index v;</span>
        <span class="plain">if (col &gt;= 100) col=TableFindCol(tab, col);</span>
        <span class="plain">if (col == 0) rfalse;</span>
        <span class="plain">if ((index&lt;1) || (index &gt; TableRows(tab))) rfalse;</span>
        <span class="plain">v = ((tab--&gt;col)--&gt;(index+COL_HSIZE));</span>
        <span class="plain">if ((v == TABLE_NOVALUE) &amp;&amp; (CheckTableEntryIsBlank(tab,col,index)))</span>
            <span class="plain">rfalse;</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Blank Rows. </b><code class="display"><span class="extract">TableRowIsBlank(T, R)</span></code> returns true if row <code class="display"><span class="extract">R</span></code> of table <code class="display"><span class="extract">T</span></code> is blank. (<code class="display"><span class="extract">R</span></code>
must be a legal row number.)
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">TableBlankOutRow(T, R)</span></code> fills row <code class="display"><span class="extract">R</span></code> of table <code class="display"><span class="extract">T</span></code> with blanks. (<code class="display"><span class="extract">R</span></code> must be
a legal row number.)
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">TableBlankRows(T)</span></code> returns the number of blank rows in <code class="display"><span class="extract">T</span></code>.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">TableFilledRows(T)</span></code> returns the number of non-blank rows in <code class="display"><span class="extract">T</span></code>.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">TableBlankRow(T)</span></code> finds the first blank row in <code class="display"><span class="extract">T</span></code>.
</p>


<pre class="display">
    <span class="plain">[ TableRowIsBlank tab j k;</span>
        <span class="plain">for (k=1:k&lt;=tab--&gt;0:k++) {</span>
            <span class="plain">if (((tab--&gt;k)--&gt;(j+COL_HSIZE)) ~= TABLE_NOVALUE) rfalse;</span>
            <span class="plain">if (CheckTableEntryIsBlank(tab, k, j) == false) rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>

    <span class="plain">[ TableBlankOutRow tab row k;</span>
        <span class="plain">if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE);</span>
        <span class="plain">for (k=1:k&lt;=tab--&gt;0:k++)</span>
            <span class="plain">ForceTableEntryBlank(tab, k, row);</span>
    <span class="plain">];</span>

    <span class="plain">[ TableBlankOutColumn tab col n k;</span>
        <span class="plain">if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE);</span>
        <span class="plain">n = TableRows(tab);</span>
        <span class="plain">for (k=1:k&lt;=n:k++)</span>
            <span class="plain">ForceTableEntryBlank(tab, col, k);</span>
    <span class="plain">];</span>

    <span class="plain">[ TableBlankOutAll tab n k;</span>
        <span class="plain">if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE);</span>
        <span class="plain">n = TableRows(tab);</span>
        <span class="plain">for (k=1:k&lt;=n:k++)</span>
            <span class="plain">TableBlankOutRow(tab, k);</span>
    <span class="plain">];</span>

    <span class="plain">[ TableBlankRows tab i j c;</span>
        <span class="plain">i = TableRows(tab); !print i, " rows^";</span>
        <span class="plain">for (j=1:j&lt;=i:j++)</span>
            <span class="plain">if (TableRowIsBlank(tab, j)) c++;</span>
        <span class="plain">!print c, " blank^";</span>
        <span class="plain">return c;</span>
    <span class="plain">];</span>

    <span class="plain">[ TableFilledRows tab;</span>
        <span class="plain">return TableRows(tab) - TableBlankRows(tab);</span>
    <span class="plain">];</span>

    <span class="plain">[ TableBlankRow tab i j;</span>
        <span class="plain">i = TableRows(tab);</span>
        <span class="plain">for (j=1:j&lt;=i:j++)</span>
            <span class="plain">if (TableRowIsBlank(tab, j)) return j;</span>
        <span class="plain">RunTimeProblem(RTP_TABLE_NOMOREBLANKS, tab);</span>
        <span class="plain">return i;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15. Random Row. </b><code class="display"><span class="extract">TableRandomRow(T)</span></code> chooses a random non-blank row in <code class="display"><span class="extract">T</span></code>.
</p>


<pre class="display">
    <span class="plain">[ TableRandomRow tab i j k;</span>
        <span class="plain">i = TableRows(tab);</span>
        <span class="plain">j = TableFilledRows(tab);</span>
        <span class="plain">if (j==0) return RunTimeProblem(RTP_TABLE_NOROWS, tab);</span>
        <span class="plain">if (j&gt;1) j = random(j);</span>
        <span class="plain">for (k=1:k&lt;=i:k++) {</span>
            <span class="plain">if (TableRowIsBlank(tab, k) == false) j--;</span>
            <span class="plain">if (j==0) return k;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16. Swap Rows. </b><code class="display"><span class="extract">TableSwapRows(T, R1, R2)</span></code> exchanges rows <code class="display"><span class="extract">R1</span></code> and <code class="display"><span class="extract">R2</span></code>.
</p>


<pre class="display">
    <span class="plain">[ TableSwapRows tab i j k l v1 v2;</span>
        <span class="plain">if (i==j) return;</span>
        <span class="plain">l = tab--&gt;0;</span>
        <span class="plain">for (k=1:k&lt;=l:k++) {</span>
            <span class="plain">v1 = (tab--&gt;k)--&gt;(i+COL_HSIZE);</span>
            <span class="plain">v2 = (tab--&gt;k)--&gt;(j+COL_HSIZE);</span>
            <span class="plain">(tab--&gt;k)--&gt;(i+COL_HSIZE) = v2;</span>
            <span class="plain">(tab--&gt;k)--&gt;(j+COL_HSIZE) = v1;</span>
            <span class="plain">if ((v1 == TABLE_NOVALUE) || (v2 == TABLE_NOVALUE))</span>
                <span class="plain">TableSwapBlankBits(tab, i, j, k);</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17. Compare Rows. </b><code class="display"><span class="extract">TableCompareRows(T, C, R1, R2, D)</span></code> returns:
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(a) +1 if the entry at row R1 of column C is &gt; the entry at row R2,
</li><li>(b) 0 if they are equal, and
</li><li>(c) -1 if entry at R1 &lt; entry at R2.
</li></ul>
<p class="inwebparagraph">When D = +1, a blank value is greater than all other values, so that in
an ascending sort the blanks come last; when D = -1, a blank value is
less than all others, so that once again blanks are last. Finally, a wholly
blank row is always placed after a row in which the entry in C is blank but
where other entries are not.
</p>


<pre class="display">
    <span class="plain">[ TableCompareRows tab col row1 row2 dir val1 val2 bl1 bl2 f;</span>
        <span class="plain">if (col &gt;= 100) col=TableFindCol(tab, col, false);</span>
        <span class="plain">val1 = (tab--&gt;col)--&gt;(row1+COL_HSIZE);</span>
        <span class="plain">val2 = (tab--&gt;col)--&gt;(row2+COL_HSIZE);</span>
        <span class="plain">if (val1 == TABLE_NOVALUE) bl1 = CheckTableEntryIsBlank(tab,col,row1);</span>
        <span class="plain">if (val2 == TABLE_NOVALUE) bl2 = CheckTableEntryIsBlank(tab,col,row2);</span>
        <span class="plain">if ((val1 == val2) &amp;&amp; (bl1 == bl2)) {</span>
            <span class="plain">if (val1 ~= TABLE_NOVALUE) return 0;</span>
            <span class="plain">if (bl1 == false) return 0;</span>
            <span class="plain">! The two entries are both blank:</span>
            <span class="plain">if (TableRowIsBlank(tab, row1)) {</span>
                <span class="plain">if (TableRowIsBlank(tab, row2)) return 0;</span>
                <span class="plain">return -1*dir;</span>
            <span class="plain">}</span>
            <span class="plain">if (TableRowIsBlank(tab, row2)) return dir;</span>
            <span class="plain">return 0;</span>
        <span class="plain">}</span>
        <span class="plain">if (bl1) return dir;</span>
        <span class="plain">if (bl2) return -1*dir;</span>
        <span class="plain">f = ((tab--&gt;col)--&gt;1);</span>
        <span class="plain">if (f &amp; TB_COLUMN_ALLOCATED) {</span>
            <span class="plain">if (BlkValueCompare(val2, val1) &lt; 0) return 1;</span>
            <span class="plain">return -1;</span>
        <span class="plain">} else if (f &amp; TB_COLUMN_REAL) {</span>
            <span class="plain">if (REAL_NUMBER_TY_Compare(val1, val2) &gt; 0) return 1;</span>
            <span class="plain">return -1;</span>
        <span class="plain">} else if (f &amp; TB_COLUMN_SIGNED) {</span>
            <span class="plain">if (val1 &gt; val2) return 1;</span>
            <span class="plain">return -1;</span>
        <span class="plain">} else {</span>
            <span class="plain">if (UnsignedCompare(val1, val2) &gt; 0) return 1;</span>
            <span class="plain">return -1;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18. Move Row Down. </b></p>


<pre class="display">
    <span class="plain">[ TableMoveRowDown tab r1 r2 rx k l m v f;</span>
        <span class="plain">if (r1==r2) return;</span>
        <span class="plain">l = tab--&gt;0;</span>
        <span class="plain">for (k=1:k&lt;=l:k++) {</span>
            <span class="plain">f = false;</span>
            <span class="plain">m = (tab--&gt;k)--&gt;(r1+COL_HSIZE);</span>
            <span class="plain">if (m == TABLE_NOVALUE) f = true;</span>
            <span class="plain">for (rx=r1:rx&lt;r2:rx++) {</span>
                <span class="plain">v = (tab--&gt;k)--&gt;(rx+COL_HSIZE+1);</span>
                <span class="plain">(tab--&gt;k)--&gt;(rx+COL_HSIZE) = v;</span>
                <span class="plain">if (v == TABLE_NOVALUE) f = true;</span>
            <span class="plain">}</span>
            <span class="plain">(tab--&gt;k)--&gt;(r2+COL_HSIZE) = m;</span>
            <span class="plain">if (f) TableMoveBlankBitsDown(tab, r1, r2, k);</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19. Shuffle. </b><code class="display"><span class="extract">TableShuffle(T)</span></code> sorts <code class="display"><span class="extract">T</span></code> into random row order.
</p>


<pre class="display">
    <span class="plain">[ TableShuffle tab i to;</span>
        <span class="plain">TableMoveBlanksToBack(tab, 1, TableRows(tab));</span>
        <span class="plain">to = TableFilledRows(tab);</span>
        <span class="plain">for (i=2:i&lt;=to:i++) TableSwapRows(tab, i, random(i));</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP20"></a><b>&#167;20. Next Row. </b><code class="display"><span class="extract">TableNextRow(T, C, R, D)</span></code> is used when scanning through a table in order
of the values in column <code class="display"><span class="extract">C</span></code>: ascending order if <code class="display"><span class="extract">D = 1</span></code>, descending if <code class="display"><span class="extract">D =
</span></code>-1<code class="display"><span class="extract">. The current position is row </span></code>R<code class="display"><span class="extract"> of column </span></code>C<code class="display"><span class="extract">, or </span></code>R = 0<code class="display"><span class="extract"> if we have
</span></code>not yet found the first row. The return value is the row number for the
next value, or 0 if we are already at the final value. Note that if there
are several equal values in the column, they will be run through in turn,
in order of their physical row numbers - ascending if <code class="display"><span class="extract">D = 1</span></code>, descending
if <code class="display"><span class="extract">D = -1</span></code>, so that using the routine with <code class="display"><span class="extract">D = -1</span></code> always produces the
exact reverse ordering from using it with <code class="display"><span class="extract">D = 1</span></code> and the same parameters.
Rows with blank entries in <code class="display"><span class="extract">C</span></code> are skipped.
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">for (R=TableNextRow(T,C,0,D): R : R=TableNextRow(T,C,R,D)) ...</span>
</pre>

<p class="inwebparagraph">will perform a loop of valid row numbers in order of column <code class="display"><span class="extract">C</span></code>.
</p>


<pre class="display">
    <span class="plain">[ TableNextRow tab col row dir i k val v dv min_dv min_at signed_arithmetic f blk z;</span>
        <span class="plain">if (col &gt;= 100) col=TableFindCol(tab, col, false);</span>
        <span class="plain">f = ((tab--&gt;col)--&gt;1);</span>
        <span class="plain">if (f &amp; TB_COLUMN_ALLOCATED) blk = true;</span>
        <span class="plain">signed_arithmetic = f &amp; TB_COLUMN_SIGNED;</span>
        <span class="plain">#Iftrue (WORDSIZE == 2);</span>
        <span class="plain">if (row == 0) {</span>
            <span class="plain">if (signed_arithmetic) {</span>
                <span class="plain">if (dir == 1) val = $8000; else val = $7fff;</span>
            <span class="plain">} else {</span>
                <span class="plain">if (dir == 1) val = 0; else val = $ffff;</span>
            <span class="plain">}</span>
        <span class="plain">} else val = (tab--&gt;col)--&gt;(row+COL_HSIZE);</span>
        <span class="plain">if (signed_arithmetic) min_dv = $7fff; else min_dv = $ffff;</span>
        <span class="plain">#ifnot; ! WORDSIZE == 4</span>
        <span class="plain">if (row == 0) {</span>
            <span class="plain">if (signed_arithmetic) {</span>
                <span class="plain">if (dir == 1) val = $80000000; else val = $7fffffff;</span>
            <span class="plain">} else {</span>
                <span class="plain">if (dir == 1) val = 0; else val = $ffffffff;</span>
            <span class="plain">}</span>
        <span class="plain">} else val = (tab--&gt;col)--&gt;(row+COL_HSIZE);</span>
        <span class="plain">if (signed_arithmetic) min_dv = $7fffffff; else min_dv = $ffffffff;</span>
        <span class="plain">#endif;</span>
        <span class="plain">k = TableRows(tab);</span>
        <span class="plain">if (dir == 1) {</span>
            <span class="plain">for (i=1:i&lt;=k:i++) {</span>
                <span class="plain">v = (tab--&gt;col)--&gt;(i+COL_HSIZE);</span>
                <span class="plain">if ((v == TABLE_NOVALUE) &amp;&amp; (CheckTableEntryIsBlank(tab,col,i)))</span>
                    <span class="plain">continue;</span>
                <span class="plain">if (blk) {</span>
                    <span class="plain">dv = v;</span>
                    <span class="plain">if (row == 0) z = 1; else z = BlkValueCompare(v, val);</span>
                    <span class="plain">f = (((z &gt; 0) || ((z == 0) &amp;&amp; (i &gt; row))) &amp;&amp;</span>
                        <span class="plain">((min_at == 0) || (BlkValueCompare(v, min_dv) &lt; 0)));</span>
                <span class="plain">} else {</span>
                    <span class="plain">dv = dir*v;</span>
                    <span class="plain">if (signed_arithmetic)</span>
                    <span class="plain">f = (((dv &gt; dir*val) || ((v == val) &amp;&amp; (i&gt;row))) &amp;&amp;</span>
                        <span class="plain">(dv &lt; min_dv));</span>
                    <span class="plain">else</span>
                    <span class="plain">f = (((UnsignedCompare(dv, dir*val) &gt; 0) || ((v == val) &amp;&amp; (i&gt;row))) &amp;&amp;</span>
                        <span class="plain">(UnsignedCompare(dv, min_dv) &lt; 0));</span>
                <span class="plain">}</span>
                <span class="plain">if (f) { min_dv = dv; min_at = i; }</span>
            <span class="plain">}</span>
        <span class="plain">} else {</span>
            <span class="plain">for (i=k:i&gt;=1:i--) {</span>
                <span class="plain">v = (tab--&gt;col)--&gt;(i+COL_HSIZE);</span>
                <span class="plain">if ((v == TABLE_NOVALUE) &amp;&amp; (CheckTableEntryIsBlank(tab,col,i)))</span>
                    <span class="plain">continue;</span>
                <span class="plain">if (blk) {</span>
                    <span class="plain">dv = v;</span>
                    <span class="plain">if (row == 0) z = -1; else z = BlkValueCompare(v, val);</span>
                    <span class="plain">f = (((z &lt; 0) || ((z == 0) &amp;&amp; (i &lt; row))) &amp;&amp;</span>
                        <span class="plain">((min_at == 0) || (BlkValueCompare(v, min_dv) &gt; 0)));</span>
                <span class="plain">} else {</span>
                    <span class="plain">dv = dir*v;</span>
                    <span class="plain">if (signed_arithmetic)</span>
                    <span class="plain">f = (((dv &gt; dir*val) || ((v == val) &amp;&amp; (i&lt;row))) &amp;&amp;</span>
                        <span class="plain">(dv &lt; min_dv));</span>
                    <span class="plain">else</span>
                    <span class="plain">f = (((UnsignedCompare(dv, dir*val) &gt; 0) || ((v == val) &amp;&amp; (i&lt;row))) &amp;&amp;</span>
                        <span class="plain">(UnsignedCompare(dv, min_dv) &lt; 0));</span>
                <span class="plain">}</span>
                <span class="plain">if (f) { min_dv = dv; min_at = i; }</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">return min_at;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP21"></a><b>&#167;21. Move Blanks to Back. </b></p>


<pre class="display">
    <span class="plain">[ TableMoveBlanksToBack tab fromrow torow i fbl lnbl blc;</span>
        <span class="plain">if (torow &lt; fromrow) return;</span>
        <span class="plain">fbl = 0; lnbl = 0;</span>
        <span class="plain">for (i=fromrow: i&lt;=torow: i++)</span>
            <span class="plain">if (TableRowIsBlank(tab, i)) {</span>
                <span class="plain">if (fbl == 0) fbl = i;</span>
                <span class="plain">blc++;</span>
            <span class="plain">} else {</span>
                <span class="plain">lnbl = i;</span>
            <span class="plain">}</span>
        <span class="plain">if ((fbl&gt;0) &amp;&amp; (lnbl&gt;0) &amp;&amp; (fbl &lt; lnbl)) {</span>
            <span class="plain">TableMoveRowDown(tab, fbl, lnbl); ! Move first blank just past last nonblank</span>
            <span class="plain">TableMoveBlanksToBack(tab, fbl, lnbl-1);</span>
        <span class="plain">}</span>
        <span class="plain">return torow-blc; ! Final non-blank row</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP22"></a><b>&#167;22. Sort. </b>This is really only a front-end: it calls the sorting code at "Sort.i6t".
</p>


<pre class="display">
    <span class="plain">[ TableSort tab col dir test_flag algorithm i j k f;</span>
        <span class="plain">for (i=1:i&lt;=tab--&gt;0:i++) {</span>
            <span class="plain">j = tab--&gt;i; ! Address of column table</span>
            <span class="plain">if ((j--&gt;1) &amp; TB_COLUMN_DONTSORTME)</span>
                <span class="plain">return RunTimeProblem(RTP_TABLE_CANTSORT, tab);</span>
        <span class="plain">}</span>
        <span class="plain">if (col &gt;= 100) col=TableFindCol(tab, col, false);</span>
        <span class="plain">k = TableRows(tab);</span>
        <span class="plain">k = TableMoveBlanksToBack(tab, 1, k);</span>
        <span class="plain">if (test_flag) {</span>
            <span class="plain">print "After moving blanks to back:^"; TableColumnDebug(tab, col);</span>
        <span class="plain">}</span>

        <span class="plain">SetSortDomain(TableSwapRows, TableCompareRows);</span>
        <span class="plain">SortArray(tab, col, dir, k, test_flag, algorithm);</span>

        <span class="plain">if (test_flag) {</span>
            <span class="plain">print "Final state:^"; TableColumnDebug(tab, col);</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP23"></a><b>&#167;23. Print Table to File. </b>This is how we serialise a table to an external file, though the writing
is done by printing characters in the standard way; it's just that the output
stream will be an external file rather than the screen when this routine
is called.
</p>


<pre class="display">
    <span class="plain">[ TablePrint tab i j k row col v tc kov;</span>
        <span class="plain">for (i=1:i&lt;=tab--&gt;0:i++) {</span>
            <span class="plain">j = tab--&gt;i; ! Address of column table</span>
            <span class="plain">if (((j--&gt;1) &amp; TB_COLUMN_CANEXCHANGE) == 0)</span>
                <span class="plain">rtrue;</span>
        <span class="plain">}</span>
        <span class="plain">k = TableRows(tab);</span>
        <span class="plain">k = TableMoveBlanksToBack(tab, 1, k);</span>
        <span class="plain">print "! ", (PrintTableName) tab, " (", k, ")^";</span>
        <span class="plain">for (row=1:row&lt;=k:row++) {</span>
            <span class="plain">for (col=1:col&lt;=tab--&gt;0:col++) {</span>
                <span class="plain">tc = ((tab--&gt;col)--&gt;1) &amp; TB_COLUMN_NUMBER;</span>
                <span class="plain">kov = KindAtomic(TC_KOV(tc));</span>
                <span class="plain">if (kov == UNKNOWN_TY) kov = NUMBER_TY;</span>
                <span class="plain">v = (tab--&gt;col)--&gt;(row+COL_HSIZE);</span>
                <span class="plain">if ((v == TABLE_NOVALUE) &amp;&amp; (CheckTableEntryIsBlank(tab,col,row)))</span>
                    <span class="plain">print "-- ";</span>
                <span class="plain">else {</span>
                    <span class="plain">if (BlkValueWriteToFile(v, kov) == false) print v;</span>
                    <span class="plain">print " ";</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">print "^";</span>
        <span class="plain">}</span>
        <span class="plain">rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP24"></a><b>&#167;24. Read Table from File. </b>And this is how we unserialise again. It makes sense only on Glulx.
</p>


<pre class="display">
    <span class="plain">#ifdef TARGET_GLULX;</span>
    <span class="plain">[ TableRead tab auxf row maxrow col ch v sgn dg j tc kov;</span>
        <span class="plain">for (col=1:col&lt;=tab--&gt;0:col++) {</span>
            <span class="plain">j = tab--&gt;col; ! Address of column table</span>
            <span class="plain">if (((j--&gt;1) &amp; TB_COLUMN_CANEXCHANGE) == 0)</span>
                <span class="plain">return RunTimeProblem(RTP_TABLE_CANTSAVE, tab);</span>
        <span class="plain">}</span>
        <span class="plain">maxrow = TableRows(tab);</span>
        <span class="plain">!print maxrow, " rows available.^";</span>
        <span class="plain">for (row=1: row&lt;=maxrow: row++) {</span>
            <span class="plain">TableBlankOutRow(tab, row);</span>
        <span class="plain">}</span>
        <span class="plain">for (row=1: row&lt;=maxrow: row++) {</span>
            <span class="plain">!print "Reading row ", row, "^";</span>
            <span class="plain">ch = FileIO_GetC(auxf);</span>
            <span class="plain">if (ch == '!') {</span>
                <span class="plain">while (ch ~= -1 or 10 or 13) ch = FileIO_GetC(auxf);</span>
                <span class="plain">while (ch == 10 or 13) ch = FileIO_GetC(auxf);</span>
            <span class="plain">}</span>
            <span class="plain">for (col=1: col&lt;=tab--&gt;0: col++) {</span>
                <span class="plain">if (ch == -1) { row++; jump NoMore; }</span>
                <span class="plain">if (ch == 10 or 13) break;</span>
                <span class="plain">tc = ((tab--&gt;col)--&gt;1) &amp; TB_COLUMN_NUMBER;</span>
                <span class="plain">kov = KindAtomic(TC_KOV(tc));</span>
                <span class="plain">if (kov == UNKNOWN_TY) kov = NUMBER_TY;</span>
                <span class="plain">!print "tc = ", tc, " kov = ", kov, "^";</span>
                <span class="plain">sgn = 1;</span>
                <span class="plain">if (ch == '-') {</span>
                    <span class="plain">ch = FileIO_GetC(auxf);</span>
                    <span class="plain">if (ch == -1) jump NotTable;</span>
                    <span class="plain">if (ch == '-') { ch = FileIO_GetC(auxf); jump EntryDone; }</span>
                    <span class="plain">sgn = -1;</span>
                <span class="plain">}</span>
                <span class="plain">if (((tab--&gt;col)--&gt;1) &amp; TB_COLUMN_ALLOCATED)</span>
                    <span class="plain">ForceTableEntryNonBlank(tab, col, row);</span>
                <span class="plain">!print "A";</span>
                <span class="plain">v = BlkValueReadFromFile(0, 0, -1, kov);</span>
                <span class="plain">if (v) {</span>
                    <span class="plain">if (((tab--&gt;col)--&gt;1) &amp; TB_COLUMN_ALLOCATED)</span>
                        <span class="plain">v = BlkValueReadFromFile(TableLookUpEntry(tab, col, row),</span>
                            <span class="plain">auxf, ch, kov);</span>
                    <span class="plain">else</span>
                        <span class="plain">v = BlkValueReadFromFile(0, auxf, ch, kov);</span>
                    <span class="plain">ch = 32;</span>
                <span class="plain">} else {</span>
                    <span class="plain">dg = ch - '0';</span>
                    <span class="plain">if ((dg &lt; 0) || (dg &gt; 9)) jump NotTable;</span>
                    <span class="plain">v = dg;</span>
                    <span class="plain">for (::) {</span>
                        <span class="plain">ch = FileIO_GetC(auxf);</span>
                        <span class="plain">dg = ch - '0';</span>
                        <span class="plain">if ((dg &lt; 0) || (dg &gt; 9)) break;</span>
                        <span class="plain">v = 10*v + dg;</span>
                    <span class="plain">}</span>
                    <span class="plain">v = v*sgn;</span>
                <span class="plain">}</span>
                <span class="plain">!print "v=", v, " ";</span>
                <span class="plain">if (((tab--&gt;col)--&gt;1) &amp; TB_COLUMN_ALLOCATED == 0)</span>
                    <span class="plain">TableLookUpEntry(tab, col, row, true, v);</span>
                <span class="plain">.EntryDone;</span>
                <span class="plain">!print "First nd is ", ch, "^";</span>
                <span class="plain">while (ch == 9 or 32) ch = FileIO_GetC(auxf);</span>
            <span class="plain">}</span>
            <span class="plain">while (ch ~= -1 or 10 or 13) {</span>
                <span class="plain">if ((ch ~= '-') &amp;&amp; (((ch-'0')&lt;0) || ((ch-'0')&gt;9))) jump NotTable;</span>
                <span class="plain">if (ch ~= 9 or 32) jump WontFit;</span>
                <span class="plain">ch = FileIO_GetC(auxf);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">.NoMore;</span>
        <span class="plain">while (ch == 9 or 32 or 10 or 13) ch = FileIO_GetC(auxf);</span>
        <span class="plain">if (ch == -1) return;</span>
        <span class="plain">.WontFit;</span>
        <span class="plain">return RunTimeProblem(RTP_TABLE_WONTFIT, tab);</span>
        <span class="plain">.NotTable;</span>
        <span class="plain">return RunTimeProblem(RTP_TABLE_BADFILE, tab);</span>
    <span class="plain">];</span>
    <span class="plain">#ENDIF; ! TARGET_GLULX</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP25"></a><b>&#167;25. Debugging. </b>Routines to print the state of a table, for debugging purposes only.
</p>


<pre class="display">
    <span class="plain">[ TableColumnDebug tab col k i v tc kov;</span>
        <span class="plain">if (col &gt;= 100) col=TableFindCol(tab, col, false);</span>
        <span class="plain">k = TableRows(tab);</span>
        <span class="plain">tc = ((tab--&gt;col)--&gt;1) &amp; TB_COLUMN_NUMBER;</span>
        <span class="plain">kov = TC_KOV(tc);</span>
        <span class="plain">for (i=1:i&lt;=k:i++) {</span>
            <span class="plain">if (i&gt;1) print ", ";</span>
            <span class="plain">v = (tab--&gt;col)--&gt;(i+COL_HSIZE);</span>
            <span class="plain">if ((v == TABLE_NOVALUE) &amp;&amp; (CheckTableEntryIsBlank(tab,col,i)))</span>
                <span class="plain">print "--";</span>
            <span class="plain">else {</span>
                <span class="plain">PrintKindValuePair(kov, v);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">say__p = 1;</span>
    <span class="plain">];</span>

    <span class="plain">[ TableRowDebug tab i col k v tc kov;</span>
        <span class="plain">k = TableRows(tab);</span>
        <span class="plain">if ((i&lt;1) || (i&gt;k)) "No such row";</span>
        <span class="plain">print "(row ", i, ")  |";</span>
        <span class="plain">for (col=1: col&lt;=tab--&gt;0: col++) {</span>
            <span class="plain">print " ";</span>
            <span class="plain">tc = ((tab--&gt;col)--&gt;1) &amp; TB_COLUMN_NUMBER;</span>
            <span class="plain">kov = TC_KOV(tc);</span>
            <span class="plain">v = (tab--&gt;col)--&gt;(i+COL_HSIZE);</span>
            <span class="plain">if ((v == TABLE_NOVALUE) &amp;&amp; (CheckTableEntryIsBlank(tab,col,i)))</span>
                <span class="plain">print "-- ";</span>
            <span class="plain">else {</span>
                <span class="plain">PrintKindValuePair(kov, v);</span>
                <span class="plain">print " |";</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">say__p = 1;</span>
    <span class="plain">];</span>

    <span class="plain">[ TableDebug tab i k;</span>
        <span class="plain">PrintTableName(tab); print "^";</span>
        <span class="plain">k = TableRows(tab);</span>
        <span class="plain">for (i=1:i&lt;=k:i++) { TableRowDebug(tab, i); print "^"; }</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="S-st.html">Back to 'Sort Template'</a></li><li><a href="S-tt2.html">Continue with 'Text Template'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

